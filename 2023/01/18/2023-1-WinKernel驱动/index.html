<!DOCTYPE html>
<html lang="zh-cn" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="郁涛丶" />
  <meta name="description" content="" />
  
  
  <title>
    
      Windows内核(二)——驱动 
      
      
      |
    
     郁涛丶&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Ghostasky</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Windows内核(二)——驱动</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-01-18	  
        </span>
    <span class="post-pubtime"> 本文共7.6k字 </span>
    
    <span class="post-pubtime">大约需要46min </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Technology/" title="Technology">
                    <b>#</b> Technology
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Win32/" title="Win32">
                    #Win32
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>[toc]</p>
<h1 id="001-驱动开发环境配置"><a href="#001-驱动开发环境配置" class="headerlink" title="001.驱动开发环境配置"></a>001.驱动开发环境配置</h1><p>vs2010:<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/releasenotes/vs2010-sp1-vs">https://learn.microsoft.com/zh-cn/visualstudio/releasenotes/vs2010-sp1-vs</a></p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20221213184310074.png" alt="image-20221213184310074"></p>
<p>wdk7600:<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=11800">https://www.microsoft.com/en-us/download/details.aspx?id=11800</a></p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20221213184334246.png" alt="image-20221213184334246"></p>
<p>添加项目属性表：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230104160816744.png" alt="image-20230104160816744"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">&quot;4.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">&quot;PropertySheets&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">&quot;UserMacros&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ExecutablePath</span>&gt;</span>D:\WinDDK\7600.16385.1\bin\x86;$(ExecutablePath)<span class="tag">&lt;/<span class="name">ExecutablePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">IncludePath</span>&gt;</span>D:\WinDDK\7600.16385.1\inc\api;D:\WinDDK\7600.16385.1\inc\ddk;D:\WinDDK\7600.16385.1\inc\crt;$(IncludePath)<span class="tag">&lt;/<span class="name">IncludePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LibraryPath</span>&gt;</span>D:\WinDDK\7600.16385.1\lib\wxp\i386;$(LibraryPath)<span class="tag">&lt;/<span class="name">LibraryPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetExt</span>&gt;</span>.sys<span class="tag">&lt;/<span class="name">TargetExt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinkIncremental</span>&gt;</span>false<span class="tag">&lt;/<span class="name">LinkIncremental</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">GenerateManifest</span>&gt;</span>false<span class="tag">&lt;/<span class="name">GenerateManifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ClCompile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PreprocessorDefinitions</span>&gt;</span>_X86_;DBG<span class="tag">&lt;/<span class="name">PreprocessorDefinitions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CallingConvention</span>&gt;</span>StdCall<span class="tag">&lt;/<span class="name">CallingConvention</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExceptionHandling</span>&gt;</span>false<span class="tag">&lt;/<span class="name">ExceptionHandling</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">BasicRuntimeChecks</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">BasicRuntimeChecks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">BufferSecurityCheck</span>&gt;</span>false<span class="tag">&lt;/<span class="name">BufferSecurityCheck</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CompileAs</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">CompileAs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DebugInformationFormat</span>&gt;</span>ProgramDatabase<span class="tag">&lt;/<span class="name">DebugInformationFormat</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AssemblerOutput</span>&gt;</span>All<span class="tag">&lt;/<span class="name">AssemblerOutput</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClCompile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>ntoskrnl.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;Hal.lib;MSVCRT.LIB;LIBCMT.LIB;%(AdditionalDependencies)<span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">IgnoreAllDefaultLibraries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">IgnoreAllDefaultLibraries</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">EnableUAC</span>&gt;</span>false<span class="tag">&lt;/<span class="name">EnableUAC</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SubSystem</span>&gt;</span>Native<span class="tag">&lt;/<span class="name">SubSystem</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">EntryPointSymbol</span>&gt;</span>DriverEntry<span class="tag">&lt;/<span class="name">EntryPointSymbol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">BaseAddress</span>&gt;</span>0x10000<span class="tag">&lt;/<span class="name">BaseAddress</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RandomizedBaseAddress</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">RandomizedBaseAddress</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DataExecutionPrevention</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">DataExecutionPrevention</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">GenerateDebugInformation</span>&gt;</span>true<span class="tag">&lt;/<span class="name">GenerateDebugInformation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Driver</span>&gt;</span>Driver<span class="tag">&lt;/<span class="name">Driver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="002-第一个驱动程序"><a href="#002-第一个驱动程序" class="headerlink" title="002.第一个驱动程序"></a>002.第一个驱动程序</h1><p>驱动开发流程：</p>
<blockquote>
<p>代码 =&gt; 生成sys文件 =&gt; 部署 =&gt; 启动 =&gt; 停止 =&gt; 卸载</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;启动程序运行了。\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver,PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;这里是入口点。\r\n&quot;</span>);</span><br><span class="line">	driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>生成两个文件为驱动文件和调试文件：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230104201904553.png" alt="image-20230104201904553"></p>
<p>之后在虚拟机里还需要两个软件：DebugView和KmdManager</p>
<p>DebugView在使用的时候要选择监视核心</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230104204933253.png" alt="image-20230104204933253"></p>
<h1 id="003-如何调试驱动程序"><a href="#003-如何调试驱动程序" class="headerlink" title="003.如何调试驱动程序"></a>003.如何调试驱动程序</h1><p>PDB文件：</p>
<blockquote>
<p>PDB文件是编译驱动的同时生成的调试信息文件，它可以帮助我们像调试应用程序一样调试驱动程序。其实之前我们已经使用过PDB，我们配置双机调试环境时，在物理机上安装了符号文件，并在windbg中导入过。</p>
<p>有了PDB，我们就可以知道当前汇编语句属于哪个函数，程序定义的结构体等关键信息，说一句题外话，软件发布的时候，切记不要把PDB也发布出去，因为这会给别人破解你的软件提供巨大便利。</p>
</blockquote>
<p>调试的话下个VirtualKD，之后将target目录放到虚拟机里，点击install(其实这步就是重新配了下环境)，物理机上点vmmon64，记得选windbg路径，重启虚拟机就ok了。</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105122422110.png" alt="image-20230105122422110"></p>
<p>之后在windbg的symbols里面加上：<code>E:\DriverLearn\_01HelloDriver\Driver</code></p>
<p>下断点的时候在代码里加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">	int 3</span><br><span class="line">		mov eax,eax</span><br><span class="line">		mov eax,eax</span><br><span class="line">		mov eax,eax</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是最终界面了：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105123953034.png" alt="image-20230105123953034"></p>
<h1 id="004-内核编程基础"><a href="#004-内核编程基础" class="headerlink" title="004.内核编程基础"></a>004.内核编程基础</h1><p>微软提供的内核专用API在<code>ntddk.h</code>这个头文件中</p>
<h2 id="未文档化函数与未导出函数"><a href="#未文档化函数与未导出函数" class="headerlink" title="未文档化函数与未导出函数"></a>未文档化函数与未导出函数</h2><p>未文档化函数与未导出函数：</p>
<ul>
<li>未文档化就是WDK文档里搜不到，但是在导出表里的函数，要使用这种函数可以使用GetProcAddress函数获取函数地址；</li>
<li>未导出函数就是不在导出表的函数，可以通过特征码搜索或者解析内核PDB的方式找到函数地址，通过函数指针调用。</li>
</ul>
<p>如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址:</p>
<ol>
<li>特征码搜索</li>
<li>解析内核PDB文件</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在ntdef.h中定义，习惯使用WDK自己的类型：</p>
<table>
<thead>
<tr>
<th>通用类型</th>
<th>wdk规范</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>unsigned long</td>
<td>ULONG</td>
<td>无符号长整形</td>
</tr>
<tr>
<td>unsigned char</td>
<td>UCHAR</td>
<td>无符号字符型</td>
</tr>
<tr>
<td>unisgned int</td>
<td>UINT</td>
<td>无符号整形</td>
</tr>
<tr>
<td>void</td>
<td>VOID</td>
<td>无类型</td>
</tr>
<tr>
<td>unsigned long*</td>
<td>PULONG</td>
<td>无符号长整形指针</td>
</tr>
<tr>
<td>unsigned char*</td>
<td>PUCHAR</td>
<td>无符号字符型指针</td>
</tr>
<tr>
<td>unsigned int*</td>
<td>PUINT</td>
<td>无符号整形指针</td>
</tr>
<tr>
<td>void*</td>
<td>PVOID</td>
<td>无类型指针</td>
</tr>
<tr>
<td>char*</td>
<td>UNICODE_STRING</td>
<td>字符串类型</td>
</tr>
</tbody></table>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>大部分内核函数返回值都是NTSTATUS类型，其实就是定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATUS_SUCCESS				<span class="number">0x00000000</span>	成功		</span><br><span class="line">STATUS_INVALID_PARAMETER	<span class="number">0xC000000D</span>	参数无效	</span><br><span class="line">STATUS_BUFFER_OVERFLOW		<span class="number">0x80000005</span>	缓冲区长度不够</span><br></pre></td></tr></table></figure>

<p>在ntstatus.h文件中定义</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line">	<span class="comment">//可能出错的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except(filter_value) &#123;</span><br><span class="line">	<span class="comment">//出错时要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：</p>
<ul>
<li>EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块</li>
<li>EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理</li>
<li>EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码</li>
</ul>
<h2 id="常用的内核内存函数"><a href="#常用的内核内存函数" class="headerlink" title="常用的内核内存函数"></a>常用的内核内存函数</h2><table>
<thead>
<tr>
<th>C语言</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>malloc</td>
<td>ExAllocatePool</td>
</tr>
<tr>
<td>memset</td>
<td>RtlFillMemory</td>
</tr>
<tr>
<td>memcpy</td>
<td>RtlMoveMemory</td>
</tr>
<tr>
<td>free</td>
<td>ExFreePool</td>
</tr>
</tbody></table>
<h2 id="内核字符串及常用字符串函数"><a href="#内核字符串及常用字符串函数" class="headerlink" title="内核字符串及常用字符串函数"></a>内核字符串及常用字符串函数</h2><p>为了提高安全性，内核中的字符串不再是字符串首地址指针作为开始，0作为结尾，而是采用了以下两个结构体：</p>
<p><strong>ANSI_STRING字符串：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PCHAR Buffer;</span><br><span class="line">&#125;STRING;</span><br></pre></td></tr></table></figure>

<p><strong>UNICODE_STRING字符串：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaxmumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING;</span><br></pre></td></tr></table></figure>

<p>下面的表格列出了常用的字符串函数：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>ANSI_STRING字符串</th>
<th>UNICODE_STRING字符串</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>RtlInitAnsiString</td>
<td>RtlInitUnicodeString</td>
</tr>
<tr>
<td>复制</td>
<td>RtlCopyString</td>
<td>RtlCopyUnicodeString</td>
</tr>
<tr>
<td>比较</td>
<td>RtlCompareString</td>
<td>RtlCompareUnicoodeString</td>
</tr>
<tr>
<td>转换</td>
<td>RtlAnsiStringToUnicodeString</td>
<td>RtlUnicodeStringToAnsiString</td>
</tr>
</tbody></table>
<h1 id="005-内核空间与内核模块"><a href="#005-内核空间与内核模块" class="headerlink" title="005.内核空间与内核模块"></a>005.内核空间与内核模块</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0 #查看所有程序</span><br><span class="line">.process [dirbase]</span><br><span class="line">dd 线性地址</span><br><span class="line">dt _DRIVER_OBJECT #查看DRIVER_OBJECT结构体，注意要加杠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看DRIVER_OBJECT结构体：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105133925444.png" alt="image-20230105133925444"></p>
<p>写份代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT driver,PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;PDRIVER_OBJECT: %p %wZ\n&quot;</span>,driver,RegistryPath);</span><br><span class="line">	driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在windbg中查看这个驱动进程的 _DRIVER_OBJECT 结构体：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105134550612.png" alt="image-20230105134550612"></p>
<p>其中的DriverSection，它实际上是 <code>_LDR_DATA_TABLE_ENTRY</code> 类型，它是一个链表的项，将所有驱动链在了一起</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105134937086.png" alt="image-20230105134937086"></p>
<p>通过这个驱动查的时候第一个就是自己的驱动，</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105135002493.png" alt="image-20230105135002493"></p>
<p>可以一直往下查：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105135139857.png" alt="image-20230105135139857"></p>
<h1 id="006-r0与r3通信-常规方式"><a href="#006-r0与r3通信-常规方式" class="headerlink" title="006.r0与r3通信(常规方式)"></a>006.r0与r3通信(常规方式)</h1><p>常规方式也就是正常驱动开发的人是如何做的。</p>
<p>3环窗口程序中的MSG结构体和窗口对象，与0环的设备对象和IRP结构体的关系有点像；在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。</p>
<p>驱动程序原本的目的是用来控制硬件，但我们也可以用驱动做一些安全相关的事情，因为驱动运行在0环。为了控制驱动运行，我们需要在3环向驱动发数据，所以我们需要有一种方法来建立0环到3环的通信。本文介绍常规方式，也就是创建设备对象的方式。</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105141141521.png" alt="image-20230105141141521"></p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105143451165.png" alt="image-20230105143451165"></p>
<h2 id="数据交互的方式"><a href="#数据交互的方式" class="headerlink" title="数据交互的方式"></a>数据交互的方式</h2><p>主要有两种方式，数据量小，一般用拷贝缓冲区的方式(DO_BUFFERED_IO)；数据量大，一般用直接方式读写(DO_DIRECT_IO)。</p>
<ul>
<li><p>缓冲区方式读写(DO_BUFFERED_IO) ：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。</p>
</li>
<li><p>直接方式读写(DO_DIRECT_IO) ：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。</p>
</li>
</ul>
<p>推荐使用以上两种，当然还有其他的。</p>
<h2 id="“-Device-“与“-”"><a href="#“-Device-“与“-”" class="headerlink" title="“\\Device\\“与“\\??\\”"></a>“\\Device\\“与“\\??\\”</h2><p>注意设备名和符号链接名：</p>
<ul>
<li><p>设备名：r0使用，开头是”\\Device\\“</p>
</li>
<li><p>符号链接名：r3使用，</p>
<ul>
<li>内核模式下开头是：<code>\\??\\</code></li>
<li>用户模式下开头是：<code>\\.\</code>，加上转义就是：<code>\\\\.\\</code></li>
</ul>
</li>
</ul>
<h2 id="派遣函数格式"><a href="#派遣函数格式" class="headerlink" title="派遣函数格式"></a>派遣函数格式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">functionName</span><span class="params">(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//业务代码区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置返回状态</span></span><br><span class="line">    pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;<span class="comment">//getLastError()得到的值</span></span><br><span class="line">    pIrp-&gt;IoStatus.Information = <span class="number">0</span>;            <span class="comment">//返回给3环多少数据，没有填0</span></span><br><span class="line">    IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0环与3环通信实验"><a href="#0环与3环通信实验" class="headerlink" title="0环与3环通信实验"></a>0环与3环通信实验</h2><p>步骤：</p>
<p>R0：</p>
<ul>
<li>创建设备：<code>IoCreateDevice</code></li>
<li>设置交互数据的方式</li>
<li>创建符号链接：<code>IoCreateSymbolicLink</code></li>
<li><h2 id="设置派遣函数：MajorFunction，IRP-MJ-DEVICE-CONTROL指win32api调用DeviceIoControl时会执行。"><a href="#设置派遣函数：MajorFunction，IRP-MJ-DEVICE-CONTROL指win32api调用DeviceIoControl时会执行。" class="headerlink" title="设置派遣函数：MajorFunction，IRP_MJ_DEVICE_CONTROL指win32api调用DeviceIoControl时会执行。"></a>设置派遣函数：<code>MajorFunction</code>，<code>IRP_MJ_DEVICE_CONTROL</code>指win32api调用<code>DeviceIoControl</code>时会执行。</h2></li>
<li>派遣函数中：<ul>
<li>获取IRP数据：<code>IoGetCurrentIrpStackLocation</code></li>
<li>获取控制码</li>
<li>获取缓冲区地址</li>
<li>读写</li>
<li>设置状态</li>
</ul>
</li>
</ul>
<p>R3：</p>
<ul>
<li>获取设备句柄：<code>CreateFileW</code></li>
<li>使用<code>DeviceIoControl</code>通信</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备名，0环用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">L&quot;\\Device\\HbgDev&quot;</span></span></span><br><span class="line"><span class="comment">// 符号链接名，3环用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOLICLINK_NAME <span class="string">L&quot;\\??\\HbgDevLnk&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)</span>;</span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">IrpCreateProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">IrpCloseProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">IrpDeviceControlProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)</span></span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	ULONG uIndex = <span class="number">0</span>;</span><br><span class="line">	PDEVICE_OBJECT pDeviceObj = <span class="literal">NULL</span>; <span class="comment">// 设备对象指针</span></span><br><span class="line"></span><br><span class="line">	UNICODE_STRING DeviceName; <span class="comment">// 设备名，0环用</span></span><br><span class="line">	UNICODE_STRING SymbolicLinkName; <span class="comment">// 符号链接名，3环用</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建设备名称</span></span><br><span class="line">	RtlInitUnicodeString(&amp;DeviceName,DEVICE_NAME);</span><br><span class="line">	<span class="comment">// 创建设备</span></span><br><span class="line">	status = IoCreateDevice(pDriver,<span class="number">0</span>,&amp;DeviceName,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,FALSE,&amp;pDeviceObj);</span><br><span class="line">	<span class="keyword">if</span> (status != STATUS_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		IoDeleteDevice(pDeviceObj);</span><br><span class="line">		DbgPrint(<span class="string">&quot;创建设备失败.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	DbgPrint(<span class="string">&quot;创建设备成功.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 设置交互数据的方式</span></span><br><span class="line">	pDeviceObj-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line">	<span class="comment">// 创建符号链接</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);</span><br><span class="line">	IoCreateSymbolicLink(&amp;SymbolicLinkName, &amp;DeviceName);</span><br><span class="line">	<span class="comment">// 设置分发函数</span></span><br><span class="line">	pDriver-&gt;MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;</span><br><span class="line">	pDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;</span><br><span class="line">	pDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;</span><br><span class="line">	<span class="comment">// 设置卸载函数</span></span><br><span class="line">	pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载驱动</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">	UNICODE_STRING SymbolicLinkName;</span><br><span class="line">	<span class="comment">// 删除符号链接，删除设备</span></span><br><span class="line">	RtlInitUnicodeString(&amp;SymbolicLinkName, SYMBOLICLINK_NAME);</span><br><span class="line">	IoDeleteSymbolicLink(&amp;SymbolicLinkName);</span><br><span class="line">	IoDeleteDevice(pDriver-&gt;DeviceObject);</span><br><span class="line">	DbgPrint(<span class="string">&quot;驱动卸载成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不设置这个函数，则Ring3调用CreateFile会返回1</span></span><br><span class="line"><span class="comment">// IRP_MJ_CREATE 处理函数</span></span><br><span class="line">NTSTATUS <span class="title function_">IrpCreateProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;应用层连接设备.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 返回状态如果不设置，Ring3返回值是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRP_MJ_CLOSE 处理函数</span></span><br><span class="line">NTSTATUS <span class="title function_">IrpCloseProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;应用层断开连接设备.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 返回状态如果不设置，Ring3返回值是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">	pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRP_MJ_DEVICE_CONTROL 处理函数</span></span><br><span class="line">NTSTATUS <span class="title function_">IrpDeviceControlProc</span><span class="params">(PDEVICE_OBJECT pDevObj, PIRP pIrp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// DbgPrint(&quot;IrpDeviceControlProc.\n&quot;);</span></span><br><span class="line">	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">	PIO_STACK_LOCATION pIrpStack;</span><br><span class="line">	ULONG uIoControlCode;</span><br><span class="line">	PVOID pIoBuffer;</span><br><span class="line">	ULONG uInLength;</span><br><span class="line">	ULONG uOutLength;</span><br><span class="line">	ULONG uRead;</span><br><span class="line">	ULONG uWrite;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置临时变量的值</span></span><br><span class="line">	uRead = <span class="number">0</span>;</span><br><span class="line">	uWrite = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="comment">// 获取IRP数据</span></span><br><span class="line">	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);</span><br><span class="line">	<span class="comment">// 获取控制码</span></span><br><span class="line">	uIoControlCode = pIrpStack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">	<span class="comment">// 获取缓冲区地址（输入输出是同一个）</span></span><br><span class="line">	pIoBuffer = pIrp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">	<span class="comment">// Ring3 发送数据的长度</span></span><br><span class="line">	uInLength = pIrpStack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">	<span class="comment">// Ring0 发送数据的长度</span></span><br><span class="line">	uOutLength = pIrpStack-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (uIoControlCode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> OPER1:</span><br><span class="line">		&#123;</span><br><span class="line">			DbgPrint(<span class="string">&quot;IrpDeviceControlProc -&gt; OPER1...\n&quot;</span>);</span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">			status = STATUS_SUCCESS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> OPER2:</span><br><span class="line">		&#123;</span><br><span class="line">			DbgPrint(<span class="string">&quot;IrpDeviceControlProc -&gt; OPER2 输入字节数: %d\n&quot;</span>, uInLength);</span><br><span class="line">			DbgPrint(<span class="string">&quot;IrpDeviceControlProc -&gt; OPER2 输出字节数: %d\n&quot;</span>, uOutLength);</span><br><span class="line">			<span class="comment">// 读取缓冲区</span></span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;uRead,pIoBuffer,<span class="number">4</span>);</span><br><span class="line">			DbgPrint(<span class="string">&quot;IrpDeviceControlProc -&gt; OPER2 uRead: %x\n&quot;</span>, uRead);</span><br><span class="line">			<span class="comment">// 写入缓冲区</span></span><br><span class="line">			<span class="built_in">memcpy</span>(pIoBuffer, &amp;uWrite, <span class="number">4</span>);</span><br><span class="line">			<span class="comment">// 设置状态</span></span><br><span class="line">			pIrp-&gt;IoStatus.Information = <span class="number">2</span>; <span class="comment">// 返回两字节</span></span><br><span class="line">			status = STATUS_SUCCESS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回状态如果不设置，Ring3返回值是失败</span></span><br><span class="line">	pIrp-&gt;IoStatus.Status = status;</span><br><span class="line">	IoCompleteRequest(pIrp, IO_NO_INCREMENT);</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOLICLINK_NAME <span class="string">L&quot;\\\\.\\HbgDevLnk&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_BUFFER_MAXLENGTH 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT_BUFFER_MAXLENGTH 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取设备句柄</span></span><br><span class="line">    HANDLE hDevice = CreateFileW(SYMBOLICLINK_NAME, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="number">0</span>, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, <span class="number">0</span>);</span><br><span class="line">    DWORD dwError = GetLastError();</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取设备句柄失败 %d.\n&quot;</span>, dwError); <span class="comment">// 如果返回1，请在驱动中指定 IRP_MJ_CREATE 处理函数</span></span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取设备句柄成功.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试通信</span></span><br><span class="line">    DWORD dwInBuffer = <span class="number">0x11111111</span>;</span><br><span class="line">    DWORD dwOutBuffer = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    DWORD dwOut;</span><br><span class="line">    DeviceIoControl(hDevice, OPER2, &amp;dwInBuffer, IN_BUFFER_MAXLENGTH, &amp;dwOutBuffer, OUT_BUFFER_MAXLENGTH, &amp;dwOut, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dwOutBuffer: %08X dwOut: %08X\n&quot;</span>, dwOutBuffer, dwOut);</span><br><span class="line">	CloseHandle(hDevice);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到r0和r3成功建立通信：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230105213719638.png" alt="image-20230105213719638"></p>
<h1 id="007-SSTD-Hook"><a href="#007-SSTD-Hook" class="headerlink" title="007.SSTD Hook"></a>007.SSTD Hook</h1><p>SSDT 的全称是 System Services Descriptor Table，系统服务描述符表。这个表就是一个把 Ring3 的 Win32 API 和 Ring0 的内核 API 联系起来。</p>
<p>前者有 ntoskrnl.exe 导出,后者由 Win32k.sys 导出。</p>
<hr>
<p>SSDT  的全称是 System Services Descriptor Table，系统服务描述符表</p>
<blockquote>
<p>kd&gt; dd  KeServiceDescriptorTable(SSDT)</p>
</blockquote>
<p>导出的 声明一下就可以使用了</p>
<blockquote>
<p>kd&gt; dd  KeServiceDescriptorTableShadow(SSDT Shadow)</p>
</blockquote>
<p>未导出 需要用其他的方式来查找</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230107230553238.png" alt="image-20230107230553238"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PULONG ServiceTableBase;			<span class="comment">// 函数地址表</span></span><br><span class="line">	PULONG ServiceCounterTableBase;		<span class="comment">// SSDT 函数被调用的次数</span></span><br><span class="line">	ULONG NumberOfService;				<span class="comment">// 函数个数</span></span><br><span class="line">	PULONG ParamTableBase;				<span class="comment">// 函数参数表</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSDT表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE ntoskrnl;		<span class="comment">// 内核函数</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE win32k;		<span class="comment">// win32k.sys 函数</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE unUsed1;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE unUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核导出的全局变量</span></span><br><span class="line"><span class="comment">// 导出由ntoskrnl所导出的SSDT</span></span><br><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="得到函数表的地址"><a href="#得到函数表的地址" class="headerlink" title="得到函数表的地址"></a>得到函数表的地址</h2><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG ServiceTableBase;        <span class="comment">// 函数地址表</span></span><br><span class="line">    PULONG ServiceCounterTableBase; <span class="comment">// SSDT 函数被调用的次数</span></span><br><span class="line">    ULONG NumberOfService;          <span class="comment">// 函数个数</span></span><br><span class="line">    PULONG ParamTableBase;          <span class="comment">// 函数参数表</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSDT表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE ntoskrnl; <span class="comment">// 内核函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE win32k;   <span class="comment">// win32k.sys 函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE unUsed1;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE unUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核导出的全局变量</span></span><br><span class="line"><span class="comment">// 导出由ntoskrnl所导出的SSDT</span></span><br><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;--%X\n&quot;</span>, KeServiceDescriptorTable);</span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117144628641.png" alt="image-20230117144628641"></p>
<p>可以看到是没问题的：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117144735160.png" alt="image-20230117144735160"></p>
<h2 id="SSDT-Hook"><a href="#SSDT-Hook" class="headerlink" title="SSDT Hook"></a>SSDT Hook</h2><p>其实就是再写一份函数代替上面的函数表里的函数</p>
<p>这里使用修改<code>NtOpenProcess</code>这个函数。</p>
<p>跟IDA可以知道是<code>0x7A</code>的位置，so：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117145313399.png" alt="image-20230117145313399"></p>
<p>在改之前还需要改一下页的属性：</p>
<p>SSDT所在的物理页是只读的，如果要修改，先要修改页属性为可写，可以直接通过页表基址修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(RCR4 &amp; <span class="number">0x00000020</span>)</span><br><span class="line">&#123;<span class="comment">//说明是2-9-9-12分页</span></span><br><span class="line">	KdPrint((<span class="string">&quot;2-9-9-12分页 %p\n&quot;</span>,RCR4));</span><br><span class="line">	KdPrint((<span class="string">&quot;PTE1 %p\n&quot;</span>,*(DWORD*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x007FFFF8</span>))));</span><br><span class="line">	*(DWORD64*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x007FFFF8</span>)) |= <span class="number">0x02</span>; </span><br><span class="line">	KdPrint((<span class="string">&quot;PTE1 %p\n&quot;</span>,*(DWORD*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x007FFFF8</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">//说明是10-10-12分页</span></span><br><span class="line">	KdPrint((<span class="string">&quot;10-10-12分页\n&quot;</span>));</span><br><span class="line">	KdPrint((<span class="string">&quot;PTE1 %p\n&quot;</span>,*(DWORD*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x003FFFFC</span>))));</span><br><span class="line">	*(DWORD*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x003FFFFC</span>)) |= <span class="number">0x02</span>;</span><br><span class="line">	KdPrint((<span class="string">&quot;PTE2 %p\n&quot;</span>,*(DWORD*)(<span class="number">0xC0000000</span> + ((HookFunAddr &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x003FFFFC</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法，就是修改CR0寄存器，CR0寄存器的第16位叫做保护属性位，控制着页的读或写属性。</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117145749081.png" alt="image-20230117145749081"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">PageProtectOn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">			mov  eax,cr0</span><br><span class="line">			or   eax,<span class="number">10000</span>h</span><br><span class="line">			mov  cr0,eax</span><br><span class="line">			sti</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PageProtectOff</span><span class="params">()</span>				</span><br><span class="line">&#123;</span><br><span class="line">	__asm&#123;</span><br><span class="line">			cli					</span><br><span class="line">			mov  eax,cr0</span><br><span class="line">			and  eax,not <span class="number">10000</span>h</span><br><span class="line">			mov  cr0,eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意无论是通过页改的还是通过寄存器改的最后都要改回来。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>就是简单将<code>OpenProcess</code>的参数打印出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 类型声明                                                             */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PULONG ServiceTableBase;        <span class="comment">// 函数地址表（SSDT）</span></span><br><span class="line">    PULONG ServiceCounterTableBase; <span class="comment">// SSDT 函数被调用的次数</span></span><br><span class="line">    ULONG NumberOfService;          <span class="comment">// 函数个数</span></span><br><span class="line">    PULONG ParamTableBase;          <span class="comment">// 函数参数表（SSPT）</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE ntoskrnl; <span class="comment">// 内核函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE win32k;   <span class="comment">// win32k.sys 函数</span></span><br><span class="line">    KSYSTEM_SERVICE_TABLE unUsed1;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE unUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTOPENPROCESS</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*NTOPENPROCESS)</span><span class="params">(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 函数声明                                                             */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span>;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)</span>;</span><br><span class="line">VOID <span class="title function_">PageProtectOff</span><span class="params">()</span>;</span><br><span class="line">VOID <span class="title function_">PageProtectOn</span><span class="params">()</span>;</span><br><span class="line">VOID <span class="title function_">HookNtOpenProcess</span><span class="params">()</span>;</span><br><span class="line">VOID <span class="title function_">UnHookNtOpenProcess</span><span class="params">()</span>;</span><br><span class="line">NTSTATUS <span class="title function_">HbgNtOpenProcess</span><span class="params">(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 全局变量                                                             */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable; <span class="comment">// ntoskrnl.exe 导出的全局变量</span></span><br><span class="line">ULONG uOldNtOpenProcess;                                    <span class="comment">// 旧的函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/* 函数定义                                                             */</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动入口</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HOOK</span></span><br><span class="line">    HookNtOpenProcess();</span><br><span class="line"></span><br><span class="line">    pDriver-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载驱动</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriver)</span></span><br><span class="line">&#123;</span><br><span class="line">    UnHookNtOpenProcess();</span><br><span class="line">    DbgPrint(<span class="string">&quot;Driver unloaded.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭页保护</span></span><br><span class="line">VOID <span class="title function_">PageProtectOff</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">		cli; <span class="comment">// 关闭中断</span></span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		and eax, not <span class="number">0x10000</span>; <span class="comment">// WP位置0</span></span><br><span class="line">		mov cr0, eax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启页保护</span></span><br><span class="line">VOID <span class="title function_">PageProtectOn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		or eax, <span class="number">0x10000</span>; <span class="comment">// WP位置1</span></span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		sti; <span class="comment">// 恢复中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HOOK NtOpenProcess</span></span><br><span class="line">VOID <span class="title function_">HookNtOpenProcess</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PageProtectOff();</span><br><span class="line">    uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7A</span>];</span><br><span class="line">    KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7A</span>] = (ULONG)HbgNtOpenProcess;</span><br><span class="line">    PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnHOOK NtOpenProcess</span></span><br><span class="line">VOID <span class="title function_">UnHookNtOpenProcess</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PageProtectOff();</span><br><span class="line">    KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7A</span>] = uOldNtOpenProcess;</span><br><span class="line">    PageProtectOn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被修改的 NtOpenProcess 函数，简单打印参数</span></span><br><span class="line">NTSTATUS <span class="title function_">HbgNtOpenProcess</span><span class="params">(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)</span></span><br><span class="line">&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;%x %x %x %x\n&quot;</span>, ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">    <span class="keyword">return</span> ((NTOPENPROCESS)uOldNtOpenProcess)(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是没挂钩子之前的：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117150934452.png" alt="image-20230117150934452"></p>
<p>这是挂上之后的：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117151105934.png" alt="image-20230117151105934"></p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117151029551.png" alt="image-20230117151029551"></p>
<p>可以看到还是很容易被发现的。</p>
<h1 id="008-Inline-Hook"><a href="#008-Inline-Hook" class="headerlink" title="008.Inline Hook"></a>008.Inline Hook</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/2020/04/20/Inline-Hook-SSDT/">https://cataloc.gitee.io/blog/2020/04/20/Inline-Hook-SSDT/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luoyesiqiu/p/12306336.html">https://www.cnblogs.com/luoyesiqiu/p/12306336.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/103557383">https://blog.csdn.net/qq_41988448/article/details/103557383</a></p>
</blockquote>
<p>SSDT Hook缺点：</p>
<ul>
<li>容易发现，容易绕过</li>
<li>只能Hook系统服务表里面有的函数</li>
</ul>
<p>无论是3环还是0环，Inline Hook的原理是一样的：</p>
<ol>
<li>通过<strong>修改</strong>函数中的<strong>指令</strong>，改变程序执行的流程</li>
<li><strong>跳转到自己定义的代码段</strong>中执行</li>
<li>最后再<strong>返回到原始函数</strong>中</li>
</ol>
<p>inline hook是一种通过修改机器码的方式来实现hook的技术。</p>
<p>挂钩：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117235442739.png" alt="image-20230117235442739"></p>
<p>执行流程：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117201023604.png" alt="image-20230117201023604"></p>
<p>脱钩：</p>
<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117235457065.png" alt="image-20230117235457065"></p>
<h2 id="实验1：3环Inline-Hook"><a href="#实验1：3环Inline-Hook" class="headerlink" title="实验1：3环Inline Hook"></a>实验1：3环Inline Hook</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="type">void</span> <span class="title function_">OnCall</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnCall函数用<code>_declspec(naked)</code>修饰，被它修饰的函数我们常称它为裸函数，裸函数的特点是在编译生成的时候不会产生过多用于平衡堆栈的指令，这意味着在裸函数中我们要编写<strong>内联汇编</strong>控制堆栈平衡。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE *ProcAddr = <span class="number">0</span>;    <span class="comment">// 原函数地址</span></span><br><span class="line">DWORD OldProtect = <span class="number">0</span>;  <span class="comment">// 保存旧的内存保护</span></span><br><span class="line">BYTE OldCmd[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储原函数头部原始指令 在最后面构造返回到原函数的指令</span></span><br><span class="line"></span><br><span class="line">BYTE *HookProcAddr = <span class="number">0</span>; <span class="comment">// 钩子函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针 将数据作为指令执行</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*POLDCMD)</span><span class="params">()</span>;</span><br><span class="line">POLDCMD pOldCmd = (POLDCMD)(<span class="type">char</span> *)OldCmd;</span><br><span class="line"><span class="comment">// printf的格式</span></span><br><span class="line"><span class="type">char</span> *format = <span class="string">&quot;%x&quot;</span>;</span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">add</span><span class="params">(DWORD a, DWORD b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __declspec(naked) HookProc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存现场</span></span><br><span class="line">    __asm</span><br><span class="line">        &#123;</span><br><span class="line">    	pushad</span><br><span class="line">    	pushfd</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得参数1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = &quot;</span>);</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">        &#123;</span><br><span class="line">    	mov eax, esp</span><br><span class="line">    	add eax, <span class="number">40</span></span><br><span class="line"></span><br><span class="line">    	push [eax]</span><br><span class="line">    	push format</span><br><span class="line">    	call <span class="built_in">printf</span></span><br><span class="line">    	add esp, <span class="number">8</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得参数2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nb = &quot;</span>);</span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">        &#123;</span><br><span class="line">    	mov eax, esp</span><br><span class="line">    	add eax, <span class="number">44</span></span><br><span class="line"></span><br><span class="line">    	push [eax]</span><br><span class="line">    	push format</span><br><span class="line">    	call <span class="built_in">printf</span></span><br><span class="line">    	add esp, <span class="number">8</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原现场</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    	popfd</span><br><span class="line">    	popad</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行原函数头部指令 并返回到原函数下一行继续执行</span></span><br><span class="line">    	jmp pOldCmd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获得需要挂钩的函数地址</span></span><br><span class="line">    ProcAddr = (BYTE *)add + <span class="number">1</span>;</span><br><span class="line">    ProcAddr += *(DWORD *)ProcAddr + <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 修改内存保护</span></span><br><span class="line">    VirtualProtect(ProcAddr, <span class="number">6</span>, PAGE_EXECUTE_READWRITE, &amp;OldProtect);</span><br><span class="line">    <span class="comment">// 将被覆盖的指令复制到数组中</span></span><br><span class="line">    <span class="built_in">strncpy</span>((<span class="type">char</span> *)OldCmd, (<span class="type">char</span> *)ProcAddr, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组末尾添上跳转指令 用于返回到被挂钩的函数</span></span><br><span class="line">    OldCmd[<span class="number">6</span>] = <span class="number">0xE9</span>;</span><br><span class="line">    *(DWORD *)&amp;OldCmd[<span class="number">7</span>] = (DWORD)(ProcAddr + <span class="number">6</span>) - (DWORD)&amp;OldCmd[<span class="number">6</span>] - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得钩子函数的地址</span></span><br><span class="line">    HookProcAddr = (BYTE *)HookProc + <span class="number">1</span>;</span><br><span class="line">    HookProcAddr += *(DWORD *)HookProcAddr + <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 修改原函数的头部 跳转到钩子函数</span></span><br><span class="line">    ProcAddr[<span class="number">0</span>] = <span class="number">0xE9</span>;</span><br><span class="line">    *(DWORD *)&amp;ProcAddr[<span class="number">1</span>] = HookProcAddr - ProcAddr - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转指令只占五个字节 原函数头部三行指令占六个字节 因此将多余字节填充为nop</span></span><br><span class="line">    ProcAddr[<span class="number">5</span>] = <span class="number">0x90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UnInlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断函数是否被挂钩</span></span><br><span class="line">    <span class="keyword">if</span> (ProcAddr[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>((<span class="type">char</span> *)ProcAddr, (<span class="type">char</span> *)OldCmd, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂钩</span></span><br><span class="line">    InlineHook();</span><br><span class="line"></span><br><span class="line">    sum = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %x\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脱钩</span></span><br><span class="line">    <span class="comment">// UnInlineHook();</span></span><br><span class="line"></span><br><span class="line">    sum = add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %x\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117235309994.png" alt="image-20230117235309994"></p>
<h2 id="实验2：0环Inline-Hook"><a href="#实验2：0环Inline-Hook" class="headerlink" title="实验2：0环Inline Hook"></a>实验2：0环Inline Hook</h2><p>这里还是使用<code>OpenProcess</code>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PUCHAR pNtOpenProcess;</span><br><span class="line">UCHAR  OldCmd[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//函数指针 用于将数据作为指令执行</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">VOID</span> <span class="params">(*POLDCMD)</span><span class="params">()</span>;</span><br><span class="line">POLDCMD pOldCmd = (POLDCMD)(PUCHAR)OldCmd;</span><br><span class="line"></span><br><span class="line">PCHAR format = <span class="string">&quot;%x %x %x %x \r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span> <span class="params">(*NTOPENPROCESS)</span><span class="params">(</span></span><br><span class="line"><span class="params">	PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">	POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">	PCLIENT_ID ClientId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">	PULONG  ServiceTableBase;			<span class="comment">// 服务函数地址表基址  </span></span><br><span class="line">	PULONG  ServiceCounterTableBase;	<span class="comment">// SSDT函数被调用的次数</span></span><br><span class="line">	ULONG   NumberOfService;			<span class="comment">// 服务函数的个数  </span></span><br><span class="line">	PULONG   ParamTableBase;			<span class="comment">// 服务函数参数表基址   </span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   ntoskrnl;		<span class="comment">// ntoskrnl.exe 的服务函数  </span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE   win32k;			<span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  </span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed1;  </span><br><span class="line">	KSYSTEM_SERVICE_TABLE   notUsed2;  </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了</span></span><br><span class="line"><span class="keyword">extern</span> PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PageProtectOn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm&#123;<span class="comment">//开启内存保护</span></span><br><span class="line">		mov  eax,cr0</span><br><span class="line">		or   eax,<span class="number">10000</span>h</span><br><span class="line">		mov  cr0,eax</span><br><span class="line">		sti</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">PageProtectOff</span><span class="params">()</span>				</span><br><span class="line">&#123;</span><br><span class="line">	__asm&#123;<span class="comment">//关闭内存保护</span></span><br><span class="line">		cli					</span><br><span class="line">		mov  eax,cr0</span><br><span class="line">		and  eax,not <span class="number">10000</span>h</span><br><span class="line">		mov  cr0,eax</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID __declspec(naked) HookProc()&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//保存现场</span></span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	</span><br><span class="line">		mov eax, esp</span><br><span class="line">		add eax, <span class="number">40</span>		<span class="comment">//eflags + 8个通用寄存器 + 返回地址</span></span><br><span class="line">		add eax, <span class="number">12</span>		<span class="comment">//定位到最后一个参数</span></span><br><span class="line">		push [eax]		<span class="comment">//ClientId</span></span><br><span class="line">		push [eax<span class="number">-0x4</span>]	<span class="comment">//ObjectAttributes</span></span><br><span class="line">		push [eax<span class="number">-0x8</span>]	<span class="comment">//DesiredAccess</span></span><br><span class="line">		push [eax<span class="number">-0xC</span>]	<span class="comment">//ProcessHandle</span></span><br><span class="line">		push format</span><br><span class="line">		call DbgPrint</span><br><span class="line">		add esp, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原现场</span></span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用原本的指令，然后返回到原函数</span></span><br><span class="line">		jmp pOldCmd</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">InlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	PageProtectOff();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存原来的指令</span></span><br><span class="line">	pNtOpenProcess = (PUCHAR)KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7A</span>];</span><br><span class="line">	RtlMoveMemory(OldCmd, pNtOpenProcess, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造回去的指令，用于返回到原函数</span></span><br><span class="line">	OldCmd[<span class="number">5</span>] = <span class="number">0xE9</span>;</span><br><span class="line">	*(PULONG)&amp;OldCmd[<span class="number">6</span>] = ((ULONG)pNtOpenProcess+<span class="number">5</span>) - (ULONG)&amp;OldCmd[<span class="number">5</span>] - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内核函数不存在中间人（call后通过jmp跳转），函数地址为实际地址</span></span><br><span class="line">	pNtOpenProcess[<span class="number">0</span>] = <span class="number">0xE9</span>;</span><br><span class="line">	*(PULONG)&amp;pNtOpenProcess[<span class="number">1</span>] = (ULONG)HookProc - (ULONG)pNtOpenProcess - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	PageProtectOn();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">UnInlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pNtOpenProcess[<span class="number">0</span>] == <span class="number">0xE9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PageProtectOff();</span><br><span class="line">		RtlMoveMemory(pNtOpenProcess, OldCmd, <span class="number">5</span>);</span><br><span class="line">		PageProtectOn();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//卸载驱动时脱钩</span></span><br><span class="line">	UnInlineHook();</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">&quot;驱动程序已停止.\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动程序入口函数，相当于控制台的main函数</span></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)</span></span><br><span class="line">&#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;驱动程序已运行.\r\n&quot;</span>);</span><br><span class="line">	<span class="comment">//运行驱动时挂钩</span></span><br><span class="line">	InlineHook();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置一个卸载函数  便于退出</span></span><br><span class="line">	DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/image-20230117235958593.png" alt="image-20230117235958593"></p>
<h1 id="009-多核同步之临界区"><a href="#009-多核同步之临界区" class="headerlink" title="009.多核同步之临界区"></a>009.多核同步之临界区</h1><p>并发：指多个线程在同时执行</p>
<ul>
<li><code>单核</code>：各个线程分时执行，不是真正意义上的同时</li>
<li><code>多核</code>：在某一时刻，会同时有多个线程在执行</li>
</ul>
<p><strong>同步</strong>：保证在并发执行的环境中各个线程可以有序的执行</p>
<h2 id="单行指令的同步"><a href="#单行指令的同步" class="headerlink" title="单行指令的同步"></a>单行指令的同步</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwVal = <span class="number">0</span>;	<span class="comment">//全局变量</span></span><br><span class="line">....</span><br><span class="line">....    </span><br><span class="line"><span class="comment">//某个线程中</span></span><br><span class="line">dwVal++;		<span class="comment">//这行代码是否安全？</span></span><br></pre></td></tr></table></figure>

<p>实际上是<strong>不安全</strong>的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [0x12345678]</span><br><span class="line">add eax, 1</span><br><span class="line">mov [0x12345678], eax</span><br></pre></td></tr></table></figure>

<p>程序<strong>在执行dwVal++时</strong>，<strong>需要按</strong>照顺序<strong>执行3条汇编指令</strong>，才能实现这条语句的功能。</p>
<p>现在我们来考虑一种情况，线程A和线程B均要进行dwVal++这条指令，理想状态下，这两个线程执行完后，该全局变量的值会增加2。但是<strong>如果在线程A执行完第二条指令后</strong>，<strong>发生了线程切换</strong>，情况就会变的不一样了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//线程A</span><br><span class="line">mov eax, [0x12345678]</span><br><span class="line">add eax, 1</span><br><span class="line"></span><br><span class="line">//发生线程切换</span><br><span class="line">//线程B</span><br><span class="line">mov eax, [0x12345678]</span><br><span class="line">add eax, 1</span><br><span class="line">mov [0x12345678], eax</span><br><span class="line"></span><br><span class="line">//发生线程切换</span><br><span class="line">//线程A</span><br><span class="line">mov [0x12345678], eax</span><br></pre></td></tr></table></figure>

<p>那单行指令安全吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc dword ptr ds:[0x12345678]	//一行汇编指令，安全吗?</span><br></pre></td></tr></table></figure>

<p>这条汇编指令仅有一行，看上去不会出现上述的情况。即使线程发生切换了，也不会造成指令的重复执行。的确，在<strong>单核</strong>的情况下，这条指令是<strong>安全</strong>的，但是<strong>多核</strong>的情况下，还是有可能发生，不同线程同时执行这条指令的情况，所以这条指令并<strong>不安全</strong>。那如何才能在多核的情况下，依旧保证线程间的同步呢？那就需要用到下面介绍的这条指令了。</p>
<h3 id="Lock指令"><a href="#Lock指令" class="headerlink" title="Lock指令"></a>Lock指令</h3><p>只需要增加一个lock指令，就能让<strong>单条指令</strong>在多核的情况下做到同步，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock inc dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>

<p><strong>lock指令可以锁定当前指令执行时线程所访问的内存</strong>，上述代码执行时，会对0x12345678地址处的值进行修改，<strong>有了lock指令</strong>的限制，此时<strong>其它线程</strong>是<strong>不能访问或修改0x12345678地址处的值</strong>的，只有在这条指令执行完后，其余线程才可以对此地址的值进行访问或者修改。这样就避免了多核情况下，不同线程同时修改此地址处的值的情况。</p>
<p>像上面这样通过Lock指令进行限制，从而<strong>不可被中断的操作</strong>叫做<strong>原子操作</strong>。Windows提供了一部分API（主要位于Kernel32.dll和Ntdll.dll）供用户使用从而保证在多核情况下的线程同步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子操作相关的API：</span></span><br><span class="line">InterlockedIncrement			InterlockedExchangeAdd</span><br><span class="line">InterlockedDecrement			InterlockedFlushSList		</span><br><span class="line">InterlockedExchange			InterlockedPopEntrySList</span><br><span class="line">InterlockedCompareExchange		InterlockedPushEntrySList</span><br></pre></td></tr></table></figure>

<h3 id="InterlockedIncrement"><a href="#InterlockedIncrement" class="headerlink" title="InterlockedIncrement"></a>InterlockedIncrement</h3><p>挑一个来分析，该API在kernel32.dll中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:7C809806 ; LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend)</span><br><span class="line">.text:7C809806                 public InterlockedIncrement</span><br><span class="line">.text:7C809806 InterlockedIncrement proc near          ; CODE XREF: CreatePipe+57↓p</span><br><span class="line">.text:7C809806                                         ; sub_7C82CBB2+41↓p ...</span><br><span class="line">.text:7C809806</span><br><span class="line">.text:7C809806 lpAddend        = dword ptr  4</span><br><span class="line">.text:7C809806</span><br><span class="line">.text:7C809806                 mov     ecx, [esp+lpAddend]</span><br><span class="line">.text:7C80980A                 mov     eax, 1          ; 将需要修改的变量的地址赋给ecx，此时可以通过[ecx]访问该变量的值</span><br><span class="line">.text:7C80980F</span><br><span class="line">.text:7C80980F loc_7C80980F:                           ; DATA XREF: .data:off_7C88500C↓o</span><br><span class="line">.text:7C80980F                 lock xadd [ecx], eax    ; 第一部分是lock，用来锁住内存；另一部分核心在于xadd指令，该指令接收2个参数，先交换两个操作数的值，再进行算术加法操作:</span><br><span class="line">.text:7C80980F                                         ; DWORD　temp;</span><br><span class="line">.text:7C80980F                                         ; temp = [ecx];</span><br><span class="line">.text:7C80980F                                         ; [ecx] = eax;</span><br><span class="line">.text:7C80980F                                         ; eax = temp;</span><br><span class="line">.text:7C80980F                                         ; [ecx] += eax;</span><br><span class="line">.text:7C809813                 inc     eax             ; eax自增1，此时eax和[ecx]的值相同，eax可以起到返回值的作用（尽管已经完成对[ecx]值的修改）</span><br><span class="line">.text:7C809814                 retn    4</span><br><span class="line">.text:7C809814 InterlockedIncrement endp</span><br></pre></td></tr></table></figure>



<h2 id="多行指令的同步"><a href="#多行指令的同步" class="headerlink" title="多行指令的同步"></a>多行指令的同步</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>可以设置一个临界区：一次只允许一个线程进入直到离开，从而保证线程的同步（这里的临界区指的是广义的临界区，各个操作系统根据临界区的思想都有各自的实现，后面也会学习到Windows提供的临界区实现）参考如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwFlag = <span class="number">0</span>;		<span class="comment">//实现临界区的方式就是加锁</span></span><br><span class="line">						<span class="comment">//锁：全局变量  进去加一 出去减一</span></span><br><span class="line"><span class="keyword">if</span>(dwFlag  == <span class="number">0</span>)		<span class="comment">//进入临界区	</span></span><br><span class="line">&#123;	</span><br><span class="line">	dwFlag   = <span class="number">1</span>	</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">	.......</span><br><span class="line">		</span><br><span class="line">	dwFlag   = <span class="number">0</span>		<span class="comment">//离开临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细观察一遍这个代码，其实是有问题的，考虑一种情况，在进入临界区后，如果dwFlag = 1这条指令还没有执行，此时发生了线程切换，这时，切换后的新线程也可以进入临界区，这样临界区的作用就失效了。</p>
<h3 id="自己实现临界区"><a href="#自己实现临界区" class="headerlink" title="自己实现临界区"></a>自己实现临界区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//定义全局变量</span><br><span class="line">Flag = 0;</span><br><span class="line"></span><br><span class="line">//进入临界区</span><br><span class="line">Lab：</span><br><span class="line">	mov eax,1</span><br><span class="line">	//多核情况下必须加lock</span><br><span class="line">	lock xadd [Flag],eax</span><br><span class="line">	cmp eax,0</span><br><span class="line">	jz endLab</span><br><span class="line">	dec [Flag]</span><br><span class="line">	//线程等待Sleep..</span><br><span class="line">	jmp Lab</span><br><span class="line"></span><br><span class="line">//临界区内部</span><br><span class="line">endLab:</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">//离开临界区</span><br><span class="line">lock dec [Flag]</span><br></pre></td></tr></table></figure>

<p>这份伪代码提供了一个新的思路，在进入临界区之前，先判断锁的值，若达到进入临界区的条件，则<strong>先修改锁的值</strong>，<strong>再进入临界区</strong>；<strong>若条件不符合</strong>，则调用sleep()函数，进行<strong>线程等待</strong>。一段时间后，在跳回进入临界区的地方重新判断。在<strong>线程退出临界区</strong>后，<strong>再</strong>通过原子操作<strong>还原锁的值</strong>。</p>
<h1 id="010-多核同步之自旋锁"><a href="#010-多核同步之自旋锁" class="headerlink" title="010.多核同步之自旋锁"></a>010.多核同步之自旋锁</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/2020/05/09/%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/">多核同步之自旋锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kwansy/article/details/109995196">自旋锁 ， cmpxchg8b 指令</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41988448/article/details/103585673">多核同步&amp;内核重载</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/13170495">读书笔记之《Windows内核原理与实现》</a></p>
</blockquote>
<p>Windows提供的一种实现多核同步的机制：<strong>自旋锁</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//单核</span><br><span class="line">ntkrnlpa.exe					2-9-9-12分页</span><br><span class="line">ntoskrnl.exe					10-10-12分页</span><br><span class="line"></span><br><span class="line">//多核:</span><br><span class="line">ntkrnlpa.exe（ntkrpamp.exe）			2-9-9-12分页</span><br><span class="line">ntoskrnl.exe（ntkrnlmp.exe）			10-10-12分页</span><br></pre></td></tr></table></figure>

<p>Intel的CPU，<strong>多核情况下</strong>，<strong>系统安装时将ntkrnlmp.exe拷贝为ntoskrnl.exe</strong>，系统加载时加载这个（原来是ntkrnlmp.exe的）ntoskrnl.exe。所以Intel多核情况下，内核<strong>文件名仍然是ntoskrnl.exe</strong>，但是其<strong>源文件名是ntkrnlmp.exe</strong>，如果加载符号，符号文件名也是ntkrnlmp.pdb。也因此，单核，多核情况下都叫做ntoskrnl.exe。</p>
<p>注意设置虚拟机CPU核心数量，</p>
<blockquote>
<p>用一个例子来解释临界区和自旋锁的区别。只有一个厕所，有一个人进去了。</p>
<p>临界区就是外面的人过来看一眼发现没位子，就回家睡觉了，睡醒了再回来看看有没有位子，重复这样的步骤；</p>
<p>自旋锁就是外面人一看没位置，他就在原地打转，一有位子马上就进去了。</p>
</blockquote>
<h2 id="KeAcquireSpinLockAtDpcLevel"><a href="#KeAcquireSpinLockAtDpcLevel" class="headerlink" title="KeAcquireSpinLockAtDpcLevel"></a>KeAcquireSpinLockAtDpcLevel</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/del/archive/2010/04/15/1712467.html">BT、BTS、BTR、BTC: 位测试指令</a></p>
</blockquote>
<p>首先介绍两个指令，一个是bt一个是bts：</p>
<ul>
<li><p>BT(Bit Test)：位测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;BT 把 10000001b 的第七位复制到 CF, 得知是 1</span><br><span class="line">mov dx, 10000001b</span><br><span class="line">bt  dx, 7</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>BTS(Bit Test and Set：位测试并置位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;BTS 在执行 BT 命令的同时, 把操作数的指定位置为 1</span><br><span class="line">mov dx, 10000001b</span><br><span class="line">bts dx, 6</span><br></pre></td></tr></table></figure></li>
</ul>
<p>单核的是直接retn了。</p>
<p>多核：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">text:0040B38B ; __stdcall KeAcquireSpinLockAtDpcLevel(x)</span><br><span class="line">.text:0040B38B                 public _KeAcquireSpinLockAtDpcLevel@4</span><br><span class="line">.text:0040B38B _KeAcquireSpinLockAtDpcLevel@4 proc near</span><br><span class="line">.text:0040B38B</span><br><span class="line">.text:0040B38B arg_0           = dword ptr  4</span><br><span class="line">.text:0040B38B</span><br><span class="line">.text:0040B38B                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:0040B38F</span><br><span class="line">.text:0040B38F loc_40B38F:                             ; CODE XREF: KeAcquireSpinLockAtDpcLevel(x)+14↓j</span><br><span class="line">.text:0040B38F                 lock bts dword ptr [ecx], 0 ;</span><br><span class="line">.text:0040B38F                                         ; 1.先判断[ecx]是否为0，是的话CF=1，否则为0</span><br><span class="line">.text:0040B38F                                         ; 2.将[ecx]指定的下标置1</span><br><span class="line">.text:0040B38F                                         ; 加lock保证多核情况下的安全</span><br><span class="line">.text:0040B394                 jb      short loc_40B399 ;</span><br><span class="line">.text:0040B394                                         ; 如果[ecx]!=0则跳转</span><br><span class="line">.text:0040B394                                         ; 如果[ecx]==0说明没有线程进入当前临界区</span><br><span class="line">.text:0040B396                 retn    4</span><br><span class="line">.text:0040B399 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040B399</span><br><span class="line">.text:0040B399 loc_40B399:                             ; CODE XREF: KeAcquireSpinLockAtDpcLevel(x)+9↑j</span><br><span class="line">.text:0040B399                                         ; KeAcquireSpinLockAtDpcLevel(x)+18↓j</span><br><span class="line">.text:0040B399                 test    dword ptr [ecx], 1 ; 如果[ecx]!=1则跳转</span><br><span class="line">.text:0040B399                                         ; 如果[ecx]==1说明当前资源被占用</span><br><span class="line">.text:0040B39F                 jz      short loc_40B38F ; 跳到开头再来KeAcquireSpinLockAtDpcLevel</span><br><span class="line">.text:0040B3A1                 pause                   ; CPU降温指令，短时间内降低CPU功率</span><br><span class="line">.text:0040B3A3                 jmp     short loc_40B399 ; 重复执行这几行指令，故称为自旋锁</span><br><span class="line">.text:0040B3A3 _KeAcquireSpinLockAtDpcLevel@4 endp</span><br></pre></td></tr></table></figure>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li> 如何HOOK高并发的内核函数？</li>
</ul>
<blockquote>
<p>这个问题的关键是，hook 后一般是 e8 / e9 后跟4字节，总共5字节，但没办法一次性改5个字节，可能改了第一个字节，正要改后4个字节时，别的线程进来了，就会出错。</p>
<p>有三种办法：</p>
<ul>
<li>短跳中转</li>
<li>中断门</li>
<li>找一条一次性修改8字节的指令</li>
</ul>
</blockquote>
<ol>
<li>先在附近未使用的内存空间构造一个<strong>长跳转</strong>（五个字节），再在要hook的地方构造一个<strong>短跳转</strong>（一次性写入两个字节）指向长跳转位置</li>
<li>使用 <strong>cmpxchg8b</strong> 指令最多可一次性写入<strong>八个字节</strong></li>
</ol>
<hr>
<p><strong>cmpxchg8b</strong>指令</p>
<blockquote>
<p>cmpxchg8b mem64 指令的工作如下：<br>比较 mem64 和 EDX:EAX<br>如果相等，那么把 ECX:EBX 存储到 mem64<br>如果不相等，那么把 mem64 存储到 EDX:EAX</p>
</blockquote>
<h1 id="011-内核重载"><a href="#011-内核重载" class="headerlink" title="011.内核重载"></a>011.内核重载</h1><ul>
<li><p>描述：</p>
<ul>
<li><p>内核中的很多函数被层层HOOK，重载一份内核可以绕过这些HOOK</p>
</li>
<li><p>内核重载与映射PE文件的方法无异，本质上没有区别</p>
</li>
<li><p>内核重载就是重新加载一份内核文件（ntkrnlpa.exe）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>步骤：</p>
<ol>
<li><p>申请内存，按内存对齐展开</p>
</li>
<li><p>根据重定位表修复全局变量</p>
</li>
<li><p>修复IAT表(修复导入表的说法不准确)</p>
</li>
<li><p>山寨系统服务表</p>
</li>
<li><p>狸猫换太子（Hook KiFastCallEntry）</p>
</li>
</ol>
</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/01/16/2023-1-WinKernel%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-01-18 00:00:00
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Technology/" title="Technology">
                        <b>#</b> Technology
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Win32/" title="Win32">
                        #Win32
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/01/22/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#001-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-text">001.驱动开发环境配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#002-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">002.第一个驱动程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#003-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">003.如何调试驱动程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#004-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">004.内核编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%96%87%E6%A1%A3%E5%8C%96%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">未文档化函数与未导出函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0"><span class="toc-text">常用的内核内存函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">内核字符串及常用字符串函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#005-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-text">005.内核空间与内核模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#006-r0%E4%B8%8Er3%E9%80%9A%E4%BF%A1-%E5%B8%B8%E8%A7%84%E6%96%B9%E5%BC%8F"><span class="toc-text">006.r0与r3通信(常规方式)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">数据交互的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C-Device-%E2%80%9C%E4%B8%8E%E2%80%9C-%E2%80%9D"><span class="toc-text">“\\Device\\“与“\\??\\”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F"><span class="toc-text">派遣函数格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E7%8E%AF%E4%B8%8E3%E7%8E%AF%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-text">0环与3环通信实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B4%BE%E9%81%A3%E5%87%BD%E6%95%B0%EF%BC%9AMajorFunction%EF%BC%8CIRP-MJ-DEVICE-CONTROL%E6%8C%87win32api%E8%B0%83%E7%94%A8DeviceIoControl%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C%E3%80%82"><span class="toc-text">设置派遣函数：MajorFunction，IRP_MJ_DEVICE_CONTROL指win32api调用DeviceIoControl时会执行。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#007-SSTD-Hook"><span class="toc-text">007.SSTD Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-text">得到函数表的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSDT-Hook"><span class="toc-text">SSDT Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#008-Inline-Hook"><span class="toc-text">008.Inline Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C1%EF%BC%9A3%E7%8E%AFInline-Hook"><span class="toc-text">实验1：3环Inline Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C2%EF%BC%9A0%E7%8E%AFInline-Hook"><span class="toc-text">实验2：0环Inline Hook</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#009-%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">009.多核同步之临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">单行指令的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E6%8C%87%E4%BB%A4"><span class="toc-text">Lock指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InterlockedIncrement"><span class="toc-text">InterlockedIncrement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">多行指令的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">自己实现临界区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#010-%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">010.多核同步之自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KeAcquireSpinLockAtDpcLevel"><span class="toc-text">KeAcquireSpinLockAtDpcLevel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-text">思考题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#011-%E5%86%85%E6%A0%B8%E9%87%8D%E8%BD%BD"><span class="toc-text">011.内核重载</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Ghostasky">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/ghostasky">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Ghostasky">怕什么真理无穷，进一寸有进一寸的欢喜。</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Windows%E5%86%85%E6%A0%B8(%E4%BA%8C)%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8 + '&url=' + https%3A%2F%2Fghostasky.github.io%2F2023%2F01%2F18%2F2023-1-WinKernel%25E9%25A9%25B1%25E5%258A%25A8%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://ghostasky.github.io/2023/01/18/2023-1-WinKernel%E9%A9%B1%E5%8A%A8/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
