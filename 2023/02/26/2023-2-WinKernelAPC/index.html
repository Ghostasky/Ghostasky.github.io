<!DOCTYPE html>
<html lang="zh-cn" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="郁涛丶" />
  <meta name="description" content="" />
  
  
  <title>
    
      Windows内核(七)——APC机制 
      
      
      |
    
     郁涛丶&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Ghostasky</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Windows内核(七)——APC机制</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-02-26	  
        </span>
		
		 <span class="post-pubtime"> 本文共7.1k字 </span>

                                                                        <span class="post-pubtime">
        大约需要49min
      </span>
		
		
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Technology/" title="Technology">
                    <b>#</b> Technology
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Win32/" title="Win32">
                    #Win32
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>[toc]</p>
<h1 id="01-APC的本质"><a href="#01-APC的本质" class="headerlink" title="01.APC的本质"></a>01.APC的本质</h1><ol>
<li>线程是不能被“杀掉”、“挂起”、“恢复”的，线程在执行的时候自己占据着CPU，别人不能控制它</li>
<li>举个极端的例子：如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占用CPU</li>
<li>所以说线程如果想“死”，一定是自己执行代码把自己杀死，不存在“他杀”的情况</li>
</ol>
<p><strong>思考</strong>：那如果想改变一个线程的行为该怎么办<br><strong>答案</strong>：可以给他提供一个函数，让它自己去调用：APC（Asyncroneus Procedure Call，异步过程调用）</p>
<h2 id="APC队列"><a href="#APC队列" class="headerlink" title="APC队列"></a>APC队列</h2><ul>
<li><code>ApcListHead</code>：<ol>
<li>由两个双向链表组成，共占16个字节</li>
<li>提供的APC函数可能是<strong>用户函数</strong>，也可能是<strong>系统函数</strong>（简单的区分方法就是判断函数地址是否大于<strong>0x80000000</strong>）</li>
</ol>
</li>
<li><code>Process</code>：指向线程所属或者挂靠进程</li>
<li><code>KernelApcInProgress</code>：内核Apc是否正在执行</li>
<li><code>KernelApcPending</code>：是否存在等待状态的<strong>内核APC</strong>，存在则置1</li>
<li><code>UserApcPending</code>：是否存在等待状态的<strong>用户APC</strong>，存在则置1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x034</span> ApcState         : _KAPC_STATE</span><br><span class="line">   ...</span><br><span class="line">kd&gt; dt _KAPC_STATE</span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +<span class="number">0x000</span> ApcListHead      : [<span class="number">2</span>] _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> Process          : Ptr32 _KPROCESS</span><br><span class="line">   +<span class="number">0x014</span> KernelApcInProgress : UChar</span><br><span class="line">   +<span class="number">0x015</span> KernelApcPending : UChar</span><br><span class="line">   +<span class="number">0x016</span> UserApcPending   : UChar</span><br></pre></td></tr></table></figure>



<h2 id="APC结构"><a href="#APC结构" class="headerlink" title="APC结构"></a>APC结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x004</span> Spare0           : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Thread           : Ptr32 _KTHREAD</span><br><span class="line">   +<span class="number">0x00c</span> ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> KernelRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x018</span> RundownRoutine   : Ptr32     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x01c</span> NormalRoutine    : Ptr32     <span class="type">void</span> <span class="comment">//找到提供的APC函数，并不完全等于APC函数的地址</span></span><br><span class="line">   +<span class="number">0x020</span> NormalContext    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x024</span> SystemArgument1  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> SystemArgument2  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ApcStateIndex    : Char</span><br><span class="line">   +<span class="number">0x02d</span> ApcMode          : Char</span><br><span class="line">   +<span class="number">0x02e</span> Inserted         : UChar</span><br></pre></td></tr></table></figure>

<p>当前线程什么时候将会执行提供的APC</p>
<ol>
<li><code>KiServiceExit</code> 函数（<strong>系统调用</strong>、<strong>异常</strong>或<strong>中断</strong>返回用户控件的必经之路）</li>
<li><code>KiDeliverApc</code> 函数（负责<strong>执行</strong>APC函数）</li>
</ol>
<h2 id="KiServiceExit"><a href="#KiServiceExit" class="headerlink" title="KiServiceExit"></a>KiServiceExit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:004069CD loc_4069CD:                             ; CODE XREF: _KiServiceExit+8↑j</span><br><span class="line">.text:004069CD                                         ; _KiServiceExit+64↓j</span><br><span class="line">.text:004069CD                 mov     ebx, large fs:124h ; 获取ETHREAD</span><br><span class="line">.text:004069D4                 mov     byte ptr [ebx+_KTHREAD.Alerted], 0</span><br><span class="line">.text:004069D8                 cmp     byte ptr [ebx+_KTHREAD.ApcState.UserApcPending], 0 ; 检查是否有APC请求</span><br><span class="line">.text:004069DC                 jz      short loc_406A23</span><br><span class="line">.text:004069DE                 mov     ebx, ebp</span><br><span class="line">.text:004069E0                 mov     [ebx+44h], eax  ; 堆栈中_KTRAP_FREAME结构的eax</span><br><span class="line">.text:004069E3                 mov     dword ptr [ebx+50h], 3Bh ; &#x27;;&#x27; ; 堆栈中_KTRAP_FREAME结构的SegFs</span><br><span class="line">.text:004069EA                 mov     dword ptr [ebx+38h], 23h ; &#x27;#&#x27; ; 堆栈中_KTRAP_FREAME结构的SegDs</span><br><span class="line">.text:004069F1                 mov     dword ptr [ebx+34h], 23h ; &#x27;#&#x27; ; 堆栈中_KTRAP_FREAME结构的SegEs</span><br><span class="line">.text:004069F8                 mov     dword ptr [ebx+30h], 0 ; 堆栈中_KTRAP_FREAME结构的SegGs</span><br><span class="line">.text:004069FF                 mov     ecx, 1          ; APC_LEVEl参数</span><br><span class="line">.text:00406A04                 call    ds:__imp_@KfRaiseIrql@4 ; KfRaiseIrql(x)</span><br><span class="line">.text:00406A0A                 push    eax</span><br><span class="line">.text:00406A0B                 sti                     ; 关中断</span><br><span class="line">.text:00406A0C                 push    ebx</span><br><span class="line">.text:00406A0D                 push    0</span><br><span class="line">.text:00406A0F                 push    1</span><br><span class="line">.text:00406A11                 call    _KiDeliverApc@12 ; 执行内核APC并为用户空间的APC的执行进行准备</span><br><span class="line">.text:00406A16                 pop     ecx             ; 将老的运行级别出栈</span><br><span class="line">.text:00406A17                 call    ds:__imp_@KfLowerIrql@4 ; 恢复原来的运行级别</span><br><span class="line">.text:00406A1D                 mov     eax, [ebx+44h]</span><br><span class="line">.text:00406A20                 cli                     ; 开中断</span><br><span class="line">.text:00406A21                 jmp     short loc_4069CD ; 获取ETHREAD</span><br></pre></td></tr></table></figure>



<h1 id="02-备用APC队列"><a href="#02-备用APC队列" class="headerlink" title="02.备用APC队列"></a>02.备用APC队列</h1><p>还是先看下线程结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _kthread</span><br><span class="line">nt!_KTHREAD</span><br><span class="line">...</span><br><span class="line">+<span class="number">0x034</span> ApcState         : _KAPC_STATE<span class="comment">//APC</span></span><br><span class="line">...</span><br><span class="line">+<span class="number">0x138</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE<span class="comment">//APC指针</span></span><br><span class="line">...</span><br><span class="line">+<span class="number">0x14c</span> SavedApcState    : _KAPC_STATE<span class="comment">//备用APC</span></span><br><span class="line">...</span><br><span class="line">+<span class="number">0x165</span> ApcStateIndex    : UChar<span class="comment">//线程状态</span></span><br><span class="line">+<span class="number">0x166</span> ApcQueueable     : UChar<span class="comment">//当前成员是否允许插入APC</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="SavedApcState"><a href="#SavedApcState" class="headerlink" title="SavedApcState"></a>SavedApcState</h2><ol>
<li>在 <code>_KTHREAD+0x14c</code> 位置处，同样也存在一个 <code>_KAPC_STATE</code> 结构体，叫做 <code>SavedApcState</code></li>
<li><strong>线程APC队列中的APC函数都是与进程相关联的</strong>，具体点说：A进程的T线程中的所有APC函数，要访问的内存地址都是A进程的</li>
<li>但线程是可以挂靠到其他的进程：比如A进程的线程T，通过修改Cr3(改为B进程的页目录基址)，就可以访问B进程地址空间，即所谓“进程挂靠”</li>
<li>当T线程挂靠B进程后，APC队列中存储的却仍然是原来的APC。具体点说，比如某个APC函数要读取一个地址为0x12345678的数据，如果此时进行读取，读到的将是B进程的地址空间，这样逻辑就错误了</li>
<li>为了避免混乱，在T线程挂靠B进程时，会将<code>ApcState</code>中的值暂时存储到<code>SavedApcState</code>中，等回到原进程A时，再将APC队列恢复。</li>
<li>因此，<code>SavedApcState</code>又称为备用APC队列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A进程的T线程挂靠B进程  </span><br><span class="line">	A是T的所属进程  </span><br><span class="line">	B是T的挂靠进程</span><br><span class="line">ApcState    	B进程相关的APC函数     </span><br><span class="line">SavedApcState	A进程相关的APC函数</span><br></pre></td></tr></table></figure>

<h2 id="ApcStateIndex"><a href="#ApcStateIndex" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h2><p><strong>ApcStateIndex</strong> 用来标识当前线程处于什么状态，位于 <strong>_KTHREAD+0x165</strong></p>
<p><strong>0</strong>：正常状态<br><strong>1</strong>：挂靠状态</p>
<h2 id="ApcStatePointer"><a href="#ApcStatePointer" class="headerlink" title="ApcStatePointer"></a>ApcStatePointer</h2><p>为了操作方便，**_KTHREAD** 结构体中定义了一个指针数组 <strong>ApcStatePointer</strong> ，长度为2，位于 <strong>_KTHREAD+0x138</strong></p>
<p>正常情况下：</p>
<ul>
<li><code>ApcStatePointer[0]</code> 指向 ApcState</li>
<li><code>ApcStatePointer[1]</code> 指向 SavedApcState</li>
</ul>
<p>挂靠情况下：</p>
<ul>
<li><code>ApcStatePointer[0]</code> 指向 SavedApcState</li>
<li><code>ApcStatePointer[1]</code> 指向 ApcState</li>
</ul>
<h3 id="组合寻址"><a href="#组合寻址" class="headerlink" title="组合寻址"></a>组合寻址</h3><p>这样和<code>ApcStateIndex</code>就可以组合寻址了：</p>
<p>正常情况下，向<code>ApcState</code>队列中插入APC时：</p>
<ul>
<li><code>ApcStatePointer[0]</code> 指向 <code>ApcState</code>，此时 <code>ApcStateIndex</code> 的值为 0</li>
<li><code>ApcStatePointer[ApcStateIndex]</code> 指向 <code>ApcState</code></li>
</ul>
<p>挂靠情况下，向<code>ApcState</code>队列中插入APC时：</p>
<ul>
<li><code>ApcStatePointer[1]</code> 指向 <code>ApcState</code>，此时 <code>ApcStateIndex</code> 的值为 1</li>
<li><code>ApcStatePointer[ApcStateIndex]</code> 指向 <code>ApcState</code></li>
</ul>
<p>总结下来就是，无论什么环境下，<strong>ApcStatePointer[ApcStateIndex]</strong> 指向的都是 <strong>ApcState</strong><br><strong>ApcState</strong> 总是表示线程当前使用的apc状态</p>
<h2 id="ApcQueueable"><a href="#ApcQueueable" class="headerlink" title="ApcQueueable"></a>ApcQueueable</h2><ol>
<li>位于 <code>_KTHREAD+0x166</code>，表示是否可以向线程的APC队列中插入APC</li>
<li>当线程正在执行退出的代码时，会将这个值设置为0 ，如果此时执行插入APC的代码（<code>KeInsertQueueApc</code>），在插入函数中会判断这个值的状态，如果为0，则插入失败</li>
</ol>
<h1 id="03-APC挂入过程"><a href="#03-APC挂入过程" class="headerlink" title="03.APC挂入过程"></a>03.APC挂入过程</h1><ol>
<li>无论是正常状态还是挂靠状态，都有两个APC队列，一个<strong>内核队列</strong>，一个<strong>用户队列</strong></li>
<li>每当要挂入一个APC函数时，不管是内核APC还是用户APC，内核都要准备一个<strong>KAPC</strong>的数据结构，并且将这个KAPC结构挂到相应的APC队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KAPC</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">	+<span class="number">0x000</span> Type             : Int2B				<span class="comment">//类型 APC类型为0x12</span></span><br><span class="line">	+<span class="number">0x002</span> Size             : Int2B				<span class="comment">//本结构体的大小  0x30</span></span><br><span class="line">	+<span class="number">0x004</span> Spare0           : Uint4B			<span class="comment">//未使用</span></span><br><span class="line">	+<span class="number">0x008</span> Thread           : Ptr32 _KTHREAD	<span class="comment">//目标线程</span></span><br><span class="line">	+<span class="number">0x00c</span> ApcListEntry     : _LIST_ENTRY		<span class="comment">//APC队列挂的位置</span></span><br><span class="line">	+<span class="number">0x014</span> KernelRoutine    : Ptr32     <span class="type">void</span> 	<span class="comment">//指向一个函数(调用ExFreePoolWithTag)APC执行完毕后，释放本结构内存</span></span><br><span class="line">	+<span class="number">0x018</span> RundownRoutine   : Ptr32     <span class="type">void</span> 	<span class="comment">//略</span></span><br><span class="line">	+<span class="number">0x01c</span> NormalRoutine    : Ptr32     <span class="type">void</span> 	<span class="comment">//用户APC总入口  或者 真正的内核apc函数</span></span><br><span class="line">	+<span class="number">0x020</span> NormalContext    : Ptr32 Void		<span class="comment">//内核APC：NULL  用户APC：真正的APC函数</span></span><br><span class="line">	+<span class="number">0x024</span> SystemArgument1  : Ptr32 Void		<span class="comment">//APC函数的参数1</span></span><br><span class="line">	+<span class="number">0x028</span> SystemArgument2  : Ptr32 Void		<span class="comment">//APC函数的参数2</span></span><br><span class="line">	+<span class="number">0x02c</span> ApcStateIndex    : Char				<span class="comment">//挂哪个队列，有四个值：0 1 2 3</span></span><br><span class="line">	+<span class="number">0x02d</span> ApcMode          : Char				<span class="comment">//内核APC 用户APC</span></span><br><span class="line">	+<span class="number">0x02e</span> Inserted         : UChar				<span class="comment">//表示本apc是否已挂入队列 挂入前：0  挂入后  1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>NormalRoutine</strong>:<ul>
<li>如果当前的APC是内核APC，通过它就能找到内核APC函数。</li>
<li>如果当前的APC是用户APC，通过它找到的只是<strong>用户APC的总入口</strong>并不是用户APC函数。</li>
</ul>
</li>
<li><strong>NormalContext</strong>：如果是内核APC这个值为空；如果是用户APC这个值执行的就是用户APC函数</li>
<li><strong>+0x02c ApcStateIndex</strong>（<strong>KTHREAD(+0x165)</strong> 的属性同名，但含义不一样）：<ul>
<li>=0：原始环境</li>
<li>=1：挂靠环境</li>
<li>=2：当前环境</li>
<li>=3：插入APC时的当前环境</li>
</ul>
</li>
</ul>
<h2 id="挂入过程"><a href="#挂入过程" class="headerlink" title="挂入过程"></a>挂入过程</h2><ul>
<li><strong>用户层调用</strong>：<code>QueueUserAPC</code>（kernel32.dll）=&gt;<code>NtQueueApcThread</code>（ntosker.exe）=&gt;内核层</li>
<li><strong>很多内核函数调用</strong>：<code>KeInitializeApc</code>（分配空间，初始化KAPC结构体）=&gt;<code>KeInsertQueueApc</code>=&gt;<code>KiInsertQueueApc</code>（将KAPC插入指定APC队列）</li>
</ul>
<h3 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">KeInitializeApc</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	IN PKAPC Apc,							<span class="comment">//KAPC指针</span></span></span><br><span class="line"><span class="params">	IN PKTHREAD Thread,						<span class="comment">//目标线程</span></span></span><br><span class="line"><span class="params">	IN KAPC_ENVIRONMENT TargetEnvironment,	<span class="comment">//0 1 2 3四种状态</span></span></span><br><span class="line"><span class="params">	IN PKKERNEL_ROUTINE KernelRoutine,		<span class="comment">//销毁KAPC的函数地址</span></span></span><br><span class="line"><span class="params">	IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span></span><br><span class="line"><span class="params">	IN PKNORMAL_ROUTINE NormalRoutine,		<span class="comment">//用户APC总入口或者内核apc函数</span></span></span><br><span class="line"><span class="params">	IN KPROCESSOR_MODE Mode,				<span class="comment">//要插入用户apc队列还是内核apc队列</span></span></span><br><span class="line"><span class="params">	IN PVOID Context						<span class="comment">//内核APC：NULL  用户APC：真正的APC函数</span></span></span><br><span class="line"><span class="params">)</span> </span><br></pre></td></tr></table></figure>

<ol>
<li><code>Thread</code>传进来会挂到 <code>_KAPC.0x8 Thread</code></li>
<li><code>TargetEnvironment</code> 传进来会挂到<code>_KAPC.0x2c ApcStateIndex</code></li>
<li><code>KernelRoutine</code> 传进来会挂到<code>_KAPC.0x14 KernelPoutine</code></li>
<li><code>NormalRoutine</code> 传进来会挂到<code>_KAPC.0x1c NormalRoutine</code></li>
<li><code>Mode</code> 传进来会挂到<code>_KAPC.0x2d ApcMode</code></li>
<li><code>Context</code> 传进来会挂到<code>_KAPC.0x20 NormalRoutine</code></li>
</ol>
<h4 id="ApcStateIndex-1"><a href="#ApcStateIndex-1" class="headerlink" title="ApcStateIndex"></a>ApcStateIndex</h4><p>0表示原始环境，1表示挂靠环境，这两个比较好理解，下面说一下2和3：</p>
<p>当值为2的时候，插入的是当前进程的队列。什么是当前队列，是我不管你环境是挂靠还是不挂靠，我就插入当前进程的<code>APC</code>队列里面，以初始化<code>APC</code>的时候为基准。</p>
<p>当值为3时，插入的是当前进程的<code>APC</code>队列，此时有修复<code>ApcStateIndex</code>的操作，以插入<code>APC</code>的时候为基准。</p>
<h3 id="KeInsertQueueApc"><a href="#KeInsertQueueApc" class="headerlink" title="KeInsertQueueApc"></a>KeInsertQueueApc</h3><ol>
<li>根据<code>KAPC</code>结构中的<code>ApcStateIndex</code>找到对应的APC队列</li>
<li>再根据<code>KAPC</code>结构中的<code>ApcMode</code>确定是用户队列还是内核队列</li>
<li>将<code>KAPC</code>挂到对应的队列中(挂到<code>KAPC</code>的<code>ApcListEntry</code>处)</li>
<li>再根据<code>KAPC</code>结构中的<code>Inserted</code>置1，标识当前的KAPC为已插入状态</li>
<li>修改<code>KAPC_STATE</code>结构中的<code>KernelApcPending</code>/<code>UserApcPending</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">.text:00402C6A var_4           = dword ptr -4</span><br><span class="line">.text:00402C6A</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0040EEB3 SIZE 00000031 BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0041049E SIZE 0000002C BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:004106A4 SIZE 00000031 BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:00412E89 SIZE 00000013 BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0041C2D7 SIZE 0000001A BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0042615A SIZE 0000000F BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0042950C SIZE 0000001E BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:00432270 SIZE 0000000F BYTES</span><br><span class="line">.text:00402C6A ; FUNCTION CHUNK AT .text:0044B3BF SIZE 0000001A BYTES</span><br><span class="line">.text:00402C6A</span><br><span class="line">.text:00402C6A                 mov     edi, edi</span><br><span class="line">.text:00402C6C                 push    ebp</span><br><span class="line">.text:00402C6D                 mov     ebp, esp</span><br><span class="line">.text:00402C6F                 push    ecx</span><br><span class="line">.text:00402C70                 mov     eax, ecx</span><br><span class="line">.text:00402C72                 cmp     byte ptr [eax+2Eh], 0</span><br><span class="line">.text:00402C76                 mov     ecx, [eax+8]</span><br><span class="line">.text:00402C79                 mov     [ebp+var_4], edx</span><br><span class="line">.text:00402C7C                 jnz     loc_44B3BF</span><br><span class="line">.text:00402C82                 cmp     [eax+_KAPC.ApcStateIndex], 3 ; 判断APCStateIndex是否为3</span><br><span class="line">.text:00402C86                 jz      loc_44B3C3      ; 取出当前进程的ApcStateIndex</span><br><span class="line">.text:00402C8C</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:0044B3C3 loc_44B3C3:                             ; CODE XREF: KiInsertQueueApc(x,x)+1C↑j</span><br><span class="line">.text:0044B3C3                 mov     dl, [ecx+_ETHREAD.Tck.ApcStateIndex] ; 取出当前进程的ApcStateIndex</span><br><span class="line">.text:0044B3C9                 mov     [eax+_KAPC.ApcStateIndex], dl ; 放入APC中</span><br><span class="line">.text:0044B3CC                 jmp     loc_402C8C</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:00402C8C loc_402C8C:                             ; CODE XREF: KiInsertQueueApc(x,x)+48762↓j</span><br><span class="line">.text:00402C8C                 cmp     [eax+_KAPC.NormalRoutine], 0s</span><br><span class="line">.text:00402C90                 movsx   edx, [eax+_KAPC.ApcStateIndex]</span><br><span class="line">.text:00402C94                 push    ebx</span><br><span class="line">.text:00402C95                 push    esi</span><br><span class="line">.text:00402C96                 push    edi</span><br><span class="line">.text:00402C97                 mov     edi, [ecx+edx*4+_KTHREAD.ApcStatePointer] ; l) 根据_ KAPC.ApcStateIndex找到要挂APC的队列: SaveApc/Apc</span><br><span class="line">.text:00402C9E                 mov     dl, [eax+_KAPC.ApcMode]</span><br><span class="line">.text:00402CA1                 jnz     loc_41049E</span><br><span class="line">.text:00402CA7                 movsx   esi, dl</span><br><span class="line">.text:00402CAA                 lea     edi, [edi+esi*8] ; 2)根据ApcMode找到是用户APC队列还是内核APC队列</span><br><span class="line">.text:00402CAD                 mov     esi, [edi+4]</span><br><span class="line">.text:00402CB0</span><br><span class="line">.text:00402CB0 loc_402CB0:                             ; CODE XREF: KiInsertQueueApc(x,x)+4876A↓j</span><br><span class="line">.text:00402CB0                 cmp     esi, edi</span><br><span class="line">.text:00402CB2                 jnz     loc_42615A</span><br><span class="line">.text:00402CB8</span><br><span class="line">.text:00402CB8 loc_402CB8:                             ; CODE XREF: KiInsertQueueApc(x,x)+234F4↓j</span><br><span class="line">.text:00402CB8                 mov     ebx, [esi]</span><br><span class="line">.text:00402CBA                 lea     edi, [eax+_KAPC.ApcListEntry]</span><br><span class="line">.text:00402CBD                 mov     [edi], ebx</span><br><span class="line">.text:00402CBF                 mov     [edi+4], esi</span><br><span class="line">.text:00402CC2                 mov     [ebx+4], edi</span><br><span class="line">.text:00402CC5                 mov     [esi], edi      ; 3)将ApcStateIndex 挂到对应的队列中：ApcListEntry</span><br><span class="line">.text:00402CC7</span><br><span class="line">.text:00402CC7 loc_402CC7:                             ; CODE XREF: KiInsertQueueApc(x,x)+D85B↓j</span><br><span class="line">.text:00402CC7                                         ; KiInsertQueueApc(x,x)+268BB↓j</span><br><span class="line">.text:00402CC7                 movsx   edi, [eax+_KAPC.ApcStateIndex]</span><br><span class="line">.text:00402CCB                 mov     [eax+_KAPC.Inserted], 1 ; 4)修改Inserted的值</span><br><span class="line">.text:00402CCF                 movzx   esi, [ecx+_KTHREAD.ApcStateIndex]</span><br><span class="line">.text:00402CD6                 cmp     edi, esi</span><br><span class="line">.text:00402CD8                 pop     edi</span><br><span class="line">.text:00402CD9                 pop     esi</span><br><span class="line">.text:00402CDA                 pop     ebx</span><br><span class="line">.text:00402CDB                 jnz     short loc_402D12</span><br><span class="line">.text:00402CDD                 test    dl, dl</span><br><span class="line">.text:00402CDF                 jnz     loc_4106A4      ; 若为用户模式APC，跳转</span><br><span class="line">.text:00402CE5                 mov     dl, [ecx+_KTHREAD.State]</span><br><span class="line">.text:00402CE8                 cmp     dl, 2</span><br><span class="line">.text:00402CEB                 mov     [ecx+_KTHREAD.ApcState.KernelApcPending], 1 ; 5)内核模式APC，修改KernelApcPending为1</span><br><span class="line">.text:00402CEF                 jnz     loc_40EEB3</span><br><span class="line">.text:00402CF5                 mov     eax, large fs:_KTHREAD.Teb</span><br><span class="line">.text:00402CFB                 mov     cl, [ecx+_KTHREAD.NextProcessor]</span><br><span class="line">.text:00402D01                 cmp     [eax+10h], cl</span><br><span class="line">.text:00402D04                 jnz     loc_412E89</span><br><span class="line">.text:00402D0A                 mov     cl, 1</span><br><span class="line">.text:00402D0C                 call    ds:__imp_@HalRequestSoftwareInterrupt@4 ; HalRequestSoftwareInterrupt(x)</span><br><span class="line">.text:004106A4 ; START OF FUNCTION CHUNK FOR KiInsertQueueApc(x,x)</span><br><span class="line">.text:004106A4</span><br><span class="line">.text:004106A4 loc_4106A4:                             ; CODE XREF: KiInsertQueueApc(x,x)+75↑j</span><br><span class="line">.text:004106A4                 cmp     [ecx+_KTHREAD.State], 5 ; 判断线程是否为等待状态如果不是则跳转</span><br><span class="line">.text:004106A8                 jnz     loc_402D12</span><br><span class="line">.text:004106AE                 cmp     [ecx+_KTHREAD.WaitMode], 1 ; 判断是否是用户导致的等待如果不是则跳转</span><br><span class="line">.text:004106B2                 jnz     loc_402D12</span><br><span class="line">.text:004106B8                 cmp     [ecx+_KTHREAD.Alertable], 0 ; 判断是否可以吵醒线程(Alertble=1)如果不是 则跳转</span><br><span class="line">.text:004106BF                 jz      loc_432270</span><br><span class="line">.text:004106C5</span><br><span class="line">.text:004106C5 loc_4106C5:                             ; CODE XREF: KiInsertQueueApc(x,x)+2F610↓j</span><br><span class="line">.text:004106C5                 mov     [ecx+_KTHREAD.ApcState.UserApcPending], 1</span><br><span class="line">.text:004106C9                 push    0</span><br><span class="line">.text:004106CB                 mov     edx, 0C0h</span><br><span class="line">.text:004106D0                 jmp     loc_40EED7</span><br><span class="line">.text:0040EED7 loc_40EED7:                             ; CODE XREF: KiInsertQueueApc(x,x)+DA66↓j</span><br><span class="line">.text:0040EED7                 push    [ebp+var_4]</span><br><span class="line">.text:0040EEDA                 call    @KiUnwaitThread@16 ; 将当前线程从等待链表转移到就绪列表</span><br><span class="line">.text:0040EEDA                                         ; 即唤醒线程</span><br><span class="line">.text:0040EEDF                 jmp     loc_402D12</span><br></pre></td></tr></table></figure>



<h3 id="Alertable"><a href="#Alertable" class="headerlink" title="Alertable"></a>Alertable</h3><p>该值指示线程是否运行被<code>APC</code>吵醒</p>
<ol>
<li><code>Alertable=0</code>，<code>UserApcPending = 0</code>：当前插入的APC函数未必有机会执行</li>
<li><code>Alertable=1</code> ，<code>UserApcPending = 1</code>：将目标线程唤醒(从等待链表中摘出来，并挂到调度链表)</li>
</ol>
<p>该属性在KTHREAD中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x164</span> Alertable        : UChar</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>很多与线程相关的结尾带<code>Ex</code>的函数的参数都会有一个<code>bAlertable</code>，举例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">SleepEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  DWORD dwMilliseconds, <span class="comment">// time-out interval</span></span></span><br><span class="line"><span class="params">  BOOL bAlertable        <span class="comment">// early completion option</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">DWORD <span class="title function_">WaitForSingleObjectEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hHandle,       <span class="comment">// handle to object</span></span></span><br><span class="line"><span class="params">  DWORD dwMilliseconds, <span class="comment">// time-out interval</span></span></span><br><span class="line"><span class="params">  BOOL bAlertable       <span class="comment">// alertable option</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>



<h1 id="04-内核APC执行过程"><a href="#04-内核APC执行过程" class="headerlink" title="04.内核APC执行过程"></a>04.内核APC执行过程</h1><h2 id="何时执行APC"><a href="#何时执行APC" class="headerlink" title="何时执行APC"></a>何时执行APC</h2><p><code>APC</code>函数的执行与插入并不是同一个线程，具体点说在A线程中向B线程插入一个<code>APC</code>，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定，所以叫“异步过程调用”</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><ol>
<li><code>SwapContext</code> 判断是否有内核APC</li>
<li><code>KiSwapThread</code></li>
<li><code>KiDeliverApc</code> 执行内核APC函数</li>
</ol>
<p>先看下<code>SwapContext</code>的最后部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                cmp     [esi+_KTHREAD.ApcState.KernelApcPending], 0</span><br><span class="line">                jnz     short loc_46A9BD</span><br><span class="line">                popf</span><br><span class="line">                xor     eax, eax</span><br><span class="line">                retn</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">loc_46A9BD:                             ; CODE XREF: SwapContext+D7↑j</span><br><span class="line">                popf</span><br><span class="line">                jnz     short loc_46A9C3</span><br><span class="line">                mov     al, 1</span><br><span class="line">                retn</span><br></pre></td></tr></table></figure>

<p><code>KernelApcPending</code>是表示有没有内核<code>APC</code>处理的标志，如果是1，也就是有的话，就会使返回值置1；反之置0。</p>
<p>之后查看上一级函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:0040581E ; __fastcall KiSwapContext(x)</span><br><span class="line">.text:0040581E @KiSwapContext@4 proc near              ; CODE XREF: KiSwapThread()+33↓p</span><br><span class="line">.text:0040581E</span><br><span class="line">.text:0040581E var_10          = dword ptr -10h</span><br><span class="line">.text:0040581E var_C           = dword ptr -0Ch</span><br><span class="line">.text:0040581E var_8           = dword ptr -8</span><br><span class="line">.text:0040581E var_4           = dword ptr -4</span><br><span class="line">.text:0040581E</span><br><span class="line">.text:0040581E                 sub     esp, 10h</span><br><span class="line">.text:00405821                 mov     [esp+10h+var_4], ebx ; KPCR</span><br><span class="line">.text:00405825                 mov     [esp+10h+var_8], esi ; 新线程 _ETHREAD</span><br><span class="line">.text:00405829                 mov     [esp+10h+var_C], edi ; 旧线程 _ETHREAD</span><br><span class="line">.text:0040582D                 mov     [esp+10h+var_10], ebp ; ebp 没用</span><br><span class="line">.text:00405830                 mov     ebx, large fs:1Ch ; _KPCR.Self</span><br><span class="line">.text:00405837                 mov     esi, ecx        ; ecx：新线程的 _ETHREAD</span><br><span class="line">.text:00405839                 mov     edi, [ebx+124h] ; edi：当前线程的 _ETHREAD</span><br><span class="line">.text:00405839                                         ; [ebx+_KPCR.PrcbData.CurrentThread]</span><br><span class="line">.text:0040583F                 mov     [ebx+124h], esi ; 修改 _KPCR，更新当前线程(124h同上</span><br><span class="line">.text:00405845                 mov     cl, [edi+58h]   ; 58==[edi+_ETHREAD.Tcb.WaitIrql]</span><br><span class="line">.text:00405848                 call    SwapContext     ; 4个参数：</span><br><span class="line">.text:00405848                                         ; ebx: _KPCR</span><br><span class="line">.text:00405848                                         ; esi: 新线程 _ETHREAD</span><br><span class="line">.text:00405848                                         ; edi: 旧线程 _ETHREAD</span><br><span class="line">.text:00405848                                         ; cl:旧线程的 WaitIrql，这个参数用来控制是否执行APC</span><br><span class="line">.text:00405848                                         ;</span><br><span class="line">.text:00405848                                         ; 调用 SwapContext 后，已经完成了线程切换</span><br><span class="line">.text:00405848                                         ; 后面就是新线程从它自己的堆栈里恢复寄存器的值的过程</span><br><span class="line">.text:0040584D                 mov     ebp, [esp+10h+var_10]</span><br><span class="line">.text:00405850                 mov     edi, [esp+10h+var_C]</span><br><span class="line">.text:00405854                 mov     esi, [esp+10h+var_8]</span><br><span class="line">.text:00405858                 mov     ebx, [esp+10h+var_4]</span><br><span class="line">.text:0040585C                 add     esp, 10h</span><br><span class="line">.text:0040585F                 retn</span><br><span class="line">.text:0040585F @KiSwapContext@4 endp</span><br></pre></td></tr></table></figure>

<p>没有用到返回值，继续查看上一级函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0040AB3B loc_40AB3B:                             ; CODE XREF: KiSwapThread()+5E33↓j</span><br><span class="line">.text:0040AB3B                 mov     ecx, eax</span><br><span class="line">.text:0040AB3D                 call    @KiSwapContext@4 ; ebx: _KPCR</span><br><span class="line">.text:0040AB3D                                         ; esi: 新线程 _ETHREAD</span><br><span class="line">.text:0040AB3D                                         ; edi: 旧线程 _ETHREAD</span><br><span class="line">.text:0040AB3D                                         ; 使用寄存器传参，因此要将使用到的寄存器暂时保存到堆栈中</span><br><span class="line">.text:0040AB3D                                         ; 和push等效</span><br><span class="line">.text:0040AB42                 test    al, al</span><br><span class="line">.text:0040AB44                 mov     cl, [edi+58h]   ; NewIrql</span><br><span class="line">.text:0040AB47                 mov     edi, [edi+54h]</span><br><span class="line">.text:0040AB4A                 mov     esi, ds:__imp_@KfLowerIrql@4 ; KfLowerIrql(x)</span><br><span class="line">.text:0040AB50                 jnz     loc_41BC76</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:0041BC76 loc_41BC76:                             ; CODE XREF: KiSwapThread()+46↑j</span><br><span class="line">.text:0041BC76                 mov     cl, 1           ; NewIrql</span><br><span class="line">.text:0041BC78                 call    esi ; KfLowerIrql(x) ; KfLowerIrql(x)</span><br><span class="line">.text:0041BC7A                 xor     eax, eax</span><br><span class="line">.text:0041BC7C                 push    eax</span><br><span class="line">.text:0041BC7D                 push    eax</span><br><span class="line">.text:0041BC7E                 push    eax//第一个参数，0处理内核APC，1处理内核APC和用户APC</span><br><span class="line">.text:0041BC7F                 call    _KiDeliverApc@12 ; KiDeliverApc(x,x,x)</span><br><span class="line">.text:0041BC84                 xor     cl, cl</span><br><span class="line">.text:0041BC86                 jmp     loc_40AB56</span><br></pre></td></tr></table></figure>

<p>如果为1的话，也就是有内核<code>APC</code>执行，就会继续往下走，调用<code>KiDeliverApc</code>这个函数，也就是处理<code>APC</code>的函数，传递的三个参数都是0。</p>
<h3 id="系统调用、中断或者异常-KiServiceExit"><a href="#系统调用、中断或者异常-KiServiceExit" class="headerlink" title="系统调用、中断或者异常(_KiServiceExit)"></a>系统调用、中断或者异常(_KiServiceExit)</h3><h4 id="KiServiceExit-1"><a href="#KiServiceExit-1" class="headerlink" title="KiServiceExit"></a>KiServiceExit</h4><p>这个函数是系统调用、中断异常必经之处，和APC相关的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:004069CD loc_4069CD:                             ; CODE XREF: _KiServiceExit+8↑j</span><br><span class="line">.text:004069CD                                         ; _KiServiceExit+64↓j</span><br><span class="line">.text:004069CD                 mov     ebx, large fs:124h ; 获取ETHREAD</span><br><span class="line">.text:004069D4                 mov     byte ptr [ebx+_KTHREAD.Alerted], 0</span><br><span class="line">.text:004069D8                 cmp     byte ptr [ebx+_KTHREAD.ApcState.UserApcPending], 0 ; 检查是否有APC请求</span><br><span class="line">.text:004069DC                 jz      short loc_406A23</span><br><span class="line">.text:004069DE                 mov     ebx, ebp</span><br><span class="line">.text:004069E0                 mov     [ebx+44h], eax  ; 堆栈中_KTRAP_FREAME结构的eax</span><br><span class="line">.text:004069E3                 mov     dword ptr [ebx+50h], 3Bh ; &#x27;;&#x27; ; 堆栈中_KTRAP_FREAME结构的SegFs</span><br><span class="line">.text:004069EA                 mov     dword ptr [ebx+38h], 23h ; &#x27;#&#x27; ; 堆栈中_KTRAP_FREAME结构的SegDs</span><br><span class="line">.text:004069F1                 mov     dword ptr [ebx+34h], 23h ; &#x27;#&#x27; ; 堆栈中_KTRAP_FREAME结构的SegEs</span><br><span class="line">.text:004069F8                 mov     dword ptr [ebx+30h], 0 ; 堆栈中_KTRAP_FREAME结构的SegGs</span><br><span class="line">.text:004069FF                 mov     ecx, 1          ; APC_LEVEl参数</span><br><span class="line">.text:00406A04                 call    ds:__imp_@KfRaiseIrql@4 ; KfRaiseIrql(x)</span><br><span class="line">.text:00406A0A                 push    eax</span><br><span class="line">.text:00406A0B                 sti                     ; 关中断</span><br><span class="line">.text:00406A0C                 push    ebx</span><br><span class="line">.text:00406A0D                 push    0</span><br><span class="line">.text:00406A0F                 push    1</span><br><span class="line">.text:00406A11                 call    _KiDeliverApc@12 ; 执行内核APC并为用户空间的APC的执行进行准备</span><br></pre></td></tr></table></figure>

<p>第一个参数是1，第二个参数是0，第三个就是所谓的<code>TrapFrame</code></p>
<h2 id="内核APC执行流程"><a href="#内核APC执行流程" class="headerlink" title="内核APC执行流程"></a>内核APC执行流程</h2><h3 id="KiDeliverApc"><a href="#KiDeliverApc" class="headerlink" title="KiDeliverApc"></a>KiDeliverApc</h3><p>执行过程：</p>
<ol>
<li>判断第一个链表是否为空</li>
<li>判断<code>KTHREAD.ApcState.KernelApcInProgress</code>是否为1</li>
<li>判断是否禁用内核APC(<code>KTHREAD.KernelApcDisable</code>是否为1)</li>
<li>将当前KAPC结构体从链表中摘除</li>
<li>执行<code>KAPC.KernelRoutine</code>指定的函数 释放KAPC结构体占用的空间</li>
<li>将<code>KTHREAD.ApcState.KernelApcInProgress</code>设置为1 标识正在执行内核APC</li>
<li>执行真正的内核APC函数(<code>KAPC.NormalRoutine</code>)</li>
<li>执行完毕 将<code>KernelApcInProgress</code>改为0</li>
<li>循环</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">.text:00405E20 loc_405E20:                             ; CODE XREF: KiDeliverApc(x,x,x)+D↑j</span><br><span class="line">.text:00405E20                                         ; KiDeliverApc(x,x,x)+B580↓j ...</span><br><span class="line">.text:00405E20                 push    ebx</span><br><span class="line">.text:00405E21                 push    esi</span><br><span class="line">.text:00405E22                 push    edi</span><br><span class="line">.text:00405E23                 mov     eax, large fs:_KTHREAD</span><br><span class="line">.text:00405E29                 mov     esi, eax</span><br><span class="line">.text:00405E2B                 mov     eax, [esi+_KTHREAD.TrapFrame]</span><br><span class="line">.text:00405E31                 mov     [ebp+var_1C], eax</span><br><span class="line">.text:00405E34                 mov     eax, [esi+_KTHREAD.ApcState.Process]</span><br><span class="line">.text:00405E37                 mov     [esi+_KTHREAD.TrapFrame], ecx</span><br><span class="line">.text:00405E3D                 lea     ecx, [esi+_KTHREAD.ApcQueueLock] ; SpinLock</span><br><span class="line">.text:00405E43                 lea     edx, [ebp+LockHandle] ; LockHandle</span><br><span class="line">.text:00405E46                 mov     [ebp+BugCheckParameter1], eax</span><br><span class="line">.text:00405E49                 call    ds:__imp_@KeAcquireInStackQueuedSpinLock@8 ; KeAcquireInStackQueuedSpinLock(x,x)</span><br><span class="line">.text:00405E4F                 mov     [esi+_KTHREAD.ApcState.KernelApcPending], 0 ; 将KernelApcPending状态改为0</span><br><span class="line">.text:00405E53                 lea     ebx, [esi+_KTHREAD.ApcState] ; 取出内核APC列表</span><br><span class="line">.text:00405E56</span><br><span class="line">.text:00405E56 loc_405E56:                             ; CODE XREF: KiDeliverApc(x,x,x)+14FDD↓j</span><br><span class="line">.text:00405E56                                         ; KiDeliverApc(x,x,x)+15E53↓j ...</span><br><span class="line">.text:00405E56                 cmp     [ebx], ebx      ; 判断第一个列表是否为空(内核APC队列)，如果内容与当前地址一样，说明没有空</span><br><span class="line">.text:00405E58                 jnz     loc_41BBEF      ; 如果为空则跳转</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:0041BBEF loc_41BBEF:                             ; CODE XREF: KiDeliverApc(x,x,x)+57↑j</span><br><span class="line">.text:0041BBEF                 mov     eax, [ebx]</span><br><span class="line">.text:0041BBF1                 lea     edi, [eax-0Ch]  ; 减0x0C就是KAPC的首地址</span><br><span class="line">.text:0041BBF4                 mov     ecx, [edi+_KAPC.KernelRoutine]</span><br><span class="line">.text:0041BBF7                 mov     [ebp+ms_exc.KernelRoutine], ecx</span><br><span class="line">.text:0041BBFA                 mov     ecx, [edi+_KAPC.NormalRoutine]</span><br><span class="line">.text:0041BBFD                 test    ecx, ecx        ; 判断内核APC是否为空</span><br><span class="line">.text:0041BBFF                 mov     [ebp+ms_exc.NormalRoutine], ecx</span><br><span class="line">.text:0041BC02                 mov     edx, [edi+_KAPC.NormalContext]</span><br><span class="line">.text:0041BC05                 mov     [ebp+ms_exc.NormalContext], edx</span><br><span class="line">.text:0041BC08                 mov     edx, [edi+_KAPC.SystemArgument1]</span><br><span class="line">.text:0041BC0B                 mov     [ebp+ms_exc.SystemArgument1], edx</span><br><span class="line">.text:0041BC0E                 mov     edx, [edi+_KAPC.SystemArgument2]</span><br><span class="line">.text:0041BC11                 mov     [ebp+ms_exc.SystemArgument2], edx</span><br><span class="line">.text:0041BC14                 jnz     loc_41AD60      ; 不为空跳转</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:0041AD60 loc_41AD60:                             ; CODE XREF: KiDeliverApc(x,x,x)+15E13↓j</span><br><span class="line">.text:0041AD60                 cmp     [esi+_KTHREAD.ApcState.KernelApcInProgress], 0</span><br><span class="line">.text:0041AD64                 jnz     loc_405E6B</span><br><span class="line">.text:0041AD6A                 cmp     [esi+_KTHREAD.KernelApcDisable], 0</span><br><span class="line">.text:0041AD71                 jnz     loc_405E6B</span><br><span class="line">.text:0041AD77                 mov     ecx, [eax]</span><br><span class="line">.text:0041AD79                 mov     eax, [eax+4]</span><br><span class="line">.text:0041AD7C                 mov     [eax], ecx</span><br><span class="line">.text:0041AD7E                 mov     [ecx+4], eax</span><br><span class="line">.text:0041AD81                 lea     ecx, [ebp+LockHandle] ; LockHandle</span><br><span class="line">.text:0041AD84                 mov     [edi+_KAPC.Inserted], 0</span><br><span class="line">.text:0041AD88                 call    ds:__imp_@KeReleaseInStackQueuedSpinLock@4 ; KeReleaseInStackQueuedSpinLock(x)</span><br><span class="line">.text:0041AD8E                 lea     eax, [ebp+ms_exc.SystemArgunent2]</span><br><span class="line">.text:0041AD91                 push    eax</span><br><span class="line">.text:0041AD92                 lea     eax, [ebp+ms_exc.SystemArgunent1]</span><br><span class="line">.text:0041AD95                 push    eax</span><br><span class="line">.text:0041AD96                 lea     eax, [ebp+ms_exc.NormalContext]</span><br><span class="line">.text:0041AD99                 push    eax</span><br><span class="line">.text:0041AD9A                 lea     eax, [ebp+ms_exc.NormalRoutine]</span><br><span class="line">.text:0041AD9D                 push    eax</span><br><span class="line">.text:0041AD9E                 push    edi</span><br><span class="line">.text:0041AD9F                 call    [ebp+ms_exc.KernelRoutine] ; 5)执行KAPC.KernelRoutine指定的函数释放KAPC结构体占用的空间</span><br><span class="line">.text:0041ADA2                 cmp     [ebp+ms_exc.NormalRoutine], 0</span><br><span class="line">.text:0041ADA6                 jz      short loc_41ADCB</span><br><span class="line">.text:0041ADA8                 xor     cl, cl          ; NewIrql</span><br><span class="line">.text:0041ADAA                 mov     [esi+_KTHREAD.ApcState.KernelApcInProgress], 1 ; 6)将KTHREAD.ApcState.KernelApcInProgress设置为1标识正在执行内核APC</span><br><span class="line">.text:0041ADAE                 call    ds:__imp_@KfLowerIrql@4 ; KfLowerIrql(x)</span><br><span class="line">.text:0041ADB4                 push    [ebp+ms_exc.SystemArgunent2]</span><br><span class="line">.text:0041ADB7                 push    [ebp+ms_exc.SystemArgunent1]</span><br><span class="line">.text:0041ADBA                 push    [ebp+ms_exc.NormalContext]</span><br><span class="line">.text:0041ADBD                 call    [ebp+ms_exc.NormalRoutine] ; 7)执行真正的内核APC函数(KAPC.NormalRoutine)</span><br><span class="line">.text:0041ADC0                 mov     cl, 1           ; NewIrql</span><br><span class="line">.text:0041ADC2                 call    ds:__imp_@KfRaiseIrql@4 ; KfRaiseIrql(x)</span><br><span class="line">.text:0041ADC8                 mov     [ebp+LockHandle.OldIrql], al</span><br><span class="line">.text:0041ADCB</span><br><span class="line">.text:0041ADCB loc_41ADCB:                             ; CODE XREF: KiDeliverApc(x,x,x)+14FA5↑j</span><br><span class="line">.text:0041ADCB                 lea     edx, [ebp+LockHandle] ; LockHandle</span><br><span class="line">.text:0041ADCE                 lea     ecx, [esi+0E8h] ; SpinLock</span><br><span class="line">.text:0041ADD4                 call    ds:__imp_@KeAcquireInStackQueuedSpinLock@8 ; KeAcquireInStackQueuedSpinLock(x,x)</span><br><span class="line">.text:0041ADDA                 mov     [esi+_KTHREAD.ApcState.KernelApcInProgress], 0 ; 8)执行完毕，将KernelApcInProgress改为0</span><br><span class="line">.text:0041ADDE                 jmp     loc_405E56      ; 9)下一个循环</span><br><span class="line">.text:0041ADDE ; END OF FUNCTION CHUNK FOR KiDeliverApc(x,x,x)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>线程切换的时候，这就意味着只要插入内核APC很快就会执行(<code>SwapContext</code>-&gt;<code>KiSwapThread</code>-&gt;<code>KiDeliverApc</code>)</li>
<li>如果有<strong>用户APC</strong>需要处理时，一定会<strong>先处理内核APC</strong></li>
<li>内核APC在内核空间执行，不需要换栈，一个循环全部执行完毕</li>
</ol>
<h1 id="05-用户APC执行过程"><a href="#05-用户APC执行过程" class="headerlink" title="05.用户APC执行过程"></a>05.用户APC执行过程</h1><p>当产生系统调用、中断或者异常，线程在返回用户空间前都会调用<code>_KiServiceExit</code>函数，在<code>_KiServiceExit</code>会判断是否有要执行的用户APC，如果有则调用<code>KiDeliverApc</code>函数(第一个参数为1)进行处理。</p>
<p>执行用户APC时的堆栈操作：</p>
<ol>
<li>当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等 (<code>_Trap_Frame</code>)，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。</li>
<li>但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：<br><code>内核</code>–&gt;<code>用户空间</code>–&gt;<code>再回到内核空间</code></li>
<li>堆栈的操作比较复杂，如果不了解堆栈的操作细节不可能理解用户APC是如何执行的</li>
</ol>
<h2 id="KiDeliverApc-1"><a href="#KiDeliverApc-1" class="headerlink" title="KiDeliverApc"></a>KiDeliverApc</h2><p>执行过程：</p>
<ol>
<li>判断用户APC链表是否为空</li>
<li>判断第一个参数是为1</li>
<li>判断<code>ApcState.UserApcPending</code>是否为1</li>
<li>将<code>ApcState.UserApcPending</code>设置为0</li>
<li>链表操作 将当前APC从用户队列中拆除</li>
<li>调用函数(<code>KAPC.KernelRoutine</code>)释放KAPC结构体内存空间</li>
<li>调用<code>KiInitializeUserApc</code>函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">.text:00405E56 loc_405E56:                             ; CODE XREF: KiDeliverApc(x,x,x)+14FDD↓j</span><br><span class="line">.text:00405E56                                         ; KiDeliverApc(x,x,x)+15E53↓j ...</span><br><span class="line">.text:00405E56                 cmp     [ebx], ebx      ; 判断第一个列表是否为空(内核APC队列)，如果内容与当前地址一样，说明没有空</span><br><span class="line">.text:00405E58                 jnz     loc_41BBEF      ; 如果为空则跳转</span><br><span class="line">.text:00405E5E                 lea     ecx, [esi+(_KTHREAD.ApcState.ApcListHead.Flink+8)] ; 取第二个链表，也就是用户APC队列</span><br><span class="line">.text:00405E61                 mov     eax, [ecx]</span><br><span class="line">.text:00405E63                 cmp     eax, ecx</span><br><span class="line">.text:00405E65                 jnz     loc_4104CA</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:004104CA loc_4104CA:                             ; CODE XREF: KiDeliverApc(x,x,x)+64↑j</span><br><span class="line">.text:004104CA                 cmp     [ebp+arg_0], 1  ; 2)判断第一个参数是为1</span><br><span class="line">.text:004104CE                 jnz     loc_405E6B</span><br><span class="line">.text:004104D4                 cmp     [esi+_KTHREAD.ApcState.UserApcPending], 0 ; 3)判断ApcState.UserApcPending是否为1</span><br><span class="line">.text:004104D8                 jz      loc_405E6B</span><br><span class="line">.text:004104DE                 mov     [esi+_KTHREAD.ApcState.UserApcPending], 0 ; 4)将ApcState.UserApcPending设置为0</span><br><span class="line">.text:004104E2                 lea     edi, [eax-0Ch]  ; 减0xc得到KAPC首地址</span><br><span class="line">.text:004104E5                 mov     ecx, [edi+_KAPC.NormalRoutine]</span><br><span class="line">.text:004104E8                 mov     ebx, [edi+_KAPC.KernelRoutine]</span><br><span class="line">.text:004104EB                 mov     [ebp+NormalRoutine], ecx</span><br><span class="line">.text:004104EE                 mov     ecx, [edi+_KAPC.NormalContext]</span><br><span class="line">.text:004104F1                 mov     [ebp+NormalContext], ecx</span><br><span class="line">.text:004104F4                 mov     ecx, [edi+_KAPC.SystemArgument1]</span><br><span class="line">.text:004104F7                 mov     [ebp+SystemArgument1], ecx</span><br><span class="line">.text:004104FA                 mov     ecx, [edi+_KAPC.SystemArgument2]</span><br><span class="line">.text:004104FD                 mov     [ebp+SystemArgument2], ecx</span><br><span class="line">.text:00410500                 mov     ecx, [eax]      ; 5)链表操作将当前APC从用户队列中拆除</span><br><span class="line">.text:00410502                 mov     eax, [eax+4]</span><br><span class="line">.text:00410505                 mov     [eax], ecx</span><br><span class="line">.text:00410507                 mov     [ecx+4], eax</span><br><span class="line">.text:0041050A                 lea     ecx, [ebp+LockHandle] ; LockHandle</span><br><span class="line">.text:0041050D                 mov     [edi+_KAPC.Inserted], 0</span><br><span class="line">.text:00410511                 call    ds:__imp_@KeReleaseInStackQueuedSpinLock@4 ; KeReleaseInStackQueuedSpinLock(x)</span><br><span class="line">.text:00410517                 lea     eax, [ebp+var_8]</span><br><span class="line">.text:0041051A                 push    eax</span><br><span class="line">.text:0041051B                 lea     eax, [ebp+var_C]</span><br><span class="line">.text:0041051E                 push    eax</span><br><span class="line">.text:0041051F                 lea     eax, [ebp+var_10]</span><br><span class="line">.text:00410522                 push    eax</span><br><span class="line">.text:00410523                 lea     eax, [ebp+var_4]</span><br><span class="line">.text:00410526                 push    eax</span><br><span class="line">.text:00410527                 push    edi</span><br><span class="line">.text:00410528                 call    ebx             ; 6)调用函数KAPC.KernelRoutine释放KAPC结构体内存空间</span><br><span class="line">.text:0041052A                 cmp     [ebp+ms_exc.NormalRoutine], 0</span><br><span class="line">.text:0041052E                 jz      loc_44B394</span><br><span class="line">.text:00410534                 push    [ebp+ms_exc.SystemArgunent2]</span><br><span class="line">.text:00410537                 push    [ebp+ms_exc.SystemArgunent1]</span><br><span class="line">.text:0041053A                 push    [ebp+ms_exc.NormalContext]</span><br><span class="line">.text:0041053D                 push    [ebp+ms_exc.NormalRoutine]</span><br><span class="line">.text:00410540                 push    [ebp+arg_8]     ; TrapFrame</span><br><span class="line">.text:00410543                 push    [ebp+arg_4]     ; ExceptionFrame</span><br><span class="line">.text:00410546                 call    _KiInitializeUserApc@24 ; 这里并未直接调用处理用户APC的函数</span><br><span class="line">.text:00410546                                         ; 原因是当前堆栈在0环用户APC需要到3环去执行</span><br><span class="line">.text:0041054B                 jmp     loc_405E74</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KiInitializeUserApc"><a href="#KiInitializeUserApc" class="headerlink" title="KiInitializeUserApc"></a>KiInitializeUserApc</h2><ol>
<li><p>线程进0环时，原来的运行环境(寄存器栈顶等)保存到 <code>_Trap_Frame</code> 结构体中，如果要提前返回3环去处理用户APC，就必须要修改 <code>_Trap_Frame</code> 结构体：</p>
</li>
<li><p>比如：进0环时的位置存储在EIP中，现在要提前返回，而且返回的并不是原来的位置，那就意味着必须要修改EIP为新的返回位置。还有堆栈ESP，也要修改为处理APC需要的堆栈。那原来的值怎么办呢?处理完APC后该如何返回原来的位置呢？</p>
</li>
<li><p><code>KiInitializeUserApc</code>要做的第一件事就是备份：</p>
<p>将原来 <code>_Trap_Frame</code> 的值备份到一个新的结构体中( <code>CONTEXT</code> ),这个功能由其子函数<code>KeContextFromKframes</code>来完成</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">.text:00410555 _KiInitializeUserApc@24 proc near       ; CODE XREF: KiDeliverApc(x,x,x)+A745↑p</span><br><span class="line">.text:00410555</span><br><span class="line">.text:00410555 ExceptionRecord = _EXCEPTION_RECORD ptr -34Ch</span><br><span class="line">.text:00410555 var_2FC         = dword ptr -2FCh</span><br><span class="line">.text:00410555 var_2F8         = dword ptr -2F8h</span><br><span class="line">.text:00410555 var_2F4         = dword ptr -2F4h</span><br><span class="line">.text:00410555 BugCheckParameter3= dword ptr -2F0h</span><br><span class="line">.text:00410555 var_2EC         = dword ptr -2ECh</span><br><span class="line">.text:00410555 var_2E8_CONTEXT = dword ptr -2E8h</span><br><span class="line">.text:00410555 var_228         = dword ptr -228h</span><br><span class="line">.text:00410555 var_224_CONTEXT.esp= dword ptr -224h</span><br><span class="line">.text:00410555 var_1C          = dword ptr -1Ch</span><br><span class="line">.text:00410555 ms_exc          = CPPEH_RECORD ptr -18h</span><br><span class="line">.text:00410555 a1              = dword ptr  8</span><br><span class="line">.text:00410555 TrapFrame_Address= dword ptr  0Ch</span><br><span class="line">.text:00410555 arg_NormalRoutine= dword ptr  10h</span><br><span class="line">.text:00410555 NormalContext   = dword ptr  14h</span><br><span class="line">.text:00410555 SystemArgument1 = dword ptr  18h</span><br><span class="line">.text:00410555 SystemArgument2 = dword ptr  1Ch</span><br><span class="line">.text:00410555</span><br><span class="line">.text:00410555 ; FUNCTION CHUNK AT .text:0043C680 SIZE 00000009 BYTES</span><br><span class="line">.text:00410555 ; FUNCTION CHUNK AT .text:0044B92B SIZE 0000001F BYTES</span><br><span class="line">.text:00410555 ; FUNCTION CHUNK AT .text:0044B94F SIZE 00000012 BYTES</span><br><span class="line">.text:00410555 ; FUNCTION CHUNK AT .text:0044B966 SIZE 0000002E BYTES</span><br><span class="line">.text:00410555</span><br><span class="line">.text:00410555 ; __unwind &#123; // __SEH_prolog</span><br><span class="line">.text:00410555                 push    33Ch</span><br><span class="line">.text:0041055A                 push    offset stru_410698</span><br><span class="line">.text:0041055F                 call    __SEH_prolog</span><br><span class="line">.text:00410564                 mov     eax, ds:___security_cookie</span><br><span class="line">.text:00410569                 mov     [ebp+var_1C], eax ; 暂存___security_cookie</span><br><span class="line">.text:0041056C                 mov     eax, [ebp+a1]   ; ExceptionFrame</span><br><span class="line">.text:0041056F                 mov     [ebp+var_2F4], eax</span><br><span class="line">.text:00410575                 mov     ebx, [ebp+TrapFrame_Address]</span><br><span class="line">.text:00410578                 mov     [ebp+BugCheckParameter3], ebx ; 暂存TrapFrame</span><br><span class="line">.text:0041057E                 test    byte ptr [ebx+72h], 2</span><br><span class="line">.text:00410582                 jnz     loc_410681</span><br><span class="line">.text:00410588                 mov     [ebp+var_2E8_CONTEXT], 10017h</span><br><span class="line">.text:00410592                 lea     ecx, [ebp+var_2E8_CONTEXT]</span><br><span class="line">.text:00410598                 push    ecx             ; CONTEXT对象的首地址</span><br><span class="line">.text:00410599                 push    eax             ; ExceptionFrame</span><br><span class="line">.text:0041059A                 push    ebx             ; TrapFrame地址</span><br><span class="line">.text:0041059B                 call    _KeContextFromKframes@12 ; 将TrapFrame备份到Context，这时候还在r0</span><br><span class="line">.text:004105A0                 and     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:004105A4                 mov     eax, 2DCh       ; 2DC =  CONTEXT 结构体的大小+用户APC所需要的4个参数</span><br><span class="line">.text:004105A9                 mov     [ebp+var_2F8], eax</span><br><span class="line">.text:004105AF                 mov     esi, [ebp+var_224_CONTEXT.esp] ; 2E8-224=C4 刚好是CONTEXT结构体ESP的偏移</span><br><span class="line">.text:004105B5                 and     esi, 0FFFFFFFCh ; 进行4字节对齐</span><br><span class="line">.text:004105B8                 sub     esi, eax        ; 在0环直接修改3环的栈 将用户3环的栈减0x2DC个字节</span><br><span class="line">.text:004105BA                 mov     [ebp+var_2EC], esi</span><br><span class="line">.text:004105C0                 push    4               ; Alignment</span><br><span class="line">.text:004105C2                 push    eax             ; Length</span><br><span class="line">.text:004105C3                 push    esi             ; Address</span><br><span class="line">.text:004105C4                 call    _ProbeForWrite@12 ; 修改新增部分的内存属性</span><br><span class="line">.text:004105C9                 lea     edi, [esi+10h]  ; 这里edi指向r3的Context</span><br><span class="line">.text:004105CC                 mov     ecx, 0B3h</span><br><span class="line">.text:004105D1                 lea     esi, [ebp+var_2E8_CONTEXT] ; 这里esi指向r0的context头</span><br><span class="line">.text:004105D7                 rep movsd               ; 从esi复制ecx个dword到edi</span><br><span class="line">.text:004105D9                 mov     [ebx+_KTRAP_FRAME.SegCs], 1Bh</span><br><span class="line">.text:004105E0                 push    23h ; &#x27;#&#x27;</span><br><span class="line">.text:004105E2                 pop     eax</span><br><span class="line">.text:004105E3                 mov     [ebx+_KTRAP_FRAME.HardwareSegSs], eax ; 修改Trap_Frame中的SS</span><br><span class="line">.text:004105E6                 mov     [ebx+_KTRAP_FRAME.SegDs], eax ; 修改Trap_Frame中的DS</span><br><span class="line">.text:004105E9                 mov     [ebx+_KTRAP_FRAME.SegEs], eax ; 修改Trap_Frame中的ES</span><br><span class="line">.text:004105EC                 mov     [ebx+_KTRAP_FRAME.SegFs], 3Bh ; &#x27;;&#x27; ; 修改Trap_Frame中的FS</span><br><span class="line">.text:004105F3                 and     [ebx+_KTRAP_FRAME.SegGs], 0 ; 修改Trap_Frame中的GS</span><br><span class="line">.text:004105F7                 mov     ecx, [ebp+var_228] ; 2E8 - 228=C0：是EFLAGS寄存器</span><br><span class="line">.text:004105FD                 test    ecx, 20000h     ; 判断EFLAGS</span><br><span class="line">.text:00410603                 jnz     loc_44B92B</span><br><span class="line">.text:00410609</span><br><span class="line">.text:00410609 loc_410609:                             ; CODE XREF: KiInitializeUserApc(x,x,x,x,x,x)+3B3DD↓j</span><br><span class="line">.text:00410609                 and     ecx, 3E0DD7h</span><br><span class="line">.text:0041060F                 or      ecx, 200h</span><br><span class="line">.text:00410615                 mov     eax, ecx</span><br><span class="line">.text:00410617</span><br><span class="line">.text:00410617 loc_410617:                             ; CODE XREF: KiInitializeUserApc(x,x,x,x,x,x)+3B3F0↓j</span><br><span class="line">.text:00410617                 mov     [ebx+_KTRAP_FRAME.EFlags], eax ; 修改Trap_Frame中的EFLAGS</span><br><span class="line">.text:0041061A                 mov     eax, large fs:_KTHREAD.Affinity</span><br><span class="line">.text:00410620                 mov     [ebp-var_CurrentThread], eax</span><br><span class="line">.text:00410626                 cmp     byte ptr [eax+_KTRAP_FRAME.SegGs], 0</span><br><span class="line">.text:0041062A                 jnz     loc_43C680</span><br><span class="line">.text:00410630</span><br><span class="line">.text:00410630 loc_410630:                             ; CODE XREF: KiInitializeUserApc(x,x,x,x,x,x)+2C12F↓j</span><br><span class="line">.text:00410630                 mov     eax, [ebp+var_2EC]</span><br><span class="line">.text:00410636                 mov     [ebx+_KTRAP_FRAME.HardwareEsp], eax ; 修改Trap_Frame中的ESP</span><br><span class="line">.text:00410639                 mov     ecx, ds:_KeUserApcDispatcher ; ntdll.KiUserApcDispatcher</span><br><span class="line">.text:0041063F                 mov     [ebx+_KTRAP_FRAME._Eip], ecx ; 修改Trap_Frame的eip,由KiUserApcDispatcher执行用户APC</span><br><span class="line">.text:00410642                 and     [ebx+_KTRAP_FRAME.ErrCode], 0</span><br><span class="line">.text:00410646                 mov     ecx, [ebp+arg_NormalRoutine] ; 将APC用到的4个值放到堆栈</span><br><span class="line">.text:00410649                 mov     [eax], ecx</span><br><span class="line">.text:0041064B                 push    4</span><br><span class="line">.text:0041064D                 pop     ecx</span><br><span class="line">.text:0041064E                 add     eax, ecx</span><br><span class="line">.text:00410650                 mov     [ebp+var_2EC], eax</span><br><span class="line">.text:00410656                 mov     edx, [ebp+NormalContext]</span><br><span class="line">.text:00410659                 mov     [eax], edx</span><br><span class="line">.text:0041065B                 add     eax, ecx</span><br><span class="line">.text:0041065D                 mov     [ebp+var_2EC], eax</span><br><span class="line">.text:00410663                 mov     edx, [ebp+SystemArgument1]</span><br><span class="line">.text:00410666                 mov     [eax], edx</span><br><span class="line">.text:00410668                 add     eax, ecx</span><br><span class="line">.text:0041066A                 mov     [ebp+var_2EC], eax</span><br><span class="line">.text:00410670                 mov     edx, [ebp+SystemArgument2]</span><br><span class="line">.text:00410673                 mov     [eax], edx</span><br><span class="line">.text:00410675                 add     eax, ecx</span><br><span class="line">.text:00410677                 mov     [ebp+var_2EC], eax ; 修复r3堆栈栈顶</span><br><span class="line">.text:0041067D</span><br><span class="line">.text:0041067D loc_41067D:                             ; CODE XREF: KiInitializeUserApc(x,x,x,x,x,x)+3B43A↓j</span><br><span class="line">.text:0041067D                 or      [ebp+ms_exc.registration.TryLevel], 0FFFFFFFFh</span><br><span class="line">.text:00410681</span><br><span class="line">.text:00410681 loc_410681:                             ; CODE XREF: KiInitializeUserApc(x,x,x,x,x,x)+2D↑j</span><br><span class="line">.text:00410681                 mov     ecx, [ebp+var_1C]</span><br><span class="line">.text:00410684                 call    sub_403063</span><br><span class="line">.text:00410689                 call    __SEH_epilog</span><br><span class="line">.text:0041068E                 retn    18h</span><br><span class="line">.text:0041068E ; &#125; // starts at 410555</span><br><span class="line">.text:0041068E _KiInitializeUserApc@24 endp</span><br></pre></td></tr></table></figure>

<p><img src="/2023/02/26/2023-2-WinKernelAPC/image-20230224142512175.png" alt="image-20230224142512175"></p>
<h2 id="KiUserApcDispatcher"><a href="#KiUserApcDispatcher" class="headerlink" title="KiUserApcDispatcher"></a>KiUserApcDispatcher</h2><ol>
<li>当用户在3环调用<code>QueueUserAPC</code>函数来插入APC时，不需要提供<code>NormalRoutine</code>，这个参数是在<code>QueueUserAPC</code>内部指定的：<code>Kernel.BaseDispatchAPC</code></li>
<li><code>ZwContinue</code>函数的意义：<ol>
<li>返回内核，如果还有用户APC，重复上面的执行过程</li>
<li>如果没有需要执行的用户APC，会将 CONTEXT 赋值给 <code>Trap_Frame</code> 结构体，就像从来没有修改过一样；<code>ZwContinue</code>后面的代码不会执行，线程从哪里进0环仍然会从哪里回去</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:7C92E430 _KiUserApcDispatcher@20 proc near       ; DATA XREF: .text:off_7C923428↑o</span><br><span class="line">.text:7C92E430</span><br><span class="line">.text:7C92E430 arg_C           = byte ptr  10h</span><br><span class="line">.text:7C92E430</span><br><span class="line">.text:7C92E430                 lea     edi, [esp+arg_C] ; +10是r3的context</span><br><span class="line">.text:7C92E434                 pop     eax             ; 处理用户APC的总入口，NormalRoutine</span><br><span class="line">.text:7C92E435                 call    eax</span><br><span class="line">.text:7C92E437                 push    1</span><br><span class="line">.text:7C92E439                 push    edi</span><br><span class="line">.text:7C92E43A                 call    _ZwContinue@8   ; 返回到用户内核</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">.text:7C92D040 _ZwContinue@8   proc near               ; CODE XREF: KiUserApcDispatcher(x,x,x,x,x)+A↓p</span><br><span class="line">.text:7C92D040                                         ; KiUserExceptionDispatcher(x,x)+17↓p ...</span><br><span class="line">.text:7C92D040                 mov     eax, 20h ; &#x27; &#x27;  ; NtContinue</span><br><span class="line">.text:7C92D045                 mov     edx, 7FFE0300h</span><br><span class="line">.text:7C92D04A                 call    dword ptr [edx]</span><br><span class="line">.text:7C92D04C                 retn    8</span><br><span class="line">.text:7C92D04C _ZwContinue@8   endp</span><br></pre></td></tr></table></figure>



<p>以上可以用一张图表示：</p>
<p><img src="/2023/02/26/2023-2-WinKernelAPC/1827556-20191103170141163-71115727.png" alt="img"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>内核APC在线程切换时执行，不需要换栈，比较简单，一个循环执行完毕</li>
<li>用户APC在系统调用、中断或异常返回3环前会进行判断，如果有要执行的用户APC，再执行</li>
<li>用户APC执行前会先执行内核APC</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/02/23/2023-2-WinKernel%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-02-26 00:00:00
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Technology/" title="Technology">
                        <b>#</b> Technology
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Win32/" title="Win32">
                        #Win32
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2023/03/02/2023-3-WinKernel%E5%BC%82%E5%B8%B8/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-APC%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">01.APC的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E9%98%9F%E5%88%97"><span class="toc-text">APC队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E7%BB%93%E6%9E%84"><span class="toc-text">APC结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KiServiceExit"><span class="toc-text">KiServiceExit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-%E5%A4%87%E7%94%A8APC%E9%98%9F%E5%88%97"><span class="toc-text">02.备用APC队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SavedApcState"><span class="toc-text">SavedApcState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApcStateIndex"><span class="toc-text">ApcStateIndex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApcStatePointer"><span class="toc-text">ApcStatePointer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%AF%BB%E5%9D%80"><span class="toc-text">组合寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApcQueueable"><span class="toc-text">ApcQueueable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-APC%E6%8C%82%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">03.APC挂入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">挂入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeInitializeApc"><span class="toc-text">KeInitializeApc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApcStateIndex-1"><span class="toc-text">ApcStateIndex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeInsertQueueApc"><span class="toc-text">KeInsertQueueApc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alertable"><span class="toc-text">Alertable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-%E5%86%85%E6%A0%B8APC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">04.内核APC执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8CAPC"><span class="toc-text">何时执行APC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">线程切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81%E4%B8%AD%E6%96%AD%E6%88%96%E8%80%85%E5%BC%82%E5%B8%B8-KiServiceExit"><span class="toc-text">系统调用、中断或者异常(_KiServiceExit)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KiServiceExit-1"><span class="toc-text">KiServiceExit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8APC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">内核APC执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KiDeliverApc"><span class="toc-text">KiDeliverApc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-%E7%94%A8%E6%88%B7APC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">05.用户APC执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KiDeliverApc-1"><span class="toc-text">KiDeliverApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KiInitializeUserApc"><span class="toc-text">KiInitializeUserApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KiUserApcDispatcher"><span class="toc-text">KiUserApcDispatcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Ghostasky">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/ghostasky">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Ghostasky">怕什么真理无穷，进一寸有进一寸的欢喜。</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Windows%E5%86%85%E6%A0%B8(%E4%B8%83)%E2%80%94%E2%80%94APC%E6%9C%BA%E5%88%B6 + '&url=' + https%3A%2F%2Fghostasky.github.io%2F2023%2F02%2F26%2F2023-2-WinKernelAPC%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://ghostasky.github.io/2023/02/26/2023-2-WinKernelAPC/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
