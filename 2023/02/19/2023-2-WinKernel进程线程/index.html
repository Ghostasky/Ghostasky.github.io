<!DOCTYPE html>
<html lang="zh-cn" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="郁涛丶" />
  <meta name="description" content="" />
  
  
  <title>
    
      Windows内核(四)——进程线程 
      
      
      |
    
     郁涛丶&#39;s Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Ghostasky</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Windows内核(四)——进程线程</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-02-19	  
        </span>
		
		 <span class="post-pubtime"> 本文共12k字 </span>

                                                                        <span class="post-pubtime">
        大约需要80min
      </span>
		
		
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Technology/" title="Technology">
                    <b>#</b> Technology
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Win32/" title="Win32">
                    #Win32
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>[toc]</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41490873/category_8987386.html">进程&amp;线程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41490873/category_9930822.html">滴水中级上</a></p>
</blockquote>
<h1 id="001-进程结构体"><a href="#001-进程结构体" class="headerlink" title="001.进程结构体"></a>001.进程结构体</h1><p>每个windows进程在0环都有一个对应的结构体：<code>EPROCESS</code> ，这个结构体包含了进程所有重要的信息。</p>
<p><strong>asdf</strong></p>
<h2 id="EPROCESS"><a href="#EPROCESS" class="headerlink" title="EPROCESS"></a>EPROCESS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x06c</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x070</span> CreateTime       : _LARGE_INTEGER<span class="comment">//进程的创建时间</span></span><br><span class="line">   +<span class="number">0x078</span> ExitTime         : _LARGE_INTEGER<span class="comment">//进程的退出时间</span></span><br><span class="line">   +<span class="number">0x080</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x084</span> UniqueProcessId  : Ptr32 Void<span class="comment">//进程的编号 任务管理器中的PID</span></span><br><span class="line">   +<span class="number">0x088</span> ActiveProcessLinks : _LIST_ENTRY<span class="comment">//双向链表 所有的活动进程都连接在一起，构成了一个链表</span></span><br><span class="line">										  <span class="comment">//PsActiveProcessHead指向全局链表头，链的位置是0x88的位置</span></span><br><span class="line">   +<span class="number">0x090</span> QuotaUsage       : [<span class="number">3</span>] Uint4B<span class="comment">//物理页相关的统计信息</span></span><br><span class="line">   +<span class="number">0x09c</span> QuotaPeak        : [<span class="number">3</span>] Uint4B<span class="comment">//物理页相关的统计信息</span></span><br><span class="line">   +<span class="number">0x0a8</span> CommitCharge     : Uint4B<span class="comment">//虚拟内存相关的统计信息</span></span><br><span class="line">   +<span class="number">0x0ac</span> PeakVirtualSize  : Uint4B<span class="comment">//虚拟内存相关的统计信息</span></span><br><span class="line">   +<span class="number">0x0b0</span> VirtualSize      : Uint4B<span class="comment">//虚拟内存相关的统计信息</span></span><br><span class="line">   +<span class="number">0x0b4</span> SessionProcessLinks : _LIST_ENTRY<span class="comment">//可以通过这个链表，遍历到所有进程。 这个是无法隐藏的，隐藏了系统无法管理到该进程。</span></span><br><span class="line">   +<span class="number">0x0bc</span> DebugPort        : Ptr32 Void<span class="comment">//调试相关</span></span><br><span class="line">   +<span class="number">0x0c0</span> ExceptionPort    : Ptr32 Void<span class="comment">//调试相关</span></span><br><span class="line">   +<span class="number">0x0c4</span> ObjectTable      : Ptr32 _HANDLE_TABLE<span class="comment">//句柄表</span></span><br><span class="line">   +<span class="number">0x0c8</span> Token            : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x0cc</span> WorkingSetLock   : _FAST_MUTEX</span><br><span class="line">   +<span class="number">0x0ec</span> WorkingSetPage   : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> AddressCreationLock : _FAST_MUTEX</span><br><span class="line">   +<span class="number">0x110</span> HyperSpaceLock   : Uint4B</span><br><span class="line">   +<span class="number">0x114</span> ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x118</span> HardwareTrigger  : Uint4B</span><br><span class="line">   +<span class="number">0x11c</span> VadRoot          : Ptr32 Void<span class="comment">//标识0-2G哪些地址没占用了</span></span><br><span class="line">   +<span class="number">0x120</span> VadHint          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x124</span> CloneRoot        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x128</span> NumberOfPrivatePages : Uint4B</span><br><span class="line">   +<span class="number">0x12c</span> NumberOfLockedPages : Uint4B</span><br><span class="line">   +<span class="number">0x130</span> Win32Process     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x134</span> Job              : Ptr32 _EJOB</span><br><span class="line">   +<span class="number">0x138</span> SectionObject    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x13c</span> SectionBaseAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x140</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x144</span> WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">   +<span class="number">0x148</span> Win32WindowStation : Ptr32 Void</span><br><span class="line">   +<span class="number">0x14c</span> InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">   +<span class="number">0x150</span> LdtInformation   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x154</span> VadFreeHint      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x158</span> VdmObjects       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x15c</span> DeviceMap        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x160</span> PhysicalVadList  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x168</span> PageDirectoryPte : _HARDWARE_PTE_X86</span><br><span class="line">   +<span class="number">0x168</span> Filler           : Uint8B</span><br><span class="line">   +<span class="number">0x170</span> Session          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x174</span> ImageFileName    : [<span class="number">16</span>] UChar<span class="comment">//进程镜像文件名 最多16个字节</span></span><br><span class="line">   +<span class="number">0x184</span> JobLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x18c</span> LockedPagesList  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x190</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x198</span> SecurityPort     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x19c</span> PaeTop           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a0</span> ActiveThreads    : Uint4B<span class="comment">//活动线程的数量</span></span><br><span class="line">   +<span class="number">0x1a4</span> GrantedAccess    : Uint4B</span><br><span class="line">   +<span class="number">0x1a8</span> DefaultHardErrorProcessing : Uint4B</span><br><span class="line">   +<span class="number">0x1ac</span> LastThreadExitStatus : Int4B</span><br><span class="line">   +<span class="number">0x1b0</span> Peb              : Ptr32 _PEB<span class="comment">//PEB((Process Environment Block 进程环境块)：进程在3环的一个结构体，里面包含了进程的模块列表、是否处于调试状态等信息。</span></span><br><span class="line">   +<span class="number">0x1b4</span> PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   +<span class="number">0x1b8</span> ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c0</span> WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c8</span> OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1d0</span> ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1d8</span> WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e0</span> OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1e8</span> CommitChargeLimit : Uint4B</span><br><span class="line">   +<span class="number">0x1ec</span> CommitChargePeak : Uint4B</span><br><span class="line">   +<span class="number">0x1f0</span> AweInfo          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1f4</span> SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   +<span class="number">0x1f8</span> Vm               : _MMSUPPORT</span><br><span class="line">   +<span class="number">0x238</span> LastFaultCount   : Uint4B</span><br><span class="line">   +<span class="number">0x23c</span> ModifiedPageCount : Uint4B</span><br><span class="line">   +<span class="number">0x240</span> NumberOfVads     : Uint4B</span><br><span class="line">   +<span class="number">0x244</span> JobStatus        : Uint4B</span><br><span class="line">   +<span class="number">0x248</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x248</span> CreateReported   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> NoDebugInherit   : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> ProcessExiting   : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> ProcessDelete    : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Wow64SplitPages  : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> VmDeleted        : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> OutswapEnabled   : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Outswapped       : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> ForkFailed       : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> HasPhysicalVad   : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> AddressSpaceInitialized : Pos <span class="number">10</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x248</span> SetTimerResolution : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> BreakOnTermination : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> SessionCreationUnderway : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> WriteWatch       : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> ProcessInSession : Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> OverrideAddressSpace : Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> HasAddressSpace  : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> LaunchPrefetched : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> InjectInpageErrors : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> VmTopDown        : Pos <span class="number">21</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Unused3          : Pos <span class="number">22</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Unused4          : Pos <span class="number">23</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> VdmAllowed       : Pos <span class="number">24</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Unused           : Pos <span class="number">25</span>, <span class="number">5</span> Bits</span><br><span class="line">   +<span class="number">0x248</span> Unused1          : Pos <span class="number">30</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> Unused2          : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x24c</span> ExitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x250</span> NextPageColor    : Uint2B</span><br><span class="line">   +<span class="number">0x252</span> SubSystemMinorVersion : UChar</span><br><span class="line">   +<span class="number">0x253</span> SubSystemMajorVersion : UChar</span><br><span class="line">   +<span class="number">0x252</span> SubSystemVersion : Uint2B</span><br><span class="line">   +<span class="number">0x254</span> PriorityClass    : UChar</span><br><span class="line">   +<span class="number">0x255</span> WorkingSetAcquiredUnsafe : UChar</span><br><span class="line">   +<span class="number">0x258</span> Cookie           : Uint4B</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KPROCESS"><a href="#KPROCESS" class="headerlink" title="KPROCESS"></a>KPROCESS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPROCESS</span><br><span class="line">ntdll!_KPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER <span class="comment">//&quot;可等待对象&quot;，有这个成员就可以被WaitForSingleObject等待</span></span><br><span class="line">   +<span class="number">0x010</span> ProfileListHead  : _LIST_ENTRY <span class="comment">//性能分析</span></span><br><span class="line">   +<span class="number">0x018</span> DirectoryTableBase : [<span class="number">2</span>] Uint4B<span class="comment">//页目录表基址，DirectoryTableBase[0] cr3 DirectoryTableBase[1] 超过4GE后的cr3</span></span><br><span class="line">   +<span class="number">0x020</span> LdtDescriptor    : _KGDTENTRY</span><br><span class="line">   +<span class="number">0x028</span> Int21Descriptor  : _KIDTENTRY</span><br><span class="line">   +<span class="number">0x030</span> IopmOffset       : Uint2B</span><br><span class="line">   +<span class="number">0x032</span> Iopl             : UChar</span><br><span class="line">   +<span class="number">0x033</span> Unused           : UChar</span><br><span class="line">   +<span class="number">0x034</span> ActiveProcessors : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> KernelTime       : Uint4B<span class="comment">//记录一个进程在内核模式下花的时间</span></span><br><span class="line">   +<span class="number">0x03c</span> UserTime         : Uint4B<span class="comment">//记录一个进程在用户模式下花的时间</span></span><br><span class="line">   +<span class="number">0x040</span> ReadyListHead    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x048</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x04c</span> VdmTrapcHandler  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x050</span> ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x058</span> ProcessLock      : Uint4B</span><br><span class="line">   +<span class="number">0x05c</span> Affinity         : Uint4B<span class="comment">//指定哪一个CPU来运行这个进程</span></span><br><span class="line">    <span class="comment">//如果值为1，那这个进程的所以线程只能在0号CPU上跑(00000001)				</span></span><br><span class="line">    <span class="comment">//如果值为3，那这个进程的所以线程能在0、1号CPU上跑(000000011)	</span></span><br><span class="line">    <span class="comment">//如果值为4，那这个进程的所以线程能在2号CPU上跑(000000100)	</span></span><br><span class="line">    <span class="comment">//如果值为5，那这个进程的所以线程能在0，2号CPU上跑(000000101)	</span></span><br><span class="line">    <span class="comment">//4个字节共32位  所以最多32核 Windows64位 就64核			</span></span><br><span class="line">    <span class="comment">//如果只有一个CPU 把这个设置为4 那么这个进程就死了</span></span><br><span class="line">   +<span class="number">0x060</span> StackCount       : Uint2B</span><br><span class="line">   +<span class="number">0x062</span> BasePriority     : Char<span class="comment">//基础优先级或最低优先级，该进程中的所有线程最起码的优先级</span></span><br><span class="line">   +<span class="number">0x063</span> ThreadQuantum    : Char</span><br><span class="line">   +<span class="number">0x064</span> AutoAlignment    : UChar</span><br><span class="line">   +<span class="number">0x065</span> State            : UChar</span><br><span class="line">   +<span class="number">0x066</span> ThreadSeed       : UChar</span><br><span class="line">   +<span class="number">0x067</span> DisableBoost     : UChar</span><br><span class="line">   +<span class="number">0x068</span> PowerState       : UChar</span><br><span class="line">   +<span class="number">0x069</span> DisableQuantum   : UChar</span><br><span class="line">   +<span class="number">0x06a</span> IdealNode        : UChar</span><br><span class="line">   +<span class="number">0x06b</span> Flags            : _KEXECUTE_OPTIONS</span><br><span class="line">   +<span class="number">0x06b</span> ExecuteOptions   : UChar</span><br></pre></td></tr></table></figure>

<h2 id="通过进程结构体遍历所有的进程"><a href="#通过进程结构体遍历所有的进程" class="headerlink" title="通过进程结构体遍历所有的进程"></a>通过进程结构体遍历所有的进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ULONG ProcessListHead=<span class="number">0</span>;</span><br><span class="line">PLIST_ENTRY pListHead;</span><br><span class="line">PLIST_ENTRY pListNext;</span><br><span class="line">__asm&#123;</span><br><span class="line"></span><br><span class="line">	mov eax,fs:<span class="number">124</span>h</span><br><span class="line">	mov ebx,[eax+<span class="number">220</span>h]  <span class="comment">//得到线程结构体</span></span><br><span class="line">	mov ProcessListHead,ebx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pListHead=(PLIST_ENTRY)(ProcessListHead+<span class="number">0x88</span>);</span><br><span class="line">pListNext=pListHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	DbgPrint(<span class="string">&quot;ImageFileName=%s\n&quot;</span>,(PULONG)pListNext<span class="number">-0x88</span>/<span class="number">4</span>+<span class="number">0x174</span>/<span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	pListNext=pListNext-&gt;Flink;</span><br><span class="line">&#125;<span class="keyword">while</span>(pListHead!=pListNext);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="002-线程结构体"><a href="#002-线程结构体" class="headerlink" title="002.线程结构体"></a>002.线程结构体</h1><p>每个windows线程在0环都有一个对应的结构体：ETHREAD  这个结构体包含了线程所有重要的信息。</p>
<h2 id="KTHREAD"><a href="#KTHREAD" class="headerlink" title="KTHREAD"></a>KTHREAD</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +<span class="number">0x000</span> Header           : _DISPATCHER_HEADER<span class="comment">//可等待对象</span></span><br><span class="line">   +<span class="number">0x010</span> MutantListHead   : _LIST_ENTRY<span class="comment">//互斥体对象链表</span></span><br><span class="line">   +<span class="number">0x018</span> InitialStack     : Ptr32 Void<span class="comment">//线程切换相关</span></span><br><span class="line">   +<span class="number">0x01c</span> StackLimit       : Ptr32 Void<span class="comment">//线程切换相关</span></span><br><span class="line">   +<span class="number">0x020</span> Teb              : Ptr32 Void</span><br><span class="line">        <span class="comment">//TEB，Thread Environment Block，线程环境块。</span></span><br><span class="line">        <span class="comment">//大小4KB,位于用户地址空间。</span></span><br><span class="line">        <span class="comment">//FS:[0] -&gt; TEB(3环时  0环时FS执行KPCR)</span></span><br><span class="line"></span><br><span class="line">   +<span class="number">0x024</span> TlsArray         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x028</span> KernelStack      : Ptr32 Void<span class="comment">//线程切换相关</span></span><br><span class="line">   +<span class="number">0x02c</span> DebugActive      : UChar<span class="comment">//如果值为-1 不能使用调试寄存器：Dr0 - Dr7</span></span><br><span class="line">   +<span class="number">0x02d</span> State            : UChar<span class="comment">//线程状态：就绪、等待还是运行</span></span><br><span class="line">   +<span class="number">0x02e</span> Alerted          : [<span class="number">2</span>] UChar</span><br><span class="line">   +<span class="number">0x030</span> Iopl             : UChar</span><br><span class="line">   +<span class="number">0x031</span> NpxState         : UChar</span><br><span class="line">   +<span class="number">0x032</span> Saturation       : Char</span><br><span class="line">   +<span class="number">0x033</span> Priority         : Char</span><br><span class="line">   +<span class="number">0x034</span> ApcState         : _KAPC_STATE<span class="comment">//APC相关</span></span><br><span class="line">   +<span class="number">0x04c</span> ContextSwitches  : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> IdleSwapBlock    : UChar</span><br><span class="line">   +<span class="number">0x051</span> Spare0           : [<span class="number">3</span>] UChar</span><br><span class="line">   +<span class="number">0x054</span> WaitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x058</span> WaitIrql         : UChar</span><br><span class="line">   +<span class="number">0x059</span> WaitMode         : Char</span><br><span class="line">   +<span class="number">0x05a</span> WaitNext         : UChar</span><br><span class="line">   +<span class="number">0x05b</span> WaitReason       : UChar</span><br><span class="line">   +<span class="number">0x05c</span> WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +<span class="number">0x060</span> WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x060</span> SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x068</span> WaitTime         : Uint4B</span><br><span class="line">   +<span class="number">0x06c</span> BasePriority     : Char<span class="comment">//其初始值是所属进程的BasePriority值(KPROCESS-&gt;BasePriority)，以后可以通过KeSetBasePriorityThread()函数重新设定</span></span><br><span class="line">   +<span class="number">0x06d</span> DecrementCount   : UChar</span><br><span class="line">   +<span class="number">0x06e</span> PriorityDecrement : Char</span><br><span class="line">   +<span class="number">0x06f</span> Quantum          : Char</span><br><span class="line">   +<span class="number">0x070</span> WaitBlock        : [<span class="number">4</span>] _KWAIT_BLOCK<span class="comment">//等待哪个对象（WaitForSingleObject）</span></span><br><span class="line">   +<span class="number">0x0d0</span> LegoData         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0d4</span> KernelApcDisable : Uint4B</span><br><span class="line">   +<span class="number">0x0d8</span> UserAffinity     : Uint4B</span><br><span class="line">   +<span class="number">0x0dc</span> SystemAffinityActive : UChar</span><br><span class="line">   +<span class="number">0x0dd</span> PowerState       : UChar</span><br><span class="line">   +<span class="number">0x0de</span> NpxIrql          : UChar</span><br><span class="line">   +<span class="number">0x0df</span> InitialNode      : UChar</span><br><span class="line">   +<span class="number">0x0e0</span> ServiceTable     : Ptr32 Void<span class="comment">//指向系统服务表基址</span></span><br><span class="line">   +<span class="number">0x0e4</span> Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +<span class="number">0x0e8</span> ApcQueueLock     : Uint4B<span class="comment">//APC相关</span></span><br><span class="line">   +<span class="number">0x0f0</span> Timer            : _KTIMER</span><br><span class="line">   +<span class="number">0x118</span> QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x120</span> SoftAffinity     : Uint4B</span><br><span class="line">   +<span class="number">0x124</span> Affinity         : Uint4B</span><br><span class="line">   +<span class="number">0x128</span> Preempted        : UChar</span><br><span class="line">   +<span class="number">0x129</span> ProcessReadyQueue : UChar</span><br><span class="line">   +<span class="number">0x12a</span> KernelStackResident : UChar</span><br><span class="line">   +<span class="number">0x12b</span> NextProcessor    : UChar</span><br><span class="line">   +<span class="number">0x12c</span> CallbackStack    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x130</span> Win32Thread      : Ptr32 Void</span><br><span class="line">   +<span class="number">0x134</span> TrapFrame        : Ptr32 _KTRAP_FRAME<span class="comment">//进0环时保存环境</span></span><br><span class="line">   +<span class="number">0x138</span> ApcStatePointer  : [<span class="number">2</span>] Ptr32 _KAPC_STATE</span><br><span class="line">   +<span class="number">0x140</span> PreviousMode     : Char<span class="comment">//某些内核函数会判断程序是0环调用还是3环调用的</span></span><br><span class="line">   +<span class="number">0x141</span> EnableStackSwap  : UChar</span><br><span class="line">   +<span class="number">0x142</span> LargeStack       : UChar</span><br><span class="line">   +<span class="number">0x143</span> ResourceIndex    : UChar</span><br><span class="line">   +<span class="number">0x144</span> KernelTime       : Uint4B</span><br><span class="line">   +<span class="number">0x148</span> UserTime         : Uint4B</span><br><span class="line">   +<span class="number">0x14c</span> SavedApcState    : _KAPC_STATE<span class="comment">//APC相关</span></span><br><span class="line">   +<span class="number">0x164</span> Alertable        : UChar</span><br><span class="line">   +<span class="number">0x165</span> ApcStateIndex    : UChar</span><br><span class="line">   +<span class="number">0x166</span> ApcQueueable     : UChar</span><br><span class="line">   +<span class="number">0x167</span> AutoAlignment    : UChar</span><br><span class="line">   +<span class="number">0x168</span> StackBase        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x16c</span> SuspendApc       : _KAPC</span><br><span class="line">   +<span class="number">0x19c</span> SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x1b0</span> ThreadListEntry  : _LIST_ENTRY<span class="comment">//双向链表，一个进程所有的线程都挂在一个链表中，挂的就是这个位置（这是第一个）</span></span><br><span class="line">   +<span class="number">0x1b8</span> FreezeCount      : Char</span><br><span class="line">   +<span class="number">0x1b9</span> SuspendCount     : Char</span><br><span class="line">   +<span class="number">0x1ba</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0x1bb</span> DisableBoost     : UChar</span><br></pre></td></tr></table></figure>



<h2 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +<span class="number">0x000</span> Tcb              : _KTHREAD</span><br><span class="line">   +<span class="number">0x1c0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c0</span> NestedFaultCount : Pos <span class="number">0</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x1c0</span> ApcNeeded        : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x1c8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x1c8</span> LpcReplyChain    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1c8</span> KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1d0</span> ExitStatus       : Int4B</span><br><span class="line">   +<span class="number">0x1d0</span> OfsChain         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1d4</span> PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1dc</span> TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +<span class="number">0x1dc</span> ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +<span class="number">0x1dc</span> KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x1e0</span> ActiveTimerListLock : Uint4B</span><br><span class="line">   +<span class="number">0x1e4</span> ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x1ec</span> Cid              : _CLIENT_ID<span class="comment">//进程ID、线程ID</span></span><br><span class="line">   +<span class="number">0x1f4</span> LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x1f4</span> KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +<span class="number">0x208</span> LpcReplyMessage  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x208</span> LpcWaitingOnPort : Ptr32 Void</span><br><span class="line">   +<span class="number">0x20c</span> ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +<span class="number">0x210</span> IrpList          : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x218</span> TopLevelIrp      : Uint4B</span><br><span class="line">   +<span class="number">0x21c</span> DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x220</span> ThreadsProcess   : Ptr32 _EPROCESS<span class="comment">//指向自己所属进程</span></span><br><span class="line">   +<span class="number">0x224</span> StartAddress     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x228</span> Win32StartAddress : Ptr32 Void</span><br><span class="line">   +<span class="number">0x228</span> LpcReceivedMessageId : Uint4B</span><br><span class="line">   +<span class="number">0x22c</span> ThreadListEntry  : _LIST_ENTRY<span class="comment">//双向链表 一个进程所有的线程 都挂在一个链表中 挂的就是这个位置（这是第二个）</span></span><br><span class="line">   +<span class="number">0x234</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x238</span> ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x23c</span> LpcReplyMessageId : Uint4B</span><br><span class="line">   +<span class="number">0x240</span> ReadClusterSize  : Uint4B</span><br><span class="line">   +<span class="number">0x244</span> GrantedAccess    : Uint4B</span><br><span class="line">   +<span class="number">0x248</span> CrossThreadFlags : Uint4B</span><br><span class="line">   +<span class="number">0x248</span> Terminated       : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> DeadThread       : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> HideFromDebugger : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> ActiveImpersonationInfo : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> SystemThread     : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> HardErrorsAreDisabled : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> BreakOnTermination : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> SkipCreationMsg  : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x248</span> SkipTerminationMsg : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x24c</span> SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +<span class="number">0x24c</span> ActiveExWorker   : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x24c</span> ExWorkerCanWaitUser : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x24c</span> MemoryMaker      : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x250</span> SameThreadApcFlags : Uint4B</span><br><span class="line">   +<span class="number">0x250</span> LpcReceivedMsgIdValid : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x250</span> LpcExitThreadCalled : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x250</span> AddressSpaceOwner : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x254</span> ForwardClusterOnly : UChar</span><br><span class="line">   +<span class="number">0x255</span> DisablePageFaultClustering : UChar</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230119203755480.png" alt="image-20230119203755480"></p>
<h1 id="003-KPCR"><a href="#003-KPCR" class="headerlink" title="003.KPCR"></a>003.KPCR</h1><ol>
<li>KPCR结构体是CPU临时记录线程信息的一个结构体</li>
<li>KPCR是CPU快速查找线程信息用的，自己在上面做不了什么事情。</li>
<li>当线程进入0环时，FS:[0]指向KPCR(3环时FS:[0] -&gt; TEB)</li>
<li>每个CPU都有一个KPCR结构体(一个核一个)</li>
<li>KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。</li>
<li>FS寄存器在三环时，记录的是TEB结构的地址。<br>在0环时，记录的是KPCR的地址。</li>
</ol>
<h2 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPCR</span><br><span class="line">nt!_KPCR</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> SelfPcr          : Ptr32 _KPCR<span class="comment">//指向自己，方便寻址</span></span><br><span class="line">   +<span class="number">0x020</span> Prcb             : Ptr32 _KPRCB<span class="comment">//指向拓展结构体PRCB  </span></span><br><span class="line">   +<span class="number">0x024</span> Irql             : UChar</span><br><span class="line">   +<span class="number">0x028</span> IRR              : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> IrrActive        : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> IDR              : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x038</span> IDT              : Ptr32 _KIDTENTRY<span class="comment">//IDT表基址</span></span><br><span class="line">   +<span class="number">0x03c</span> GDT              : Ptr32 _KGDTENTRY<span class="comment">//GDT表基址</span></span><br><span class="line">   +<span class="number">0x040</span> TSS              : Ptr32 _KTSS<span class="comment">//指针，指向TSS，每个CPU都有一个TSS</span></span><br><span class="line">   +<span class="number">0x044</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x046</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x048</span> SetMember        : Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> StallScaleFactor : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> DebugActive      : UChar</span><br><span class="line">   +<span class="number">0x051</span> Number           : UChar<span class="comment">//CPU编号：0 1 2 3 4 5。。。</span></span><br><span class="line">   +<span class="number">0x052</span> Spare0           : UChar</span><br><span class="line">   +<span class="number">0x053</span> SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +<span class="number">0x054</span> VdmAlert         : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> KernelReserved   : [<span class="number">14</span>] Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SecondLevelCacheSize : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> HalReserved      : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> InterruptMode    : Uint4B</span><br><span class="line">   +<span class="number">0x0d8</span> Spare1           : UChar</span><br><span class="line">   +<span class="number">0x0dc</span> KernelReserved2  : [<span class="number">17</span>] Uint4B</span><br><span class="line">   +<span class="number">0x120</span> PrcbData         : _KPRCB<span class="comment">//拓展结构体</span></span><br></pre></td></tr></table></figure>

<h2 id="NT-TIB"><a href="#NT-TIB" class="headerlink" title="NT_TIB"></a>NT_TIB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _NT_TIB</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD<span class="comment">//当前线程内核异常链表(SEH)</span></span><br><span class="line">   +<span class="number">0x004</span> StackBase        : Ptr32 Void<span class="comment">//当前线程内核栈的基址</span></span><br><span class="line">   +<span class="number">0x008</span> StackLimit       : Ptr32 Void<span class="comment">//当前线程内核栈的大小</span></span><br><span class="line">   +<span class="number">0x00c</span> SubSystemTib     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> FiberData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> Version          : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Self             : Ptr32 _NT_TIB<span class="comment">//指向自己(也就是指向KPCR结构) </span></span><br></pre></td></tr></table></figure>



<h2 id="KPRCB"><a href="#KPRCB" class="headerlink" title="KPRCB"></a>KPRCB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KPRCB</span><br><span class="line">ntdll!_KPRCB</span><br><span class="line">   +<span class="number">0x000</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> CurrentThread    : Ptr32 _KTHREAD<span class="comment">//当前线程</span></span><br><span class="line">   +<span class="number">0x008</span> NextThread       : Ptr32 _KTHREAD<span class="comment">//即将切换的下一个线程</span></span><br><span class="line">   +<span class="number">0x00c</span> IdleThread       : Ptr32 _KTHREAD<span class="comment">//空闲线程</span></span><br><span class="line">   +<span class="number">0x010</span> Number           : Char</span><br><span class="line">   +<span class="number">0x011</span> Reserved         : Char</span><br><span class="line">   +<span class="number">0x012</span> BuildType        : Uint2B</span><br><span class="line">   +<span class="number">0x014</span> SetMember        : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> CpuType          : Char</span><br><span class="line">   +<span class="number">0x019</span> CpuID            : Char</span><br><span class="line">   +<span class="number">0x01a</span> CpuStep          : Uint2B</span><br><span class="line">   +<span class="number">0x01c</span> ProcessorState   : _KPROCESSOR_STATE</span><br><span class="line">   +<span class="number">0x33c</span> KernelReserved   : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x37c</span> HalReserved      : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x3bc</span> PrcbPad0         : [<span class="number">92</span>] UChar</span><br><span class="line">   +<span class="number">0x418</span> LockQueue        : [<span class="number">16</span>] _KSPIN_LOCK_QUEUE</span><br><span class="line">   +<span class="number">0x498</span> PrcbPad1         : [<span class="number">8</span>] UChar</span><br><span class="line">   +<span class="number">0x4a0</span> NpxThread        : Ptr32 _KTHREAD</span><br><span class="line">   +<span class="number">0x4a4</span> InterruptCount   : Uint4B</span><br><span class="line">   +<span class="number">0x4a8</span> KernelTime       : Uint4B</span><br><span class="line">   +<span class="number">0x4ac</span> UserTime         : Uint4B</span><br><span class="line">   +<span class="number">0x4b0</span> DpcTime          : Uint4B</span><br><span class="line">   +<span class="number">0x4b4</span> DebugDpcTime     : Uint4B</span><br><span class="line">   +<span class="number">0x4b8</span> InterruptTime    : Uint4B</span><br><span class="line">   +<span class="number">0x4bc</span> AdjustDpcThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x4c0</span> PageColor        : Uint4B</span><br><span class="line">   +<span class="number">0x4c4</span> SkipTick         : Uint4B</span><br><span class="line">   +<span class="number">0x4c8</span> MultiThreadSetBusy : UChar</span><br><span class="line">   +<span class="number">0x4c9</span> Spare2           : [<span class="number">3</span>] UChar</span><br><span class="line">   +<span class="number">0x4cc</span> ParentNode       : Ptr32 _KNODE</span><br><span class="line">   +<span class="number">0x4d0</span> MultiThreadProcessorSet : Uint4B</span><br><span class="line">   +<span class="number">0x4d4</span> MultiThreadSetMaster : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x4d8</span> ThreadStartCount : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x4e0</span> CcFastReadNoWait : Uint4B</span><br><span class="line">   +<span class="number">0x4e4</span> CcFastReadWait   : Uint4B</span><br><span class="line">   +<span class="number">0x4e8</span> CcFastReadNotPossible : Uint4B</span><br><span class="line">   +<span class="number">0x4ec</span> CcCopyReadNoWait : Uint4B</span><br><span class="line">   +<span class="number">0x4f0</span> CcCopyReadWait   : Uint4B</span><br><span class="line">   +<span class="number">0x4f4</span> CcCopyReadNoWaitMiss : Uint4B</span><br><span class="line">   +<span class="number">0x4f8</span> KeAlignmentFixupCount : Uint4B</span><br><span class="line">   +<span class="number">0x4fc</span> KeContextSwitches : Uint4B</span><br><span class="line">   +<span class="number">0x500</span> KeDcacheFlushCount : Uint4B</span><br><span class="line">   +<span class="number">0x504</span> KeExceptionDispatchCount : Uint4B</span><br><span class="line">   +<span class="number">0x508</span> KeFirstLevelTbFills : Uint4B</span><br><span class="line">   +<span class="number">0x50c</span> KeFloatingEmulationCount : Uint4B</span><br><span class="line">   +<span class="number">0x510</span> KeIcacheFlushCount : Uint4B</span><br><span class="line">   +<span class="number">0x514</span> KeSecondLevelTbFills : Uint4B</span><br><span class="line">   +<span class="number">0x518</span> KeSystemCalls    : Uint4B</span><br><span class="line">   +<span class="number">0x51c</span> SpareCounter0    : [<span class="number">1</span>] Uint4B</span><br><span class="line">   +<span class="number">0x520</span> PPLookasideList  : [<span class="number">16</span>] _PP_LOOKASIDE_LIST</span><br><span class="line">   +<span class="number">0x5a0</span> PPNPagedLookasideList : [<span class="number">32</span>] _PP_LOOKASIDE_LIST</span><br><span class="line">   +<span class="number">0x6a0</span> PPPagedLookasideList : [<span class="number">32</span>] _PP_LOOKASIDE_LIST</span><br><span class="line">   +<span class="number">0x7a0</span> PacketBarrier    : Uint4B</span><br><span class="line">   +<span class="number">0x7a4</span> ReverseStall     : Uint4B</span><br><span class="line">   +<span class="number">0x7a8</span> IpiFrame         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x7ac</span> PrcbPad2         : [<span class="number">52</span>] UChar</span><br><span class="line">   +<span class="number">0x7e0</span> CurrentPacket    : [<span class="number">3</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x7ec</span> TargetSet        : Uint4B</span><br><span class="line">   +<span class="number">0x7f0</span> WorkerRoutine    : Ptr32     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x7f4</span> IpiFrozen        : Uint4B</span><br><span class="line">   +<span class="number">0x7f8</span> PrcbPad3         : [<span class="number">40</span>] UChar</span><br><span class="line">   +<span class="number">0x820</span> RequestSummary   : Uint4B</span><br><span class="line">   +<span class="number">0x824</span> SignalDone       : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x828</span> PrcbPad4         : [<span class="number">56</span>] UChar</span><br><span class="line">   +<span class="number">0x860</span> DpcListHead      : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x868</span> DpcStack         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x86c</span> DpcCount         : Uint4B</span><br><span class="line">   +<span class="number">0x870</span> DpcQueueDepth    : Uint4B</span><br><span class="line">   +<span class="number">0x874</span> DpcRoutineActive : Uint4B</span><br><span class="line">   +<span class="number">0x878</span> DpcInterruptRequested : Uint4B</span><br><span class="line">   +<span class="number">0x87c</span> DpcLastCount     : Uint4B</span><br><span class="line">   +<span class="number">0x880</span> DpcRequestRate   : Uint4B</span><br><span class="line">   +<span class="number">0x884</span> MaximumDpcQueueDepth : Uint4B</span><br><span class="line">   +<span class="number">0x888</span> MinimumDpcRate   : Uint4B</span><br><span class="line">   +<span class="number">0x88c</span> QuantumEnd       : Uint4B</span><br><span class="line">   +<span class="number">0x890</span> PrcbPad5         : [<span class="number">16</span>] UChar</span><br><span class="line">   +<span class="number">0x8a0</span> DpcLock          : Uint4B</span><br><span class="line">   +<span class="number">0x8a4</span> PrcbPad6         : [<span class="number">28</span>] UChar</span><br><span class="line">   +<span class="number">0x8c0</span> CallDpc          : _KDPC</span><br><span class="line">   +<span class="number">0x8e0</span> ChainedInterruptList : Ptr32 Void</span><br><span class="line">   +<span class="number">0x8e4</span> LookasideIrpFloat : Int4B</span><br><span class="line">   +<span class="number">0x8e8</span> SpareFields0     : [<span class="number">6</span>] Uint4B</span><br><span class="line">   +<span class="number">0x900</span> VendorString     : [<span class="number">13</span>] UChar</span><br><span class="line">   +<span class="number">0x90d</span> InitialApicId    : UChar</span><br><span class="line">   +<span class="number">0x90e</span> LogicalProcessorsPerPhysicalProcessor : UChar</span><br><span class="line">   +<span class="number">0x910</span> MHz              : Uint4B</span><br><span class="line">   +<span class="number">0x914</span> FeatureBits      : Uint4B</span><br><span class="line">   +<span class="number">0x918</span> UpdateSignature  : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x920</span> NpxSaveArea      : _FX_SAVE_AREA</span><br><span class="line">   +<span class="number">0xb30</span> PowerState       : _PROCESSOR_POWER_STATE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别强调：</p>
<p>我们课程里面讲解的内容，与《内核情景分析》《Windows内核原理与实现》均有不同。</p>
<p>ReactOS是开源免费的Windows NT系列(含NT4.0/2000/XP/2003)克隆操作系统</p>
<p>WRK 是微软针对教育和学术界开放的 Windows 内核的部分源码</p>
<p>而我们的课程是基于Windows XP SP2/SP3 二进制文件.</p>
<p>微软并不开源，很多内核成员的作用需要自己去分析.    </p>
</blockquote>
<h1 id="004-等待链表-调度链表"><a href="#004-等待链表-调度链表" class="headerlink" title="004.等待链表_调度链表"></a>004.等待链表_调度链表</h1><blockquote>
<p>回顾：</p>
<p>EPROCESS结构体有两个链表：0x50，0x190，里面圈着当前进程的所有线程。</p>
</blockquote>
<p><strong>对进程断链，程序可以正常运行，原因是CPU执行与调度是基于线程的，进程断链只是影响一些遍历系统进程的API，并不会影响程序执行。</strong></p>
<p><strong>对线程断链也是一样的，断链后在Windbg或者OD中无法看到被断掉的线程，但并不影响其执行(仍然再跑)。</strong></p>
<h2 id="线程的三种状态：等待，运行，就绪"><a href="#线程的三种状态：等待，运行，就绪" class="headerlink" title="线程的三种状态：等待，运行，就绪"></a>线程的三种状态：等待，运行，就绪</h2><p>正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。一个等待链表，32个就绪链表：</p>
<p>这些链表都使用了_KTHREAD(0x060)这个位置，也就是说，线程在某一时刻，只能属于其中一个圈。</p>
<h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><p>导致线程等待的原因有多种，例如调用了Sleep, WaitForSingleObject 等函数，或者在创建时和运行时让线程挂起的API，例如 SuspendThread 函数。</p>
<p>等待线程存储在等待链表头 KiWaitListHead 中， KiWaitListHead 是一个全局变量，可以 dd 查看。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; <span class="built_in">dd</span> KiWaitListHead</span><br><span class="line">8055d4a8  863ee840 86407a30 00000011 00000000</span><br><span class="line">8055d4b8  e57a42bd d6bf94d5 01000013 ffdff980</span><br><span class="line">8055d4c8  ffdff980 805032c6 00000000 0000493c</span><br><span class="line">8055d4d8  00000000 ffdff9c0 8055d4e0 8055d4e0</span><br><span class="line">8055d4e8  00000000 00000000 8055d4f0 8055d4f0</span><br><span class="line">8055d4f8  00000000 00000000 00000000 865b5860</span><br><span class="line">8055d508  00000000 00000000 00040001 00000000</span><br><span class="line">8055d518  865b58d0 865b58d0 00000000 00000000</span><br></pre></td></tr></table></figure>
<p>比如：线程调用了Sleep() 或者 WaitForSingleObject()等函数时，就挂到这个链表(查看等待线程)</p>
<p><code>0x8055d4a8</code>存储了 <code>KiWaitListHead</code> ，这是一个 <code>_LIST_ENTRY</code>，它属于某个线程 <code>_KTHREAD + 0x60</code> 的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD 863ee840-60</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListHead   : _LIST_ENTRY [ 0x863ee7f0 - 0x863ee7f0 ]</span><br><span class="line">   +0x018 InitialStack     : 0xf6fd6000 Void</span><br><span class="line">   +0x01c StackLimit       : 0xf6fd3000 Void</span><br><span class="line">   +0x020 Teb              : 0x7ffd7000 Void</span><br><span class="line">   +0x024 TlsArray         : (null) </span><br><span class="line">   +0x028 KernelStack      : 0xf6fd5c70 Void</span><br><span class="line">   +0x02c DebugActive      : 0 &#x27;&#x27;</span><br><span class="line">   +0x02d State            : 0x5 &#x27;&#x27;</span><br><span class="line">   +0x02e Alerted          : [2]  &quot;&quot;</span><br><span class="line">   +0x030 Iopl             : 0 &#x27;&#x27;</span><br><span class="line">   +0x031 NpxState         : 0xa &#x27;&#x27;</span><br><span class="line">   +0x032 Saturation       : 0 &#x27;&#x27;</span><br><span class="line">   +0x033 Priority         : 11 &#x27;&#x27;</span><br><span class="line">   +0x034 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x04c ContextSwitches  : 0x9d</span><br><span class="line">   +0x050 IdleSwapBlock    : 0 &#x27;&#x27;</span><br><span class="line">   +0x051 Spare0           : [3]  &quot;&quot;</span><br><span class="line">   +0x054 WaitStatus       : 0n0</span><br><span class="line">   +0x058 WaitIrql         : 0 &#x27;&#x27;</span><br><span class="line">   +0x059 WaitMode         : 1 &#x27;&#x27;</span><br><span class="line">   +0x05a WaitNext         : 0 &#x27;&#x27;</span><br><span class="line">   +0x05b WaitReason       : 0xf &#x27;&#x27;</span><br><span class="line">   +0x05c WaitBlockList    : 0x863ee850 _KWAIT_BLOCK</span><br><span class="line">   +0x060 WaitListEntry    : _LIST_ENTRY [ 0x86031998 - 0x8055d4a8 ]</span><br><span class="line">   +0x060 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x068 WaitTime         : 0x45bd</span><br><span class="line">   +0x06c BasePriority     : 9 &#x27;&#x27;</span><br><span class="line">   +0x06d DecrementCount   : 0 &#x27;&#x27;</span><br><span class="line">   +0x06e PriorityDecrement : 0 &#x27;&#x27;</span><br><span class="line">   +0x06f Quantum          : 5 &#x27;&#x27;</span><br><span class="line">   +0x070 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x0d0 LegoData         : (null) </span><br><span class="line">   +0x0d4 KernelApcDisable : 0</span><br><span class="line">   +0x0d8 UserAffinity     : 1</span><br><span class="line">   +0x0dc SystemAffinityActive : 0 &#x27;&#x27;</span><br><span class="line">   +0x0dd PowerState       : 0 &#x27;&#x27;</span><br><span class="line">   +0x0de NpxIrql          : 0 &#x27;&#x27;</span><br><span class="line">   +0x0df InitialNode      : 0 &#x27;&#x27;</span><br><span class="line">   +0x0e0 ServiceTable     : 0x8055d700 Void</span><br><span class="line">   +0x0e4 Queue            : 0x8605c290 _KQUEUE</span><br><span class="line">   +0x0e8 ApcQueueLock     : 0</span><br><span class="line">   +0x0f0 Timer            : _KTIMER</span><br><span class="line">   +0x118 QueueListEntry   : _LIST_ENTRY [ 0x8605c2b0 - 0x864728c0 ]</span><br><span class="line">   +0x120 SoftAffinity     : 1</span><br><span class="line">   +0x124 Affinity         : 1</span><br><span class="line">   +0x128 Preempted        : 0 &#x27;&#x27;</span><br><span class="line">   +0x129 ProcessReadyQueue : 0 &#x27;&#x27;</span><br><span class="line">   +0x12a KernelStackResident : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x12b NextProcessor    : 0 &#x27;&#x27;</span><br><span class="line">   +0x12c CallbackStack    : (null) </span><br><span class="line">   +0x130 Win32Thread      : (null) </span><br><span class="line">   +0x134 TrapFrame        : 0xf6fd5d64 _KTRAP_FRAME</span><br><span class="line">   +0x138 ApcStatePointer  : [2] 0x863ee814 _KAPC_STATE</span><br><span class="line">   +0x140 PreviousMode     : 1 &#x27;&#x27;</span><br><span class="line">   +0x141 EnableStackSwap  : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x142 LargeStack       : 0 &#x27;&#x27;</span><br><span class="line">   +0x143 ResourceIndex    : 0 &#x27;&#x27;</span><br><span class="line">   +0x144 KernelTime       : 0</span><br><span class="line">   +0x148 UserTime         : 0</span><br><span class="line">   +0x14c SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x164 Alertable        : 0 &#x27;&#x27;</span><br><span class="line">   +0x165 ApcStateIndex    : 0 &#x27;&#x27;</span><br><span class="line">   +0x166 ApcQueueable     : 0x1 &#x27;&#x27;</span><br><span class="line">   +0x167 AutoAlignment    : 0 &#x27;&#x27;</span><br><span class="line">   +0x168 StackBase        : 0xf6fd6000 Void</span><br><span class="line">   +0x16c SuspendApc       : _KAPC</span><br><span class="line">   +0x19c SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1b0 ThreadListEntry  : _LIST_ENTRY [ 0x863ee4b8 - 0x8649a9d8 ]</span><br><span class="line">   +0x1b8 FreezeCount      : 0 &#x27;&#x27;</span><br><span class="line">   +0x1b9 SuspendCount     : 0 &#x27;&#x27;</span><br><span class="line">   +0x1ba IdealProcessor   : 0 &#x27;&#x27;</span><br><span class="line">   +0x1bb DisableBoost     : 0 &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>查看这个线程是那个进程的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD 863ee840-60</span><br><span class="line">nt_exe!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x1c0 CreateTime       : _LARGE_INTEGER 0x0eca09f4`d2f538a0</span><br><span class="line">   +0x1c0 NestedFaultCount : 0y00</span><br><span class="line">   +0x1c0 ApcNeeded        : 0y0</span><br><span class="line">   +0x1c8 ExitTime         : _LARGE_INTEGER 0x863ee9a8`863ee9a8</span><br><span class="line">   +0x1c8 LpcReplyChain    : _LIST_ENTRY [ 0x863ee9a8 - 0x863ee9a8 ]</span><br><span class="line">   +0x1c8 KeyedWaitChain   : _LIST_ENTRY [ 0x863ee9a8 - 0x863ee9a8 ]</span><br><span class="line">   +0x1d0 ExitStatus       : 0n0</span><br><span class="line">   +0x1d0 OfsChain         : (null) </span><br><span class="line">   +0x1d4 PostBlockList    : _LIST_ENTRY [ 0x863ee9b4 - 0x863ee9b4 ]</span><br><span class="line">   +0x1dc TerminationPort  : 0xe1726cd8 _TERMINATION_PORT</span><br><span class="line">   +0x1dc ReaperLink       : 0xe1726cd8 _ETHREAD</span><br><span class="line">   +0x1dc KeyedWaitValue   : 0xe1726cd8 Void</span><br><span class="line">   +0x1e0 ActiveTimerListLock : 0</span><br><span class="line">   +0x1e4 ActiveTimerListHead : _LIST_ENTRY [ 0x863ee9c4 - 0x863ee9c4 ]</span><br><span class="line">   +0x1ec Cid              : _CLIENT_ID</span><br><span class="line">   +0x1f4 LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x208 LpcReplyMessage  : (null) </span><br><span class="line">   +0x208 LpcWaitingOnPort : (null) </span><br><span class="line">   +0x20c ImpersonationInfo : 0xe1581808 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +0x210 IrpList          : _LIST_ENTRY [ 0x86472548 - 0x86472548 ]</span><br><span class="line">   +0x218 TopLevelIrp      : 0</span><br><span class="line">   +0x21c DeviceToVerify   : (null) </span><br><span class="line">   +0x220 ThreadsProcess   : 0x86057748 _EPROCESS //这里</span><br><span class="line">   +0x224 StartAddress     : 0x7c8106f9 Void</span><br><span class="line">   +0x228 Win32StartAddress : 0x77e56c7d Void</span><br><span class="line">   +0x228 LpcReceivedMessageId : 0x77e56c7d</span><br><span class="line">   +0x22c ThreadListEntry  : _LIST_ENTRY [ 0x863ee534 - 0x8649aa54 ]</span><br><span class="line">   +0x234 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x238 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">kd&gt; dt _EPROCESS 0x86057748</span><br><span class="line">nt_exe!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">  .....</span><br><span class="line">   +0x174 ImageFileName    : [16]  &quot;lsass.exe&quot;//可以看到是这个进程的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>_KTHREAD + 0x60</code> 是一个共用体 union ，线程处于等待或者调度状态就会存到这个位置的链表里，如果是等待状态，这个地方就是等待链表；如果是调度状态，这里就是调度链表。</p>
<h3 id="运行链表"><a href="#运行链表" class="headerlink" title="运行链表"></a>运行链表</h3><p>一个核只有一个运行中的线程，运行中的线程存储在 KPCR 中。</p>
<h3 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h3><p>调度链表有32个圈，就是优先级:0 - 31  0最低  31最高  </p>
<p>默认优先级一般是8</p>
<p>改变优先级就是从一个圈里面卸下来挂到另外一个圈上</p>
<p>这32个圈是正在调度中的线程：包括正在运行的和准备运行的</p>
<p>比如：只有一个CPU但有10个线程在运行，那么某一时刻，正在运行的线程在KPCR中，其他9个在这32个圈中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">既然有32个链表，就要有32个链表头。</span><br><span class="line">kd&gt; dd KiDispatcherReadyListHead L70</span><br><span class="line">8055df80  8055df80 8055df80 8055df88 8055df88</span><br><span class="line">8055df90  8055df90 8055df90 8055df98 8055df98</span><br><span class="line">8055dfa0  8055dfa0 8055dfa0 8055dfa8 8055dfa8</span><br><span class="line">8055dfb0  8055dfb0 8055dfb0 8055dfb8 8055dfb8</span><br><span class="line">8055dfc0  8055dfc0 8055dfc0 8055dfc8 8055dfc8</span><br><span class="line">8055dfd0  8055dfd0 8055dfd0 8055dfd8 8055dfd8</span><br><span class="line">8055dfe0  8055dfe0 8055dfe0 8055dfe8 8055dfe8</span><br><span class="line">8055dff0  8055dff0 8055dff0 8055dff8 8055dff8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每两个4字节就构成了一个 LIST_ENTRY，我们发现这里32个链表都是空的，原因是现在windbg把系统挂起了，所有线程都处于等待状态，不能被调度了。</p>
<p>32个链表对应32个优先级 0-31，默认优先级是8，优先级越高越优先。</p>
<h4 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h4><p>XP只有一个33个圈，也就是说上面这个数组只有一个，多核也只有一个.</p>
<p>Win7也是一样的只有一个圈，如果是64位的，那就有64个圈.</p>
<p>服务器版本：    </p>
<p><code>KiWaitListHead</code>整个系统只有一个，但<code>KiDispatcherReadyListHead</code>这个数组有几个CPU就有几组</p>
<h1 id="005-模拟线程切换"><a href="#005-模拟线程切换" class="headerlink" title="005.模拟线程切换"></a>005.模拟线程切换</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kwansy/article/details/109554283">模拟线程切换</a></p>
</blockquote>
<p>3环模拟线程切换的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXGMTHREAD 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_CREATE		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_READY		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_RUNNING	0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_SLEEP		0x08</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_EXIT		0x100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREADSTACKSIZE 0x80000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程结构体（仿ETHREAD）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> *name;							<span class="comment">// 线程名，相当于线程TID</span></span><br><span class="line">	<span class="type">int</span> Flags;							<span class="comment">// 线程状态</span></span><br><span class="line">	<span class="type">int</span> SleepMillisecondDot;			<span class="comment">// 休眠时间</span></span><br><span class="line">	<span class="type">void</span> *InitialStack;					<span class="comment">// 线程堆栈起始位置</span></span><br><span class="line">	<span class="type">void</span> *StackLimit;					<span class="comment">// 线程堆栈界限</span></span><br><span class="line">	<span class="type">void</span> *KernelStack;					<span class="comment">// 线程堆栈当前位置，即ESP0</span></span><br><span class="line">	<span class="type">void</span> *lpParameter;					<span class="comment">// 线程函数参数</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter);	<span class="comment">// 线程函数</span></span><br><span class="line">&#125; GMThread_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前调度线程下标</span></span><br><span class="line"><span class="type">int</span> CurrentThreadIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程调度队列</span></span><br><span class="line">GMThread_t GMThreadList[MAXGMTHREAD] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *WindowsStackLimit = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SwitchContext</span><span class="params">(GMThread_t *OldGMThreadp, GMThread_t *NewGMThreadp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GMThreadStartup</span><span class="params">(GMThread_t *GMThreadp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IdleGMThread</span><span class="params">(<span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> **Stackpp, <span class="type">unsigned</span> <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGMThread</span> <span class="params">(GMThread_t *GMThreadp, <span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter), <span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">RegisterGMThread</span><span class="params">(<span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter), <span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduling</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GMSleep</span><span class="params">(<span class="type">int</span> Milliseconds)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread1</span><span class="params">(<span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread2</span><span class="params">(<span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread3</span><span class="params">(<span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread4</span><span class="params">(<span class="type">void</span> *lpParameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化线程环境</span></span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread1&quot;</span>, Thread1, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread2&quot;</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread3&quot;</span>, Thread3, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread4&quot;</span>, Thread4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仿Windows线程切换，模拟系统时钟中断，是被动切换</span></span><br><span class="line">	<span class="comment">//Scheduling();</span></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">20</span>);</span><br><span class="line">		Scheduling();</span><br><span class="line">		<span class="comment">// 如果回到主线程，说明没有找到就绪线程，CurrentThreadIndex 一定是 0</span></span><br><span class="line">		<span class="comment">//printf(&quot;时钟中断. %d\n&quot;, CurrentThreadIndex);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程切换函数</span></span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">SwitchContext</span><span class="params">(GMThread_t *OldGMThreadp, GMThread_t *NewGMThreadp)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 当前线程保存寄存器到自己的栈顶</span></span><br><span class="line">		push ebp;</span><br><span class="line">		mov ebp,esp;</span><br><span class="line">		push edi;</span><br><span class="line">		push esi;</span><br><span class="line">		push ebx;</span><br><span class="line">		push ecx;</span><br><span class="line">		push edx;</span><br><span class="line">		push eax;</span><br><span class="line"></span><br><span class="line">		mov esi,OldGMThreadp; <span class="comment">// mov esi, [ebp + 0x08]</span></span><br><span class="line">		mov edi,NewGMThreadp; <span class="comment">// mov edi, [ebp + 0x0C]</span></span><br><span class="line"></span><br><span class="line">		mov [esi + GMThread_t.KernelStack], esp; <span class="comment">// 保存旧ESP</span></span><br><span class="line">		mov esp,[edi + GMThread_t.KernelStack]; <span class="comment">// 设置新ESP</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从新线程的栈里恢复寄存器的值</span></span><br><span class="line">		pop eax;</span><br><span class="line">		pop edx;</span><br><span class="line">		pop ecx;</span><br><span class="line">		pop ebx;</span><br><span class="line">		pop esi;</span><br><span class="line">		pop edi;</span><br><span class="line">		pop ebp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回到新线程之前调用 SwitchContext 的地方；如果是第一次调度，则跳转到 GMThreadStartup</span></span><br><span class="line">		ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数在 SwitchContext 的 ret 指令执行时调用，功能是调用线程入口函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GMThreadStartup</span><span class="params">(GMThread_t *GMThreadp)</span></span><br><span class="line">&#123;</span><br><span class="line">	GMThreadp-&gt;func(GMThreadp-&gt;lpParameter);</span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_EXIT;</span><br><span class="line">	Scheduling();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;这句永远不会执行，因为修改线程状态为退出，Scheduling 永远不会返回到这里.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲线程，没事做就调用它</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IdleGMThread</span><span class="params">(<span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IdleGMThread-------------------\n&quot;</span>);</span><br><span class="line">	Scheduling();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> **Stackpp, <span class="type">unsigned</span> <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">	*Stackpp -= <span class="number">1</span>;</span><br><span class="line">	**Stackpp = v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程结构体和线程栈，设置状态为“就绪”</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGMThread</span> <span class="params">(GMThread_t *GMThreadp, <span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter), <span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *StackPages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *ESP;</span><br><span class="line">	<span class="comment">// 结构初始化赋值</span></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_CREATE;</span><br><span class="line">	GMThreadp-&gt;name = name;</span><br><span class="line">	GMThreadp-&gt;func = func;</span><br><span class="line">	GMThreadp-&gt;lpParameter = lpParameter;</span><br><span class="line">	<span class="comment">// 申请栈空间</span></span><br><span class="line">	StackPages = (<span class="type">unsigned</span> <span class="type">char</span>*)VirtualAlloc(<span class="literal">NULL</span>,GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="comment">// 清零</span></span><br><span class="line">	<span class="built_in">memset</span>(StackPages,<span class="number">0</span>,GMTHREADSTACKSIZE);</span><br><span class="line">	<span class="comment">// 栈初始化地址</span></span><br><span class="line">	GMThreadp-&gt;InitialStack = (StackPages + GMTHREADSTACKSIZE);</span><br><span class="line">	<span class="comment">// 栈限制</span></span><br><span class="line">	GMThreadp-&gt;StackLimit = StackPages;</span><br><span class="line">	<span class="comment">// 栈地址</span></span><br><span class="line">	ESP = (<span class="type">unsigned</span> <span class="type">int</span> *)GMThreadp-&gt;InitialStack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化线程栈</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadp);		<span class="comment">// 通过这个指针来找到：线程函数、函数参数</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// 平衡堆栈，此值无意义，详见 SwitchContext 函数注释</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadStartup);	<span class="comment">// 线程入口函数，这个函数负责调用线程函数</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push ebp，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push edi，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push esi，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push ebx，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push ecx，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push edx，此值无意义，是寄存器初始值</span></span><br><span class="line">	PushStack(&amp;ESP, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">0</span>);				<span class="comment">// push eax，此值无意义，是寄存器初始值</span></span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;KernelStack = ESP;</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_READY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新线程到调度队列，然后初始化线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">RegisterGMThread</span><span class="params">(<span class="type">char</span> *name, <span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter), <span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找一个空位置，或者是name已经存在的那个项</span></span><br><span class="line">	<span class="comment">// 下标0是当前正在运行的线程，所以从1开始遍历</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; GMThreadList[i].name; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == stricmp(GMThreadList[i].name, name))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化线程结构体</span></span><br><span class="line">	InitGMThread(&amp;GMThreadList[i], name, func, lpParameter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (i | <span class="number">0x55AA0000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程调度函数，功能是遍历调度队列，找到“就绪”线程，然后切换线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduling</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> TickCount;</span><br><span class="line">	GMThread_t *OldGMThreadp;</span><br><span class="line">	GMThread_t *NewGMThreadp;</span><br><span class="line"></span><br><span class="line">	TickCount = GetTickCount(); <span class="comment">// GetTickCount 返回操作系统启动到目前为止经过的毫秒</span></span><br><span class="line">	<span class="comment">// 正在调度的线程，第一次是 GMThreadList[0]，这个表示主线程</span></span><br><span class="line">	OldGMThreadp = &amp;GMThreadList[CurrentThreadIndex];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历线程调度队列，找第一个“就绪”线程</span></span><br><span class="line">	<span class="comment">// 如果找不到，就回到主函数，模拟时钟中断</span></span><br><span class="line">	NewGMThreadp = &amp;GMThreadList[<span class="number">0</span>];	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; GMThreadList[i].name; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 如果达到“等待时间”，就修改状态为“就绪”</span></span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_SLEEP)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (TickCount &gt; GMThreadList[i].SleepMillisecondDot)</span><br><span class="line">			&#123;</span><br><span class="line">				GMThreadList[i].Flags = GMTHREAD_READY;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到“就绪”线程</span></span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_READY)</span><br><span class="line">		&#123;</span><br><span class="line">			NewGMThreadp = &amp;GMThreadList[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新当前调度线程下标</span></span><br><span class="line">	CurrentThreadIndex = NewGMThreadp - GMThreadList;</span><br><span class="line">	<span class="comment">// 线程切换</span></span><br><span class="line">	SwitchContext(OldGMThreadp, NewGMThreadp);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正在运行的线程主动调用此函数，将自己设置成“等待”状态，然后让调度函数调度其他线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GMSleep</span><span class="params">(<span class="type">int</span> Milliseconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	GMThread_t *GMThreadp;</span><br><span class="line">	GMThreadp = &amp;GMThreadList[CurrentThreadIndex];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((GMThreadp-&gt;Flags) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GMThreadp-&gt;SleepMillisecondDot = GetTickCount() + Milliseconds;</span><br><span class="line">		GMThreadp-&gt;Flags = GMTHREAD_SLEEP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Scheduling();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread1</span><span class="params">(<span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread1\n&quot;</span>);</span><br><span class="line">		GMSleep(<span class="number">100</span>); <span class="comment">// 主动切换，模拟WIN32 API</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread2</span><span class="params">(<span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;	Thread2(%d)\n&quot;</span>, i);</span><br><span class="line">		GMSleep(<span class="number">200</span>); <span class="comment">// 主动切换，模拟WIN32 API</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread3</span><span class="params">(<span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;		Thread3(%d)\n&quot;</span>, i);</span><br><span class="line">		GMSleep(<span class="number">200</span>); <span class="comment">// 主动切换，模拟WIN32 API</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread4</span><span class="params">(<span class="type">void</span> *lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;			Thread4(%d)\n&quot;</span>, i);</span><br><span class="line">		GMSleep(<span class="number">400</span>); <span class="comment">// 主动切换，模拟WIN32 API</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RegisterGMThread"><a href="#RegisterGMThread" class="headerlink" title="RegisterGMThread"></a>RegisterGMThread</h2><p>RegisterGMThread 函数负责创建线程，它遍历线程调度队列，找到一个空位作为新线程结构体，然后调用 InitGMThread 初始化。</p>
<h2 id="InitGMThread"><a href="#InitGMThread" class="headerlink" title="InitGMThread"></a>InitGMThread</h2><p>InitGMThread 函数负责初始化线程结构体；为线程申请堆栈内存；向堆栈压入必要的初始数据，包括线程结构体指针</p>
<h2 id="GMThreadStartup"><a href="#GMThreadStartup" class="headerlink" title="GMThreadStartup"></a>GMThreadStartup</h2><p>GMThreadStartup 函数指针，以及一堆寄存器的初始值，最后设置线程状态为“就绪”。</p>
<p><strong>这里所做的所有压栈操作，没有一个是多余的。</strong></p>
<p>所有线程都要通过 <code>GMThreadStartup</code> 函数调用自己的线程入口函数，而调用 <code>GMThreadStartup</code> 函数的地方以及传参的过程设计非常巧妙，这一步发生在 <code>SwitchContext</code> 函数中，恢复线程后，pop了7个寄存器，esp就指向了 <code>GMThreadStartup</code>，此时 <code>SwitchContext</code> 调用 ret (ret相当于pop eip)指令，就跳转到 <code>GMThreadStartup</code> 函数，完全模拟了 call 调用的堆栈，那个看起来没用的堆栈平衡值其实模拟的是 call 时压入堆栈的返回地址，而 GMThreadp 模拟的是 call 之前push的参数。进入 <code>GMThreadStartup</code> 后，函数从 ebp + 8 处取得参数1 GMThreadp 。</p>
<h2 id="Scheduling-线程调度函数"><a href="#Scheduling-线程调度函数" class="headerlink" title="Scheduling 线程调度函数"></a>Scheduling 线程调度函数</h2><p>Scheduling负责遍历线程调度队列，如果遍历到“等待”状态的线程，判断它是否已经完成了“等待”，如果是，那么修改其状态为就绪。通过遍历，找出第一个“就绪”线程，如果遍历完都没有发现新的就绪线程，那么就认为主函数是“就绪”线程。</p>
<p>最后，调用 SwitchContext 函数“切换”到刚才找到的“就绪”线程。</p>
<h2 id="SwitchContext-切换线程函数"><a href="#SwitchContext-切换线程函数" class="headerlink" title="SwitchContext 切换线程函数"></a>SwitchContext 切换线程函数</h2><p>旧线程调用 SwitchContext 时，首先把7个寄存器压到自己的栈顶，然后保存当前栈顶 esp 到 KernelStack，然后从新线程的线程结构体里取出 KernelStack 填到 esp，就完成了线程切换。</p>
<p>接下来就是从新线程的栈顶 pop 还原7个寄存器。pop 了那7个寄存器后，esp 一定是指向下一条指令的地址的，如果新线程尚未被调度过，那么栈顶一定是 GMThreadStartup；如果新线程曾被调度过，那么栈顶一定是新线程上一次调用 SwitchContext 的返回地址，即 Scheduling 函数的末尾。</p>
<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t3YW5zeQ==,size_16,color_FFFFFF,t_70#pic_center.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模拟线程切换总结：</p>
<ol>
<li>线程不是被动切换的，而是<strong>主动</strong>让出CPU.</li>
<li><strong>线程切换</strong>并<strong>没有使用TSS</strong>来保存寄存器，而是使用堆栈.</li>
<li>线程切换的过程就是堆栈切换的过程.</li>
</ol>
<h1 id="006-Windows线程切换-主动切换"><a href="#006-Windows线程切换-主动切换" class="headerlink" title="006.Windows线程切换_主动切换"></a>006.Windows线程切换_主动切换</h1><p>线程切换是操作系统的核心内容，几乎所有的内核API都会调用切换线程的函数。接下来逆向 <code>KiSwapContext</code> 和 <code>SwapContext</code> 这两个函数，看看Windows是怎么切换线程的。</p>
<h2 id="分析-KiSwapContext"><a href="#分析-KiSwapContext" class="headerlink" title="分析 KiSwapContext"></a>分析 KiSwapContext</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:0040581E ; __fastcall KiSwapContext(x)</span><br><span class="line">.text:0040581E @KiSwapContext@4 proc near              ; CODE XREF: KiSwapThread()+33↓p</span><br><span class="line">.text:0040581E</span><br><span class="line">.text:0040581E var_10          = dword ptr -10h</span><br><span class="line">.text:0040581E var_C           = dword ptr -0Ch</span><br><span class="line">.text:0040581E var_8           = dword ptr -8</span><br><span class="line">.text:0040581E var_4           = dword ptr -4</span><br><span class="line">.text:0040581E</span><br><span class="line">.text:0040581E                 sub     esp, 10h;使用寄存器传参，因此要将使用到的寄存器暂时保存到堆栈中,和push等效</span><br><span class="line">.text:00405821                 mov     [esp+10h+var_4], ebx ; KPCR</span><br><span class="line">.text:00405825                 mov     [esp+10h+var_8], esi ; 新线程 _ETHREAD</span><br><span class="line">.text:00405829                 mov     [esp+10h+var_C], edi ; 旧线程 _ETHREAD</span><br><span class="line">.text:0040582D                 mov     [esp+10h+var_10], ebp ; ebp 没用</span><br><span class="line">.text:00405830                 mov     ebx, large fs:1Ch ; _KPCR.Self</span><br><span class="line">.text:00405837                 mov     esi, ecx        ; ecx：新线程的 _ETHREAD</span><br><span class="line">.text:00405839                 mov     edi, [ebx+124h] ; edi：当前线程的 _ETHREAD</span><br><span class="line">.text:00405839                                         ; [ebx+_KPCR.PrcbData.CurrentThread]</span><br><span class="line">.text:0040583F                 mov     [ebx+124h], esi ; 修改 _KPCR，更新当前线程(124h同上</span><br><span class="line">.text:00405845                 mov     cl, [edi+58h]   ; 58==[edi+_ETHREAD.Tcb.WaitIrql]</span><br><span class="line">.text:00405848                 call    SwapContext     ; 4个参数：</span><br><span class="line">.text:00405848                                         ; ebx: _KPCR</span><br><span class="line">.text:00405848                                         ; esi: 新线程 _ETHREAD</span><br><span class="line">.text:00405848                                         ; edi: 旧线程 _ETHREAD</span><br><span class="line">.text:00405848                                         ; cl:旧线程的 WaitIrql，这个参数用来控制是否执行APC</span><br><span class="line">.text:00405848                                         ;</span><br><span class="line">.text:00405848                                         ; 调用 SwapContext 后，已经完成了线程切换</span><br><span class="line">.text:00405848                                         ; 后面就是新线程从它自己的堆栈里恢复寄存器的值的过程</span><br><span class="line">.text:0040584D                 mov     ebp, [esp+10h+var_10]</span><br><span class="line">.text:00405850                 mov     edi, [esp+10h+var_C]</span><br><span class="line">.text:00405854                 mov     esi, [esp+10h+var_8]</span><br><span class="line">.text:00405858                 mov     ebx, [esp+10h+var_4]</span><br><span class="line">.text:0040585C                 add     esp, 10h</span><br><span class="line">.text:0040585F                 retn</span><br><span class="line">.text:0040585F @KiSwapContext@4 endp</span><br></pre></td></tr></table></figure>

<h2 id="分析-SwapContext"><a href="#分析-SwapContext" class="headerlink" title="分析 SwapContext"></a>分析 SwapContext</h2><p><code>SwapContext</code>是线程切换最终发生的地方。</p>
<h3 id="线程切换汇编语句"><a href="#线程切换汇编语句" class="headerlink" title="线程切换汇编语句"></a>线程切换汇编语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov     esp, [esi+_ETHREAD.Tcb.KernelStack] ; 此处是切换线程，切换线程本质是切换堆栈</span><br></pre></td></tr></table></figure>

<h3 id="线程切换是否会切换CR3"><a href="#线程切换是否会切换CR3" class="headerlink" title="线程切换是否会切换CR3"></a>线程切换是否会切换CR3</h3><p>如果新旧线程属于同一个进程，就不换 cr3,；否则就要换。</p>
<p>判断是否属于同一进程的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [edi+_ETHREAD.Tcb.ApcState.Process] ;</span><br><span class="line">                        ; 通常情况下，ApcState.Process 和 _ETHREAD.ThreadsProcess 是同一个</span><br><span class="line">                        ; 但是当A进程调用API访问B进程的内存时，ApcState.Process 存的就是B进程</span><br><span class="line">cmp     eax, [esi+_ETHREAD.Tcb.ApcState.Process]</span><br><span class="line">mov     [edi+_ETHREAD.Tcb.IdleSwapBlock], 0</span><br><span class="line">jz      short loc_46A994 ; 如果是同一个进程内的线程切换，就跳转</span><br><span class="line">                        ;</span><br><span class="line">                        ; 如果不是同一个进程的，那么就要做额外的工作，主要就是切换CR3</span><br></pre></td></tr></table></figure>

<p>切换 cr3 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">loc_46A975:             ; 修改 LDT 寄存器</span><br><span class="line">lldt    ax</span><br><span class="line">xor     eax, eax</span><br><span class="line">mov     gs, eax         ; gs 寄存器清零</span><br><span class="line">                        ; 这就是 Windows 不使用 gs 的依据</span><br><span class="line">assume gs:GAP</span><br><span class="line">mov     eax, [edi+_EPROCESS.Pcb.DirectoryTableBase]</span><br><span class="line">mov     ebp, [ebx+_KPCR.TSS]</span><br><span class="line">mov     ecx, dword ptr [edi+_EPROCESS.Pcb.IopmOffset]</span><br><span class="line">mov     [ebp+TSS.CR3], eax</span><br><span class="line">mov     cr3, eax        ; 关键步骤：切换 cr3</span><br><span class="line">mov     [ebp+TSS.IOMap], cx</span><br><span class="line">jmp     short loc_46A994</span><br></pre></td></tr></table></figure>

<h3 id="SwapContext全部分析"><a href="#SwapContext全部分析" class="headerlink" title="SwapContext全部分析"></a>SwapContext全部分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">.text:0046A8E0 ; 参数有4个，均通过寄存器保存</span><br><span class="line">.text:0046A8E0 ; ebx: _KPCR</span><br><span class="line">.text:0046A8E0 ; esi: 新线程 _ETHREAD</span><br><span class="line">.text:0046A8E0 ; edi: 旧线程 _ETHREAD</span><br><span class="line">.text:0046A8E0 ; cl: 旧线程的 WaitIrql，貌似用不到，直接覆盖了</span><br><span class="line">.text:0046A8E0</span><br><span class="line">.text:0046A8E0 SwapContext     proc near               ; CODE XREF: KiUnlockDispatcherDatabase(x)+72↑p</span><br><span class="line">.text:0046A8E0                                         ; KiSwapContext(x)+29↑p ...</span><br><span class="line">.text:0046A8E0                 or      cl, cl</span><br><span class="line">.text:0046A8E2                 mov     es:[esi+_ETHREAD.Tcb.State], 2 ; 修改新线程状态为 2</span><br><span class="line">.text:0046A8E2                                         ; 1 就绪</span><br><span class="line">.text:0046A8E2                                         ; 2 运行</span><br><span class="line">.text:0046A8E2                                         ; 5 等待</span><br><span class="line">.text:0046A8E7                 pushf</span><br><span class="line">.text:0046A8E8</span><br><span class="line">.text:0046A8E8 loc_46A8E8:                             ; CODE XREF: KiIdleLoop()+5A↓j</span><br><span class="line">.text:0046A8E8                 mov     ecx, [ebx+_KPCR.NtTib.ExceptionList] ;</span><br><span class="line">.text:0046A8E8                                         ; 保存本线程切换时的内核seh链表</span><br><span class="line">.text:0046A8EA                 cmp     [ebx+_KPCR.PrcbData.DpcRoutineActive], 0 ; 是否有DPC，有就蓝屏</span><br><span class="line">.text:0046A8F1                 push    ecx</span><br><span class="line">.text:0046A8F2                 jnz     loc_46AA2D</span><br><span class="line">.text:0046A8F8                 cmp     ds:_PPerfGlobalGroupMask, 0</span><br><span class="line">.text:0046A8FF                 jnz     loc_46AA04</span><br><span class="line">.text:0046A905</span><br><span class="line">.text:0046A905 loc_46A905:                             ; CODE XREF: SwapContext+12C↓j</span><br><span class="line">.text:0046A905                                         ; SwapContext+13D↓j ...</span><br><span class="line">.text:0046A905                 mov     ebp, cr0        ; cr0 控制寄存器可以判断当前环境是实模式还是保护模式，是否开启分页模式，写保护</span><br><span class="line">.text:0046A908                 mov     edx, ebp        ; edx = ebp = cr0</span><br><span class="line">.text:0046A90A                 mov     cl, [esi+_ETHREAD.Tcb.DebugActive]</span><br><span class="line">.text:0046A90D                 mov     [ebx+_KPCR.DebugActive], cl ; 更新 _KPCR 中当前线程的调试状态位，此时存的是新线程的值</span><br><span class="line">.text:0046A910                 cli                     ; 屏蔽时钟中断</span><br><span class="line">.text:0046A911                 mov     [edi+_ETHREAD.Tcb.KernelStack], esp</span><br><span class="line">.text:0046A914                 mov     eax, [esi+_ETHREAD.Tcb.InitialStack]</span><br><span class="line">.text:0046A917                 mov     ecx, [esi+_ETHREAD.Tcb.StackLimit]</span><br><span class="line">.text:0046A91A                 sub     eax, 210h       ; 线程堆栈的前 0x210 字节是浮点寄存器</span><br><span class="line">.text:0046A91A                                         ; 此时 eax 指向 _KTRAP_FRAME.V86Gs</span><br><span class="line">.text:0046A91F                 mov     [ebx+_KPCR.NtTib.StackLimit], ecx</span><br><span class="line">.text:0046A922                 mov     [ebx+_KPCR.NtTib.StackBase], eax</span><br><span class="line">.text:0046A925                 xor     ecx, ecx</span><br><span class="line">.text:0046A927                 mov     cl, [esi+_ETHREAD.Tcb.NpxState]</span><br><span class="line">.text:0046A92A                 and     edx, 0FFFFFFF1h ; 判断 NpxState 是否支持浮点</span><br><span class="line">.text:0046A92A                                         ;</span><br><span class="line">.text:0046A92A                                         ; 根据判断结果决定是否更新 cr0</span><br><span class="line">.text:0046A92D                 or      ecx, edx</span><br><span class="line">.text:0046A92F                 or      ecx, [eax+20Ch]</span><br><span class="line">.text:0046A935                 cmp     ebp, ecx</span><br><span class="line">.text:0046A937                 jnz     loc_46A9FC</span><br><span class="line">.text:0046A93D                 lea     ecx, [ecx+0]</span><br><span class="line">.text:0046A940</span><br><span class="line">.text:0046A940 loc_46A940:                             ; CODE XREF: SwapContext+11F↓j</span><br><span class="line">.text:0046A940                 test    dword ptr [eax-1Ch], 20000h ; SegCs &amp; 20000h</span><br><span class="line">.text:0046A940                                         ; 判断是否是虚拟8086模式，如果不是，直接减掉</span><br><span class="line">.text:0046A940                                         ;    +0x07c V86Es            : Uint4B</span><br><span class="line">.text:0046A940                                         ;    +0x080 V86Ds            : Uint4B</span><br><span class="line">.text:0046A940                                         ;    +0x084 V86Fs            : Uint4B</span><br><span class="line">.text:0046A940                                         ;    +0x088 V86Gs            : Uint4B</span><br><span class="line">.text:0046A940                                         ;</span><br><span class="line">.text:0046A940                                         ; 如果是，那么就不减</span><br><span class="line">.text:0046A940                                         ;</span><br><span class="line">.text:0046A940                                         ; 这样做了之后，eax 就指向了0环栈顶，接下来就会存储到 TSS 里</span><br><span class="line">.text:0046A940                                         ; 以后这个线程进0环，不论是中断门还是快速调用，都会从 TSS 里获取 ESP0</span><br><span class="line">.text:0046A947                 jnz     short loc_46A94C</span><br><span class="line">.text:0046A949                 sub     eax, 10h</span><br><span class="line">.text:0046A94C</span><br><span class="line">.text:0046A94C loc_46A94C:                             ; CODE XREF: SwapContext+67↑j</span><br><span class="line">.text:0046A94C                 mov     ecx, [ebx+_KPCR.TSS] ;</span><br><span class="line">.text:0046A94C                                         ; ecx 指向 TSS</span><br><span class="line">.text:0046A94C                                         ; TSS 的用途是3环进0环时，要从 TSS 取 SS0 和 ESP0</span><br><span class="line">.text:0046A94F                 mov     [ecx+TSS.ESP0], eax ; 更新 TSS 中存储的0环栈顶 ESP0</span><br><span class="line">.text:0046A952                 mov     esp, [esi+_ETHREAD.Tcb.KernelStack] ; 此处是切换线程，切换线程本质是切换堆栈</span><br><span class="line">.text:0046A952                                         ; 将 esp 修改为新线程的栈顶，然后就可以从堆栈里取数据恢复现场了</span><br><span class="line">.text:0046A955                 mov     eax, [esi+_ETHREAD.Tcb.Teb]</span><br><span class="line">.text:0046A958                 mov     [ebx+_KPCR.NtTib.Self], eax ; 暂时存储 TEB 到 ffdff000</span><br><span class="line">.text:0046A95B                 sti</span><br><span class="line">.text:0046A95C                 mov     eax, [edi+_ETHREAD.Tcb.ApcState.Process]</span><br><span class="line">.text:0046A95F                 cmp     eax, [esi+_ETHREAD.Tcb.ApcState.Process]</span><br><span class="line">.text:0046A962                 mov     [edi+_ETHREAD.Tcb.IdleSwapBlock], 0</span><br><span class="line">.text:0046A966                 jz      short loc_46A994 ; 如果是同一个进程内的线程切换，就跳转</span><br><span class="line">.text:0046A966                                         ;</span><br><span class="line">.text:0046A966                                         ; 如果不是同一个进程的，那么就要做额外的工作，主要就是切换CR3</span><br><span class="line">.text:0046A968                 mov     edi, [esi+_ETHREAD.Tcb.ApcState.Process] ; edi: 新线程所属进程</span><br><span class="line">.text:0046A96B                 test    [edi+_EPROCESS.Pcb.LdtDescriptor.LimitLow], 0FFFFh ; 判断 LDT</span><br><span class="line">.text:0046A971                 jnz     short loc_46A9CE</span><br><span class="line">.text:0046A973                 xor     eax, eax</span><br><span class="line">.text:0046A975</span><br><span class="line">.text:0046A975 loc_46A975:                             ; CODE XREF: SwapContext+117↓j</span><br><span class="line">.text:0046A975                 lldt    ax              ; 修改 LDT 寄存器</span><br><span class="line">.text:0046A978                 xor     eax, eax</span><br><span class="line">.text:0046A97A                 mov     gs, eax         ; gs 寄存器清零</span><br><span class="line">.text:0046A97A                                         ; 这就是 Windows 不使用 gs 的依据</span><br><span class="line">.text:0046A97C                 assume gs:GAP</span><br><span class="line">.text:0046A97C                 mov     eax, [edi+_EPROCESS.Pcb.DirectoryTableBase]</span><br><span class="line">.text:0046A97F                 mov     ebp, [ebx+_KPCR.TSS]</span><br><span class="line">.text:0046A982                 mov     ecx, dword ptr [edi+_EPROCESS.Pcb.IopmOffset]</span><br><span class="line">.text:0046A985                 mov     [ebp+TSS.CR3], eax</span><br><span class="line">.text:0046A988                 mov     cr3, eax        ; 关键步骤：切换 cr3</span><br><span class="line">.text:0046A98B                 mov     [ebp+TSS.IOMap], cx</span><br><span class="line">.text:0046A98F                 jmp     short loc_46A994</span><br><span class="line">.text:0046A98F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0046A991                 align 4</span><br><span class="line">.text:0046A994</span><br><span class="line">.text:0046A994 loc_46A994:                             ; CODE XREF: SwapContext+86↑j</span><br><span class="line">.text:0046A994                                         ; SwapContext+AF↑j</span><br><span class="line">.text:0046A994                 mov     eax, [ebx+_KPCR.NtTib.Self] ;</span><br><span class="line">.text:0046A994                                         ; 此时 eax 指向了 TEB</span><br><span class="line">.text:0046A997                 mov     ecx, [ebx+_KPCR.GDT] ; 假设 GDT表在 0x8003f000</span><br><span class="line">.text:0046A997                                         ; ecx = 0x8003f000</span><br><span class="line">.text:0046A997                                         ; 3环 FS = 0x3B</span><br><span class="line">.text:0046A997                                         ; 所以 FS 在 GDT表里的地址是 0x8003f03B</span><br><span class="line">.text:0046A997                                         ; 下面的操作是修改 FS 的段描述符，这样3环 FS 就能找到 TEB 了</span><br><span class="line">.text:0046A997                                         ; ;</span><br><span class="line">.text:0046A99A                 mov     [ecx+3Ah], ax   ; BaseAddress 15:00</span><br><span class="line">.text:0046A99E                 shr     eax, 10h        ; eax 指向 TEB 的地址高16位</span><br><span class="line">.text:0046A9A1                 mov     [ecx+3Ch], al   ; BaseAddress 23:16</span><br><span class="line">.text:0046A9A4                 mov     [ecx+3Fh], ah   ; BaseAddress 31:24</span><br><span class="line">.text:0046A9A7                 inc     [esi+_ETHREAD.Tcb.ContextSwitches]</span><br><span class="line">.text:0046A9AA                 inc     [ebx+_KPCR.PrcbData.KeContextSwitches]</span><br><span class="line">.text:0046A9B0                 pop     ecx</span><br><span class="line">.text:0046A9B1                 mov     [ebx], ecx</span><br><span class="line">.text:0046A9B3                 cmp     [esi+_ETHREAD.Tcb.ApcState.KernelApcPending], 0</span><br><span class="line">.text:0046A9B7                 jnz     short loc_46A9BD</span><br><span class="line">.text:0046A9B9                 popf</span><br><span class="line">.text:0046A9BA                 xor     eax, eax</span><br><span class="line">.text:0046A9BC                 retn</span><br></pre></td></tr></table></figure>

<h1 id="007-Windows线程切换-时钟中断切换"><a href="#007-Windows线程切换-时钟中断切换" class="headerlink" title="007.Windows线程切换_时钟中断切换"></a>007.Windows线程切换_时钟中断切换</h1><p>如何中断一个正在执行的程序?</p>
<ol>
<li>异常：比如缺页，或者INT N指令</li>
<li>中断：比如时钟中断</li>
</ol>
<p>Windows系统每隔10-20毫秒会触发一次时钟中断，可以调用 <code>GetSystemTimeAdjustment</code> 函数获取准确数值</p>
<p>时钟中断的中断号是0x30，中断请求级别IRQL是0，我们可以在IDT表里找到时钟中断处理函数 <code>KiStartUnexpectedRange</code> 。</p>
<p>时钟中断执行流程：</p>
<ol>
<li><code>KiStartUnexpectedRange</code></li>
<li><code>KiEndUnexpectedRange</code></li>
<li><code>KiUnexpectedInterruptTail</code></li>
<li><code>HalBeginSystemInterrupt</code></li>
<li><code>HalEndSystemInterrupt</code></li>
<li><code>KiDispatchInterrupt</code>：<code>KiDispatchInterrupt</code>会根据当前线程剩余时间片和备用线程的情况来决定下一步的调用</li>
<li><code>SwapContext</code></li>
</ol>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>线程切换的几种情况：</p>
<ol>
<li>主动调用API函数</li>
<li>时钟中断</li>
<li> 异常处理</li>
</ol>
<h1 id="008-Windows线程切换-时间片管理"><a href="#008-Windows线程切换-时间片管理" class="headerlink" title="008.Windows线程切换_时间片管理"></a>008.Windows线程切换_时间片管理</h1><p>时钟中断不一定会切换线程。</p>
<p>时钟中断时，两种情况会导致线程切换：    </p>
<p>1、当前的线程CPU时间片到期</p>
<p>2、有备用线程(<code>KPCR.PrcbData.NextThread</code>)</p>
<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><ol>
<li>当一个新的线程开始执行时，初始化程序会在<code>_KTHREAD.Quantum</code>赋初始值，该值的大小由<code>_KPROCESS.ThreadQuantum</code>决定(观察<code>ThreadQuantum</code>大小，默认是6)</li>
<li>每次时钟中断会调用<code>KeUpdateRunTime</code>函数，该函数每次将当前线程<code>Quantum</code>减少3个单位，如果减到0，则将<code>KPCR.PrcbData.QuantumEnd</code>的值设置为非0。</li>
<li><code>KiDispatchInterrupt</code>判断时间片到期：调用<code>KiQuantumEnd</code>(重新设置时间片、找到要运行的线程) </li>
</ol>
<h3 id="KeUpdateRunTime"><a href="#KeUpdateRunTime" class="headerlink" title="KeUpdateRunTime"></a>KeUpdateRunTime</h3><p>每次时钟中断会调用<code>KeUpdateRunTime</code>函数，该函数每次将当前线程<code>Quantum</code>减少3个单位，如果减到0，则将<code>KPCR.PrcbData.QuantumEnd</code>的值设置为非0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0046A1B8                 sub     [ebx+_KTHREAD.Quantum], 3 ; 时间片 -3</span><br><span class="line">.text:0046A1BC                 jg      short loc_46A1D7</span><br><span class="line">.text:0046A1BE                 cmp     ebx, [eax+_KPCR.PrcbData.IdleThread]</span><br><span class="line">.text:0046A1C4                 jz      short loc_46A1D7</span><br><span class="line">.text:0046A1C6                 mov     [eax+_KPCR.PrcbData.QuantumEnd], esp</span><br></pre></td></tr></table></figure>

<p>一个线程初始状态有6个时间片，每次中断会把当前线程时间片减3，这意味着一个线程要经过两次时钟中断时间片才会用完。</p>
<h3 id="KiDispatchInterrupt"><a href="#KiDispatchInterrupt" class="headerlink" title="KiDispatchInterrupt"></a>KiDispatchInterrupt</h3><p><code>KiDispatchInterrupt</code> 函数会判断当前线程时间片，如果 <code>QuantumEnd</code> 是非0，表明时间片用完，然后就会调用 <code>KiQuantumEnd</code> 函数重新设置时间片，然后执行线程切换；如果时间片没用完，但是存在备用线程 <code>NextThread</code>，那么也会发生切换：</p>
<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230218163344642.png" alt="image-20230218163344642"></p>
<h3 id="KiQuantumEnd"><a href="#KiQuantumEnd" class="headerlink" title="KiQuantumEnd"></a>KiQuantumEnd</h3><p><code>KiQuantumEnd</code> 函数主要工作就是重新设置时间片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     al, [eax+_EPROCESS.Pcb.ThreadQuantum]</span><br><span class="line">mov     [esi+_ETHREAD.Tcb.Quantum], al ; 重新设置一下当前线程的时间片</span><br></pre></td></tr></table></figure>

<p>之后调用 <code>KiFindReadyThread</code> 找新的就绪线程作为函数返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movzx   ecx, [esi+_ETHREAD.Tcb.NextProcessor]</span><br><span class="line">call    @KiFindReadyThread@8 ; KiFindReadyThread(x,x)</span><br><span class="line">cmp     eax, ebx</span><br><span class="line">jz      short loc_428C4B</span><br></pre></td></tr></table></figure>

<h3 id="KiReadyThread"><a href="#KiReadyThread" class="headerlink" title="KiReadyThread"></a>KiReadyThread</h3><p>作用是把旧线程 ETHREAD（ecx 传参）添加到就绪链表里，关键代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:00429A40 loc_429A40:                             ; CODE XREF: KiReadyThread(x)+5E↑j</span><br><span class="line">.text:00429A40                                         ; KiReadyThread(x)+12A↑j</span><br><span class="line">.text:00429A40                 mov     [eax+_ETHREAD.Tcb.State], 1 ; 就绪状态</span><br><span class="line">.text:00429A44                 add     eax, 60h        ; ETHREAD + 0x60 是一个链表, WaitListEntry / SwapListEntry</span><br><span class="line">.text:00429A47                 test    bl, bl</span><br><span class="line">.text:00429A49                 lea     edx, _KiDispatcherReadyListHead[ecx*8] ; edx 指向对应优先级的链表头</span><br><span class="line">.text:00429A50                 jz      short loc_429A60</span><br><span class="line">.text:00429A52                 mov     esi, [edx]      ; 下一个线程.FLink</span><br><span class="line">.text:00429A54                 mov     [eax], esi      ; ETHREAD.WaitListEntry.FLink 指向下一个线程</span><br><span class="line">.text:00429A56                 mov     [eax+4], edx    ; ETHREAD.WaitListEntry.BLink 指向链表头</span><br><span class="line">.text:00429A59                 mov     [esi+4], eax    ; 下一个线程.BLink 指向 ETHREAD.WaitListEntry</span><br><span class="line">.text:00429A5C                 mov     [edx], eax      ; 链表头.FLink = ETHREAD.WaitListEntry</span><br><span class="line">.text:00429A5E                 jmp     short loc_429A6D</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>线程切换的三种情况：</p>
<p>(1)、当前线程主动调用API：</p>
<p>API函数 -&gt; <code>KiSwapThread</code> -&gt; <code>KiSwapContext</code> -&gt; <strong><code>SwapContext</code></strong></p>
<p>(2)、当前线程时间片到期：</p>
<p><code>KiDispatchInterrupt</code> -&gt; <code>KiQuantumEnd</code> -&gt; <strong><code>SwapContext</code></strong></p>
<p>(3)、有备用线程(<code>KPCR.PrcbData.NextThread</code>)</p>
<p><code>KiDispatchInterrupt</code> -&gt; <strong><code>SwapContext</code></strong></p>
<h1 id="009-Windows线程切换-TSS"><a href="#009-Windows线程切换-TSS" class="headerlink" title="009.Windows线程切换_TSS"></a>009.Windows线程切换_TSS</h1><p>内核堆栈：</p>
<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230218165731076.png" alt="image-20230218165731076"></p>
<p>内核堆栈结构：</p>
<p>(栈底开始往上0x210个字节存储浮点寄存器的值，以上都是<code>TrapFrame</code>结构（在api3环进0环已经讲过了，<code>系统调用</code>那一节）。)</p>
<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230218165835614.png" alt="image-20230218165835614"></p>
<p> <strong>调用API进0环</strong></p>
<p>普通调用：通过<code>TSS.ESP0</code>得到0环堆栈</p>
<p>快速调用：从MSR得到一个临时0环栈，代码执行后仍然通过<code>TSS.esp0</code>得到当前线程0环堆栈。</p>
<p><code>KiFastCallEntry</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:0040689F                 mov     ecx, 23h</span><br><span class="line">.text:004068A4                 push    30h</span><br><span class="line">.text:004068A6                 pop     fs</span><br><span class="line">.text:004068A8                 mov     ds, ecx</span><br><span class="line">.text:004068AA                 mov     es, ecx</span><br><span class="line">.text:004068AC                 mov     ecx, large fs:40h ; KPCR.tss</span><br><span class="line">.text:004068B3                 mov     esp, [ecx+4]    ; tss.esp0</span><br><span class="line">.text:004068B6                 push    23h</span><br><span class="line">.text:004068B8                 push    edx</span><br><span class="line">.text:004068B9                 pushf</span><br></pre></td></tr></table></figure>

<h2 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h2><p> Intel设计TSS的目的是为了任务切换(线程切换)，但Windows与Linux并没有使用。而是采用堆栈来保存线程的各种寄存器。</p>
<p>一个CPU只有一个TSS，但是线程很多，如何用一个TSS来保存所有线程的ESP0呢?</p>
<p>swapContext部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, [esi+_ETHREAD.Tcb.InitialStack]</span><br><span class="line">sub     eax, 210h       ; 线程堆栈的前 0x210 字节是浮点寄存器</span><br><span class="line">                        ; 此时 eax 指向 _KTRAP_FRAME.V86Gs</span><br><span class="line">sub     eax, 10h;虚拟8086模式下使用 TrapFrame结构</span><br><span class="line">之后是：</span><br><span class="line"></span><br><span class="line">.text:0046A94C loc_46A94C:                             ; CODE XREF: SwapContext+67↑j</span><br><span class="line">.text:0046A94C                 mov     ecx, [ebx+_KPCR.TSS] ;</span><br><span class="line">.text:0046A94C                                         ; ecx 指向 TSS</span><br><span class="line">.text:0046A94C                                         ; TSS 的用途是3环进0环时，要从 TSS 取 SS0 和 ESP0</span><br><span class="line">.text:0046A94F                 mov     [ecx+TSS.ESP0], eax ; 更新 TSS 中存储的0环栈顶 ESP0</span><br><span class="line">.text:0046A952                 mov     esp, [esi+_ETHREAD.Tcb.KernelStack] ; 此处是切换线程，切换线程本质是切换堆栈</span><br><span class="line">.text:0046A952                                         ; 将 esp 修改为新线程的栈顶，然后就可以从堆栈里取数据恢复现场了</span><br><span class="line">.text:0046A955                 mov     eax, [esi+_ETHREAD.Tcb.Teb]</span><br><span class="line">.text:0046A958                 mov     [ebx+_KPCR.NtTib.Self], eax ; 暂时存储 TEB 到 ffdff000</span><br><span class="line">.text:0046A95B                 sti</span><br><span class="line">.text:0046A95C                 mov     eax, [edi+_ETHREAD.Tcb.ApcState.Process]</span><br><span class="line">.text:0046A95F                 cmp     eax, [esi+_ETHREAD.Tcb.ApcState.Process]</span><br><span class="line">.text:0046A962                 mov     [edi+_ETHREAD.Tcb.IdleSwapBlock], 0</span><br><span class="line">.text:0046A966                 jz      short loc_46A994 ; 如果是同一个进程内的线程切换，就跳转</span><br><span class="line">.text:0046A966                                         ;</span><br><span class="line">.text:0046A966                                         ; 如果不是同一个进程的，那么就要做额外的工作，主要就是切换CR3</span><br><span class="line">.text:0046A968                 mov     edi, [esi+_ETHREAD.Tcb.ApcState.Process] ; edi: 新线程所属进程</span><br><span class="line">.text:0046A96B                 test    [edi+_EPROCESS.Pcb.LdtDescriptor.LimitLow], 0FFFFh ; 判断 LDT</span><br><span class="line">.text:0046A971                 jnz     short loc_46A9CE</span><br><span class="line">.text:0046A973                 xor     eax, eax</span><br><span class="line">.text:0046A975</span><br><span class="line">.text:0046A975 loc_46A975:                             ; CODE XREF: SwapContext+117↓j</span><br><span class="line">.text:0046A975                 lldt    ax              ; 修改 LDT 寄存器</span><br><span class="line">.text:0046A978                 xor     eax, eax</span><br><span class="line">.text:0046A97A                 mov     gs, eax         ; gs 寄存器清零</span><br><span class="line">.text:0046A97A                                         ; 这就是 Windows 不使用 gs 的依据</span><br><span class="line">.text:0046A97C                 assume gs:GAP</span><br><span class="line">.text:0046A97C                 mov     eax, [edi+_EPROCESS.Pcb.DirectoryTableBase]</span><br><span class="line">.text:0046A97F                 mov     ebp, [ebx+_KPCR.TSS]</span><br><span class="line">.text:0046A982                 mov     ecx, dword ptr [edi+_EPROCESS.Pcb.IopmOffset]</span><br><span class="line">.text:0046A985                 mov     [ebp+TSS.CR3], eax;将当前TSS中的CR3修改为目标进程的CR3</span><br><span class="line">.text:0046A988                 mov     cr3, eax        ; 关键步骤：切换 cr3</span><br><span class="line">.text:0046A98B                 mov     [ebp+TSS.IOMap], cx;存储IO权限位图到TSS 当前线程的IO权限位图 Windows2000以后不用了</span><br><span class="line">.text:0046A98F                 jmp     short loc_46A994</span><br></pre></td></tr></table></figure>



<h1 id="010-Windows线程切换-FS"><a href="#010-Windows线程切换-FS" class="headerlink" title="010.Windows线程切换_FS"></a>010.Windows线程切换_FS</h1><p><code>FS:[0]</code>寄存器在3环时指向TEB，进入0环后<code>FS:[0]</code>指向KPCR</p>
<p>系统中同时存在很多个线程，这就意味着<code>FS:[0]</code>在3环时指向的TEB要有多个(每个线程一份)。</p>
<p><strong>思考</strong>：在实际的使用中我们发现，当我们在3环查看不同线程的FS寄存器时，FS的段选择子都是相同的，那么<strong>如何实现通过一个FS寄存器指向多个TEB</strong>？(线程切换的时候把基址给改了)</p>
<p>还是<code>SwapContext</code>的部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0046A994 loc_46A994:                             ; CODE XREF: SwapContext+86↑j</span><br><span class="line">.text:0046A994                                         ; SwapContext+AF↑j</span><br><span class="line">.text:0046A994                 mov     eax, [ebx+_KPCR.NtTib.Self] ;</span><br><span class="line">.text:0046A994                                         ; 此时 eax 指向了 TEB</span><br><span class="line">.text:0046A997                 mov     ecx, [ebx+_KPCR.GDT] ; 假设 GDT表在 0x8003f000</span><br><span class="line">.text:0046A997                                         ; ecx = 0x8003f000</span><br><span class="line">.text:0046A997                                         ; 3环 FS = 0x3B</span><br><span class="line">.text:0046A997                                         ; 所以 FS 在 GDT表里的地址是 0x8003f03B</span><br><span class="line">.text:0046A997                                         ; 下面的操作是修改 FS 的段描述符，这样3环 FS 就能找到 TEB 了</span><br><span class="line">.text:0046A997                                         ; ;</span><br><span class="line">.text:0046A99A                 mov     [ecx+3Ah], ax   ; BaseAddress 15:00</span><br><span class="line">.text:0046A99E                 shr     eax, 10h        ; eax 指向 TEB 的地址高16位</span><br><span class="line">.text:0046A9A1                 mov     [ecx+3Ch], al   ; BaseAddress 23:16</span><br><span class="line">.text:0046A9A4                 mov     [ecx+3Fh], ah   ; BaseAddress 31:24</span><br><span class="line">.text:0046A9A7                 inc     [esi+_ETHREAD.Tcb.ContextSwitches]</span><br><span class="line">.text:0046A9AA                 inc     [ebx+_KPCR.PrcbData.KeContextSwitches]</span><br><span class="line">.text:0046A9B0                 pop     ecx</span><br><span class="line">.text:0046A9B1                 mov     [ebx], ecx</span><br><span class="line">.text:0046A9B3                 cmp     [esi+_ETHREAD.Tcb.ApcState.KernelApcPending], 0</span><br><span class="line">.text:0046A9B7                 jnz     short loc_46A9BD</span><br><span class="line">.text:0046A9B9                 popf</span><br><span class="line">.text:0046A9BA                 xor     eax, eax</span><br><span class="line">.text:0046A9BC                 retn</span><br></pre></td></tr></table></figure>

<h3 id="段描述符结构"><a href="#段描述符结构" class="headerlink" title="段描述符结构"></a>段描述符结构</h3><p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230218174027106.png" alt="image-20230218174027106"></p>
<h1 id="011-Windows线程切换-线程优先级"><a href="#011-Windows线程切换-线程优先级" class="headerlink" title="011.Windows线程切换_线程优先级"></a>011.Windows线程切换_线程优先级</h1><p>回顾：</p>
<p>三种情况会导致线程切换：</p>
<ol>
<li><p>当前线程主动调用API：</p>
<p><code>KiSwapThread</code> -&gt; <code>KiSwapContext</code> -&gt; <code>SwapContext</code></p>
</li>
<li><p>当前线程时间片到期：</p>
<p><code>KiDispatchInterrupt</code> -&gt; <code>KiQuantumEnd</code> -&gt; <code>SwapContext</code></p>
</li>
<li><p>存在备用线程（<code>KPCR.PrcbData.NextThread</code>）</p>
<p><code>KiDispatchInterrupt</code> -&gt; <code>SwapContext</code></p>
</li>
</ol>
<p><strong>思考</strong>：在<strong>KiSwapThread与KiQuantumEnd</strong>函数中都是通过<strong>KiFindReadyThread</strong>来找下一个要切换的线程，<strong>KiFindReadyThread</strong>是根据什么条件来选择下一个要执行的线程呢?</p>
<h2 id="调度链表-1"><a href="#调度链表-1" class="headerlink" title="调度链表"></a>调度链表</h2><p><strong>描述</strong>：</p>
<ol>
<li>在<strong>Windows 32位</strong>操作系统中，共有<strong>32</strong>个双向链表（调度链表）</li>
<li>在<strong>Windows 64位</strong>操作系统中，共有<strong>64</strong>个双向链表（调度链表）</li>
<li>线程在调度链表的中下标表示<strong>线程优先级</strong>（0~31/64）</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; <span class="built_in">dd</span> KiDispatcherReadyListHead L70</span><br><span class="line">8055df80  8055df80 8055df80 8055df88 8055df88</span><br><span class="line">8055df90  8055df90 8055df90 8055df98 8055df98</span><br><span class="line">8055dfa0  8055dfa0 8055dfa0 8055dfa8 8055dfa8</span><br><span class="line">8055dfb0  8055dfb0 8055dfb0 8055dfb8 8055dfb8</span><br><span class="line">8055dfc0  8055dfc0 8055dfc0 8055dfc8 8055dfc8</span><br><span class="line">8055dfd0  8055dfd0 8055dfd0 8055dfd8 8055dfd8</span><br><span class="line">8055dfe0  8055dfe0 8055dfe0 8055dfe8 8055dfe8</span><br><span class="line">8055dff0  8055dff0 8055dff0 8055dff8 8055dff8</span><br><span class="line">8055e000  8055e000 8055e000 8055e008 8055e008</span><br><span class="line">8055e010  8055e010 8055e010 8055e018 8055e018</span><br><span class="line">8055e020  8055e020 8055e020 8055e028 8055e028</span><br><span class="line">8055e030  8055e030 8055e030 8055e038 8055e038</span><br><span class="line">8055e040  8055e040 8055e040 8055e048 8055e048</span><br><span class="line">8055e050  8055e050 8055e050 8055e058 8055e058</span><br><span class="line">8055e060  8055e060 8055e060 8055e068 8055e068</span><br><span class="line">8055e070  8055e070 8055e070 8055e078 8055e078</span><br></pre></td></tr></table></figure>

<p><code>KiFindReadyThread</code>查找方式：</p>
<blockquote>
<p><strong>按照优先级别进行查找</strong>：31…30…29…28…<br>也就是说，在本次查找中，如果级别31的链表里面有线程，那么就不会查找级别为30的链表</p>
</blockquote>
<p>注意：</p>
<ol>
<li><p>Windows 32位操作系统中调度链表有32个，由于每次都从头开始查找效率太低，所以Windows通过一个DWORD类型的变量来记录：<code>_KiReadySummary</code></p>
</li>
<li><p>当向调度链表(32个)中挂入或者摘除某个线程时，会判断当前级别的链表是否为空，为空则将 <code>_KiReadySummary</code> 对应位置0，否则置1</p>
</li>
<li><p>若当前级别链表的链表头和链表尾的值相同，并且等于它们的地址，说明不存在等待调度的线程</p>
<p>若当前级别链表的链表头和链表尾的值相同，但不等于它们的地址，说明存在一个等待调度的线程</p>
</li>
<li><p>多cpu会随机寻找 KiDispatcherReadyListHead 指向的数组中的线程。线程可以绑定某个cpu（API：setThreadAffinityMask）</p>
</li>
<li><p>若当前CPU不存在就绪线程，则会执行空闲线程，每一个CPU都会指定一个空闲线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nt!_KPRCB</span><br><span class="line">   +0x004 CurrentThread    : Ptr32 _KTHREAD		//当前线程</span><br><span class="line">   +0x008 NextThread       : Ptr32 _KTHREAD		//就绪线程</span><br><span class="line">   +0x00c IdleThread       : Ptr32 _KTHREAD		//空闲线程</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="KiSwapThread"><a href="#KiSwapThread" class="headerlink" title="KiSwapThread"></a>KiSwapThread</h2><p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230218205639146.png" alt="image-20230218205639146"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol>
<li>调度链表的下标即线程优先级</li>
<li>CPU通过遍历调度链表判断是否存在需要调度的线程</li>
<li>若不存在需要调度的线程，则会执行空闲线程（<strong>_KPRCB.IdleThread</strong>）</li>
</ol>
<h1 id="012-进程挂靠"><a href="#012-进程挂靠" class="headerlink" title="012.进程挂靠"></a>012.进程挂靠</h1><h2 id="进程线程关系"><a href="#进程线程关系" class="headerlink" title="进程线程关系"></a>进程线程关系</h2><p>进程为线程提供资源，也就是提供Cr3的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>来看这样一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>

<p>CPU如何解析0x12345678这个地址呢？</p>
<ol>
<li>CPU解析线性地址时，需要通过<strong>页目录表（PDT）</strong>来找到对应的物理页，页目录表基址存在Cr3寄存器中</li>
<li>当前的Cr3的值来源于当前的进程(<strong>_KPROCESS.DirectoryTableBase(+0x018)</strong>)</li>
</ol>
<h3 id="线程找进程"><a href="#线程找进程" class="headerlink" title="线程找进程"></a>线程找进程</h3><p>线程找进程有两种情况：</p>
<ol>
<li><strong>KHTREAD.ApcState.Process</strong>(+0x44)：<strong>资源提供者</strong>（养父母），为这个线程提供资源（也就提供Cr3）</li>
<li><strong>ETHREAD.ThreadProcess</strong>(+0x220)：<strong>线程创建者</strong>（亲生父母）</li>
<li>一般情况下，<strong>_ETHREAD.Tcb.ApcState.Process</strong>和 <strong>_ETHREAD.ThreadsProcess</strong> 指向的是同一个进程</li>
<li>将当前Cr3的值改为其它进程的Cr3(进程切换)，称为“<strong>进程挂靠</strong>”</li>
</ol>
<p><img src="/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-20230219125142968.png" alt="image-20230219125142968"></p>
<p>有了上述概念后，我们知道了，正常情况下，Cr3的值是由养父母提供的，但是Cr3的值也可以改成和当前线程毫不相干的其它进程的<code>DirectoryTableBase</code>。</p>
<p>观察下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov cr3,A.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//A进程的0x12345678内存</span><br><span class="line">mov cr3,B.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//B进程的0x12345678内存</span><br><span class="line">mov cr3,C.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//C进程的0x12345678内存</span><br></pre></td></tr></table></figure>

<p>有了进程挂靠，就意味着可以读取其它进程的内存。</p>
<h2 id="分析NtReadVirtualMemory"><a href="#分析NtReadVirtualMemory" class="headerlink" title="分析NtReadVirtualMemory"></a>分析NtReadVirtualMemory</h2><p><code>ReadProcessMemory</code>这个三环API是可以读取其它进程的内存的，该函数在0环的实现是<code>NtReadVirtualMemory</code></p>
<p><code>NtReadVirtualMemory</code>：读取某一个进程的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NtReadVirtualMemory =&gt;</span><br><span class="line"></span><br><span class="line">KiAttachProcess =&gt;</span><br><span class="line"></span><br><span class="line">修改养父母 =&gt;</span><br><span class="line"></span><br><span class="line">修改Cr3 </span><br></pre></td></tr></table></figure>

<p>可不可以只修改Cr3而不修改养父母？不可以，如果不修改养父母的值,一旦产生线程切换，就会变成自己读自己！</p>
<p>如果我们自己来写这个代码，在切换Cr3后关闭中断，并且不调用会导致线程切换的API,就可以不用修改养父母的值。</p>
<p><code>NtReadVirtualMemory</code>比较复杂，挑重点说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PAGE:004B05BE                 push    eax             ; int</span><br><span class="line">PAGE:004B05BF                 push    dword ptr [ebp+AccessMode] ; AccessMode</span><br><span class="line">PAGE:004B05C2                 push    esi             ; Length</span><br><span class="line">PAGE:004B05C3                 push    [ebp+Buffer]    ; 要存储的位置</span><br><span class="line">PAGE:004B05C6                 push    dword ptr [edi+_ETHREAD.Tcb.ApcState.Process] ; PROCESS</span><br><span class="line">PAGE:004B05C9                 push    [ebp+BaseAddress] ; 要存储的起始地址</span><br><span class="line">PAGE:004B05CC                 push    [ebp+Object]    ; 要读取的进程的_KPROCESS</span><br><span class="line">PAGE:004B05CF                 call    _MmCopyVirtualMemory@28 ; COPY函数</span><br><span class="line">PAGE:004B05D4                 mov     [ebp+var_1C], eax</span><br><span class="line">PAGE:004B05D7                 mov     ecx, [ebp+Object] ; Object</span><br><span class="line">PAGE:004B05DA                 call    @ObfDereferenceObject@4 ; ObfDereferenceObject(x)</span><br></pre></td></tr></table></figure>

<p><code>MmCopyVirtualMemory</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PAGE:004AB0F5 loc_4AB0F5:                             ; CODE XREF: MmCopyVirtualMemory(x,x,x,x,x,x,x)+7B771↓j</span><br><span class="line">PAGE:004AB0F5                 push    edi             ; int</span><br><span class="line">PAGE:004AB0F6                 push    dword ptr [ebp+AccessMode] ; char</span><br><span class="line">PAGE:004AB0F9                 push    [ebp+Length]    ; Length</span><br><span class="line">PAGE:004AB0FC                 push    [ebp+Address]   ; Address</span><br><span class="line">PAGE:004AB0FF                 push    [ebp+PROCESS]   ; PROCESS</span><br><span class="line">PAGE:004AB102                 push    [ebp+arg_4]     ; int</span><br><span class="line">PAGE:004AB105                 push    ebx             ; PRKPROCESS</span><br><span class="line">PAGE:004AB106                 call    _MiDoPoolCopy@28 ; 真正的COPY函数</span><br><span class="line">PAGE:004AB10B                 mov     esi, eax</span><br></pre></td></tr></table></figure>

<p><code>MiDoPoolCopy</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PAGE:004AB7B9 loc_4AB7B9:                             ; CODE XREF: MiDoPoolCopy(x,x,x,x,x,x,x)+7B0C9↓j</span><br><span class="line">PAGE:004AB7B9                 lea     eax, [ebp+ApcState]</span><br><span class="line">PAGE:004AB7BC                 push    eax             ; _KAPC_STATE</span><br><span class="line">PAGE:004AB7BD                 push    [ebp+arg_0]     ; _KPROCESS</span><br><span class="line">PAGE:004AB7C0                 call    _KeStackAttachProcess@8 ; 进程挂靠</span><br><span class="line">PAGE:004AB7C5                 xor     esi, esi</span><br></pre></td></tr></table></figure>

<p><code>KeStackAttachProcess</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0041AB80                 push    eax             ; _KTHREAD -&gt; SavedApcState</span><br><span class="line">.text:0041AB81                 push    [ebp+PROCESS]</span><br><span class="line">.text:0041AB84                 push    edi             ; 要读取进程的_KPROCESS</span><br><span class="line">.text:0041AB85                 push    esi             ; 当前进程的_KTHREAD</span><br><span class="line">.text:0041AB86                 call    _KiAttachProcess@16 ; KiAttachProcess(x,x,x,x)</span><br></pre></td></tr></table></figure>

<p><code>KiAttachProcess</code>：真正的挂靠函数</p>
<p>1）修改<strong>养父母</strong>，即<code>KTHREAD.ApcState.Process</code>的值，修改为将要访问的进程的<strong>进程结构体</strong></p>
<p>2）调用进程切换函数<code>KiSwapProcess</code>（<strong>本质是切换Cr3</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.text:0041A2A2                 cmp     [ebp+arg_C], eax </span><br><span class="line">.text:0041A2A5                 mov     [esi+44h], edi ; 修改养父母(KHTREAD.ApcState.Process)的值</span><br><span class="line">.text:0041A2A8                 mov     byte ptr [esi+48h], 0</span><br><span class="line">.text:0041A2AC                 mov     byte ptr [esi+49h], 0</span><br><span class="line">.text:0041A2B0                 mov     byte ptr [esi+4Ah], 0</span><br><span class="line">.text:0041A2B4                 jnz     short loc_41A2C9</span><br><span class="line">.text:0041A2B6                 mov     [esi+138h], eax</span><br><span class="line">.text:0041A2BC                 mov     [esi+13Ch], ebx</span><br><span class="line">.text:0041A2C2                 mov     byte ptr [esi+165h], 1</span><br><span class="line">.text:0041A2C9</span><br><span class="line">.text:0041A2C9 loc_41A2C9:                             ; CODE XREF: KiAttachProcess(x,x,x,x)+43↑j</span><br><span class="line">.text:0041A2C9                 cmp     byte ptr [edi+65h], 0</span><br><span class="line">.text:0041A2CD                 jnz     loc_44A88C</span><br><span class="line">.text:0041A2D3                 lea     esi, [edi+40h]</span><br><span class="line">.text:0041A2D6</span><br><span class="line">.text:0041A2D6 loc_41A2D6:                             ; CODE XREF: KiAttachProcess(x,x,x,x)+30611↓j</span><br><span class="line">.text:0041A2D6                 mov     eax, [esi]</span><br><span class="line">.text:0041A2D8                 cmp     eax, esi</span><br><span class="line">.text:0041A2DA                 jnz     loc_44A869</span><br><span class="line">.text:0041A2E0                 mov     eax, [ebp+arg_C]</span><br><span class="line">.text:0041A2E3                 push    dword ptr [eax+10h]</span><br><span class="line">.text:0041A2E6                 push    edi             ; 新的进程</span><br><span class="line">.text:0041A2E7                 call    _KiSwapProcess@8 ; 进程切换(即切换CR3)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>KiSwapProcess</code>：</p>
<p>先从外部参数，获取到了将要访问的进程的Cr3，然后分别<strong>修改TSS.Cr3和KPROCESS+0x18（DirectoryTableBase）处的值</strong>，然后便完成了进程切换。可以发现，进程切换，实际上就是切换了Cr3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00405BA4 loc_405BA4:                             ; CODE XREF: KiSwapProcess(x,x)+2D↑j</span><br><span class="line">.text:00405BA4                 lldt    ax</span><br><span class="line">.text:00405BA7                 mov     ecx, large fs:20h</span><br><span class="line">.text:00405BAE                 lea     ecx, [ecx+420h]</span><br><span class="line">.text:00405BB4                 call    @KeReleaseQueuedSpinLockFromDpcLevel@4 ; KeReleaseQueuedSpinLockFromDpcLevel(x)</span><br><span class="line">.text:00405BB9                 mov     ecx, large fs:40h ; 取KPCR.TSS</span><br><span class="line">.text:00405BC0                 mov     edx, [esp+arg_0] ; 取新的KPROCESS</span><br><span class="line">.text:00405BC4                 xor     eax, eax</span><br><span class="line">.text:00405BC6                 mov     gs, eax</span><br><span class="line">.text:00405BC8                 mov     eax, [edx+18h]  ; 获取新进程的KPRCESS+0x18(DirectoryTableBase)</span><br><span class="line">.text:00405BCB                 mov     [ecx+1Ch], eax  ; 要读取进程的CR3</span><br><span class="line">.text:00405BCE                 mov     cr3, eax        ; 修改CR3</span><br><span class="line">.text:00405BD1                 mov     ax, [edx+30h]</span><br><span class="line">.text:00405BD5                 mov     [ecx+66h], ax</span><br><span class="line">.text:00405BD9                 retn    8</span><br></pre></td></tr></table></figure>

<h3 id="NtReadVirtualMemory总结"><a href="#NtReadVirtualMemory总结" class="headerlink" title="NtReadVirtualMemory总结"></a>NtReadVirtualMemory总结</h3><p><code>NtReadVirtualMemory</code>主要做了两件事：</p>
<ul>
<li><strong>修改线程养父母</strong></li>
<li><strong>修改进程Cr3</strong></li>
</ul>
<p><strong>思考</strong>：可不可以只修改Cr3而不修改养父母？<br><strong>答案</strong>：不可以，假设刚刚修改完Cr3，还没读取内存时，发生了线程切换，当再次切换回来时，会根据养父母的值为Cr3赋值，Cr3又变回了原来的值，此时将变成自己读自己。如果我们自己来写这个代码，在切换Cr3后关闭中断，并且不调用会导致线程切换的API,就可以不用修改养父母的值</p>
<h2 id="进程挂靠总结"><a href="#进程挂靠总结" class="headerlink" title="进程挂靠总结"></a>进程挂靠总结</h2><ol>
<li>正常情况下，当前线程使用的Cr3是由其所属进程提供的（<code>_ETHREAD.Tcb.ApcState.Process</code>），正是因为如此，A进程中的线程只能访问A的内存</li>
<li>如果要让A进程中的线程能够访问B进程的内存，就必须要修改Cr3的值为B进程的页目录表基址(B.DirectoryTableBase)，这就是所谓的“进程挂靠”</li>
</ol>
<h1 id="013-跨进程读写内存"><a href="#013-跨进程读写内存" class="headerlink" title="013.跨进程读写内存"></a>013.跨进程读写内存</h1><p>如果如下操作的话，读取的内容还是放到了B进程的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cr3,B.DirectoryTableBase		//切换Cr3的值为B进程</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		//将进程B 0x12345678的值存的eax中</span><br><span class="line">mov dword ptr ds:[0x00401234],eax		//将数据存储到0x00401234中</span><br><span class="line">mov cr3,A.DirectoryTableBase		//切换回Cr3的值	 </span><br></pre></td></tr></table></figure>

<h2 id="NtReadVirtualMemory跨进程读"><a href="#NtReadVirtualMemory跨进程读" class="headerlink" title="NtReadVirtualMemory跨进程读"></a>NtReadVirtualMemory跨进程读</h2><p>执行流程：</p>
<ol>
<li>将<strong>当前线程</strong>的Cr3切换至<strong>目标进程</strong>的Cr3</li>
<li>将要读的数据复制到<strong>高2G</strong>（暂存区）</li>
<li>将<strong>当前线程</strong>的Cr3切换至<strong>原本进程</strong>的Cr3</li>
<li>将要读的数据从<strong>高2G</strong>复制到<strong>目标位置</strong></li>
</ol>
<h2 id="NtWriteVirtualMemory跨进程写"><a href="#NtWriteVirtualMemory跨进程写" class="headerlink" title="NtWriteVirtualMemory跨进程写"></a>NtWriteVirtualMemory跨进程写</h2><ol>
<li>将当前线程的数据复制到<strong>高2G</strong>（暂存区）</li>
<li>将<strong>当前线程</strong>的Cr3切换至<strong>目标进程</strong>的Cr3</li>
<li>将要写入的数据从<strong>高2G</strong>复制到<strong>目标位置</strong></li>
<li>将<strong>当前线程</strong>的Cr3切换至<strong>原本进程</strong>的Cr3</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2023/02/08/2023-2-HTTP%E5%A4%B4/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-02-19 00:00:00
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Technology/" title="Technology">
                        <b>#</b> Technology
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Win32/" title="Win32">
                        #Win32
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2099/12/31/TOP/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#001-%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">001.进程结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EPROCESS"><span class="toc-text">EPROCESS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KPROCESS"><span class="toc-text">KPROCESS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">通过进程结构体遍历所有的进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#002-%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">002.线程结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KTHREAD"><span class="toc-text">KTHREAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ETHREAD"><span class="toc-text">ETHREAD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#003-KPCR"><span class="toc-text">003.KPCR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KPCR"><span class="toc-text">KPCR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NT-TIB"><span class="toc-text">NT_TIB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KPRCB"><span class="toc-text">KPRCB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#004-%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8-%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8"><span class="toc-text">004.等待链表_调度链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A%E7%AD%89%E5%BE%85%EF%BC%8C%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%B0%B1%E7%BB%AA"><span class="toc-text">线程的三种状态：等待，运行，就绪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8"><span class="toc-text">等待链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">运行链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8"><span class="toc-text">调度链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-text">版本差异</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#005-%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">005.模拟线程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RegisterGMThread"><span class="toc-text">RegisterGMThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InitGMThread"><span class="toc-text">InitGMThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GMThreadStartup"><span class="toc-text">GMThreadStartup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scheduling-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">Scheduling 线程调度函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SwitchContext-%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-text">SwitchContext 切换线程函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#006-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-%E4%B8%BB%E5%8A%A8%E5%88%87%E6%8D%A2"><span class="toc-text">006.Windows线程切换_主动切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-KiSwapContext"><span class="toc-text">分析 KiSwapContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-SwapContext"><span class="toc-text">分析 SwapContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5"><span class="toc-text">线程切换汇编语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%98%AF%E5%90%A6%E4%BC%9A%E5%88%87%E6%8D%A2CR3"><span class="toc-text">线程切换是否会切换CR3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SwapContext%E5%85%A8%E9%83%A8%E5%88%86%E6%9E%90"><span class="toc-text">SwapContext全部分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#007-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2"><span class="toc-text">007.Windows线程切换_时钟中断切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#008-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-%E6%97%B6%E9%97%B4%E7%89%87%E7%AE%A1%E7%90%86"><span class="toc-text">008.Windows线程切换_时间片管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-text">CPU时间片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KeUpdateRunTime"><span class="toc-text">KeUpdateRunTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiDispatchInterrupt"><span class="toc-text">KiDispatchInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiQuantumEnd"><span class="toc-text">KiQuantumEnd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KiReadyThread"><span class="toc-text">KiReadyThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#009-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-TSS"><span class="toc-text">009.Windows线程切换_TSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TSS"><span class="toc-text">TSS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#010-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-FS"><span class="toc-text">010.Windows线程切换_FS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84"><span class="toc-text">段描述符结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#011-Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">011.Windows线程切换_线程优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8-1"><span class="toc-text">调度链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KiSwapThread"><span class="toc-text">KiSwapThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#012-%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0"><span class="toc-text">012.进程挂靠</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="toc-text">进程线程关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">代码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%BE%E8%BF%9B%E7%A8%8B"><span class="toc-text">线程找进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90NtReadVirtualMemory"><span class="toc-text">分析NtReadVirtualMemory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NtReadVirtualMemory%E6%80%BB%E7%BB%93"><span class="toc-text">NtReadVirtualMemory总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0%E6%80%BB%E7%BB%93"><span class="toc-text">进程挂靠总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#013-%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98"><span class="toc-text">013.跨进程读写内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NtReadVirtualMemory%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB"><span class="toc-text">NtReadVirtualMemory跨进程读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtWriteVirtualMemory%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%86%99"><span class="toc-text">NtWriteVirtualMemory跨进程写</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Ghostasky">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="twitter" target="_blank" rel="noopener" href="https://twitter.com/ghostasky">
            <i class="iconfont icon-twitter"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/Ghostasky">怕什么真理无穷，进一寸有进一寸的欢喜。</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Windows%E5%86%85%E6%A0%B8(%E5%9B%9B)%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B + '&url=' + https%3A%2F%2Fghostasky.github.io%2F2023%2F02%2F19%2F2023-2-WinKernel%25E8%25BF%259B%25E7%25A8%258B%25E7%25BA%25BF%25E7%25A8%258B%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://ghostasky.github.io/2023/02/19/2023-2-WinKernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
