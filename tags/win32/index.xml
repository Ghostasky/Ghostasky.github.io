<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Win32 on Ghostasky&#39;s Blog</title>
    <link>http://ghostasky.github.io/tags/win32/</link>
    <description>Recent content in Win32 on Ghostasky&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>wt20wl@gmail.com (Ghostasky)</managingEditor>
    <webMaster>wt20wl@gmail.com (Ghostasky)</webMaster>
    <lastBuildDate>Sun, 12 Mar 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://ghostasky.github.io/tags/win32/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Windows内核(十一)——软件调试</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sun, 12 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E8%B0%83%E8%AF%95/</guid>
      <description>[toc] 最后一部分了，接下来好好写个调试器，看看win内核的洞去了。 01.调试对象 调试器与被调试程序 示例图如下： 调试器与被调试对象建立联系的方式： CreateProcess（创建进程） DebugActiveProcess（附加进程） 这里主要是附加</description>
    </item>
    <item>
      <title>Windows内核(十)——消息机制</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 07 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
      <description>[toc] 1.消息队列 消息队列 本质上是一种数据结构，先进先出。 消息队列在哪 Linux：专用进程 使用专用进程捕获所有消息 判断消息所属进程，进行分发，将消息分配到目标进程的消息队列中 Windows：GUI线程 KTHREAD结构体： kd&amp;gt; dt _KTHREAD ntdll!_KTHREAD ... +0x130 Win32Thread //若当</description>
    </item>
    <item>
      <title>Windows内核(九)——内存管理</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>[toc] 01.线性地址的管理 每个进程都有自己的用户空间需要管理，当我们使用VirtualAlloc等函数申请一块固定的地址空间时，首先需要确认这块空间是否被占用，如果该空间已被占用则申请失败。 用户空间并非像内核空间一样通过一块链表去管理已占用的线</description>
    </item>
    <item>
      <title>Windows内核(八)——异常</title>
      <link>http://ghostasky.github.io/posts/2023-3-winkernel%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-3-winkernel%E5%BC%82%E5%B8%B8/</guid>
      <description>[toc] 01.CPU异常记录 一个异常产生后，首先是要记录异常信息（异常的类型、异常发生的位置等），然后要寻找异常的处理函数，称为异常的分发,最后找到异常处理函数并调用，称为异常处理。 分类： CPU产生的异常 软件产生的异常 异常处理流程 CPU指令检测到</description>
    </item>
    <item>
      <title>Windows内核(七)——APC机制</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernelapc/</link>
      <pubDate>Sun, 26 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernelapc/</guid>
      <description>[toc] 01.APC的本质 线程是不能被“杀掉”、“挂起”、“恢复”的，线程在执行的时候自己占据着CPU，别人不能控制它 举个极端的例子：如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占用CPU 所以说线程如果想“死”，一定是自己执行代码</description>
    </item>
    <item>
      <title>Windows内核(六)——事件等待</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E4%BA%8B%E4%BB%B6%E7%AD%89%E5%BE%85/</guid>
      <description>[toc] 01.临界区 这个部分在驱动那一部分写了，这里就直接复制粘贴过来了 并发是指多个线程在同时执行： 单核（是分时执行，不是真正的同时） 多核（在某一个时刻，会同时有多个线程再执行） 同步则是保证在并发执行的环境中各个线程可以有序的执行 单行指令的同步 DWORD</description>
    </item>
    <item>
      <title>Windows内核(五)——句柄表</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E5%8F%A5%E6%9F%84%E8%A1%A8/</link>
      <pubDate>Sun, 19 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E5%8F%A5%E6%9F%84%E8%A1%A8/</guid>
      <description>[toc] 01.句柄表 当一个进程创建或者打开一个内核对象时，将获得一个句柄，通过这个句柄可以访问对应的内核对象 句柄表存储在零环，一个进程使用了几个句柄，在该进程的句柄表中就会存储几个句柄 所有的句柄所对应的内核对象，都包含在**_OBJECT_HEA</description>
    </item>
    <item>
      <title>Windows内核(四)——进程线程</title>
      <link>http://ghostasky.github.io/posts/2023-2-winkernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sat, 18 Feb 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-2-winkernel%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid>
      <description>[toc] 进程&amp;amp;线程 滴水中级上 001.进程结构体 每个windows进程在0环都有一个对应的结构体：EPROCESS ，这个结构体包含了进程所有重要的信息。 EPROCESS kd&amp;gt; dt _EPROCESS ntdll!_EPROCESS +0x000 Pcb : _KPROCESS +0x06c ProcessLock : _EX_PUSH_LOCK +0x070 CreateTime : _LARGE_INTEGER//进程的创建时间 +0x078 ExitTime : _L</description>
    </item>
    <item>
      <title>Windows内核(二)——驱动</title>
      <link>http://ghostasky.github.io/posts/2023-1-winkernel%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-1-winkernel%E9%A9%B1%E5%8A%A8/</guid>
      <description>[toc] 001.驱动开发环境配置 vs2010:https://learn.microsoft.com/zh-cn/visualstudio/releasenotes/vs2010-sp1-vs wdk7600:https://www.microsoft.com/en-us/download/details.aspx?id=11800 添加项目属性表： &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;Project ToolsVersion=&amp;#34;4.0&amp;#34; xmlns=&amp;#34;http://schemas.microsoft.com/developer/msbuild/2003&amp;#34;&amp;gt; &amp;lt;ImportGroup Label=&amp;#34;PropertySheets&amp;#34; /&amp;gt; &amp;lt;PropertyGroup Label=&amp;#34;UserMacros&amp;#34; /&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;ExecutablePath&amp;gt;D:\WinDDK\7600.16385.1\bin\x86;$(ExecutablePath)&amp;lt;/ExecutablePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;IncludePath&amp;gt;D:\WinDDK\7600.16385.1\inc\api;D:\WinDDK\7600.16385.1\inc\ddk;D:\WinDDK\7600.16385.1\inc\crt;$(IncludePath)&amp;lt;/IncludePath&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;PropertyGroup&amp;gt; &amp;lt;LibraryPath&amp;gt;D:\WinDDK\7600.16385.1\lib\wxp\i386;$(LibraryPath)&amp;lt;/LibraryPath&amp;gt; &amp;lt;TargetExt&amp;gt;.sys&amp;lt;/TargetExt&amp;gt; &amp;lt;LinkIncremental&amp;gt;false&amp;lt;/LinkIncremental&amp;gt; &amp;lt;GenerateManifest&amp;gt;false&amp;lt;/GenerateManifest&amp;gt; &amp;lt;/PropertyGroup&amp;gt; &amp;lt;ItemDefinitionGroup&amp;gt; &amp;lt;ClCompile&amp;gt; &amp;lt;PreprocessorDefinitions&amp;gt;_X86_;DBG&amp;lt;/PreprocessorDefinitions&amp;gt; &amp;lt;CallingConvention&amp;gt;StdCall&amp;lt;/CallingConvention&amp;gt; &amp;lt;ExceptionHandling&amp;gt;false&amp;lt;/ExceptionHandling&amp;gt; &amp;lt;BasicRuntimeChecks&amp;gt;Default&amp;lt;/BasicRuntimeChecks&amp;gt; &amp;lt;BufferSecurityCheck&amp;gt;false&amp;lt;/BufferSecurityCheck&amp;gt; &amp;lt;CompileAs&amp;gt;Default&amp;lt;/CompileAs&amp;gt; &amp;lt;DebugInformationFormat&amp;gt;ProgramDatabase&amp;lt;/DebugInformationFormat&amp;gt; &amp;lt;AssemblerOutput&amp;gt;All&amp;lt;/AssemblerOutput&amp;gt; &amp;lt;/ClCompile&amp;gt; &amp;lt;Link&amp;gt; &amp;lt;AdditionalDependencies&amp;gt;ntoskrnl.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;Hal.lib;MSVCRT.LIB;LIBCMT.LIB;%(AdditionalDependencies)&amp;lt;/AdditionalDependencies&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;Link&amp;gt; &amp;lt;IgnoreAllDefaultLibraries&amp;gt;true&amp;lt;/IgnoreAllDefaultLibraries&amp;gt; &amp;lt;EnableUAC&amp;gt;false&amp;lt;/EnableUAC&amp;gt; &amp;lt;SubSystem&amp;gt;Native&amp;lt;/SubSystem&amp;gt; &amp;lt;EntryPointSymbol&amp;gt;DriverEntry&amp;lt;/EntryPointSymbol&amp;gt; &amp;lt;BaseAddress&amp;gt;0x10000&amp;lt;/BaseAddress&amp;gt; &amp;lt;RandomizedBaseAddress&amp;gt; &amp;lt;/RandomizedBaseAddress&amp;gt; &amp;lt;DataExecutionPrevention&amp;gt; &amp;lt;/DataExecutionPrevention&amp;gt; &amp;lt;GenerateDebugInformation&amp;gt;true&amp;lt;/GenerateDebugInformation&amp;gt; &amp;lt;Driver&amp;gt;Driver&amp;lt;/Driver&amp;gt; &amp;lt;/Link&amp;gt; &amp;lt;/ItemDefinitionGroup&amp;gt; &amp;lt;ItemGroup /&amp;gt; &amp;lt;/Project&amp;gt; 002.第一个驱动程序 驱动开发流程： 代码 =&amp;gt; 生成sys文件 =&amp;gt; 部署 =&amp;gt; 启动 =&amp;gt; 停止 =&amp;gt; 卸载 ##include &amp;lt;ntddk.h&amp;gt;</description>
    </item>
    <item>
      <title>Windows内核(三)——系统调用</title>
      <link>http://ghostasky.github.io/posts/2023-1-winkernel%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2023-1-winkernel%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</guid>
      <description>[toc] 本文是windows内核系列的第三部分，本来应该是放到第二部分后面的，但是第二部分会用到这部分的相关内容 ，就先放第三部分了。 001.API函数的调用过程(3环部分) 主要是存放在 C:\WINDOWS\system32 下面所有的dll 几个重要的DLL Kernel32.dll:最</description>
    </item>
    <item>
      <title>Windows Program Learn_0x1</title>
      <link>http://ghostasky.github.io/posts/2022-9-wincode1/</link>
      <pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-9-wincode1/</guid>
      <description>[toc] 准备开个系列，就叫“Windows Program Learn”，记录《Windows黑客编程技术详解》书的代码和笔记。 https://github.com/jash-git/Windows-Hack-Programming-backup 基础 最开始是环境的搭建，这里就不搞了，好像也没啥。 单一实例 也就是实现进程互斥。 CreateMutexA HANDLE CreateMutexA( [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, [in] BOOL bInitialOwner, [in, optional] LPCSTR lpName ); 参数： lpMutexAt</description>
    </item>
    <item>
      <title>Windows内核(一)——保护模式</title>
      <link>http://ghostasky.github.io/posts/2022-9-winkernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-9-winkernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>[toc] 001.保护模式 x86CPU三个模式：实模式， 保护模式，虚拟8086模式 市面上能见到的x64对x86向下兼容，是x86的扩展 保护模式特点： 段的机制 页的基址 002.段寄存器结构 学段机制之前先要知道段寄存器结构 mov dword ptr ds:[0x123456],eax 实际上读的地址是：ds.</description>
    </item>
  </channel>
</rss>
