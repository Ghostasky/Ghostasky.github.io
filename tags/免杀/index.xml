<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>免杀 on Ghostasky&#39;s Blog</title>
    <link>http://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/</link>
    <description>Recent content in 免杀 on Ghostasky&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>wt20wl@gmail.com (Ghostasky)</managingEditor>
    <webMaster>wt20wl@gmail.com (Ghostasky)</webMaster>
    <lastBuildDate>Sat, 02 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BypassAVDynamics[译]</title>
      <link>http://ghostasky.github.io/posts/2022-6-29-bypassavdynamics/</link>
      <pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/2022-6-29-bypassavdynamics/</guid>
      <description>本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西 好久之前的文章了，vt应该查杀挺多的，没测试 need read： PE注入 这个应该写过，win32那里&amp;hellip; [toc] 简介 绕过AV的两大步骤： 恶意代码的隐藏，</description>
    </item>
    <item>
      <title>msfvenom参数详解</title>
      <link>http://ghostasky.github.io/posts/msfvenom%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/msfvenom%E8%AF%A6%E8%A7%A3/</guid>
      <description>[toc] 常规参数 所有参数 -p, –payload &amp;lt; payload&amp;gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的 -l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, platforms, archs, encrypt, formats, all -n, –nopsled &amp;lt; length&amp;gt; 为payloa</description>
    </item>
    <item>
      <title>ShellCode Loader(持续更新)</title>
      <link>http://ghostasky.github.io/posts/shellcodeloader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/shellcodeloader/</guid>
      <description>记录一些语言的shellcode 加载方式，持续更新&amp;hellip; [toc] C/C++ 首先是c的loader，分两种，指针直接执行和动态分配。 指针执行 ##include &amp;lt;stdio.h&amp;gt; ##include &amp;lt;windows.h&amp;gt; //设置入口地址，不弹出黑窗口 ## pragma comment(linker,&amp;#34;/subsystem:\&amp;#34;Windows\&amp;#34; /entry:\&amp;#34;mainCRTStartup\&amp;#34;&amp;#34;) unsigned char shellcode[] = &amp;#34;shellcode&amp;#34;; void main() { //都可 //((void(*)()) &amp;amp;shellcode)(); //(*(void(*)()) &amp;amp;shellcode)(); //也可以这样 //void (*func)(); //func = (void (*)())(void *)shellcode;</description>
    </item>
    <item>
      <title>回调函数加载shellcode</title>
      <link>http://ghostasky.github.io/posts/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>wt20wl@gmail.com (Ghostasky)</author>
      <guid>http://ghostasky.github.io/posts/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/</guid>
      <description>&lt;p&gt;坟墓里寂静无比，埋葬你的是你所有没说出口的话&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
